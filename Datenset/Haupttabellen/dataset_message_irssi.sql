-- MySQL dump 10.13  Distrib 8.0.18, for Win64 (x86_64)
--
-- Host: localhost    Database: dataset_message
-- ------------------------------------------------------
-- Server version	8.0.18

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `irssi`
--

DROP TABLE IF EXISTS `irssi`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `irssi` (
  `name` varchar(255) DEFAULT NULL,
  `release_number` varchar(255) DEFAULT NULL,
  `commit_hash` longtext,
  `commit_author` varchar(255) DEFAULT NULL,
  `commit_msg` longtext,
  `filename` varchar(255) DEFAULT NULL,
  `nloc` varchar(255) DEFAULT NULL,
  `cycomplexity` varchar(255) DEFAULT NULL,
  `lines_added` varchar(255) DEFAULT NULL,
  `lines_removed` varchar(255) DEFAULT NULL,
  `change_type` varchar(255) DEFAULT NULL,
  `diff` longtext,
  `corrective` varchar(255) DEFAULT NULL,
  `bug_introducing` varchar(255) DEFAULT NULL,
  `feature` longtext
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `irssi`
--

LOCK TABLES `irssi` WRITE;
/*!40000 ALTER TABLE `irssi` DISABLE KEYS */;
INSERT INTO `irssi` VALUES ('irssi','1.0.0','ea7826b0ec097b9fdc29336ff7fe7074052773f5','ailin-nemui','tag as 1.0.0','NEWS','2858','0','55','21','MODIFY','@@ -1,22 +1,29 @@\n-v0.8.22-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n-	* Removed --disable-ipv6\n+v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>\n+	* Removed --disable-ipv6 (#408).\n 	* /connect Network now aborts with an error if no servers have been\n-	  added to that network.\n+	  added to that network (#443).\n 	* /dcc commands now use quotes around spaces consistently.\n-	+ irssiproxy can now forward all tags through a single port.\n-	+ irssiproxy can also listen on unix sockets.\n-	+ send channel -botcmds immediately when no mask is specified (#175).\n+	* bell_beeps was removed (#524, #565).\n+	* Switch to GRegex instead of regex.h (#412).\n+	+ irssiproxy can now forward all tags through a single\n+	  port. By Lukas Mai (mauke, #425).\n+	+ irssiproxy can also listen on unix sockets. By Lukas Mai (#427).\n+	+ send channel -botcmds immediately when no mask is specified (#175, #399).\n 	+ the kill buffer now remembers consecutive kills.\n 	  New bindings were added: yank_next_cutbuffer and append_next_kill\n+	  By Todd A. Pratt (#353, #414, #455)\n 	+ connections will avoid looking up IPv6 addresses if the machine does\n 	  not have an IPv6 address assigned (exact behaviour is implementation\n-	  defined).\n+	  defined, #410).\n 	+ Fix potential crash if scripts insert undef values into the completion\n-	  list.\n-	+ Paste warning is now also shown on pasting overlong lines.\n+	  list (#413).\n+	+ Paste warning is now also shown on pasting overlong\n+	  lines. By Manish Goregaokar (#426).\n 	+ autolog_ignore_targets and activity_hide_targets learn a new syntax\n 	      tag/* and * to ignore whole networks or everything.\n-	+ /hilight got a -matchcase flag to hilight case sensitively (#421).\n+	  By Jari Matilainen (vague666, #437)\n+	+ /hilight got a -matchcase flag to hilight case\n+	  sensitively. By Thibault B (isundil, #421, #476).\n 	+ Always build irssi with TLS support.\n 	+ Rename SSL to TLS in the code and add -tls_* versions of the -ssl_*\n 	  options to /CONNECT and /SERVER, but make sure the -ssl_* options continue\n@@ -54,10 +61,36 @@ v0.8.22-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n 	  does not rely on the libval library. It is causing a lot of troubles for\n 	  our downstream maintainers.\n \n+	+ /names and $[...] now uses utf8 string operations. By Xavier\n+          G. (#40, #411, #471, #480).\n+	+ New setting completion_nicks_match_case (#488).\n+	+ /channel /server /network now support modify subcommand. By\n+	  Jari Matilainen (#338, #498).\n+	+ Irssi::signal_remove now works with coderefs. By Tom Feist (shabble, #512).\n+	+ /script reset got an -autorun switch (#540, #538).\n+	+ cap_toggle can now be called from Perl, and fields\n+	  cap_active and cap_supported can be inspected (#542).\n+	+ Make it possible to disable empty line completion. By Lauri\n+	  Tirkkonen (lotheac, #574).\n+	+ New option sasl_disconnect_on_failure to disconnect when\n+	  SASL log-in failed (#514).\n 	- IP addresses are no longer stored when resolve_reverse_lookup is\n 	  used.\n-	- /names and $[...] now uses utf8 string operations (#40, #411).\n-	- Removed broken support for curses.\n+	- Removed broken support for curses (#521).\n+	- Removed broken dummy mode (#526).\n+	- Fix terminal state after suspend (#450, #452).\n+	- Improve Perl library path detection (#479, #132).\n+	- Reconnect now works on unix connections (#493).\n+	- Fix completion warnings (#125, #496, FS#124).\n+	- Fix a crash in the --more-- item (#501).\n+	- Fix a display issue in /unignore (#517, bdo#577202).\n+	- Fix a crash in some netsplits (#529, #500).\n+	- Fix crashes with some invalid config (#550, #551, #563, #564, #587, #581, #570).\n+	- Add support for SASL Fragmentation. By Kenny Root (kruton, #506).\n+	- Improve netsplit dumping (#420, #465).\n+	- Improve responsibility under DCC I/O strain (#578, #159).\n+	- Fix query nick change on open (#580, #586).\n+	- Correct a few help texts.\n \n v0.8.21 2017-01-03  The Irssi team <staff@irssi.org>\n 	- Correct a NULL pointer dereference in the nickcmp function found by\n@@ -72,11 +105,11 @@ v0.8.20 2016-09-16  The Irssi team <staff@irssi.org>\n 	- Correct the name of an emitted sasl signal (#484)\n 	- Correct the prototype for the \'message private\' signal (#515)\n 	- Corrections in away and hilight help text (#477, #518)\n-	- /squery and /servlist commands have been restored.\n+	- /squery and /servlist commands have been restored (#461).\n 	- Where Irssi would previously only report \"System error\" on connect,\n-	  it will now try harder to retrieve the system error message.\n+	  it will now try harder to retrieve the system error message (#467).\n 	- Fixed issue with +channels not working properly (#533)\n-	- Fixed crash in optchan when item has no server (#485)\n+	- Fixed crash in optchan when item has no server (#485, bdo#826525)\n 	- Fixed random remote crash in the nicklist handling (#529)\n 	- Fixed remote crash due to incorrect bounds checking on\n 	  formats, reported by Gabriel Campana and Adrien Guinet from\n@@ -84,16 +117,17 @@ v0.8.20 2016-09-16  The Irssi team <staff@irssi.org>\n \n v0.8.19 2016-03-23  The Irssi team <staff@irssi.org>\n 	- Fixed regression when joining and parting channels on IRCnet (#435)\n-	- Fixed SASL EXTERNAL (#432)\n+	- Fixed SASL EXTERNAL. By Mantas Mikulėnas (grawity, #432)\n 	- Fixed regression when not using SASL (#438)\n-	- Fixed incorrect SSL disconnects when using SSL from modules/scripts\n-	  (#439)\n+	- Fixed incorrect SSL disconnects when using SSL from modules/scripts.\n+	  By Will Storey (horgh, #439)\n 	- Fixed regression where proxy_string could not be configured or\n-	  certain file transfers could not be accepted (#445)\n-	- Fixed storing layout of !channels (#183)\n-	- Fixed restoration of bracketed paste mode on quit (#449)\n+	  certain file transfers could not be accepted (#445, #446)\n+	- Fixed storing layout of !channels (#183, #405)\n+	- Fixed restoration of bracketed paste mode on quit (#449, #457)\n 	- Make the usage of meta-O for cursor keys configurable with\n 	      /set term_appkey_mode off\n+	  (#430, #459)\n \n v0.8.18 2016-02-13  The Irssi team <staff@irssi.org>\n 	* Modules will now require to define a\n','false','false','none'),('irssi','1.0.0','ea7826b0ec097b9fdc29336ff7fe7074052773f5','ailin-nemui','tag as 1.0.0','configure.ac','618','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-AC_INIT(irssi, 0.8.22-head)\n+AC_INIT(irssi, 1.0.0)\n AC_CONFIG_SRCDIR([src])\n AC_CONFIG_AUX_DIR(build-aux)\n AC_PREREQ(2.50)\n','false','false','none'),('irssi','1.0.0','cbb931ed1da91b2cee36f89673edd6a526d56e9a','ailin-nemui','continue head','NEWS','2859','0','2','0','MODIFY','@@ -1,3 +1,5 @@\n+v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n+\n v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>\n 	* Removed --disable-ipv6 (#408).\n 	* /connect Network now aborts with an error if no servers have been\n','false','false','none'),('irssi','1.0.0','cbb931ed1da91b2cee36f89673edd6a526d56e9a','ailin-nemui','continue head','configure.ac','618','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-AC_INIT(irssi, 1.0.0)\n+AC_INIT(irssi, 1.1-head)\n AC_CONFIG_SRCDIR([src])\n AC_CONFIG_AUX_DIR(build-aux)\n AC_PREREQ(2.50)\n','false','false','none'),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory\n\nirssi 1.0.0 will not build if perl is enabled and a separate\nobject code directory is used. the problem was a relative path\nto an internal perl dependency in four makefile.pl.in files.','Makefile.PL.in','6','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory\n\nirssi 1.0.0 will not build if perl is enabled and a separate\nobject code directory is used. the problem was a relative path\nto an internal perl dependency in four makefile.pl.in files.','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi::Irc\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory\n\nirssi 1.0.0 will not build if perl is enabled and a separate\nobject code directory is used. the problem was a relative path\nto an internal perl dependency in four makefile.pl.in files.','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi::TextUI\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory\n\nirssi 1.0.0 will not build if perl is enabled and a separate\nobject code directory is used. the problem was a relative path\nto an internal perl dependency in four makefile.pl.in files.','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi::UI\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','752f484c6ce4c2aa7284b617a59a8906b269281c','dequis','add openssl_no_ec for solaris 11.3, see issue #598\n\noriginal patch by \'slarky\'\n\naccording to that ticket, the next major version of solaris won\'t need\nthis. consider reverting this when solaris 11.3 stops being relevant.','network-openssl.c','629','135','6','0','MODIFY','@@ -646,7 +646,11 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n #ifdef SSL_get_server_tmp_key\n 	// Show ephemeral key information.\n 	EVP_PKEY *ephemeral_key = NULL;\n+\n+	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598\n+#ifndef OPENSSL_NO_EC\n 	EC_KEY *ec_key = NULL;\n+#endif\n 	char *ephemeral_key_algorithm = NULL;\n 	char *cname = NULL;\n 	int nid;\n@@ -658,6 +662,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n 				tls_rec_set_ephemeral_key_size(tls, EVP_PKEY_bits(ephemeral_key));\n 				break;\n \n+#ifndef OPENSSL_NO_EC\n 			case EVP_PKEY_EC:\n 				ec_key = EVP_PKEY_get1_EC_KEY(ephemeral_key);\n 				nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key));\n@@ -670,6 +675,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n \n 				g_free_and_null(ephemeral_key_algorithm);\n 				break;\n+#endif\n \n 			default:\n 				tls_rec_set_ephemeral_key_algorithm(tls, \"Unknown\");\n','false','false','ssl_get_server_tmp_key'),('irssi','1.0.0','752f484c6ce4c2aa7284b617a59a8906b269281c','dequis','add openssl_no_ec for solaris 11.3, see issue #598\n\noriginal patch by \'slarky\'\n\naccording to that ticket, the next major version of solaris won\'t need\nthis. consider reverting this when solaris 11.3 stops being relevant.','network-openssl.c','629','135','6','0','MODIFY','@@ -646,7 +646,11 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n #ifdef SSL_get_server_tmp_key\n 	// Show ephemeral key information.\n 	EVP_PKEY *ephemeral_key = NULL;\n+\n+	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598\n+#ifndef OPENSSL_NO_EC\n 	EC_KEY *ec_key = NULL;\n+#endif\n 	char *ephemeral_key_algorithm = NULL;\n 	char *cname = NULL;\n 	int nid;\n@@ -658,6 +662,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n 				tls_rec_set_ephemeral_key_size(tls, EVP_PKEY_bits(ephemeral_key));\n 				break;\n \n+#ifndef OPENSSL_NO_EC\n 			case EVP_PKEY_EC:\n 				ec_key = EVP_PKEY_get1_EC_KEY(ephemeral_key);\n 				nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key));\n@@ -670,6 +675,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n \n 				g_free_and_null(ephemeral_key_algorithm);\n 				break;\n+#endif\n \n 			default:\n 				tls_rec_set_ephemeral_key_algorithm(tls, \"Unknown\");\n','false','false','not openssl_no_ec'),('irssi','1.0.0','ef9da295cdd8af0036396e7fc772fcee8a1c7c51','Lasse Toimela','fix syntax on /help server example','server.in','65','0','1','1','MODIFY','@@ -64,7 +64,7 @@\n     /SERVER CONNECT chat.freenode.net\n     /SERVER CONNECT +chat.freenode.net\n     /SERVER ADD -network Freenode -noautosendcmd orwell.freenode.net\n-    /SERVER ADD -! -auto -host staff.irssi.org -port 6667 -4 -network Freenode -noproxy orwell.freenode.net\n+    /SERVER ADD -! -auto -host staff.irssi.org -4 -network Freenode -noproxy orwell.freenode.net 6667\n     /SERVER MODIFY -network Freenode -noauto orwell.freenode.net\n     /SERVER REMOVE orwell.freenode.net 6667 Freenode\n     /SERVER PURGE\n','true','false','none'),('irssi','1.0.0','1831a8e1a710decbbcae524c60cdf6216f19a121','dequis','don\'t reset wait_cmd during connection registration (fixes early ison)','irc-servers.c','780','196','6','0','MODIFY','@@ -527,6 +527,12 @@ void irc_server_send_data(IRC_SERVER_REC *server, const char *data, int len)\n 		return;\n 	}\n \n+	/* Don\'t reset wait_cmd during connection registration\n+	 * (while sending CAP / SASL related commands) */\n+	if (!server->connected) {\n+		return;\n+	}\n+\n 	g_get_current_time(&server->last_cmd);\n \n 	/* A bit kludgy way to do the flood protection. In ircnet, there\n','true','true','none'),('irssi','1.0.0','69e112fbd1b44a6f9f3380167c12bbe0f76693a1','dequis','news: avoid explicitly mentioning freenode in the pinning examples\n\nthey have proper certs, so using them as an example is wrong.\nparticularly worse since they started using letsencrypt recently so\nevery server has a different cert and pubkey.\n\nwe\'ll figure out how to link this from the release notes later.','NEWS','2858','0','4','4','MODIFY','@@ -39,16 +39,16 @@ v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>\n 	  values like this: Start by downloading the certificate from a given IRC\n 	  server:\n \n-	      $ openssl s_client -connect chat.freenode.net:6697 < /dev/null 2>/dev/null | \\\n-	        openssl x509 > freenode.cert\n+	      $ openssl s_client -connect irc.example.net:6697 < /dev/null 2>/dev/null | \\\n+	        openssl x509 > example.cert\n \n 	  Find the value for -tls_pinned_cert:\n \n-	      $ openssl x509 -in freenode.cert -fingerprint -sha256 -noout\n+	      $ openssl x509 -in example.cert -fingerprint -sha256 -noout\n \n 	  Find the value for -tls_pinned_pubkey:\n \n-	      $ openssl x509 -in freenode.cert -pubkey -noout | \\\n+	      $ openssl x509 -in example.cert -pubkey -noout | \\\n 	        openssl pkey -pubin -outform der | \\\n 	        openssl dgst -sha256 -c | \\\n 	        tr a-z A-Z\n','false','false','none'),('irssi','1.0.0','5917bc6f75dd87806807d3d526826b64e8271a5b','Tim Konick','follow g_strsplit with call to g_strfreev','modes.c','700','195','2','1','MODIFY','@@ -743,6 +743,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,\n 			    g_hash_table_lookup(optlist, \"yes\") == NULL) {\n                                 /* too many matches */\n 				g_string_free(str, TRUE);\n+				g_strfreev(matches);\n 				cmd_params_free(free_arg);\n \n 				signal_emit(\"error command\", 1,\n@@ -756,7 +757,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,\n         if (str->len > 0) g_string_truncate(str, str->len-1);\n 	ret = str->str;\n 	g_string_free(str, FALSE);\n-\n+	g_strfreev(matches);\n 	cmd_params_free(free_arg);\n \n 	*ret_channel = channel;\n','false','false','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','.gitignore','53','0','4','0','MODIFY','@@ -32,6 +32,7 @@ docs/help/[a-z]*\n docs/help/in/Makefile.am\n \n src/fe-text/irssi\n+src/fe-fuzz/irssi-fuzz\n \n src/fe-common/irc/irc-modules.c\n src/irc/irc.c\n@@ -46,6 +47,9 @@ src/perl/ui/*.c\n src/perl/*/MYMETA.*\n src/perl/*/Makefile.old\n \n+src/fe-fuzz/crash-*\n+src/fe-fuzz/oom-*\n+\n *.a\n *.bs\n *.la\n','false','false','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','configure.ac','662','4','40','0','MODIFY','@@ -52,6 +52,19 @@ AC_ARG_WITH(bot,\n 	fi,\n 	want_irssibot=no)\n \n+AC_ARG_WITH(fuzzer,\n+[  --with-fuzzer           Build irssi-fuzzer],\n+	if test x$withval = xno; then\n+		want_irssifuzzer=no\n+	else\n+		want_irssifuzzer=yes\n+	fi,\n+	want_irssifuzzer=no)\n+\n+AC_ARG_WITH(fuzzer-lib,\n+[  --with-fuzzer-lib       Specify path to fuzzer library],\n+	fuzzerlibpath=\"$withval\")\n+\n AC_ARG_WITH(proxy,\n [  --with-proxy            Build irssi-proxy],\n 	if test x$withval = xno; then\n@@ -297,6 +310,30 @@ if test \"x$want_textui\" != \"xno\"; then\n \n fi\n \n+dnl **\n+dnl ** irssifuzzer checks\n+dnl **\n+\n+if test \"$want_irssifuzzer\" != \"no\"; then\n+	dnl * we need to build with -fsanitize-coverage=trace-pc-guard\n+	dnl * otherwise fuzzer won\'t be very successful at finding bugs :)\n+	if test -z \"$SANFLAGS\"; then\n+		SANFLAGS=\"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\"\n+	fi\n+	CFLAGS=\"$CFLAGS $SANFLAGS\"\n+	CXXFLAGS=\"$CXXFLAGS $SANFLAGS\"\n+\n+	AC_MSG_CHECKING(for fuzzer library)\n+\n+	if test -z \"$fuzzerlibpath\"; then\n+		AC_MSG_RESULT([not found, building without fuzzer front end])\n+		want_irssifuzzer=no\n+	else\n+		FUZZER_LIBS=\"$fuzzerlibpath\"\n+		AC_SUBST(FUZZER_LIBS)\n+	fi\n+fi\n+\n dnl **\n dnl ** perl checks\n dnl **\n@@ -456,6 +493,7 @@ fi\n dnl ** check what we want to build\n AM_CONDITIONAL(BUILD_TEXTUI, test \"$want_textui\" = \"yes\")\n AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\")\n+AM_CONDITIONAL(BUILD_IRSSIFUZZER, test \"$want_irssifuzzer\" = \"yes\")\n AM_CONDITIONAL(BUILD_IRSSIPROXY, test \"$want_irssiproxy\" = \"yes\")\n AM_CONDITIONAL(HAVE_PERL, test \"$want_perl\" != \"no\")\n \n@@ -572,6 +610,7 @@ src/fe-common/core/Makefile\n src/fe-common/irc/Makefile\n src/fe-common/irc/dcc/Makefile\n src/fe-common/irc/notifylist/Makefile\n+src/fe-fuzz/Makefile\n src/fe-none/Makefile\n src/fe-text/Makefile\n src/lib-config/Makefile\n@@ -611,6 +650,7 @@ echo\n \n echo \"Building text frontend ........... : $want_textui\"\n echo \"Building irssi bot ............... : $want_irssibot\"\n+echo \"Building irssi fuzzer ............ : $want_irssifuzzer\"\n echo \"Building irssi proxy ............. : $want_irssiproxy\"\n if test \"x$have_gmodule\" = \"xyes\"; then\n 	echo \"Building with module support ..... : yes\"\n','false','true','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','Makefile.am','16','0','5','1','MODIFY','@@ -6,6 +6,10 @@ if BUILD_IRSSIBOT\n BOTUI=fe-none\n endif\n \n+if BUILD_IRSSIFUZZER\n+FUZZERUI=fe-fuzz\n+endif\n+\n if HAVE_PERL\n PERLDIR=perl\n endif\n@@ -14,4 +18,4 @@ pkginc_srcdir=$(pkgincludedir)/src\n pkginc_src_HEADERS = \\\n 	common.h\n \n-SUBDIRS = lib-config core irc fe-common $(PERLDIR) $(TEXTUI) $(BOTUI)\n+SUBDIRS = lib-config core irc fe-common $(PERLDIR) $(TEXTUI) $(BOTUI) $(FUZZERUI)\n','false','false','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','Makefile.am','18','0','25','0','ADD','@@ -0,0 +1,25 @@\n+bin_PROGRAMS = irssi-fuzz\n+\n+# Force link with clang++ for libfuzzer support\n+CCLD=clang++ $(CXXFLAGS)\n+\n+AM_CPPFLAGS = \\\n+	-I$(top_srcdir)/src \\\n+	-I$(top_srcdir)/src/core/ \\\n+	-I$(top_srcdir)/src/irc/core/ \\\n+	-I$(top_srcdir)/src/fe-common/core/ \\\n+	$(GLIB_CFLAGS)\n+\n+irssi_fuzz_DEPENDENCIES = @COMMON_LIBS@\n+\n+irssi_fuzz_LDADD = \\\n+	@COMMON_LIBS@ \\\n+	@PROG_LIBS@ \\\n+	$(FUZZER_LIBS)\n+\n+irssi_fuzz_SOURCES = \\\n+        irssi.c \\\n+	module-formats.c\n+\n+noinst_HEADERS = \\\n+	module-formats.h\n','false','false','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','irssi.c','34','2','58','0','ADD','@@ -0,0 +1,58 @@\n+/*\n+ irssi.c : irssi\n+\n+    Copyright (C) 2017 Joseph Bisch\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+*/\n+\n+#include \"module.h\"\n+#include \"modules-load.h\"\n+#include \"levels.h\"\n+#include \"module-formats.h\"\n+#include \"themes.h\"\n+#include \"core.h\"\n+#include \"fe-common-core.h\"\n+#include \"args.h\"\n+#include \"printtext.h\"\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int LLVMFuzzerInitialize(int *argc, char ***argv) {\n+	core_register_options();\n+	fe_common_core_register_options();\n+	/* no args */\n+	args_execute(0, NULL);\n+	core_preinit((*argv)[0]);\n+	core_init();\n+	fe_common_core_init();\n+	theme_register(gui_text_formats);\n+	module_register(\"core\", \"fe-fuzz\");\n+	printtext_string(NULL, NULL, MSGLEVEL_CLIENTCRAP, \"init\");\n+	return 0;\n+}\n+\n+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n+	char *copy = (char *)malloc(sizeof(char)*(size+1));\n+	memcpy(copy, data, size);\n+	copy[size] = \'\\0\';\n+	printtext_string(NULL, NULL, MSGLEVEL_CLIENTCRAP, copy);\n+	free(copy);\n+	return 0;\n+}\n','false','false','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','module-formats.c','48','0','82','0','ADD','@@ -0,0 +1,82 @@\n+/*\n+ module-formats.c : irssi\n+\n+    Copyright (C) 2000 Timo Sirainen\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+*/\n+\n+#include \"module.h\"\n+#include \"formats.h\"\n+\n+FORMAT_REC gui_text_formats[] =\n+{\n+	{ MODULE_NAME, \"Text user interface\", 0 },\n+\n+	/* ---- */\n+	{ NULL, \"Lastlog\", 0 },\n+\n+	{ \"lastlog_too_long\", \"/LASTLOG would print $0 lines. If you really want to print all these lines use -force option.\", 1, { 1 } },\n+	{ \"lastlog_count\", \"{hilight Lastlog}: $0 lines\", 1, { 1 } },\n+	{ \"lastlog_start\", \"{hilight Lastlog}:\", 0 },\n+	{ \"lastlog_end\", \"{hilight End of Lastlog}\", 0 },\n+	{ \"lastlog_separator\", \"--\", 0 },\n+	{ \"lastlog_date\", \"%%F \", 0 },\n+\n+	/* ---- */\n+	{ NULL, \"Windows\", 0 },\n+\n+	{ \"refnum_not_found\", \"Window number $0 not found\", 1, { 0 } },\n+	{ \"window_too_small\", \"Not enough room to resize this window\", 0 },\n+	{ \"cant_hide_last\", \"You can\'t hide the last window\", 0 },\n+	{ \"cant_hide_sticky_windows\", \"You can\'t hide sticky windows (use /WINDOW STICK OFF)\", 0 },\n+	{ \"cant_show_sticky_windows\", \"You can\'t show sticky windows (use /WINDOW STICK OFF)\", 0 },\n+	{ \"window_not_sticky\", \"Window is not sticky\", 0 },\n+	{ \"window_set_sticky\", \"Window set sticky\", 0 },\n+	{ \"window_unset_sticky\", \"Window is not sticky anymore\", 0 },\n+	{ \"window_info_sticky\", \"%#Sticky  : $0\", 1, { 0 } },\n+	{ \"window_info_scroll\", \"%#Scroll  : $0\", 1, { 0 } },\n+	{ \"window_scroll\", \"Window scroll mode is now $0\", 1, { 0 } },\n+	{ \"window_scroll_unknown\", \"Unknown scroll mode $0, must be ON, OFF or DEFAULT\", 1, { 0 } },\n+\n+	/* ---- */\n+	{ NULL, \"Statusbars\", 0 },\n+\n+	{ \"statusbar_list_header\", \"%#Name                           Type   Placement Position Visible\", 0 },\n+	{ \"statusbar_list_footer\", \"\", 0 },\n+	{ \"statusbar_list\", \"%#$[30]0 $[6]1 $[9]2 $[8]3 $4\", 5, { 0, 0, 0, 1, 0 } },\n+	{ \"statusbar_info_name\", \"%#Statusbar: {hilight $0}\", 1, { 0 } },\n+	{ \"statusbar_info_type\", \"%#Type     : $0\", 1, { 0 } },\n+	{ \"statusbar_info_placement\", \"%#Placement: $0\", 1, { 0 } },\n+	{ \"statusbar_info_position\", \"%#Position : $0\", 1, { 1 } },\n+	{ \"statusbar_info_visible\", \"%#Visible  : $0\", 1, { 0 } },\n+	{ \"statusbar_info_item_header\", \"%#Items    : Name                                Priority  Alignment\", 0 },\n+	{ \"statusbar_info_item_footer\", \"\", 0 },\n+	{ \"statusbar_info_item_name\",  \"%#         : $[35]0 $[9]1 $2\", 3, { 0, 1, 0 } },\n+	{ \"statusbar_not_found\", \"Statusbar doesn\'t exist: $0\", 1, { 0 } },\n+	{ \"statusbar_item_not_found\", \"Statusbar item doesn\'t exist: $0\", 1, { 0 } },\n+	{ \"statusbar_unknown_command\", \"Unknown statusbar command: $0\", 1, { 0 } },\n+	{ \"statusbar_unknown_type\", \"Statusbar type must be \'window\' or \'root\'\", 1, { 0 } },\n+	{ \"statusbar_unknown_placement\", \"Statusbar placement must be \'top\' or \'bottom\'\", 1, { 0 } },\n+	{ \"statusbar_unknown_visibility\", \"Statusbar visibility must be \'always\', \'active\' or \'inactive\'\", 1, { 0 } },\n+\n+	/* ---- */\n+	{ NULL, \"Pasting\", 0 },\n+\n+	{ \"paste_warning\", \"Pasting $0 lines to $1. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.\", 2, { 1, 0 } },\n+	{ \"paste_prompt\", \"Hit Ctrl-K to paste, Ctrl-C to abort?\", 0 },\n+\n+	{ NULL, NULL, 0 }\n+};\n','false','false','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','module-formats.h','47','0','58','0','ADD','@@ -0,0 +1,58 @@\n+#include \"formats.h\"\n+\n+enum {\n+	TXT_MODULE_NAME,\n+\n+	TXT_FILL_1,\n+\n+        TXT_LASTLOG_TOO_LONG,\n+        TXT_LASTLOG_COUNT,\n+	TXT_LASTLOG_START,\n+	TXT_LASTLOG_END,\n+	TXT_LASTLOG_SEPARATOR,\n+	TXT_LASTLOG_DATE,\n+\n+	TXT_FILL_2,\n+\n+        TXT_REFNUM_NOT_FOUND,\n+        TXT_WINDOW_TOO_SMALL,\n+        TXT_CANT_HIDE_LAST,\n+	TXT_CANT_HIDE_STICKY_WINDOWS,\n+        TXT_CANT_SHOW_STICKY_WINDOWS,\n+        TXT_WINDOW_NOT_STICKY,\n+        TXT_WINDOW_SET_STICKY,\n+	TXT_WINDOW_UNSET_STICKY,\n+	TXT_WINDOW_INFO_STICKY,\n+        TXT_WINDOW_INFO_SCROLL,\n+        TXT_WINDOW_SCROLL,\n+        TXT_WINDOW_SCROLL_UNKNOWN,\n+\n+	TXT_FILL_3,\n+\n+        TXT_STATUSBAR_LIST_HEADER,\n+	TXT_STATUSBAR_LIST_FOOTER,\n+	TXT_STATUSBAR_LIST,\n+	TXT_STATUSBAR_INFO_NAME,\n+	TXT_STATUSBAR_INFO_TYPE,\n+        TXT_STATUSBAR_INFO_PLACEMENT,\n+	TXT_STATUSBAR_INFO_POSITION,\n+	TXT_STATUSBAR_INFO_VISIBLE,\n+        TXT_STATUSBAR_INFO_ITEM_HEADER,\n+	TXT_STATUSBAR_INFO_ITEM_FOOTER,\n+        TXT_STATUSBAR_INFO_ITEM_NAME,\n+        TXT_STATUSBAR_NOT_FOUND,\n+        TXT_STATUSBAR_ITEM_NOT_FOUND,\n+	TXT_STATUSBAR_UNKNOWN_COMMAND,\n+        TXT_STATUSBAR_UNKNOWN_TYPE,\n+	TXT_STATUSBAR_UNKNOWN_PLACEMENT,\n+        TXT_STATUSBAR_UNKNOWN_VISIBILITY,\n+\n+	TXT_FILL_4,\n+\n+	TXT_PASTE_WARNING,\n+	TXT_PASTE_PROMPT,\n+\n+	TXT_COUNT\n+};\n+\n+extern FORMAT_REC gui_text_formats[TXT_COUNT+1];\n','false','false','none'),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','add frontend for fuzzing\n\nuse the following configure command:\n\n$ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libfuzzer.a \\\n      cc=clang cxx=clang++\n\nplaces an irssi-fuzz in src/fe-fuzz/ after build.\n\nalso can specify sanflags to override the chosen sanitizer flags\n(defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','tokens.txt','143','0','143','0','ADD','@@ -0,0 +1,143 @@\n+\"@%+\"\n+\"*@*!*\"\n+\"001\"\n+\"002\"\n+\"003\"\n+\"004\"\n+\"005\"\n+\"221\"\n+\"254\"\n+\"271\"\n+\"272\"\n+\"281\"\n+\"301\"\n+\"302\"\n+\"303\"\n+\"305\"\n+\"306\"\n+\"311\"\n+\"312\"\n+\"313\"\n+\"314\"\n+\"315\"\n+\"317\"\n+\"318\"\n+\"319\"\n+\"324\"\n+\"326\"\n+\"327\"\n+\"328\"\n+\"329\"\n+\"330\"\n+\"332\"\n+\"333\"\n+\"338\"\n+\"341\"\n+\"344\"\n+\"345\"\n+\"346\"\n+\"347\"\n+\"348\"\n+\"349\"\n+\"352\"\n+\"353\"\n+\"364\"\n+\"365\"\n+\"366\"\n+\"367\"\n+\"368\"\n+\"369\"\n+\"372\"\n+\"375\"\n+\"376\"\n+\"377\"\n+\"378\"\n+\"379\"\n+\"381\"\n+\"386\"\n+\"387\"\n+\"388\"\n+\"389\"\n+\"396\"\n+\"401\"\n+\"403\"\n+\"404\"\n+\"405\"\n+\"407\"\n+\"408\"\n+\"410\"\n+\"421\"\n+\"422\"\n+\"433\"\n+\"436\"\n+\"437\"\n+\"438\"\n+\"439\"\n+\"442\"\n+\"465\"\n+\"470\"\n+\"471\"\n+\"472\"\n+\"473\"\n+\"474\"\n+\"475\"\n+\"476\"\n+\"477\"\n+\"478\"\n+\"479\"\n+\"482\"\n+\"486\"\n+\"489\"\n+\"494\"\n+\"506\"\n+\"707\"\n+\"716\"\n+\"717\"\n+\"728\"\n+\"729\"\n+\"902\"\n+\"903\"\n+\"904\"\n+\"905\"\n+\"906\"\n+\"907\"\n+\":a\"\n+\"+a\"\n+\"ACK\"\n+\"authenticate\"\n+\"away\"\n+\"-b\"\n+\"+b\"\n+\"cap\"\n+\"#chan\"\n+\"connected\"\n+\"empty\"\n+\"error\"\n+\"invite\"\n+\"join\"\n+\"kick\"\n+\"kill\"\n+\"LS\"\n+\"mode\"\n+\"multi-prefix\"\n+\"NAK\"\n+\"network\"\n+\"nick\"\n+\"nicklen\"\n+\"notice\"\n+\"-o\"\n+\"+o\"\n+\"part\"\n+\"ping\"\n+\"pong\"\n+\"prefix\"\n+\"privmsg\"\n+\"quit\"\n+\"sasl\"\n+\"topic\"\n+\"wallops\"\n+\"watch\"\n+\":\\x01\"\n+\":\\x01ACTION\"\n+\":\\x01PING\"\n+\":\\x01VERSION\"\n','false','false','none'),('irssi','1.0.0','17fc77565e3278ffc19c5294be57c2467f43974b','ailin-nemui','fix regression in completion\n\nfixes #609','completion.c','639','180','1','1','MODIFY','@@ -191,7 +191,7 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i\n 				g_strdup_printf(\"%s%c%s\",\n 						/* do not accidentally duplicate the word separator */\n 						line == wordstart - 1 ? \"\" : linestart,\n-						wordstart[-1], word);\n+						old_wordstart[-1], word);\n 			g_free(old);\n \n 			g_free(word);\n','true','false','none'),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','don\'t duplicate module-formats.* in fe-fuzz','Makefile.am','18','0','2','2','MODIFY','@@ -19,7 +19,7 @@ irssi_fuzz_LDADD = \\\n \n irssi_fuzz_SOURCES = \\\n         irssi.c \\\n-	module-formats.c\n+	$(top_srcdir)/src/fe-text/module-formats.c\n \n noinst_HEADERS = \\\n-	module-formats.h\n+	$(top_srcdir)/src/fe-text/module-formats.h\n','false','false','none'),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','don\'t duplicate module-formats.* in fe-fuzz','irssi.c','34','2','1','1','MODIFY','@@ -21,7 +21,7 @@\n #include \"module.h\"\n #include \"modules-load.h\"\n #include \"levels.h\"\n-#include \"module-formats.h\"\n+#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text\n #include \"themes.h\"\n #include \"core.h\"\n #include \"fe-common-core.h\"\n','false','false','none'),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','don\'t duplicate module-formats.* in fe-fuzz','module-formats.c','None','None','0','82','DELETE','@@ -1,82 +0,0 @@\n-/*\n- module-formats.c : irssi\n-\n-    Copyright (C) 2000 Timo Sirainen\n-\n-    This program is free software; you can redistribute it and/or modify\n-    it under the terms of the GNU General Public License as published by\n-    the Free Software Foundation; either version 2 of the License, or\n-    (at your option) any later version.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU General Public License for more details.\n-\n-    You should have received a copy of the GNU General Public License along\n-    with this program; if not, write to the Free Software Foundation, Inc.,\n-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n-*/\n-\n-#include \"module.h\"\n-#include \"formats.h\"\n-\n-FORMAT_REC gui_text_formats[] =\n-{\n-	{ MODULE_NAME, \"Text user interface\", 0 },\n-\n-	/* ---- */\n-	{ NULL, \"Lastlog\", 0 },\n-\n-	{ \"lastlog_too_long\", \"/LASTLOG would print $0 lines. If you really want to print all these lines use -force option.\", 1, { 1 } },\n-	{ \"lastlog_count\", \"{hilight Lastlog}: $0 lines\", 1, { 1 } },\n-	{ \"lastlog_start\", \"{hilight Lastlog}:\", 0 },\n-	{ \"lastlog_end\", \"{hilight End of Lastlog}\", 0 },\n-	{ \"lastlog_separator\", \"--\", 0 },\n-	{ \"lastlog_date\", \"%%F \", 0 },\n-\n-	/* ---- */\n-	{ NULL, \"Windows\", 0 },\n-\n-	{ \"refnum_not_found\", \"Window number $0 not found\", 1, { 0 } },\n-	{ \"window_too_small\", \"Not enough room to resize this window\", 0 },\n-	{ \"cant_hide_last\", \"You can\'t hide the last window\", 0 },\n-	{ \"cant_hide_sticky_windows\", \"You can\'t hide sticky windows (use /WINDOW STICK OFF)\", 0 },\n-	{ \"cant_show_sticky_windows\", \"You can\'t show sticky windows (use /WINDOW STICK OFF)\", 0 },\n-	{ \"window_not_sticky\", \"Window is not sticky\", 0 },\n-	{ \"window_set_sticky\", \"Window set sticky\", 0 },\n-	{ \"window_unset_sticky\", \"Window is not sticky anymore\", 0 },\n-	{ \"window_info_sticky\", \"%#Sticky  : $0\", 1, { 0 } },\n-	{ \"window_info_scroll\", \"%#Scroll  : $0\", 1, { 0 } },\n-	{ \"window_scroll\", \"Window scroll mode is now $0\", 1, { 0 } },\n-	{ \"window_scroll_unknown\", \"Unknown scroll mode $0, must be ON, OFF or DEFAULT\", 1, { 0 } },\n-\n-	/* ---- */\n-	{ NULL, \"Statusbars\", 0 },\n-\n-	{ \"statusbar_list_header\", \"%#Name                           Type   Placement Position Visible\", 0 },\n-	{ \"statusbar_list_footer\", \"\", 0 },\n-	{ \"statusbar_list\", \"%#$[30]0 $[6]1 $[9]2 $[8]3 $4\", 5, { 0, 0, 0, 1, 0 } },\n-	{ \"statusbar_info_name\", \"%#Statusbar: {hilight $0}\", 1, { 0 } },\n-	{ \"statusbar_info_type\", \"%#Type     : $0\", 1, { 0 } },\n-	{ \"statusbar_info_placement\", \"%#Placement: $0\", 1, { 0 } },\n-	{ \"statusbar_info_position\", \"%#Position : $0\", 1, { 1 } },\n-	{ \"statusbar_info_visible\", \"%#Visible  : $0\", 1, { 0 } },\n-	{ \"statusbar_info_item_header\", \"%#Items    : Name                                Priority  Alignment\", 0 },\n-	{ \"statusbar_info_item_footer\", \"\", 0 },\n-	{ \"statusbar_info_item_name\",  \"%#         : $[35]0 $[9]1 $2\", 3, { 0, 1, 0 } },\n-	{ \"statusbar_not_found\", \"Statusbar doesn\'t exist: $0\", 1, { 0 } },\n-	{ \"statusbar_item_not_found\", \"Statusbar item doesn\'t exist: $0\", 1, { 0 } },\n-	{ \"statusbar_unknown_command\", \"Unknown statusbar command: $0\", 1, { 0 } },\n-	{ \"statusbar_unknown_type\", \"Statusbar type must be \'window\' or \'root\'\", 1, { 0 } },\n-	{ \"statusbar_unknown_placement\", \"Statusbar placement must be \'top\' or \'bottom\'\", 1, { 0 } },\n-	{ \"statusbar_unknown_visibility\", \"Statusbar visibility must be \'always\', \'active\' or \'inactive\'\", 1, { 0 } },\n-\n-	/* ---- */\n-	{ NULL, \"Pasting\", 0 },\n-\n-	{ \"paste_warning\", \"Pasting $0 lines to $1. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.\", 2, { 1, 0 } },\n-	{ \"paste_prompt\", \"Hit Ctrl-K to paste, Ctrl-C to abort?\", 0 },\n-\n-	{ NULL, NULL, 0 }\n-};\n','false','false','none'),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','don\'t duplicate module-formats.* in fe-fuzz','module-formats.h','None','None','0','58','DELETE','@@ -1,58 +0,0 @@\n-#include \"formats.h\"\n-\n-enum {\n-	TXT_MODULE_NAME,\n-\n-	TXT_FILL_1,\n-\n-        TXT_LASTLOG_TOO_LONG,\n-        TXT_LASTLOG_COUNT,\n-	TXT_LASTLOG_START,\n-	TXT_LASTLOG_END,\n-	TXT_LASTLOG_SEPARATOR,\n-	TXT_LASTLOG_DATE,\n-\n-	TXT_FILL_2,\n-\n-        TXT_REFNUM_NOT_FOUND,\n-        TXT_WINDOW_TOO_SMALL,\n-        TXT_CANT_HIDE_LAST,\n-	TXT_CANT_HIDE_STICKY_WINDOWS,\n-        TXT_CANT_SHOW_STICKY_WINDOWS,\n-        TXT_WINDOW_NOT_STICKY,\n-        TXT_WINDOW_SET_STICKY,\n-	TXT_WINDOW_UNSET_STICKY,\n-	TXT_WINDOW_INFO_STICKY,\n-        TXT_WINDOW_INFO_SCROLL,\n-        TXT_WINDOW_SCROLL,\n-        TXT_WINDOW_SCROLL_UNKNOWN,\n-\n-	TXT_FILL_3,\n-\n-        TXT_STATUSBAR_LIST_HEADER,\n-	TXT_STATUSBAR_LIST_FOOTER,\n-	TXT_STATUSBAR_LIST,\n-	TXT_STATUSBAR_INFO_NAME,\n-	TXT_STATUSBAR_INFO_TYPE,\n-        TXT_STATUSBAR_INFO_PLACEMENT,\n-	TXT_STATUSBAR_INFO_POSITION,\n-	TXT_STATUSBAR_INFO_VISIBLE,\n-        TXT_STATUSBAR_INFO_ITEM_HEADER,\n-	TXT_STATUSBAR_INFO_ITEM_FOOTER,\n-        TXT_STATUSBAR_INFO_ITEM_NAME,\n-        TXT_STATUSBAR_NOT_FOUND,\n-        TXT_STATUSBAR_ITEM_NOT_FOUND,\n-	TXT_STATUSBAR_UNKNOWN_COMMAND,\n-        TXT_STATUSBAR_UNKNOWN_TYPE,\n-	TXT_STATUSBAR_UNKNOWN_PLACEMENT,\n-        TXT_STATUSBAR_UNKNOWN_VISIBILITY,\n-\n-	TXT_FILL_4,\n-\n-	TXT_PASTE_WARNING,\n-	TXT_PASTE_PROMPT,\n-\n-	TXT_COUNT\n-};\n-\n-extern FORMAT_REC gui_text_formats[TXT_COUNT+1];\n','false','false','none'),('irssi','1.0.0','b15c27cc63fa967f3e8fe98fdc6d093dd8692c93','dx','revert \"don\'t reset wait_cmd during connection registration (fixes early ison)\"','irc-servers.c','777','195','0','6','MODIFY','@@ -527,12 +527,6 @@ void irc_server_send_data(IRC_SERVER_REC *server, const char *data, int len)\n 		return;\n 	}\n \n-	/* Don\'t reset wait_cmd during connection registration\n-	 * (while sending CAP / SASL related commands) */\n-	if (!server->connected) {\n-		return;\n-	}\n-\n 	g_get_current_time(&server->last_cmd);\n \n 	/* A bit kludgy way to do the flood protection. In ircnet, there\n','true','false','none'),('irssi','1.0.0','fe1ea4b80a3467c23b1ec2d30bdfe4cfaf9b94d6','Joseph Bisch','fix fe-fuzz nits','configure.ac','661','4','0','1','MODIFY','@@ -650,7 +650,6 @@ echo\n \n echo \"Building text frontend ........... : $want_textui\"\n echo \"Building irssi bot ............... : $want_irssibot\"\n-echo \"Building irssi fuzzer ............ : $want_irssifuzzer\"\n echo \"Building irssi proxy ............. : $want_irssiproxy\"\n if test \"x$have_gmodule\" = \"xyes\"; then\n 	echo \"Building with module support ..... : yes\"\n','true','false','none'),('irssi','1.0.0','fe1ea4b80a3467c23b1ec2d30bdfe4cfaf9b94d6','Joseph Bisch','fix fe-fuzz nits','irssi.c','33','2','0','1','MODIFY','@@ -28,7 +28,6 @@\n #include \"args.h\"\n #include \"printtext.h\"\n \n-#include <stdbool.h>\n #include <stddef.h>\n #include <stdint.h>\n #include <stdlib.h>\n','true','false','none'),('irssi','1.0.0','677fb1f55ca52d0e43c93f7d8361d333ff5bffd6','Hanno','perl_parse needs null terminated parameter list.','perl-core.c','321','60','2','2','MODIFY','@@ -41,7 +41,7 @@ GSList *perl_scripts;\n PerlInterpreter *my_perl;\n \n static int print_script_errors;\n-static char *perl_args[] = {\"\", \"-e\", \"0\"};\n+static char *perl_args[] = {\"\", \"-e\", \"0\", NULL};\n \n #define IS_PERL_SCRIPT(file) \\\n 	(strlen(file) > 3 && g_strcmp0(file+strlen(file)-3, \".pl\") == 0)\n@@ -123,7 +123,7 @@ void perl_scripts_init(void)\n 	my_perl = perl_alloc();\n 	perl_construct(my_perl);\n \n-	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args), perl_args, NULL);\n+	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args)-1, perl_args, NULL);\n #if PERL_STATIC_LIBS == 1\n 	perl_eval_pv(\"Irssi::Core::->boot_Irssi_Core(0.9);\", TRUE);\n #endif\n','false','false','none'),('irssi','1.0.0','c8dafe2a76f199f35e24440ca85796454717965e','Joseph Bisch','add suppress_printf_fallback\n\nthere are some cases (such as fuzzing with fe-fuzz) where suppressing\nprintf output may be desirable.','printtext.c','400','72','2','0','MODIFY','@@ -446,7 +446,9 @@ static void sig_print_text(TEXT_DEST_REC *dest, const char *text)\n \n 	if (dest->window == NULL) {\n                 str = strip_codes(text);\n+#ifndef SUPPRESS_PRINTF_FALLBACK\n 		printf(\"NO WINDOWS: %s\\n\", str);\n+#endif\n                 g_free(str);\n                 return;\n 	}\n','false','false','not suppress_printf_fallback'),('irssi','1.0.0','6221ce520644efe4095bfecbc29f11c9c6962e0f','Joseph Bisch','fix glib-2.0.m4 so that $pkg_config doesn\'t break configure script\n\nif $pkg_config contains a space, then the test may not work, so\nsurround with quotation mark characters. (for example,\npkg_config=\"pkg-config --static\" breaks configure before this commit).','glib-2.0.m4','199','0','1','1','MODIFY','@@ -43,7 +43,7 @@ AC_ARG_ENABLE(glibtest, [  --disable-glibtest      do not try to compile and run\n   min_glib_version=ifelse([$1], ,2.0.0,$1)\n   AC_MSG_CHECKING(for GLIB - version >= $min_glib_version)\n \n-  if test x$PKG_CONFIG != xno ; then\n+  if test \"x$PKG_CONFIG\" != xno ; then\n     ## don\'t try to run the test against uninstalled libtool libs\n     if $PKG_CONFIG --uninstalled $pkg_config_args; then\n 	  echo \"Will use uninstalled version of GLib found in PKG_CONFIG_PATH\"\n','true','false','none'),('irssi','1.0.0','bc1ff509d2a9dc5592e7c2cb996d0c32cde026ff','ailin-nemui','sync mail.pl','mail.pl','388','0','13','14','MODIFY','@@ -30,6 +30,7 @@ $VERSION = \"2.92\";\n # Check /mailbox help for help.\n \n use Irssi::TextUI;\n+use Irssi;\n \n my $maildirmode = 0; # maildir=1, file(spools)=0\n my $old_is_not_new = 0; \n@@ -37,7 +38,7 @@ my $extprog;\n my ($last_refresh_time, $refresh_tag);\n \n # for mbox caching\n-my $last_size, $last_mtime, $last_mailcount, $last_mode;\n+my ($last_size, $last_mtime, $last_mailcount, $last_mode);\n \n # list of mailboxes\n my %mailboxes = (); \n@@ -101,8 +102,9 @@ sub mbox_count {\n   my $old_is_not_new=Irssi::settings_get_bool(\'mail_oldnotnew\');\n \n   if ($extprog ne \"\") {\n-     $total = `$extprog`;\n-     chomp $unread;\n+     my $total = `$extprog`;\n+     chomp $total;\n+     ($read, $unread) = split \' \', $total, 2;\n   } else {\n     if (!$maildirmode) {\n       if (-f $mailfile) {\n@@ -115,8 +117,7 @@ sub mbox_count {\n 	$last_size = $size;\n 	$last_mtime = $mtime;\n \n-	my $f = gensym;\n-	return 0 if (!open($f, \"<\", $mailfile));\n+	return 0 if (!open(my $f, \"<\", $mailfile));\n \n 	# count new mails only\n 	my $internal_removed = 0;\n@@ -205,7 +206,7 @@ sub mail {\n   my $total = 0;\n \n   # check all mailboxes for new email\n-  foreach $name (keys(%mailboxes)) {\n+  foreach my $name (keys(%mailboxes)) {\n     my $box = $mailboxes{$name};\n     # replace \"~/\" at the beginning by the user\'s home dir\n     $box =~ s/^~\\//$ENV{\'HOME\'}\\//;\n@@ -233,7 +234,7 @@ sub mail {\n     # Show this only if there are any new, unread messages.\n     if (Irssi::settings_get_bool(\'mail_show_message\') &&\n         $unread > $new_mails_in_box{$name}) {\n-      $new_mails = $unread - $new_mails_in_box{$name};\n+      my $new_mails = $unread - $new_mails_in_box{$name};\n       if ($nummailboxes == 1) {\n         Irssi::print(\"You have $new_mails new message\" . ($new_mails != 1 ? \"s.\" : \".\"), MSGLEVEL_CRAP);\n       } else {\n@@ -263,11 +264,9 @@ sub add_mailboxes {\n   my $boxstring = $_[0];\n   my @boxes = split(/,/, $boxstring);\n \n-  foreach $dbox(@boxes) {\n-    my $name = $dbox;\n-    $name = substr($dbox, 0, index($dbox, \'=\'));\n-    my $box = $dbox;\n-    $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox));\n+  foreach my $dbox(@boxes) {\n+    my $name = substr($dbox, 0, index($dbox, \'=\'));\n+    my $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox));\n     addmailbox($name, $box);\n   }\n }\n@@ -306,7 +305,7 @@ sub delmailbox {\n sub update_settings_string {\n   my $setting;\n \n-  foreach $name (keys(%mailboxes)) {\n+  foreach my $name (keys(%mailboxes)) {\n     $setting .= $name . \"=\" . $mailboxes{$name} . \",\";\n   }\n \n@@ -345,7 +344,7 @@ sub cmd_showmailboxes {\n     return;\n   }\n   Irssi::print(\"Mailboxes:\", MSGLEVEL_CRAP);\n-  foreach $box (keys(%mailboxes)) {\n+  foreach my $box (keys(%mailboxes)) {\n     Irssi::print(\"$box: \" . $mailboxes{$box}, MSGLEVEL_CRAP);\n   }\n }\n','false','false','none'),('irssi','1.0.0','876c1dd93e06b9e627918f142f547e3deea682be','ailin-nemui','implement break_wide\n\nfor more pleasant east asian mixed display','gui-windows.c','218','51','7','3','MODIFY','@@ -49,6 +49,7 @@ static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,\n 					   settings_get_int(\"indent\"),\n 					   !settings_get_bool(\"indent_always\"),\n 					   get_default_indent_func());\n+	textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));\n 	if (parent->active == window)\n 		textbuffer_view_set_window(gui->view, parent->screen_win);\n 	return gui;\n@@ -201,12 +202,14 @@ void gui_windows_reset_settings(void)\n \n 	for (tmp = windows; tmp != NULL; tmp = tmp->next) {\n 		WINDOW_REC *rec = tmp->data;\n-                GUI_WINDOW_REC *gui = WINDOW_GUI(rec);\n+		GUI_WINDOW_REC *gui = WINDOW_GUI(rec);\n \n-                textbuffer_view_set_default_indent(gui->view,\n+		textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));\n+\n+		textbuffer_view_set_default_indent(gui->view,\n 						   settings_get_int(\"indent\"),\n 						   !settings_get_bool(\"indent_always\"),\n-                                                   get_default_indent_func());\n+						   get_default_indent_func());\n \n 		textbuffer_view_set_scroll(gui->view,\n 					   gui->use_scroll ? gui->scroll :\n@@ -281,6 +284,7 @@ void gui_windows_init(void)\n         settings_add_bool(\"lookandfeel\", \"autostick_split_windows\", TRUE);\n 	settings_add_int(\"lookandfeel\", \"indent\", 10);\n 	settings_add_bool(\"lookandfeel\", \"indent_always\", FALSE);\n+	settings_add_bool(\"lookandfeel\", \"break_wide\", FALSE);\n 	settings_add_bool(\"lookandfeel\", \"scroll\", TRUE);\n \n 	window_create_override = -1;\n','false','false','none'),('irssi','1.0.0','876c1dd93e06b9e627918f142f547e3deea682be','ailin-nemui','implement break_wide\n\nfor more pleasant east asian mixed display','textbuffer-view.c','1043','251','11','1','MODIFY','@@ -307,7 +307,7 @@ view_update_line_cache(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line)\n 			continue;\n 		}\n \n-		if (!view->utf8 && char_width > 1) {\n+		if (view->break_wide && char_width > 1) {\n 			last_space = xpos;\n 			last_space_ptr = next_ptr;\n 			last_color = color; last_fg24 = fg24; last_bg24 = bg24;\n@@ -665,6 +665,16 @@ void textbuffer_view_set_default_indent(TEXT_BUFFER_VIEW_REC *view,\n 	view->default_indent_func = indent_func;\n }\n \n+/* Enable breaking of wide chars */\n+void textbuffer_view_set_break_wide(TEXT_BUFFER_VIEW_REC *view,\n+				    gboolean break_wide)\n+{\n+	if (view->break_wide != break_wide) {\n+		view->break_wide = break_wide;\n+		view_reset_cache(view);\n+	}\n+}\n+\n static void view_unregister_indent_func(TEXT_BUFFER_VIEW_REC *view,\n 					INDENT_FUNC indent_func)\n {\n','false','false','none'),('irssi','1.0.0','876c1dd93e06b9e627918f142f547e3deea682be','ailin-nemui','implement break_wide\n\nfor more pleasant east asian mixed display','textbuffer-view.h','82','0','3','0','MODIFY','@@ -59,6 +59,7 @@ struct _TEXT_BUFFER_VIEW_REC {\n 	unsigned int longword_noindent:1;\n 	unsigned int scroll:1; /* scroll down automatically when at bottom */\n 	unsigned int utf8:1; /* use UTF8 in this view */\n+	unsigned int break_wide:1; /* Break wide chars in this view */\n \n 	TEXT_BUFFER_CACHE_REC *cache;\n 	int ypos; /* cursor position - visible area is 0..height-1 */\n@@ -97,6 +98,8 @@ void textbuffer_view_set_default_indent(TEXT_BUFFER_VIEW_REC *view,\n 					int longword_noindent,\n 					INDENT_FUNC indent_func);\n void textbuffer_views_unregister_indent_func(INDENT_FUNC indent_func);\n+void textbuffer_view_set_break_wide(TEXT_BUFFER_VIEW_REC *view,\n+				    gboolean break_wide);\n \n void textbuffer_view_set_scroll(TEXT_BUFFER_VIEW_REC *view, int scroll);\n void textbuffer_view_set_utf8(TEXT_BUFFER_VIEW_REC *view, int utf8);\n','false','false','none'),('irssi','1.0.0','697dd19d887c58930c76de68268d58f2251904d6','LemonBoy','check whether the client certificate is expired.\n\nright now we only warn the user, the connection keeps going.\nfixes #211','network-openssl.c','643','139','29','7','MODIFY','@@ -420,16 +420,38 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_\n \n 	if (mycert && *mycert) {\n 		char *scert = NULL, *spkey = NULL;\n+		FILE *fp;\n 		scert = convert_home(mycert);\n 		if (mypkey && *mypkey)\n 			spkey = convert_home(mypkey);\n-		ERR_clear_error();\n-		if (! SSL_CTX_use_certificate_file(ctx, scert, SSL_FILETYPE_PEM))\n-			g_warning(\"Loading of client certificate \'%s\' failed: %s\", mycert, ERR_reason_error_string(ERR_get_error()));\n-		else if (! SSL_CTX_use_PrivateKey_file(ctx, spkey ? spkey : scert, SSL_FILETYPE_PEM))\n-			g_warning(\"Loading of private key \'%s\' failed: %s\", mypkey ? mypkey : mycert, ERR_reason_error_string(ERR_get_error()));\n-		else if (! SSL_CTX_check_private_key(ctx))\n-			g_warning(\"Private key does not match the certificate\");\n+\n+		if ((fp = fopen(scert, \"r\"))) {\n+			X509 *cert;\n+			/* Let\'s parse the certificate by hand instead of using\n+			 * SSL_CTX_use_certificate_file so that we can validate\n+			 * some parts of it. */\n+			cert = PEM_read_X509(fp, NULL, get_pem_password_callback, (void *)mypass);\n+			if (cert != NULL) {\n+				/* Only the expiration date is checked right now */\n+				if (X509_cmp_current_time(X509_get_notAfter(cert))  <= 0 ||\n+				    X509_cmp_current_time(X509_get_notBefore(cert)) >= 0)\n+					g_warning(\"The client certificate is expired\");\n+\n+				ERR_clear_error();\n+				if (! SSL_CTX_use_certificate(ctx, cert))\n+					g_warning(\"Loading of client certificate \'%s\' failed: %s\", mycert, ERR_reason_error_string(ERR_get_error()));\n+				else if (! SSL_CTX_use_PrivateKey_file(ctx, spkey ? spkey : scert, SSL_FILETYPE_PEM))\n+					g_warning(\"Loading of private key \'%s\' failed: %s\", mypkey ? mypkey : mycert, ERR_reason_error_string(ERR_get_error()));\n+				else if (! SSL_CTX_check_private_key(ctx))\n+					g_warning(\"Private key does not match the certificate\");\n+\n+				X509_free(cert);\n+			} else\n+				g_warning(\"Loading of client certificate \'%s\' failed: %s\", mycert, ERR_reason_error_string(ERR_get_error()));\n+\n+			fclose(fp);\n+		} else\n+			g_warning(\"Could not find client certificate \'%s\'\", scert);\n 		g_free(scert);\n 		g_free(spkey);\n 	}\n','false','false','none'),('irssi','1.0.0','19c51789967a2f63da033e60f6ef08848b9cd144','LemonBoy','prevent a memory leak during the processing of the sasl response.\n\nwe also get rid of an allocation in the process of doing so.','sasl.c','199','35','10','4','MODIFY','@@ -174,10 +174,16 @@ static gboolean sasl_reassemble_incoming(IRC_SERVER_REC *server, const char *fra\n 		*decoded = g_string_new_len(\"\", 0);\n 	} else {\n 		gsize dec_len;\n-		gchar *tmp;\n-\n-		tmp = (gchar *) g_base64_decode(enc_req->str, &dec_len);\n-		*decoded = g_string_new_len(tmp, dec_len);\n+		gint state = 0;\n+		guint save = 0;\n+\n+		/* Since we\'re not going to use the enc_req GString anymore we\n+		 * can perform the decoding in place. */\n+		dec_len = g_base64_decode_step(enc_req->str, enc_req->len,\n+					       (guchar *)enc_req->str,\n+					       &state, &save);\n+		/* A copy of the data is made when the GString is created. */\n+		*decoded = g_string_new_len(enc_req->str, dec_len);\n 	}\n \n 	g_string_free(enc_req, TRUE);\n','false','false','none'),('irssi','1.0.0','73e8a065bd24092a03c0938eb6c93fec3ee0f4d9','LemonBoy','support openssl 1.1.0.\n\n- x509_get_notbefore becomes x509_get0_notbefore\n- x509_get_notafter becomes x509_get0_notafter\n- asn1_string_data becomes asn1_string_get0_data (and drops the const)\n- the whole library is now initialized by openssl_init_ssl\n\ncloses #597','network-openssl.c','633','137','18','1','MODIFY','@@ -32,6 +32,17 @@\n #include <openssl/ssl.h>\n #include <openssl/err.h>\n \n+/* OpenSSL 1.1.0 introduced some backward-incompatible changes to the api */\n+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n+/* The two functions below could be already defined if OPENSSL_API_COMPAT is\n+ * below the 1.1.0 version so let\'s do a clean start */\n+#undef  X509_get_notBefore\n+#undef  X509_get_notAfter\n+#define X509_get_notBefore(x)     X509_get0_notBefore(x)\n+#define X509_get_notAfter(x)      X509_get0_notAfter(x)\n+#define ASN1_STRING_data(x)       ASN1_STRING_get0_data(x)\n+#endif\n+\n /* ssl i/o channel object */\n typedef struct\n {\n@@ -352,13 +363,19 @@ static GIOFuncs irssi_ssl_channel_funcs = {\n \n static gboolean irssi_ssl_init(void)\n {\n+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n+	if (!OPENSSL_init_ssl(OPENSSL_INIT_SSL_DEFAULT, NULL)) {\n+		g_error(\"Could not initialize OpenSSL\");\n+		return FALSE;\n+	}\n+#else\n 	SSL_library_init();\n 	SSL_load_error_strings();\n 	OpenSSL_add_all_algorithms();\n+#endif\n 	ssl_inited = TRUE;\n \n 	return TRUE;\n-\n }\n \n static int get_pem_password_callback(char *buffer, int max_length, int rwflag, void *pass)\n','false','false','none'),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','merge pull request #602 from mcdutchie/master\n\nmake irssi --with-perl build with separate object directory','Makefile.PL.in','6','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','merge pull request #602 from mcdutchie/master\n\nmake irssi --with-perl build with separate object directory','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi::Irc\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','merge pull request #602 from mcdutchie/master\n\nmake irssi --with-perl build with separate object directory','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi::TextUI\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','merge pull request #602 from mcdutchie/master\n\nmake irssi --with-perl build with separate object directory','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\";\n+use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";\n \n WriteMakefile(\'NAME\' => \'Irssi::UI\',\n               \'LIBS\' => \'\',\n','false','false','none'),('irssi','1.0.0','8dbf186ad6e808c269fa10c22444c89df63f2d7d','ailin-nemui','merge pull request #604 from dequis/solaris\n\nadd openssl_no_ec for solaris 11.3, see issue #598','network-openssl.c','629','135','6','0','MODIFY','@@ -646,7 +646,11 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n #ifdef SSL_get_server_tmp_key\n 	// Show ephemeral key information.\n 	EVP_PKEY *ephemeral_key = NULL;\n+\n+	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598\n+#ifndef OPENSSL_NO_EC\n 	EC_KEY *ec_key = NULL;\n+#endif\n 	char *ephemeral_key_algorithm = NULL;\n 	char *cname = NULL;\n 	int nid;\n@@ -658,6 +662,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n 				tls_rec_set_ephemeral_key_size(tls, EVP_PKEY_bits(ephemeral_key));\n 				break;\n \n+#ifndef OPENSSL_NO_EC\n 			case EVP_PKEY_EC:\n 				ec_key = EVP_PKEY_get1_EC_KEY(ephemeral_key);\n 				nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key));\n@@ -670,6 +675,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n \n 				g_free_and_null(ephemeral_key_algorithm);\n 				break;\n+#endif\n \n 			default:\n 				tls_rec_set_ephemeral_key_algorithm(tls, \"Unknown\");\n','false','false','ssl_get_server_tmp_key'),('irssi','1.0.0','8dbf186ad6e808c269fa10c22444c89df63f2d7d','ailin-nemui','merge pull request #604 from dequis/solaris\n\nadd openssl_no_ec for solaris 11.3, see issue #598','network-openssl.c','629','135','6','0','MODIFY','@@ -646,7 +646,11 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n #ifdef SSL_get_server_tmp_key\n 	// Show ephemeral key information.\n 	EVP_PKEY *ephemeral_key = NULL;\n+\n+	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598\n+#ifndef OPENSSL_NO_EC\n 	EC_KEY *ec_key = NULL;\n+#endif\n 	char *ephemeral_key_algorithm = NULL;\n 	char *cname = NULL;\n 	int nid;\n@@ -658,6 +662,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n 				tls_rec_set_ephemeral_key_size(tls, EVP_PKEY_bits(ephemeral_key));\n 				break;\n \n+#ifndef OPENSSL_NO_EC\n 			case EVP_PKEY_EC:\n 				ec_key = EVP_PKEY_get1_EC_KEY(ephemeral_key);\n 				nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key));\n@@ -670,6 +675,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n \n 				g_free_and_null(ephemeral_key_algorithm);\n 				break;\n+#endif\n \n 			default:\n 				tls_rec_set_ephemeral_key_algorithm(tls, \"Unknown\");\n','false','false','not openssl_no_ec'),('irssi','1.0.0','3a3b34fc633fe8e045bf4b696c41857c9f8c5ba5','ailin-nemui','merge pull request #606 from or4n/master\n\nfix syntax on /help server example','server.in','65','0','1','1','MODIFY','@@ -64,7 +64,7 @@\n     /SERVER CONNECT chat.freenode.net\n     /SERVER CONNECT +chat.freenode.net\n     /SERVER ADD -network Freenode -noautosendcmd orwell.freenode.net\n-    /SERVER ADD -! -auto -host staff.irssi.org -port 6667 -4 -network Freenode -noproxy orwell.freenode.net\n+    /SERVER ADD -! -auto -host staff.irssi.org -4 -network Freenode -noproxy orwell.freenode.net 6667\n     /SERVER MODIFY -network Freenode -noauto orwell.freenode.net\n     /SERVER REMOVE orwell.freenode.net 6667 Freenode\n     /SERVER PURGE\n','false','false','none'),('irssi','1.0.0','929c9477477a4ccf03626388499192d8003b96d5','LemonBoy','merge pull request #608 from tijko/master\n\nfollow g_strsplit with call to g_strfreev','modes.c','700','195','2','1','MODIFY','@@ -743,6 +743,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,\n 			    g_hash_table_lookup(optlist, \"yes\") == NULL) {\n                                 /* too many matches */\n 				g_string_free(str, TRUE);\n+				g_strfreev(matches);\n 				cmd_params_free(free_arg);\n \n 				signal_emit(\"error command\", 1,\n@@ -756,7 +757,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,\n         if (str->len > 0) g_string_truncate(str, str->len-1);\n 	ret = str->str;\n 	g_string_free(str, FALSE);\n-\n+	g_strfreev(matches);\n 	cmd_params_free(free_arg);\n \n 	*ret_channel = channel;\n','false','false','none'),('irssi','1.0.0','d63c93ae1dbb1254a92e8e4fafc39fe8d69d00ae','LemonBoy','merge pull request #613 from ailin-nemui/fix_completion\n\nfix regression in completion','completion.c','639','180','1','1','MODIFY','@@ -191,7 +191,7 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i\n 				g_strdup_printf(\"%s%c%s\",\n 						/* do not accidentally duplicate the word separator */\n 						line == wordstart - 1 ? \"\" : linestart,\n-						wordstart[-1], word);\n+						old_wordstart[-1], word);\n 			g_free(old);\n \n 			g_free(word);\n','false','false','none'),('irssi','1.0.0','1f42d2aa950e4d70bf4c4aebae3a7040bd710cf3','LemonBoy','merge pull request #619 from hannob/master\n\nperl_parse needs null terminated parameter list.','perl-core.c','321','60','2','2','MODIFY','@@ -41,7 +41,7 @@ GSList *perl_scripts;\n PerlInterpreter *my_perl;\n \n static int print_script_errors;\n-static char *perl_args[] = {\"\", \"-e\", \"0\"};\n+static char *perl_args[] = {\"\", \"-e\", \"0\", NULL};\n \n #define IS_PERL_SCRIPT(file) \\\n 	(strlen(file) > 3 && g_strcmp0(file+strlen(file)-3, \".pl\") == 0)\n@@ -123,7 +123,7 @@ void perl_scripts_init(void)\n 	my_perl = perl_alloc();\n 	perl_construct(my_perl);\n \n-	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args), perl_args, NULL);\n+	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args)-1, perl_args, NULL);\n #if PERL_STATIC_LIBS == 1\n 	perl_eval_pv(\"Irssi::Core::->boot_Irssi_Core(0.9);\", TRUE);\n #endif\n','false','false','none'),('irssi','1.0.0','ca5e9bd623862bd9a640bf8799aafa53502b79f6','ailin-nemui','merge pull request #624 from ailin-nemui/mail_pl\n\nsync mail.pl','mail.pl','388','0','13','14','MODIFY','@@ -30,6 +30,7 @@ $VERSION = \"2.92\";\n # Check /mailbox help for help.\n \n use Irssi::TextUI;\n+use Irssi;\n \n my $maildirmode = 0; # maildir=1, file(spools)=0\n my $old_is_not_new = 0; \n@@ -37,7 +38,7 @@ my $extprog;\n my ($last_refresh_time, $refresh_tag);\n \n # for mbox caching\n-my $last_size, $last_mtime, $last_mailcount, $last_mode;\n+my ($last_size, $last_mtime, $last_mailcount, $last_mode);\n \n # list of mailboxes\n my %mailboxes = (); \n@@ -101,8 +102,9 @@ sub mbox_count {\n   my $old_is_not_new=Irssi::settings_get_bool(\'mail_oldnotnew\');\n \n   if ($extprog ne \"\") {\n-     $total = `$extprog`;\n-     chomp $unread;\n+     my $total = `$extprog`;\n+     chomp $total;\n+     ($read, $unread) = split \' \', $total, 2;\n   } else {\n     if (!$maildirmode) {\n       if (-f $mailfile) {\n@@ -115,8 +117,7 @@ sub mbox_count {\n 	$last_size = $size;\n 	$last_mtime = $mtime;\n \n-	my $f = gensym;\n-	return 0 if (!open($f, \"<\", $mailfile));\n+	return 0 if (!open(my $f, \"<\", $mailfile));\n \n 	# count new mails only\n 	my $internal_removed = 0;\n@@ -205,7 +206,7 @@ sub mail {\n   my $total = 0;\n \n   # check all mailboxes for new email\n-  foreach $name (keys(%mailboxes)) {\n+  foreach my $name (keys(%mailboxes)) {\n     my $box = $mailboxes{$name};\n     # replace \"~/\" at the beginning by the user\'s home dir\n     $box =~ s/^~\\//$ENV{\'HOME\'}\\//;\n@@ -233,7 +234,7 @@ sub mail {\n     # Show this only if there are any new, unread messages.\n     if (Irssi::settings_get_bool(\'mail_show_message\') &&\n         $unread > $new_mails_in_box{$name}) {\n-      $new_mails = $unread - $new_mails_in_box{$name};\n+      my $new_mails = $unread - $new_mails_in_box{$name};\n       if ($nummailboxes == 1) {\n         Irssi::print(\"You have $new_mails new message\" . ($new_mails != 1 ? \"s.\" : \".\"), MSGLEVEL_CRAP);\n       } else {\n@@ -263,11 +264,9 @@ sub add_mailboxes {\n   my $boxstring = $_[0];\n   my @boxes = split(/,/, $boxstring);\n \n-  foreach $dbox(@boxes) {\n-    my $name = $dbox;\n-    $name = substr($dbox, 0, index($dbox, \'=\'));\n-    my $box = $dbox;\n-    $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox));\n+  foreach my $dbox(@boxes) {\n+    my $name = substr($dbox, 0, index($dbox, \'=\'));\n+    my $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox));\n     addmailbox($name, $box);\n   }\n }\n@@ -306,7 +305,7 @@ sub delmailbox {\n sub update_settings_string {\n   my $setting;\n \n-  foreach $name (keys(%mailboxes)) {\n+  foreach my $name (keys(%mailboxes)) {\n     $setting .= $name . \"=\" . $mailboxes{$name} . \",\";\n   }\n \n@@ -345,7 +344,7 @@ sub cmd_showmailboxes {\n     return;\n   }\n   Irssi::print(\"Mailboxes:\", MSGLEVEL_CRAP);\n-  foreach $box (keys(%mailboxes)) {\n+  foreach my $box (keys(%mailboxes)) {\n     Irssi::print(\"$box: \" . $mailboxes{$box}, MSGLEVEL_CRAP);\n   }\n }\n','false','false','none'),('irssi','1.0.0','97b182089eec8cc158313c424b453dcaa39e05af','Nei','merge branch \'dub-the-wub\' into \'master\'\r\n\r\nprevent a memory leak during the processing of the sasl response.\r\n\r\nsee merge request !8','sasl.c','199','35','10','4','MODIFY','@@ -174,10 +174,16 @@ static gboolean sasl_reassemble_incoming(IRC_SERVER_REC *server, const char *fra\n 		*decoded = g_string_new_len(\"\", 0);\n 	} else {\n 		gsize dec_len;\n-		gchar *tmp;\n-\n-		tmp = (gchar *) g_base64_decode(enc_req->str, &dec_len);\n-		*decoded = g_string_new_len(tmp, dec_len);\n+		gint state = 0;\n+		guint save = 0;\n+\n+		/* Since we\'re not going to use the enc_req GString anymore we\n+		 * can perform the decoding in place. */\n+		dec_len = g_base64_decode_step(enc_req->str, enc_req->len,\n+					       (guchar *)enc_req->str,\n+					       &state, &save);\n+		/* A copy of the data is made when the GString is created. */\n+		*decoded = g_string_new_len(enc_req->str, dec_len);\n 	}\n \n 	g_string_free(enc_req, TRUE);\n','false','false','none'),('irssi','1.0.1','8ec923082737276bce122e082998928ac038bf7f','Paolo','make themes\' docs more consistent.\n\nmentioning \"sb-item\" was misleading in that there is no such template,\nnor any occurrence of that exact string anywhere else in the source.\n\nin going from `sb-item` to `\"sb\"` i am following the pattern established\nin a couple of comments above:\n\n	\"msgownnick\" specifies the styling …\n	\"ownmsgnick\" specifies …','colorless.theme','236','0','2','2','MODIFY','@@ -261,8 +261,8 @@ abstracts = {\n   # background for topicbar (same default)\n   #sb_topic_bg = \"%8\";\n \n-  # text at the beginning of statusbars. sb-item already puts\n-  # space there,so we don\'t use anything by default.\n+  # text at the beginning of statusbars. \"sb\" already puts a space there,\n+  # so we don\'t use anything by default.\n   sbstart = \"\";\n   # text at the end of statusbars. Use space so that it\'s never\n   # used for anything.\n','false','false','none'),('irssi','1.0.1','8ec923082737276bce122e082998928ac038bf7f','Paolo','make themes\' docs more consistent.\n\nmentioning \"sb-item\" was misleading in that there is no such template,\nnor any occurrence of that exact string anywhere else in the source.\n\nin going from `sb-item` to `\"sb\"` i am following the pattern established\nin a couple of comments above:\n\n	\"msgownnick\" specifies the styling …\n	\"ownmsgnick\" specifies …','default.theme','240','0','2','2','MODIFY','@@ -261,8 +261,8 @@ abstracts = {\n   # background for topicbar (same default)\n   #sb_topic_bg = \"%4\";\n \n-  # text at the beginning of statusbars. sb-item already puts\n-  # space there,so we don\'t use anything by default.\n+  # text at the beginning of statusbars. \"sb\" already puts a space there,\n+  # so we don\'t use anything by default.\n   sbstart = \"\";\n   # text at the end of statusbars. Use space so that it\'s never\n   # used for anything.\n','false','false','none'),('irssi','1.0.1','99e3d8a30bdf68775825eb79e5c29f3af12cd255','ailin-nemui','tag as 1.0.1','NEWS','2866','0','9','0','MODIFY','@@ -1,3 +1,12 @@\n+v1.0.1 2017-02-03  The Irssi team <staff@irssi.org>\n+	- Fix Perl compilation in object dir. By Martijn Dekker (#602, #623).\n+	- Disable EC cryptography on Solaris to fix build (#604, #598).\n+	- Fix incorrect HELP SERVER example (#606, #519).\n+	- Correct memory leak in /OP and /VOICE. By Tim Konick (#608).\n+	- Fix regression that broke second level completion (#613, #609).\n+	- Correct missing NULL termination in perl_parse. By Hanno Böck (#619).\n+	- Sync broken mail.pl script (#624, #607).\n+\n v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>\n 	* Removed --disable-ipv6 (#408).\n 	* /connect Network now aborts with an error if no servers have been\n','false','false','none'),('irssi','1.0.1','99e3d8a30bdf68775825eb79e5c29f3af12cd255','ailin-nemui','tag as 1.0.1','configure.ac','618','0','1','1','MODIFY','@@ -1,4 +1,4 @@\n-AC_INIT(irssi, 1.0.0)\n+AC_INIT(irssi, 1.0.1)\n AC_CONFIG_SRCDIR([src])\n AC_CONFIG_AUX_DIR(build-aux)\n AC_PREREQ(2.50)\n','false','false','none'),('irssi','1.0.1','28df637055bc6f20f26ec40158f428ed4dac3c3d','ailin-nemui','provide net_start_ssl api\n\nfixes #615','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@\n #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */\n #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */\n \n-#define IRSSI_ABI_VERSION 7\n+#define IRSSI_ABI_VERSION 8\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n \n','false','false','none'),('irssi','1.0.1','28df637055bc6f20f26ec40158f428ed4dac3c3d','ailin-nemui','provide net_start_ssl api\n\nfixes #615','network-openssl.c','640','137','16','0','MODIFY','@@ -20,6 +20,7 @@\n \n #include \"module.h\"\n #include \"network.h\"\n+#include \"net-sendbuffer.h\"\n #include \"misc.h\"\n #include \"servers.h\"\n #include \"signals.h\"\n@@ -701,6 +702,21 @@ GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *\n 	return ssl_handle;\n }\n \n+GIOChannel *net_start_ssl(SERVER_REC *server)\n+{\n+	GIOChannel *handle, *ssl_handle;\n+\n+	g_return_val_if_fail(server != NULL, NULL);\n+\n+	handle = net_sendbuffer_handle(server->handle);\n+	if (handle == NULL)\n+		return NULL;\n+\n+	ssl_handle  = irssi_ssl_get_iochannel(handle, server->connrec->port, server);\n+	return ssl_handle;\n+}\n+\n+\n int irssi_ssl_handshake(GIOChannel *handle)\n {\n 	GIOSSLChannel *chan = (GIOSSLChannel *)handle;\n','false','false','none'),('irssi','1.0.1','28df637055bc6f20f26ec40158f428ed4dac3c3d','ailin-nemui','provide net_start_ssl api\n\nfixes #615','network.h','35','0','3','0','MODIFY','@@ -40,6 +40,9 @@ int net_ip_compare(IPADDR *ip1, IPADDR *ip2);\n GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED;\n /* Connect to socket with ip address and SSL*/\n GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server);\n+/* Start TLS */\n+GIOChannel *net_start_ssl(SERVER_REC *server);\n+\n int irssi_ssl_handshake(GIOChannel *handle);\n /* Connect to socket with ip address */\n GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);\n','false','false','none'),('irssi','1.0.1','15736ba5ab63d62bfbf8c7907835e5530ba58311','dequis','notify-ison: don\'t send ison before the connection is done','notify-ison.c','239','44','4','0','MODIFY','@@ -80,6 +80,10 @@ static void ison_send(IRC_SERVER_REC *server, GString *cmd)\n {\n 	MODULE_SERVER_REC *mserver;\n \n+	if (!server->connected) {\n+		return;\n+	}\n+\n 	mserver = MODULE_DATA(server);\n 	mserver->ison_count++;\n \n','false','false','none'),('irssi','1.0.1','98ead50b4eea7cda4b357f1c4b19a741205c6fa4','LemonBoy','prevent some potential null-pointer deferences.\n\nspotted by our friend scan-build.','fe-channels.c','520','131','1','1','MODIFY','@@ -453,7 +453,7 @@ static void display_sorted_nicks(CHANNEL_REC *channel, GSList *nicklist)\n 		}\n 	}\n \n-	if (str->len > strlen(prefix_format)) {\n+	if (prefix_format != NULL && str->len > strlen(prefix_format)) {\n 		printtext(channel->server, channel->visible_name,\n 		          MSGLEVEL_CLIENTCRAP, \"%s\", str->str);\n 	}\n','false','false','none'),('irssi','1.0.1','98ead50b4eea7cda4b357f1c4b19a741205c6fa4','LemonBoy','prevent some potential null-pointer deferences.\n\nspotted by our friend scan-build.','fe-netsplit.c','285','62','2','0','MODIFY','@@ -148,6 +148,8 @@ static void print_server_splits(IRC_SERVER_REC *server, TEMP_SPLIT_REC *rec, con\n 	char *sourceserver;\n 	GSList *tmp;\n \n+	g_return_if_fail(rec->servers != NULL);\n+\n 	destservers = g_string_new(NULL);\n 	for (tmp = rec->servers; tmp != NULL; tmp = tmp->next) {\n 		NETSPLIT_SERVER_REC *rec = tmp->data;\n','false','false','none'),('irssi','1.0.1','98ead50b4eea7cda4b357f1c4b19a741205c6fa4','LemonBoy','prevent some potential null-pointer deferences.\n\nspotted by our friend scan-build.','mainwindows-layout.c','160','37','2','0','MODIFY','@@ -121,6 +121,8 @@ static void sig_layout_restore(void)\n 	if (node == NULL) return;\n \n 	sorted_config = get_sorted_windows_config(node);\n+	if (sorted_config == NULL) return;\n+\n         windows_count = g_slist_length(sorted_config);\n \n         /* calculate the saved terminal height */\n','false','false','none'),('irssi','1.0.1','c067f8e99b9332ca485bf1e1809b745878c80f4a','LemonBoy','do not alias /server <hostname> to /server connect <hostname>\n\ncloses #559.','server.in','63','0','0','2','MODIFY','@@ -59,8 +59,6 @@\n %9Examples:%9\n \n     /SERVER\n-    /SERVER chat.freenode.net\n-    /SERVER +chat.freenode.net\n     /SERVER CONNECT chat.freenode.net\n     /SERVER CONNECT +chat.freenode.net\n     /SERVER ADD -network Freenode -noautosendcmd orwell.freenode.net\n','false','false','none'),('irssi','1.0.1','c067f8e99b9332ca485bf1e1809b745878c80f4a','LemonBoy','do not alias /server <hostname> to /server connect <hostname>\n\ncloses #559.','chat-commands.c','366','114','6','13','MODIFY','@@ -250,19 +250,14 @@ static void cmd_server(const char *data, SERVER_REC *server, WI_ITEM_REC *item)\n 	command_runsub(\"server\", data, server, item);\n }\n \n-static void sig_default_command_server(const char *data, SERVER_REC *server,\n-				       WI_ITEM_REC *item)\n-{\n-        signal_emit(\"command server connect\", 3, data, server, item);\n-}\n-\n-/* SYNTAX: SERVER [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>] [-ssl_pass <password>]\n-                  [-ssl_verify] [-ssl_cafile <cafile>] [-ssl_capath <capath>]\n-                  [-ssl_ciphers <list>]\n-                  [-!] [-noautosendcmd]\n+/* SYNTAX: SERVER CONNECT [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>] \n+		  [-ssl_pass <password>] [-ssl_verify] [-ssl_cafile <cafile>] \n+		  [-ssl_capath <capath>]\n+		  [-ssl_ciphers <list>]\n+		  [-!] [-noautosendcmd]\n 		  [-noproxy] [-network <network>] [-host <hostname>]\n 		  [-rawlog <file>]\n-                  [+]<address>|<chatnet> [<port> [<password> [<nick>]]] */\n+		  [+]<address>|<chatnet> [<port> [<password> [<nick>]]] */\n /* NOTE: -network replaces the old -ircnet flag. */\n static void cmd_server_connect(const char *data, SERVER_REC *server)\n {\n@@ -495,7 +490,6 @@ void chat_commands_init(void)\n 	command_bind(\"foreach channel\", NULL, (SIGNAL_FUNC) cmd_foreach_channel);\n 	command_bind(\"foreach query\", NULL, (SIGNAL_FUNC) cmd_foreach_query);\n \n-	signal_add(\"default command server\", (SIGNAL_FUNC) sig_default_command_server);\n 	signal_add(\"server sendmsg\", (SIGNAL_FUNC) sig_server_sendmsg);\n \n 	command_set_options(\"connect\", \"4 6 !! -network ssl +ssl_cert +ssl_pkey +ssl_pass ssl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_pinned_cert +ssl_pinned_pubkey tls +tls_cert +tls_pkey +tls_pass tls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey +host noproxy -rawlog noautosendcmd\");\n@@ -515,6 +509,5 @@ void chat_commands_deinit(void)\n 	command_unbind(\"foreach channel\", (SIGNAL_FUNC) cmd_foreach_channel);\n 	command_unbind(\"foreach query\", (SIGNAL_FUNC) cmd_foreach_query);\n \n-        signal_remove(\"default command server\", (SIGNAL_FUNC) sig_default_command_server);\n 	signal_remove(\"server sendmsg\", (SIGNAL_FUNC) sig_server_sendmsg);\n }\n','false','false','none'),('irssi','1.0.1','9cae98e6421cb454ecc9b3b48d06cce5a042bb6a','LemonBoy','execute what\'s left in the input queue when the timeout expires.\n\nsimilar to how vim behaves.','keyboard.c','675','147','45','1','MODIFY','@@ -35,6 +35,7 @@\n \n GSList *keyinfos;\n static GHashTable *keys, *default_keys;\n+static int key_timeout;\n \n /* A cache of some sort for key presses that generate a single char only.\n    If the key isn\'t used, used_keys[key] is zero. */\n@@ -48,7 +49,8 @@ static int key_config_frozen;\n \n struct _KEYBOARD_REC {\n 	char *key_state; /* the ongoing key combo */\n-        void *gui_data; /* GUI specific data sent in \"key pressed\" signal */\n+	guint timer_tag; /* used to check when a pending combo has expired */\n+	void *gui_data; /* GUI specific data sent in \"key pressed\" signal */\n };\n \n /* Creates a new \"keyboard\" - this is used only for keeping track of\n@@ -60,6 +62,7 @@ KEYBOARD_REC *keyboard_create(void *data)\n \n 	rec = g_new0(KEYBOARD_REC, 1);\n 	rec->gui_data = data;\n+	rec->timer_tag = 0;\n \n 	signal_emit(\"keyboard created\", 1, rec);\n         return rec;\n@@ -68,6 +71,11 @@ KEYBOARD_REC *keyboard_create(void *data)\n /* Destroys a keyboard */\n void keyboard_destroy(KEYBOARD_REC *keyboard)\n {\n+	if (keyboard->timer_tag > 0) {\n+		g_source_remove(keyboard->timer_tag);\n+		keyboard->timer_tag = 0;\n+	}\n+\n 	signal_emit(\"keyboard destroyed\", 1, keyboard);\n \n         g_free_not_null(keyboard->key_state);\n@@ -592,6 +600,25 @@ static int key_states_search(const unsigned char *combo,\n         return 0;\n }\n \n+static gboolean key_timeout_expired(KEYBOARD_REC *keyboard)\n+{\n+	KEY_REC *rec;\n+\n+	keyboard->timer_tag = 0;\n+\n+	/* So, the timeout has expired with the input queue full, let\'s see if\n+	 * what we\'ve got is bound to some action. */\n+	rec = g_tree_lookup(key_states, keyboard->key_state);\n+	/* Drain the queue anyway. */\n+	g_free_and_null(keyboard->key_state);\n+\n+	if (rec != NULL) {\n+		(void)key_emit_signal(keyboard, rec);\n+	}\n+\n+	return FALSE;\n+}\n+\n int key_pressed(KEYBOARD_REC *keyboard, const char *key)\n {\n 	KEY_REC *rec;\n@@ -601,6 +628,11 @@ int key_pressed(KEYBOARD_REC *keyboard, const char *key)\n 	g_return_val_if_fail(keyboard != NULL, FALSE);\n 	g_return_val_if_fail(key != NULL && *key != \'\\0\', FALSE);\n \n+	if (keyboard->timer_tag > 0) {\n+		g_source_remove(keyboard->timer_tag);\n+		keyboard->timer_tag = 0;\n+	}\n+\n 	if (keyboard->key_state == NULL && key[1] == \'\\0\' &&\n 	    !used_keys[(int) (unsigned char) key[0]]) {\n 		/* fast check - key not used */\n@@ -625,6 +657,13 @@ int key_pressed(KEYBOARD_REC *keyboard, const char *key)\n 	if (g_tree_lookup(key_states, combo) != rec) {\n 		/* key combo continues.. */\n 		keyboard->key_state = combo;\n+		/* respect the timeout if specified by the user */\n+		if (key_timeout > 0) {\n+			keyboard->timer_tag =\n+				g_timeout_add(key_timeout,\n+					      (GSourceFunc) key_timeout_expired,\n+					      keyboard);\n+		}\n                 return 0;\n 	}\n \n@@ -870,6 +909,9 @@ static void read_keyboard_config(void)\n 		key_config_read(tmp->data);\n \n         key_configure_thaw();\n+\n+	/* any positive value other than 0 enables the timeout (in ms). */\n+	key_timeout = settings_get_int(\"key_timeout\");\n }\n \n void keyboard_init(void)\n@@ -883,6 +925,8 @@ void keyboard_init(void)\n         key_config_frozen = 0;\n 	memset(used_keys, 0, sizeof(used_keys));\n \n+	settings_add_int(\"misc\", \"key_timeout\", 0);\n+\n 	key_bind(\"command\", \"Run any command\", NULL, NULL, (SIGNAL_FUNC) sig_command);\n 	key_bind(\"key\", \"Specify name for key binding\", NULL, NULL, (SIGNAL_FUNC) sig_key);\n 	key_bind(\"multi\", \"Run multiple commands\", NULL, NULL, (SIGNAL_FUNC) sig_multi);\n','false','false','none'),('irssi','1.0.1','db85ab7c90f23e00cd444728f6a5b3d1f63254df','LemonBoy','quote the filename when dcc requests are auto accepted.\n\npr #453 forces the user to quote the filenames given to /dcc commands\nwhen they contain spaces but the autoget functionality didn\'t get\nupdated so the filename was always passed without quotes.\n\ncloses #656.','dcc-autoget.c','51','18','1','1','MODIFY','@@ -70,7 +70,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)\n 	file = dcc_get_download_path(dcc->arg);\n 	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&\n 			      stat(file, &statbuf) == 0 ?\n-			      \"RESUME %s %s\" : \"GET %s %s\",\n+			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\",\n 			      dcc->nick, dcc->arg);\n 	signal_emit(\"command dcc\", 2, str, dcc->server);\n         g_free(file);\n','false','false','none'),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','handle file names with quotes.\n\nlet\'s repurpose escape_string and make it more flexible by letting us\nchoose the characters to escape.','misc.c','707','237','11','9','MODIFY','@@ -724,18 +724,20 @@ int expand_escape(const char **data)\n 	}\n }\n \n-/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */\n-char *escape_string(const char *str)\n+/* Escape all the characters in `what\' with a backslash */\n+char *escape_string(const char *str, const char *what)\n {\n-	char *ret, *p;\n+	const char *p;\n+	char *ret;\n \n-	p = ret = g_malloc(strlen(str)*2+1);\n-	while (*str != \'\\0\') {\n-		if (*str == \'\"\' || *str == \'\\\'\' || *str == \'\\\\\')\n-			*p++ = \'\\\\\';\n-		*p++ = *str++;\n+	ret = g_malloc(strlen(str) * 2 + 1);\n+	for (p = str; *p != \'\\0\'; p++, ret++) {\n+		if (strchr(what, *p) != NULL) {\n+			*ret++ = \'\\\\\';\n+		}\n+		*ret = *p;\n 	}\n-	*p = \'\\0\';\n+	*ret = \'\\0\';\n \n 	return ret;\n }\n','false','false','none'),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','handle file names with quotes.\n\nlet\'s repurpose escape_string and make it more flexible by letting us\nchoose the characters to escape.','misc.h','47','0','2','2','MODIFY','@@ -88,8 +88,8 @@ char *stristr_full(const char *data, const char *key);\n char *ascii_strup(char *str);\n char *ascii_strdown(char *str);\n \n-/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */\n-char *escape_string(const char *str);\n+/* Escape all the characters in `what\' with a backslash */\n+char *escape_string(const char *str, const char *what);\n \n /* convert all low-ascii (<32) to ^<A..> combinations */\n char *show_lowascii(const char *str);\n','false','false','none'),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','handle file names with quotes.\n\nlet\'s repurpose escape_string and make it more flexible by letting us\nchoose the characters to escape.','chat-completion.c','954','227','1','1','MODIFY','@@ -1113,7 +1113,7 @@ static void event_text(const char *data, SERVER_REC *server, WI_ITEM_REC *item)\n 	/* the nick is quoted in case it contains \'-\' character. also\n 	   spaces should work too now :) The nick is also escaped in case\n 	   it contains \'\\\' characters */\n-	target = escape_string(window_item_get_target(item));\n+	target = escape_string(window_item_get_target(item), \"\\\"\'\\\\\");\n 	str = g_strdup_printf(IS_CHANNEL(item) ? \"-channel \\\"%s\\\" %s\" :\n 			      IS_QUERY(item) ? \"-nick \\\"%s\\\" %s\" : \"%s %s\",\n 			      target, line);\n','false','false','none'),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','handle file names with quotes.\n\nlet\'s repurpose escape_string and make it more flexible by letting us\nchoose the characters to escape.','dcc-autoget.c','54','18','6','2','MODIFY','@@ -23,6 +23,7 @@\n #include \"masks.h\"\n #include \"settings.h\"\n #include \"servers.h\"\n+#include \"misc.h\"\n \n #include \"dcc-get.h\"\n \n@@ -30,7 +31,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)\n {\n         struct stat statbuf;\n 	const char *masks;\n-        char *str, *file;\n+        char *str, *file, *esc_arg;\n         int max_size;\n \n         if (!IS_DCC_GET(dcc)) return;\n@@ -68,11 +69,14 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)\n \n 	/* ok. but do we want/need to resume? */\n 	file = dcc_get_download_path(dcc->arg);\n+	/* we have to escape the quotes as the whole file name gets quoted */\n+	esc_arg = escape_string(dcc->arg, \"\\\"\");\n 	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&\n 			      stat(file, &statbuf) == 0 ?\n 			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\",\n-			      dcc->nick, dcc->arg);\n+			      dcc->nick, esc_arg);\n 	signal_emit(\"command dcc\", 2, str, dcc->server);\n+	g_free(esc_arg);\n         g_free(file);\n 	g_free(str);\n }\n','false','false','none'),('irssi','1.0.1','9aaa6449a0a554c83d40b56ce0a87bd0cba8bdbf','ailin-nemui','make foreach send commands','chat-commands.c','384','117','34','9','MODIFY','@@ -438,41 +438,66 @@ static void cmd_foreach(const char *data, SERVER_REC *server,\n /* SYNTAX: FOREACH SERVER <command> */\n static void cmd_foreach_server(const char *data, SERVER_REC *server)\n {\n-        GSList *list;\n+	GSList *list;\n+	const char *cmdchars;\n+	char *str;\n+\n+	cmdchars = settings_get_str(\"cmdchars\");\n+	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) :\n+		g_strdup_printf(\"%c%s\", *cmdchars, data);\n \n 	list = g_slist_copy(servers);\n 	while (list != NULL) {\n-		signal_emit(\"send command\", 3, data, list->data, NULL);\n-                list = g_slist_remove(list, list->data);\n+		signal_emit(\"send command\", 3, str, list->data, NULL);\n+		list = g_slist_remove(list, list->data);\n 	}\n+\n+	g_free(str);\n }\n \n /* SYNTAX: FOREACH CHANNEL <command> */\n static void cmd_foreach_channel(const char *data)\n {\n-        GSList *list;\n+	GSList *list;\n+	const char *cmdchars;\n+	char *str;\n+\n+	cmdchars = settings_get_str(\"cmdchars\");\n+	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) :\n+		g_strdup_printf(\"%c%s\", *cmdchars, data);\n \n 	list = g_slist_copy(channels);\n 	while (list != NULL) {\n 		CHANNEL_REC *rec = list->data;\n \n-		signal_emit(\"send command\", 3, data, rec->server, rec);\n-                list = g_slist_remove(list, list->data);\n+		signal_emit(\"send command\", 3, str, rec->server, rec);\n+		list = g_slist_remove(list, list->data);\n 	}\n+\n+	g_free(str);\n }\n \n /* SYNTAX: FOREACH QUERY <command> */\n static void cmd_foreach_query(const char *data)\n {\n-        GSList *list;\n+	GSList *list;\n+	const char *cmdchars;\n+	char *str;\n+\n+	cmdchars = settings_get_str(\"cmdchars\");\n+	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) :\n+		g_strdup_printf(\"%c%s\", *cmdchars, data);\n+\n \n 	list = g_slist_copy(queries);\n 	while (list != NULL) {\n 		QUERY_REC *rec = list->data;\n \n-		signal_emit(\"send command\", 3, data, rec->server, rec);\n-                list = g_slist_remove(list, list->data);\n+		signal_emit(\"send command\", 3, str, rec->server, rec);\n+		list = g_slist_remove(list, list->data);\n 	}\n+\n+	g_free(str);\n }\n \n void chat_commands_init(void)\n','false','false','none'),('irssi','1.0.1','9aaa6449a0a554c83d40b56ce0a87bd0cba8bdbf','ailin-nemui','make foreach send commands','window-commands.c','711','178','13','5','MODIFY','@@ -839,23 +839,31 @@ static void cmd_layout(const char *data, SERVER_REC *server, WI_ITEM_REC *item)\n /* SYNTAX: FOREACH WINDOW <command> */\n static void cmd_foreach_window(const char *data)\n {\n-        WINDOW_REC *old;\n-        GSList *list;\n+	WINDOW_REC *old;\n+	GSList *list;\n+	const char *cmdchars;\n+	char *str;\n \n-        old = active_win;\n+	cmdchars = settings_get_str(\"cmdchars\");\n+	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) :\n+		g_strdup_printf(\"%c%s\", *cmdchars, data);\n+\n+	old = active_win;\n \n 	list = g_slist_copy(windows);\n 	while (list != NULL) {\n 		WINDOW_REC *rec = list->data;\n \n 		active_win = rec;\n-		signal_emit(\"send command\", 3, data, rec->active_server,\n+		signal_emit(\"send command\", 3, str, rec->active_server,\n 			    rec->active);\n-                list = g_slist_remove(list, list->data);\n+		list = g_slist_remove(list, list->data);\n 	}\n \n 	if (g_slist_find(windows, old) != NULL)\n 		active_win = old;\n+\n+	g_free(str);\n }\n \n void window_commands_init(void)\n','false','false','none'),('irssi','1.0.1','7c09b72848f99886964266ff531b41c69fe138f5','dequis','fe-netjoin: remove irc servers on \"server disconnected\" signal','fe-netjoin.c','375','91','16','0','MODIFY','@@ -470,6 +470,20 @@ static void read_settings(void)\n 	}\n }\n \n+static void sig_server_disconnected(IRC_SERVER_REC *server)\n+{\n+	NETJOIN_SERVER_REC *netjoin_server;\n+\n+	g_return_if_fail(server != NULL);\n+\n+	if (!IS_IRC_SERVER(server))\n+		return;\n+\n+	if ((netjoin_server = netjoin_find_server(server))) {\n+		netjoin_server_remove(netjoin_server);\n+	}\n+}\n+\n void fe_netjoin_init(void)\n {\n 	settings_add_bool(\"misc\", \"hide_netsplit_quits\", TRUE);\n@@ -480,6 +494,7 @@ void fe_netjoin_init(void)\n \n 	read_settings();\n 	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings);\n+	signal_add(\"server disconnected\", (SIGNAL_FUNC) sig_server_disconnected);\n }\n \n void fe_netjoin_deinit(void)\n@@ -492,6 +507,7 @@ void fe_netjoin_deinit(void)\n 	}\n \n 	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);\n+	signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_server_disconnected);\n \n 	signal_remove(\"message quit\", (SIGNAL_FUNC) msg_quit);\n 	signal_remove(\"message join\", (SIGNAL_FUNC) msg_join);\n','false','false','none'),('irssi','1.0.1','5c4e6304ce12a3c94cc58eec01d4ef45db4dabc3','Stephen Oberholtzer','don\'t emit the script destroyed signal before script is actually destroyed\n\nthe script unloading code originally worked like this:\n\n1. destroy package\n2. emit \'script destroyed\' signal\n3. unhook script\'s signal handlers\n\nif a script added a \'script destroyed\' signal handler, unloading\nthat script would cause the \'script destroyed\' signal to be sent to the\n(already destroyed) package.  this would cause a script error, which would\ntrigger a script unload, which would start the whole process over again,\nuntil we run out of heap or stack space and segfault.\n\nthis commit simply reorders the operations so that the \'script destroyed\'\nsignal is sent *after* the script is fully destroyed.','perl-core.c','321','60','2','2','MODIFY','@@ -67,11 +67,11 @@ static void perl_script_destroy(PERL_SCRIPT_REC *script)\n {\n 	perl_scripts = g_slist_remove(perl_scripts, script);\n \n-	signal_emit(\"script destroyed\", 1, script);\n-\n 	perl_signal_remove_script(script);\n 	perl_source_remove_script(script);\n \n+	signal_emit(\"script destroyed\", 1, script);\n+\n 	g_free(script->name);\n 	g_free(script->package);\n         g_free_not_null(script->path);\n','false','false','none'),('irssi','1.0.1','dc99f8d7a5f90eebd4c52cef8d186bf20e2a9912','LemonBoy','properly check the command arguments in tail place.\n\na command requiring an argument and given in tail position would not\nraise an error but silently set the value to the empty string \'\'.','commands.c','711','187','3','2','MODIFY','@@ -567,13 +567,14 @@ static int get_cmd_options(char **data, int ignore_unknown,\n \n 	option = NULL; pos = -1;\n 	for (;;) {\n-		if (**data == \'-\') {\n+		if (**data == \'\\0\' || **data == \'-\') {\n 			if (option != NULL && *optlist[pos] == \'+\') {\n 				/* required argument missing! */\n                                 *data = optlist[pos] + 1;\n 				return CMDERR_OPTION_ARG_MISSING;\n 			}\n-\n+		}\n+		if (**data == \'-\') {\n 			(*data)++;\n 			if (**data == \'-\' && (*data)[1] == \' \') {\n 				/* -- option means end of options even\n','false','false','none'),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','revert \"quote the filename when dcc requests are auto accepted.\"','misc.c','705','239','9','11','MODIFY','@@ -724,20 +724,18 @@ int expand_escape(const char **data)\n 	}\n }\n \n-/* Escape all the characters in `what\' with a backslash */\n-char *escape_string(const char *str, const char *what)\n+/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */\n+char *escape_string(const char *str)\n {\n-	const char *p;\n-	char *ret;\n+	char *ret, *p;\n \n-	ret = g_malloc(strlen(str) * 2 + 1);\n-	for (p = str; *p != \'\\0\'; p++, ret++) {\n-		if (strchr(what, *p) != NULL) {\n-			*ret++ = \'\\\\\';\n-		}\n-		*ret = *p;\n+	p = ret = g_malloc(strlen(str)*2+1);\n+	while (*str != \'\\0\') {\n+		if (*str == \'\"\' || *str == \'\\\'\' || *str == \'\\\\\')\n+			*p++ = \'\\\\\';\n+		*p++ = *str++;\n 	}\n-	*ret = \'\\0\';\n+	*p = \'\\0\';\n \n 	return ret;\n }\n','false','false','none'),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','revert \"quote the filename when dcc requests are auto accepted.\"','misc.h','47','0','2','2','MODIFY','@@ -88,8 +88,8 @@ char *stristr_full(const char *data, const char *key);\n char *ascii_strup(char *str);\n char *ascii_strdown(char *str);\n \n-/* Escape all the characters in `what\' with a backslash */\n-char *escape_string(const char *str, const char *what);\n+/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */\n+char *escape_string(const char *str);\n \n /* convert all low-ascii (<32) to ^<A..> combinations */\n char *show_lowascii(const char *str);\n','false','false','none'),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','revert \"quote the filename when dcc requests are auto accepted.\"','chat-completion.c','954','227','1','1','MODIFY','@@ -1113,7 +1113,7 @@ static void event_text(const char *data, SERVER_REC *server, WI_ITEM_REC *item)\n 	/* the nick is quoted in case it contains \'-\' character. also\n 	   spaces should work too now :) The nick is also escaped in case\n 	   it contains \'\\\' characters */\n-	target = escape_string(window_item_get_target(item), \"\\\"\'\\\\\");\n+	target = escape_string(window_item_get_target(item));\n 	str = g_strdup_printf(IS_CHANNEL(item) ? \"-channel \\\"%s\\\" %s\" :\n 			      IS_QUERY(item) ? \"-nick \\\"%s\\\" %s\" : \"%s %s\",\n 			      target, line);\n','false','false','none'),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','revert \"quote the filename when dcc requests are auto accepted.\"','dcc-autoget.c','51','18','3','7','MODIFY','@@ -23,7 +23,6 @@\n #include \"masks.h\"\n #include \"settings.h\"\n #include \"servers.h\"\n-#include \"misc.h\"\n \n #include \"dcc-get.h\"\n \n@@ -31,7 +30,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)\n {\n         struct stat statbuf;\n 	const char *masks;\n-        char *str, *file, *esc_arg;\n+        char *str, *file;\n         int max_size;\n \n         if (!IS_DCC_GET(dcc)) return;\n@@ -69,14 +68,11 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)\n \n 	/* ok. but do we want/need to resume? */\n 	file = dcc_get_download_path(dcc->arg);\n-	/* we have to escape the quotes as the whole file name gets quoted */\n-	esc_arg = escape_string(dcc->arg, \"\\\"\");\n 	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&\n 			      stat(file, &statbuf) == 0 ?\n-			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\",\n-			      dcc->nick, esc_arg);\n+			      \"RESUME %s %s\" : \"GET %s %s\",\n+			      dcc->nick, dcc->arg);\n 	signal_emit(\"command dcc\", 2, str, dcc->server);\n-	g_free(esc_arg);\n         g_free(file);\n 	g_free(str);\n }\n','false','true','none'),('irssi','1.0.1','7bd1b80687cc97010094de0d398b429480e0a608','ailin-nemui','fix dcc get\n\nfixes #656','dcc-autoget.c','54','18','6','3','MODIFY','@@ -23,6 +23,7 @@\n #include \"masks.h\"\n #include \"settings.h\"\n #include \"servers.h\"\n+#include \"misc.h\"\n \n #include \"dcc-get.h\"\n \n@@ -30,7 +31,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)\n {\n         struct stat statbuf;\n 	const char *masks;\n-        char *str, *file;\n+        char *str, *file, *esc_arg;\n         int max_size;\n \n         if (!IS_DCC_GET(dcc)) return;\n@@ -68,11 +69,13 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)\n \n 	/* ok. but do we want/need to resume? */\n 	file = dcc_get_download_path(dcc->arg);\n+	esc_arg = escape_string(dcc->arg);\n 	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&\n 			      stat(file, &statbuf) == 0 ?\n-			      \"RESUME %s %s\" : \"GET %s %s\",\n-			      dcc->nick, dcc->arg);\n+			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\",\n+			      dcc->nick, esc_arg);\n 	signal_emit(\"command dcc\", 2, str, dcc->server);\n+	g_free(esc_arg);\n         g_free(file);\n 	g_free(str);\n }\n','true','false','none'),('irssi','1.0.1','93c158d8156293bd95e4bf5bdb75cf8d44bc4eab','dequis','expand_escape: expand double backslash as a backslash','misc.c','707','240','2','0','MODIFY','@@ -690,6 +690,8 @@ int expand_escape(const char **data)\n 		return \'\\n\';\n 	case \'e\':\n 		return 27; /* ESC */\n+	case \'\\\\\':\n+		return \'\\\\\';\n \n 	case \'x\':\n                 /* hex digit */\n','false','false','none'),('irssi','1.0.1','22bc7fcc3906ff3dd6e3837e049d37dc352edf94','ailin-nemui','amend forgotten fix\n\n(cherry picked from commit 0ada284a257cfb08da984a78dab24c3ddaf09ec7)','NEWS','2869','0','2','0','MODIFY','@@ -8,6 +8,8 @@ v1.0.1 2017-02-03  The Irssi team <staff@irssi.org>\n 	- Fix regression that broke second level completion (#613, #609).\n 	- Correct missing NULL termination in perl_parse. By Hanno Böck (#619).\n 	- Sync broken mail.pl script (#624, #607).\n+	- Prevent a memory leak during the processing of the SASL\n+	  response (GL!8, GL#5)\n \n v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>\n 	* Removed --disable-ipv6 (#408).\n','true','false','none'),('irssi','1.0.2','3930f91edcf4b1e96c9d857233d58f7cb45c8a86','Ailin Nemui','tag as 1.0.2\n\n(cherry picked from commit 2a53853f369b47e42e32e183c8109e3d63808899)','NEWS','2878','0','10','0','MODIFY','@@ -1,5 +1,15 @@\n v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n \n+v1.0.2 2017-03-10  The Irssi team <staff@irssi.org>\n+	- Prevent some null-pointer crashes (GL!9).\n+	- Fix compilation with OpenSSL 1.1.0 (#628, #597).\n+	- Correct dereferencing of already freed server objects during\n+	  output of netjoins. Found by APic (GL!10, GL#7).\n+	- Fix in command arg parser to detect missing arguments in tail place\n+	  (#652, #651).\n+	- Fix regression that broke incoming DCC file transfers (#667, #656).\n+	- Fix issue with escaping \\ in evaluated strings (#669, #520).\n+\n v1.0.1 2017-02-03  The Irssi team <staff@irssi.org>\n 	- Fix Perl compilation in object dir. By Martijn Dekker (#602, #623).\n 	- Disable EC cryptography on Solaris to fix build (#604, #598).\n','false','false','none'),('irssi','1.0.2','966efced3c178031f5f75a1009acc0ec8f897b4a','ailin-nemui','up abi ver','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@\n #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */\n #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */\n \n-#define IRSSI_ABI_VERSION 8\n+#define IRSSI_ABI_VERSION 9\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n \n','false','false','none'),('irssi','1.0.2','a720c3b5efdcd9b580110441bb22be91a4a16732','Rodrigo Rebello','get back to using pkg-config to check for openssl\n\ncommit 6300dfec7 removed the option to disable ssl support from the\nconfigure script since it became a requirement, but it also removed the\nuse of pkg-config for finding the openssl library and its dependencies.\n\nthis had the unfortunate consequence of breaking the correct detection\nof library flags in many static linking scenarios. in some cases, for\nexample, openssl might have been built with zlib, which requires `-lz`\nto be passed to the linker when doing a static link of the irssi\nexecutable. thus, pkg-config becomes an invaluable tool in such\nsituations, since no guessing work is needed as the openssl .pc file\nprovides all the necessary flags.\n\nso, this commit re-inserts the pkg_check_modules macro in the configure\nscript when looking for openssl. the test using ac_check_lib remains,\nbut only as a last resort in case the one using pkg-config fails.\n\nalso, because the macro am_path_glib_2_0 contains an unconditional call\nto pkg_prog_pkg_config, the openssl checks are moved so that they come\nafter the glib ones in order to avoid doubly checking for the pkg-config\nbinary (pkg_check_modules skips that check if it has been performed\nbefore, but pkg_prog_pkg_config does not).','configure.ac','670','4','15','6','MODIFY','@@ -243,11 +243,6 @@ if test \"x$want_socks\" = \"xyes\"; then\n 	])\n fi\n \n-dnl **\n-dnl ** OpenSSL checks\n-dnl **\n-AC_CHECK_LIB([ssl], [SSL_library_init])\n-\n dnl **\n dnl ** fe-text checks\n dnl **\n@@ -289,7 +284,21 @@ if test -z \"$GLIB_LIBS\"; then\n   AC_ERROR([GLIB is required to build irssi.])\n fi\n \n-LIBS=\"$LIBS $GLIB_LIBS -lssl -lcrypto\"\n+LIBS=\"$LIBS $GLIB_LIBS\"\n+\n+dnl **\n+dnl ** OpenSSL checks\n+dnl **\n+PKG_CHECK_MODULES([OPENSSL], [openssl], [\n+	CFLAGS=\"$CFLAGS $OPENSSL_CFLAGS\"\n+	LIBS=\"$LIBS $OPENSSL_LIBS\"\n+], [\n+	AC_CHECK_LIB([ssl], [SSL_library_init], [\n+		LIBS=\"$LIBS -lssl -lcrypto\"\n+	], [\n+		AC_MSG_ERROR([The OpenSSL library was not found])\n+	])\n+])\n \n dnl **\n dnl ** curses checks\n','false','false','none'),('irssi','1.0.2','449b8a4589f1fcadae44387999260ed5f8c6c2bf','Rodrigo Rebello','remove outdated information from install\n\ndisabling ssl support is no longer an option.','INSTALL','80','0','0','4','MODIFY','@@ -30,10 +30,6 @@ configure options\n \n   Build the irssi proxy (see startup-HOWTO).\n \n-  --disable-ssl\n-\n-  Disable SSL support.\n-\n   --with-perl=[yes|no|module]\n \n   Enable Perl support\n','false','false','none'),('irssi','1.0.2','70f9db3cbdc0a3c6b622e64edbd504592f921892','Stephen Oberholtzer','fix delay at startup when running against glib 2.49.3+\n\nin glib v2.49.3, an optimization was made to eliminate certain\nunnecessary wakeups.  (the specific change was made in\ne4ee3079c5afc3c1c3d2415f20c3e8605728f074). before this change, the\nfirst call to g_main_iteration would always complete immediately.\nin irssi, this effectively reversed the order of the main loop, causing\nthe reload_config check and the dirty_check to run *before* the first\nblocking call to g_main_iteration.\n\nwith the new logic, the first g_main_iteration call now blocks,\npreventing the screen from being refreshed until the user starts typing\nor a timer goes off.  (it also delays processing of sighup, but i\nexpect that is not a common situation.)\n\nthis commit reorders the main loop to wait at the end of the loop,\nrather than the beginning, addressing the problem.\n\n(this closes debian bug #856201.)','irssi.c','224','24','4','4','MODIFY','@@ -317,10 +317,6 @@ int main(int argc, char **argv)\n 	/* Does the same as g_main_run(main_loop), except we\n 	   can call our dirty-checker after each iteration */\n 	while (!quitting) {\n-		term_refresh_freeze();\n-		g_main_iteration(TRUE);\n-                term_refresh_thaw();\n-\n 		if (reload_config) {\n                         /* SIGHUP received, do /RELOAD */\n 			reload_config = FALSE;\n@@ -328,6 +324,10 @@ int main(int argc, char **argv)\n 		}\n \n 		dirty_check();\n+\n+		term_refresh_freeze();\n+		g_main_iteration(TRUE);\n+                term_refresh_thaw();\n 	}\n \n 	g_main_destroy(main_loop);\n','true','true','none'),('irssi','1.0.2','2b9be6e2ed446293008d0e850fd726aad30fbcd2','Stephen Oberholtzer','intentation/whitespace fixes\n\nchange several instances of space-indentation to tabs, matching the\nsurrounding code.','irssi.c','224','24','4','4','MODIFY','@@ -318,21 +318,21 @@ int main(int argc, char **argv)\n 	   can call our dirty-checker after each iteration */\n 	while (!quitting) {\n 		if (reload_config) {\n-                        /* SIGHUP received, do /RELOAD */\n+			/* SIGHUP received, do /RELOAD */\n 			reload_config = FALSE;\n-                        signal_emit(\"command reload\", 1, \"\");\n+			signal_emit(\"command reload\", 1, \"\");\n 		}\n \n 		dirty_check();\n \n 		term_refresh_freeze();\n 		g_main_iteration(TRUE);\n-                term_refresh_thaw();\n+		term_refresh_thaw();\n 	}\n \n 	g_main_destroy(main_loop);\n 	textui_deinit();\n \n-        session_upgrade(); /* if we /UPGRADEd, start the new process */\n+	session_upgrade(); /* if we /UPGRADEd, start the new process */\n 	return 0;\n }\n','true','false','none'),('irssi','1.0.2','a4cc4e0ad7278835d976aa5e75ca2b42443f5bb1','Joseph Bisch','fix off by one error with char_expandos','expandos.c','547','114','1','1','MODIFY','@@ -51,7 +51,7 @@ const char *current_expando = NULL;\n \n static int timer_tag;\n \n-static EXPANDO_REC *char_expandos[255];\n+static EXPANDO_REC *char_expandos[256];\n static GHashTable *expandos;\n static char *last_sent_msg, *last_sent_msg_body;\n static char *last_privmsg_from, *last_public_from;\n','true','false','none'),('irssi','1.0.2','41776d71f76924664bce1562ebe37743ba0cc9b7','Joseph Bisch','fix strange history behavior when history is empty\n\nif text is being entered and then the user presses the up arrow\nfollowed by the down arrow, the expected behavior is to return to the\ntext being entered. prior to this commit that was not the case.\n\nfixes #462','command-history.c','227','55','2','0','MODIFY','@@ -116,6 +116,8 @@ const char *command_history_prev(WINDOW_REC *window, const char *text)\n 		history->pos = history->pos->prev;\n 		if (history->pos == NULL)\n                         history->over_counter++;\n+	} else if (history->lines == 0) {\n+		history->over_counter++;\n 	} else {\n 		history->pos = g_list_last(history->list);\n 	}\n','true','false','none'),('irssi','1.0.2','7c86575b02d4f80539bcd2da3bef8195b963fa92','Joseph Bisch','don\'t allow command history to wrap around\n\nthis changes the behavior of the command history to avoid wrapping back\nto the bottom once the top of the history is reached.','command-history.c','220','53','4','10','MODIFY','@@ -113,11 +113,9 @@ const char *command_history_prev(WINDOW_REC *window, const char *text)\n 	pos = history->pos;\n \n 	if (pos != NULL) {\n-		history->pos = history->pos->prev;\n-		if (history->pos == NULL)\n-                        history->over_counter++;\n-	} else if (history->lines == 0) {\n-		history->over_counter++;\n+		/* don\'t go past the first entry (no wrap around) */\n+		if (history->pos->prev != NULL)\n+			history->pos = history->pos->prev;\n 	} else {\n 		history->pos = g_list_last(history->list);\n 	}\n@@ -128,7 +126,7 @@ const char *command_history_prev(WINDOW_REC *window, const char *text)\n 		command_history_add(history, text);\n 	}\n \n-	return history->pos == NULL ? \"\" : history->pos->data;\n+	return history->pos == NULL ? text : history->pos->data;\n }\n \n const char *command_history_next(WINDOW_REC *window, const char *text)\n@@ -141,10 +139,6 @@ const char *command_history_next(WINDOW_REC *window, const char *text)\n \n 	if (pos != NULL)\n 		history->pos = history->pos->next;\n-	else if (history->over_counter > 0) {\n-		history->over_counter--;\n-		history->pos = history->list;\n-	}\n \n 	if (*text != \'\\0\' &&\n 	    (pos == NULL || g_strcmp0(pos->data, text) != 0)) {\n','false','false','none'),('irssi','1.0.2','405136440cbfd18a39e2d5aa01c812a1247c369d','Joseph Bisch','remove over_counter\n\nwe are no longer using over_counter for any functional purpose, so\nremove it.','command-history.c','219','53','0','1','MODIFY','@@ -150,7 +150,6 @@ const char *command_history_next(WINDOW_REC *window, const char *text)\n \n void command_history_clear_pos_func(HISTORY_REC *history, gpointer user_data)\n {\n-	history->over_counter = 0;\n 	history->pos = NULL;\n }\n \n','false','false','none'),('irssi','1.0.2','405136440cbfd18a39e2d5aa01c812a1247c369d','Joseph Bisch','remove over_counter\n\nwe are no longer using over_counter for any functional purpose, so\nremove it.','command-history.h','21','0','1','1','MODIFY','@@ -7,7 +7,7 @@ typedef struct {\n 	char *name;\n \n 	GList *list, *pos;\n-	int lines, over_counter;\n+	int lines;\n \n 	int refcount;\n } HISTORY_REC;\n','false','false','none'),('irssi','1.0.2','3297fafcd9be1fc3f48557a12023a1ef20884985','Joseph Bisch','add syntax info for completion\n\nallows syntax info to be picked up and displayed by help command.\n\nfixes #687','completion.c','639','180','1','0','MODIFY','@@ -784,6 +784,7 @@ static void sig_complete_command(GList **list, WINDOW_REC *window,\n 	if (*list != NULL) signal_stop();\n }\n \n+/* SYNTAX: COMPLETION [-auto] [-delete] <key> <value> */\n static void cmd_completion(const char *data)\n {\n 	GHashTable *optlist;\n','false','false','none'),('irssi','1.0.2','c8a19e112499c0ca1d2b07a98d68415ca1509614','ailin-nemui','detect netbsd terminfo\n\nfixes #694','configure.ac','670','4','1','1','MODIFY','@@ -308,7 +308,7 @@ if test \"x$want_textui\" != \"xno\"; then\n \n 	TEXTUI_NO_LIBS=\"$LIBS\"\n 	LIBS=\n-	AC_SEARCH_LIBS([setupterm], [tinfo ncursesw ncurses], [want_textui=yes], [\n+	AC_SEARCH_LIBS([setupterm], [tinfo ncursesw ncurses terminfo], [want_textui=yes], [\n 		AC_ERROR(Terminfo not found - install libncurses-dev or ncurses-devel package)\n 		want_textui=\"no, Terminfo not found\"\n 	])\n','false','false','none'),('irssi','1.0.2','0c760b0c1bd86134fd5f55205b2ea45ba8e2f4af','Joseph Bisch','add fuzz.diff for fuzzing with afl\n\nauthored by dx.','fuzz.diff','226','0','257','0','ADD','@@ -0,0 +1,269 @@\n+diff --git a/src/core/network.c b/src/core/network.c\n+index 3e1b7c7..1e5324a 100644\n+--- a/src/core/network.c\n++++ b/src/core/network.c\n+@@ -199,6 +199,10 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n+ /* Connect to named UNIX socket */\n+ GIOChannel *net_connect_unix(const char *path)\n+ {\n++	if (strcmp(path, \"/dev/stdin\") == 0) {\n++		return g_io_channel_new(0);\n++	}\n++\n+ 	struct sockaddr_un sa;\n+ 	int handle, ret;\n+ \n+@@ -336,6 +340,8 @@ int net_receive(GIOChannel *handle, char *buf, int len)\n+ /* Transmit data, return number of bytes sent, -1 = error */\n+ int net_transmit(GIOChannel *handle, const char *data, int len)\n+ {\n++	return write(1, data, len);\n++\n+         gsize ret;\n+ 	GIOStatus status;\n+ 	GError *err = NULL;\n+@@ -495,6 +501,7 @@ int net_host2ip(const char *host, IPADDR *ip)\n+ /* Get socket error */\n+ int net_geterror(GIOChannel *handle)\n+ {\n++	return 0;\n+ 	int data;\n+ 	socklen_t len = sizeof(data);\n+ \n+diff --git a/src/core/servers-reconnect.c b/src/core/servers-reconnect.c\n+index 58c9dd0..0c6ec1b 100644\n+--- a/src/core/servers-reconnect.c\n++++ b/src/core/servers-reconnect.c\n+@@ -484,7 +484,8 @@ void servers_reconnect_init(void)\n+ 	reconnects = NULL;\n+ 	last_reconnect_tag = 0;\n+ \n+-	reconnect_timeout_tag = g_timeout_add(1000, (GSourceFunc) server_reconnect_timeout, NULL);\n++	(void) server_reconnect_timeout;\n++\n+ 	read_settings();\n+ \n+ 	signal_add(\"server connect failed\", (SIGNAL_FUNC) sig_reconnect);\n+diff --git a/src/core/settings.c b/src/core/settings.c\n+index e65ceb2..f9dc678 100644\n+--- a/src/core/settings.c\n++++ b/src/core/settings.c\n+@@ -704,7 +704,10 @@ int irssi_config_is_changed(const char *fname)\n+ \n+ static CONFIG_REC *parse_configfile(const char *fname)\n+ {\n+-	CONFIG_REC *config;\n++	CONFIG_REC *config = config_open(NULL, -1);\n++	config_parse_data(config, default_config, \"internal\");\n++	return config;\n++\n+ 	struct stat statbuf;\n+         const char *path;\n+ 	char *str;\n+@@ -871,8 +874,6 @@ void settings_init(void)\n+ 	init_configfile();\n+ \n+ 	settings_add_bool(\"misc\", \"settings_autosave\", TRUE);\n+-	timeout_tag = g_timeout_add(SETTINGS_AUTOSAVE_TIMEOUT,\n+-				    (GSourceFunc) sig_autosave, NULL);\n+ 	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n+ 	signal_add(\"gui exit\", (SIGNAL_FUNC) sig_autosave);\n+ }\n+diff --git a/src/fe-common/core/fe-common-core.c b/src/fe-common/core/fe-common-core.c\n+index 1b2ab1e..4344cd9 100644\n+--- a/src/fe-common/core/fe-common-core.c\n++++ b/src/fe-common/core/fe-common-core.c\n+@@ -320,6 +320,8 @@ static void autoconnect_servers(void)\n+ 	GSList *tmp, *chatnets;\n+ 	char *str;\n+ \n++	return;\n++\n+ 	if (autocon_server != NULL) {\n+ 		/* connect to specified server */\n+ 		if (autocon_password == NULL)\n+@@ -390,6 +392,7 @@ static void sig_setup_changed(void)\n+ \n+ static void autorun_startup(void)\n+ {\n++	return;\n+ 	char *path;\n+ 	GIOChannel *handle;\n+ 	GString *buf;\n+diff --git a/src/fe-common/core/themes.c b/src/fe-common/core/themes.c\n+index 2b1459b..2e518a1 100644\n+--- a/src/fe-common/core/themes.c\n++++ b/src/fe-common/core/themes.c\n+@@ -790,9 +790,8 @@ static void theme_read_module(THEME_REC *theme, const char *module)\n+ {\n+ 	CONFIG_REC *config;\n+ \n+-	config = config_open(theme->path, -1);\n+-	if (config != NULL)\n+-		config_parse(config);\n++	config = config_open(NULL, -1);\n++	config_parse_data(config, default_theme, \"internal\");\n+ \n+ 	theme_init_module(theme, module, config);\n+ \n+@@ -987,7 +986,7 @@ static int theme_read(THEME_REC *theme, const char *path)\n+ 	THEME_READ_REC rec;\n+         char *str;\n+ \n+-	config = config_open(path, -1) ;\n++	config = config_open(NULL, -1) ;\n+ 	if (config == NULL) {\n+ 		/* didn\'t exist or no access? */\n+ 		str = g_strdup_printf(\"Error reading theme file %s: %s\",\n+@@ -997,7 +996,7 @@ static int theme_read(THEME_REC *theme, const char *path)\n+ 		return FALSE;\n+ 	}\n+ \n+-	if (path == NULL)\n++	if (1)\n+ 		config_parse_data(config, default_theme, \"internal\");\n+         else\n+ 		config_parse(config);\n+@@ -1200,6 +1199,7 @@ static void module_save(const char *module, MODULE_THEME_REC *rec,\n+ \n+ static void theme_save(THEME_REC *theme, int save_all)\n+ {\n++	return;\n+ 	CONFIG_REC *config;\n+ 	THEME_SAVE_REC data;\n+ 	char *path;\n+diff --git a/src/fe-text/gui-readline.c b/src/fe-text/gui-readline.c\n+index 7c71edd..6bf2177 100644\n+--- a/src/fe-text/gui-readline.c\n++++ b/src/fe-text/gui-readline.c\n+@@ -1126,7 +1126,6 @@ void gui_readline_init(void)\n+ 	paste_timeout_id = -1;\n+ 	paste_bracketed_mode = FALSE;\n+ 	g_get_current_time(&last_keypress);\n+-        input_listen_init(STDIN_FILENO);\n+ \n+ 	settings_add_bool(\"lookandfeel\", \"term_appkey_mode\", TRUE);\n+ 	settings_add_str(\"history\", \"scroll_page_count\", \"/2\");\n+diff --git a/src/fe-text/irssi.c b/src/fe-text/irssi.c\n+index ad79e0c..84d0c5c 100644\n+--- a/src/fe-text/irssi.c\n++++ b/src/fe-text/irssi.c\n+@@ -314,20 +314,16 @@ int main(int argc, char **argv)\n+ 	textui_finish_init();\n+ 	main_loop = g_main_new(TRUE);\n+ \n++#ifdef __AFL_HAVE_MANUAL_CONTROL\n++	__AFL_INIT();\n++#endif\n++\n++	signal_emit(\"command connect\", 1, \"/dev/stdin 6667\");\n++\n+ 	/* Does the same as g_main_run(main_loop), except we\n+ 	   can call our dirty-checker after each iteration */\n+ 	while (!quitting) {\n+-		term_refresh_freeze();\n+ 		g_main_iteration(TRUE);\n+-                term_refresh_thaw();\n+-\n+-		if (reload_config) {\n+-                        /* SIGHUP received, do /RELOAD */\n+-			reload_config = FALSE;\n+-                        signal_emit(\"command reload\", 1, \"\");\n+-		}\n+-\n+-		dirty_check();\n+ 	}\n+ \n+ 	g_main_destroy(main_loop);\n+diff --git a/src/fe-text/term-terminfo.c b/src/fe-text/term-terminfo.c\n+index b2478c6..cebe260 100644\n+--- a/src/fe-text/term-terminfo.c\n++++ b/src/fe-text/term-terminfo.c\n+@@ -29,6 +29,10 @@\n+ #include <termios.h>\n+ #include <stdio.h>\n+ \n++#undef putc\n++#define putc(x, y) (void) (x)\n++#define fputc(x, y) (void) (x), 0\n++\n+ /* returns number of characters in the beginning of the buffer being a\n+    a single character, or -1 if more input is needed. The character will be\n+    saved in result */\n+@@ -113,7 +117,8 @@ int term_init(void)\n+ 	vcmove = FALSE; cforcemove = TRUE;\n+         curs_visible = TRUE;\n+ \n+-	current_term = terminfo_core_init(stdin, stdout);\n++	FILE *devnull = fopen(\"/dev/null\", \"r+\");\n++	current_term = terminfo_core_init(devnull, devnull);\n+ 	if (current_term == NULL)\n+ 		return FALSE;\n+ \n+@@ -670,6 +675,7 @@ void term_set_input_type(int type)\n+ \n+ void term_gets(GArray *buffer, int *line_count)\n+ {\n++	return;\n+ 	int ret, i, char_len;\n+ \n+         /* fread() doesn\'t work */\n+diff --git a/src/fe-text/terminfo-core.c b/src/fe-text/terminfo-core.c\n+index 9c9179a..6349935 100644\n+--- a/src/fe-text/terminfo-core.c\n++++ b/src/fe-text/terminfo-core.c\n+@@ -6,6 +6,10 @@\n+ #  define _POSIX_VDISABLE 0\n+ #endif\n+ \n++#undef putc\n++#define putc(x, y) (void) (x)\n++#define fputc(x, y) (void) (x), 0\n++\n+ #define tput(s) tputs(s, 0, term_putchar)\n+ inline static int term_putchar(int c)\n+ {\n+diff --git a/src/irc/core/irc.c b/src/irc/core/irc.c\n+index 4dce3fc..25fbb34 100644\n+--- a/src/irc/core/irc.c\n++++ b/src/irc/core/irc.c\n+@@ -383,12 +383,13 @@ static void irc_parse_incoming(SERVER_REC *server)\n+ 		signal_emit_id(signal_server_incoming, 2, server, str);\n+ \n+ 		if (server->connection_lost)\n+-			server_disconnect(server);\n++			exit(0);\n+ \n+ 		count++;\n+ 	}\n+ 	if (ret == -1) {\n+ 		/* connection lost */\n++		exit(0);\n+ 		server->connection_lost = TRUE;\n+ 		server_disconnect(server);\n+ 	}\n+diff --git a/src/lib-config/write.c b/src/lib-config/write.c\n+index 37e51f0..ee82726 100644\n+--- a/src/lib-config/write.c\n++++ b/src/lib-config/write.c\n+@@ -299,6 +299,8 @@ static int config_write_block(CONFIG_REC *rec, CONFIG_NODE *node, int list, int\n+ \n+ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)\n+ {\n++	return 0;\n++\n+ 	int ret;\n+ 	int fd;\n+ \n+diff --git a/src/perl/perl-core.c b/src/perl/perl-core.c\n+index 2c61df7..485fe25 100644\n+--- a/src/perl/perl-core.c\n++++ b/src/perl/perl-core.c\n+@@ -395,6 +395,7 @@ int perl_get_api_version(void)\n+ \n+ void perl_scripts_autorun(void)\n+ {\n++	return;\n+ 	DIR *dirp;\n+ 	struct dirent *dp;\n+ 	struct stat statbuf;\n','false','false','__afl_have_manual_control'),('irssi','1.0.2','dbde9f0fe3c9fcd7eb8e56e9b1beffb71b0607e1','Jari Matilainen','added support for -notls and -notls_verify','fe-server.c','372','109','8','2','MODIFY','@@ -156,6 +156,10 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n \n 	if (g_hash_table_lookup(optlist, \"tls\") || g_hash_table_lookup(optlist, \"ssl\"))\n 		rec->use_tls = TRUE;\n+	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) {\n+		rec->use_tls = FALSE;\n+		rec->tls_verify = FALSE;\n+	}\n \n 	value = g_hash_table_lookup(optlist, \"tls_cert\");\n 	if (value == NULL)\n@@ -177,6 +181,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n \n 	if (g_hash_table_lookup(optlist, \"tls_verify\") || g_hash_table_lookup(optlist, \"ssl_verify\"))\n 		rec->tls_verify = TRUE;\n+	else if (g_hash_table_lookup(optlist, \"notls_verify\") || g_hash_table_lookup(optlist, \"nossl_verify\"))\n+		rec->tls_verify = FALSE;\n \n 	value = g_hash_table_lookup(optlist, \"tls_cafile\");\n 	if (value == NULL)\n@@ -434,8 +440,8 @@ void fe_server_init(void)\n 	command_bind_first(\"server\", NULL, (SIGNAL_FUNC) server_command);\n 	command_bind_first(\"disconnect\", NULL, (SIGNAL_FUNC) server_command);\n \n-	command_set_options(\"server add\", \"4 6 !! ssl +ssl_cert +ssl_pkey +ssl_pass ssl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls +tls_cert +tls_pkey +tls_pass tls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\");\n-	command_set_options(\"server modify\", \"4 6 !! ssl +ssl_cert +ssl_pkey +ssl_pass ssl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls +tls_cert +tls_pkey +tls_pass tls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\");\n+	command_set_options(\"server add\", \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\");\n+	command_set_options(\"server modify\", \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\");\n \n 	signal_add(\"server looking\", (SIGNAL_FUNC) sig_server_looking);\n 	signal_add(\"server connecting\", (SIGNAL_FUNC) sig_server_connecting);\n','false','false','none'),('irssi','1.0.2','f060292a9cd0835dd9cc8c24a4ede67909a2b68b','Jari Matilainen','added braces','fe-server.c','373','109','2','1','MODIFY','@@ -154,8 +154,9 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n         else if (g_hash_table_lookup(optlist, \"4\"))\n 		rec->family = AF_INET;\n \n-	if (g_hash_table_lookup(optlist, \"tls\") || g_hash_table_lookup(optlist, \"ssl\"))\n+	if (g_hash_table_lookup(optlist, \"tls\") || g_hash_table_lookup(optlist, \"ssl\")) {\n 		rec->use_tls = TRUE;\n+	}\n 	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) {\n 		rec->use_tls = FALSE;\n 		rec->tls_verify = FALSE;\n','false','false','none'),('irssi','1.0.2','25f9c71f690f9fd846a39e646fbd11f715ffbfa5','Jari Matilainen','allow -port <num> or irc.host.tld <port num> in /server add and /server modify','fe-server.c','367','105','7','5','MODIFY','@@ -117,7 +117,11 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 		return;\n \n 	if (*addr == \'\\0\') cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);\n-	port = *portstr == \'\\0\' ? DEFAULT_SERVER_ADD_PORT : atoi(portstr);\n+\n+        value = g_hash_table_lookup(optlist, \"port\");\n+        port = *portstr == \'\\0\' ?\n+                (value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT)\n+		: atoi(portstr);\n \n 	chatnet = g_hash_table_lookup(optlist, \"network\");\n \n@@ -137,11 +141,7 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 			return;\n 		}\n 		rec->address = g_strdup(addr);\n-		rec->port = port;\n 	} else {\n-		value = g_hash_table_lookup(optlist, \"port\");\n-		if (value != NULL && *value != \'\\0\') rec->port = atoi(value);\n-\n 		if (*password != \'\\0\') g_free_and_null(rec->password);\n 		if (g_hash_table_lookup(optlist, \"host\")) {\n 			g_free_and_null(rec->own_host);\n@@ -149,6 +149,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 		}\n 	}\n \n+	rec->port = port;\n+\n 	if (g_hash_table_lookup(optlist, \"6\"))\n 		rec->family = AF_INET6;\n         else if (g_hash_table_lookup(optlist, \"4\"))\n','false','false','none'),('irssi','1.0.2','783458e9ba068117089d23730add317069cf6447','Jari Matilainen','added code comments','fe-server.c','373','109','2','0','MODIFY','@@ -159,6 +159,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 	}\n 	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) {\n 		rec->use_tls = FALSE;\n+		/* if rec has tls_verify = TRUE then use_tls will be set to true on lines 224-225\n+		   so explicitly set tls_verify to FALSE when -notls is used */\n 		rec->tls_verify = FALSE;\n 	}\n \n','false','false','none'),('irssi','1.0.2','787e192567626dab7788e54363dbccda52d5322c','ailin-nemui','improve nicklist performance','nicklist.c','415','102','31','22','MODIFY','@@ -166,41 +166,50 @@ void nicklist_rename_unique(SERVER_REC *server,\n 			     nicklist_get_same_unique(server, old_nick_id));\n }\n \n+#define NICKLIST_GETNICKS_LOOP_INIT(hashtable)			 \\\n+	do {							 \\\n+		GHashTableIter _iter;				 \\\n+		g_hash_table_iter_init(&_iter, (hashtable));		\\\n+		while (g_hash_table_iter_next(&_iter, NULL, (void*)&nick)) { \\\n+			while (nick != NULL) {\n+#define NICKLIST_GETNICKS_LOOP_END					\\\n+				nick = nick->next;			\\\n+			}						\\\n+		}							\\\n+	} while (0)\n+\n static NICK_REC *nicklist_find_wildcards(CHANNEL_REC *channel,\n 					 const char *mask)\n {\n-	GSList *nicks, *tmp;\n 	NICK_REC *nick;\n \n-	nicks = nicklist_getnicks(channel);\n-	nick = NULL;\n-	for (tmp = nicks; tmp != NULL; tmp = tmp->next) {\n-		nick = tmp->data;\n+	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks);\n \n-		if (mask_match_address(channel->server, mask,\n-				       nick->nick, nick->host))\n-			break;\n-	}\n-	g_slist_free(nicks);\n-	return tmp == NULL ? NULL : nick;\n+	if (mask_match_address(channel->server, mask,\n+			       nick->nick, nick->host))\n+		return nick;\n+\n+	NICKLIST_GETNICKS_LOOP_END;\n+	return NULL;\n }\n \n GSList *nicklist_find_multiple(CHANNEL_REC *channel, const char *mask)\n {\n-	GSList *nicks, *tmp, *next;\n+	GSList *nicks;\n+	NICK_REC *nick;\n \n 	g_return_val_if_fail(IS_CHANNEL(channel), NULL);\n 	g_return_val_if_fail(mask != NULL, NULL);\n \n-	nicks = nicklist_getnicks(channel);\n-	for (tmp = nicks; tmp != NULL; tmp = next) {\n-		NICK_REC *nick = tmp->data;\n+	nicks = NULL;\n \n-		next = tmp->next;\n-		if (!mask_match_address(channel->server, mask,\n-					nick->nick, nick->host))\n-                        nicks = g_slist_remove(nicks, tmp->data);\n-	}\n+	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks);\n+\n+	if (mask_match_address(channel->server, mask,\n+			       nick->nick, nick->host))\n+		nicks = g_slist_prepend(nicks, nick);\n+\n+	NICKLIST_GETNICKS_LOOP_END;\n \n 	return nicks;\n }\n@@ -264,8 +273,8 @@ NICK_REC *nicklist_find_mask(CHANNEL_REC *channel, const char *mask)\n static void get_nicks_hash(gpointer key, NICK_REC *rec, GSList **list)\n {\n 	while (rec != NULL) {\n-		*list = g_slist_append(*list, rec);\n-                rec = rec->next;\n+		*list = g_slist_prepend(*list, rec);\n+		rec = rec->next;\n 	}\n }\n \n','false','false','none'),('irssi','1.0.2','371eb7f5052b9cce7efcbcc4086cd6f6716e21fd','ailin-nemui','expand macro','nicklist.c','423','106','19','26','MODIFY','@@ -166,30 +166,21 @@ void nicklist_rename_unique(SERVER_REC *server,\n 			     nicklist_get_same_unique(server, old_nick_id));\n }\n \n-#define NICKLIST_GETNICKS_LOOP_INIT(hashtable)			 \\\n-	do {							 \\\n-		GHashTableIter _iter;				 \\\n-		g_hash_table_iter_init(&_iter, (hashtable));		\\\n-		while (g_hash_table_iter_next(&_iter, NULL, (void*)&nick)) { \\\n-			while (nick != NULL) {\n-#define NICKLIST_GETNICKS_LOOP_END					\\\n-				nick = nick->next;			\\\n-			}						\\\n-		}							\\\n-	} while (0)\n-\n static NICK_REC *nicklist_find_wildcards(CHANNEL_REC *channel,\n 					 const char *mask)\n {\n 	NICK_REC *nick;\n+	GHashTableIter iter;\n+\n+	g_hash_table_iter_init(&iter, channel->nicks);\n+	while (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) {\n+		for (; nick != NULL; nick = nick->next) {\n+			if (mask_match_address(channel->server, mask,\n+					       nick->nick, nick->host))\n+				return nick;\n+		}\n+	}\n \n-	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks);\n-\n-	if (mask_match_address(channel->server, mask,\n-			       nick->nick, nick->host))\n-		return nick;\n-\n-	NICKLIST_GETNICKS_LOOP_END;\n 	return NULL;\n }\n \n@@ -197,19 +188,21 @@ GSList *nicklist_find_multiple(CHANNEL_REC *channel, const char *mask)\n {\n 	GSList *nicks;\n 	NICK_REC *nick;\n+	GHashTableIter iter;\n \n 	g_return_val_if_fail(IS_CHANNEL(channel), NULL);\n 	g_return_val_if_fail(mask != NULL, NULL);\n \n 	nicks = NULL;\n \n-	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks);\n-\n-	if (mask_match_address(channel->server, mask,\n-			       nick->nick, nick->host))\n-		nicks = g_slist_prepend(nicks, nick);\n-\n-	NICKLIST_GETNICKS_LOOP_END;\n+	g_hash_table_iter_init(&iter, channel->nicks);\n+	while (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) {\n+		for (; nick != NULL; nick = nick->next) {\n+			if (mask_match_address(channel->server, mask,\n+					       nick->nick, nick->host))\n+				nicks = g_slist_prepend(nicks, nick);\n+		}\n+	}\n \n 	return nicks;\n }\n','false','false','none'),('irssi','1.0.2','4a6fbdbe7891859ffd7b51a87147ecb6158df141','Jari Matilainen','spaces to tabs','fe-server.c','367','105','3','3','MODIFY','@@ -118,9 +118,9 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n \n 	if (*addr == \'\\0\') cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);\n \n-        value = g_hash_table_lookup(optlist, \"port\");\n-        port = *portstr == \'\\0\' ?\n-                (value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT)\n+	value = g_hash_table_lookup(optlist, \"port\");\n+	port = *portstr == \'\\0\' ?\n+		(value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT)\n 		: atoi(portstr);\n \n 	chatnet = g_hash_table_lookup(optlist, \"network\");\n','false','false','none'),('irssi','1.0.2','81cf8d8813c4226e0d9db5f776e0f6a6904813e0','ailin-nemui','update fe-server.c','fe-server.c','373','109','1','2','MODIFY','@@ -159,8 +159,7 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 	}\n 	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) {\n 		rec->use_tls = FALSE;\n-		/* if rec has tls_verify = TRUE then use_tls will be set to true on lines 224-225\n-		   so explicitly set tls_verify to FALSE when -notls is used */\n+		/* tls_verify implies use_tls, disable it explicitly */\n 		rec->tls_verify = FALSE;\n 	}\n \n','false','false','none'),('irssi','1.0.2','0c26aeb9fc716416aa7dde2356cc59643f7cc793','Jari Matilainen','make sure port is only set on /server modify if specified','fe-server.c','370','107','6','3','MODIFY','@@ -120,7 +120,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n \n 	value = g_hash_table_lookup(optlist, \"port\");\n 	port = *portstr == \'\\0\' ?\n-		(value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT)\n+			(value != NULL && *value != \'\\0\' ?\n+			atoi(value) : DEFAULT_SERVER_ADD_PORT)\n 		: atoi(portstr);\n \n 	chatnet = g_hash_table_lookup(optlist, \"network\");\n@@ -141,7 +142,11 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 			return;\n 		}\n 		rec->address = g_strdup(addr);\n+		rec->port = port;\n 	} else {\n+		if (*portstr != \'\\0\' || g_hash_table_lookup(optlist, \"port\"))\n+			rec->port = port;\n+\n 		if (*password != \'\\0\') g_free_and_null(rec->password);\n 		if (g_hash_table_lookup(optlist, \"host\")) {\n 			g_free_and_null(rec->own_host);\n@@ -149,8 +154,6 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 		}\n 	}\n \n-	rec->port = port;\n-\n 	if (g_hash_table_lookup(optlist, \"6\"))\n 		rec->family = AF_INET6;\n         else if (g_hash_table_lookup(optlist, \"4\"))\n','false','false','none'),('irssi','1.0.2','5045f4766a72f18a3d682d1c9eeeffb40ab32569','mh','dcc.in: fixed typo \'resolved\' -&gt; \'resolves\'\n\nn/t','dcc.in','31','0','1','1','MODIFY','@@ -27,7 +27,7 @@\n     and file transfers.\n \n     If you are behind NAT, or if the firewall is too restrictive, you might\n-    want to try if using the passive parameter resolved your connection\n+    want to try if using the passive parameter resolves your connection\n     problem.\n \n     You can send files which contain special character or spaces by enclosing\n','true','false','none'),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','add parse_uint function to improve integer overflow handling\n\noriginally found by oss-fuzz (issue 525) in get_ansi_color using ubsan.\nafter a lot of analysis i\'m 99% sure this isn\'t security relevant so\nit\'s fine to handle this publicly.\n\nthe fix is mainly adding a function that does it right and use it\neverywhere. this is harder than it seems because the strtol() family of\nfunctions doesn\'t have the friendliest of interfaces.\n\naside from get_ansi_color(), there were other pieces of code that used\nthe same (out*10+(*in-\'0\')) pattern, like the parse_size() and\nparse_time_interval() functions, which are mostly used for settings.\nthose are interesting cases, since they multiply the parsed number\n(resulting in more overflows) and they write to a signed integer\nparameter (which can accidentally make the uints negative without ub)\n\nthanks to pascal cuoq for enlightening me about the undefined behavior\nof parse_size (and, in particular, the implementation-defined behavior\nof one of the wip versions of this commit, where something like signed\ninteger overflow happened, but it was legal). also for writing\ntis-interpreter, which is better than ubsan to verify these things.','misc.c','771','255','103','16','MODIFY','@@ -750,10 +750,42 @@ int nearest_power(int num)\n 	return n;\n }\n \n-int parse_time_interval(const char *time, int *msecs)\n+/* Parses unsigned integers from strings with decent error checking.\n+ * Returns true on success, false otherwise (overflow, no valid number, etc)\n+ * There\'s a 31 bit limit so the output can be assigned to signed positive ints */\n+int parse_uint(const char *nptr, char **endptr, int base, guint *number)\n+{\n+	char *endptr_;\n+	gulong parsed;\n+\n+	/* strtoul accepts whitespace and plus/minus signs, for some reason */\n+	if (!i_isdigit(*nptr)) {\n+		return FALSE;\n+	}\n+\n+	errno = 0;\n+	parsed = strtoul(nptr, &endptr_, base);\n+\n+	if (errno || endptr_ == nptr || parsed >= (1U << 31)) {\n+		return FALSE;\n+	}\n+\n+	if (endptr) {\n+		*endptr = endptr_;\n+	}\n+\n+	if (number) {\n+		*number = (guint) parsed;\n+	}\n+\n+	return TRUE;\n+}\n+\n+static int parse_time_interval_uint(const char *time, guint *msecs)\n {\n 	const char *desc;\n-	int number, sign, len, ret, digits;\n+	guint number;\n+	int sign, len, ret, digits;\n \n 	*msecs = 0;\n \n@@ -769,8 +801,11 @@ int parse_time_interval(const char *time, int *msecs)\n 	}\n 	for (;;) {\n 		if (i_isdigit(*time)) {\n-			number = number*10 + (*time - \'0\');\n-			time++;\n+			char *endptr;\n+			if (!parse_uint(time, &endptr, 10, &number)) {\n+				return FALSE;\n+			}\n+			time = endptr;\n 			digits = TRUE;\n 			continue;\n 		}\n@@ -835,10 +870,11 @@ int parse_time_interval(const char *time, int *msecs)\n 	return ret;\n }\n \n-int parse_size(const char *size, int *bytes)\n+static int parse_size_uint(const char *size, guint *bytes)\n {\n 	const char *desc;\n-	int number, len;\n+	guint number, multiplier, limit;\n+	int len;\n \n 	*bytes = 0;\n \n@@ -846,8 +882,11 @@ int parse_size(const char *size, int *bytes)\n 	number = 0;\n 	while (*size != \'\\0\') {\n 		if (i_isdigit(*size)) {\n-			number = number*10 + (*size - \'0\');\n-			size++;\n+			char *endptr;\n+			if (!parse_uint(size, &endptr, 10, &number)) {\n+				return FALSE;\n+			}\n+			size = endptr;\n 			continue;\n 		}\n \n@@ -869,14 +908,31 @@ int parse_size(const char *size, int *bytes)\n 			return FALSE;\n 		}\n \n-		if (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0)\n-			*bytes += number * 1024*1024*1024;\n-		if (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0)\n-			*bytes += number * 1024*1024;\n-		if (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0)\n-			*bytes += number * 1024;\n-		if (g_ascii_strncasecmp(desc, \"bytes\", len) == 0)\n-			*bytes += number;\n+		multiplier = 0;\n+		limit = 0;\n+\n+		if (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0) {\n+			multiplier = 1U << 30;\n+			limit = 2U << 0;\n+		}\n+		if (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0) {\n+			multiplier = 1U << 20;\n+			limit = 2U << 10;\n+		}\n+		if (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0) {\n+			multiplier = 1U << 10;\n+			limit = 2U << 20;\n+		}\n+		if (g_ascii_strncasecmp(desc, \"bytes\", len) == 0) {\n+			multiplier = 1;\n+			limit = 2U << 30;\n+		}\n+\n+		if (limit && number > limit) {\n+			return FALSE;\n+		}\n+\n+		*bytes += number * multiplier;\n \n 		/* skip punctuation */\n 		while (*size != \'\\0\' && i_ispunct(*size))\n@@ -886,6 +942,37 @@ int parse_size(const char *size, int *bytes)\n 	return TRUE;\n }\n \n+int parse_size(const char *size, int *bytes)\n+{\n+	guint bytes_;\n+	int ret;\n+\n+	ret = parse_size_uint(size, &bytes_);\n+\n+	if (bytes_ > (1U << 31)) {\n+		return FALSE;\n+	}\n+\n+	*bytes = bytes_;\n+	return ret;\n+}\n+\n+int parse_time_interval(const char *time, int *msecs)\n+{\n+	guint msecs_;\n+	int ret;\n+\n+	ret = parse_time_interval_uint(time, &msecs_);\n+\n+	if (msecs_ > (1U << 31)) {\n+		return FALSE;\n+	}\n+\n+	*msecs = msecs_;\n+	return ret;\n+}\n+\n+\n char *ascii_strup(char *str)\n {\n 	char *s;\n','false','false','none'),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','add parse_uint function to improve integer overflow handling\n\noriginally found by oss-fuzz (issue 525) in get_ansi_color using ubsan.\nafter a lot of analysis i\'m 99% sure this isn\'t security relevant so\nit\'s fine to handle this publicly.\n\nthe fix is mainly adding a function that does it right and use it\neverywhere. this is harder than it seems because the strtol() family of\nfunctions doesn\'t have the friendliest of interfaces.\n\naside from get_ansi_color(), there were other pieces of code that used\nthe same (out*10+(*in-\'0\')) pattern, like the parse_size() and\nparse_time_interval() functions, which are mostly used for settings.\nthose are interesting cases, since they multiply the parsed number\n(resulting in more overflows) and they write to a signed integer\nparameter (which can accidentally make the uints negative without ub)\n\nthanks to pascal cuoq for enlightening me about the undefined behavior\nof parse_size (and, in particular, the implementation-defined behavior\nof one of the wip versions of this commit, where something like signed\ninteger overflow happened, but it was legal). also for writing\ntis-interpreter, which is better than ubsan to verify these things.','misc.h','48','0','1','0','MODIFY','@@ -71,6 +71,7 @@ int expand_escape(const char **data);\n int nearest_power(int num);\n \n /* Returns TRUE / FALSE */\n+int parse_uint(const char *nptr, char **endptr, int base, guint *number);\n int parse_time_interval(const char *time, int *msecs);\n int parse_size(const char *size, int *bytes);\n \n','false','false','none'),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','add parse_uint function to improve integer overflow handling\n\noriginally found by oss-fuzz (issue 525) in get_ansi_color using ubsan.\nafter a lot of analysis i\'m 99% sure this isn\'t security relevant so\nit\'s fine to handle this publicly.\n\nthe fix is mainly adding a function that does it right and use it\neverywhere. this is harder than it seems because the strtol() family of\nfunctions doesn\'t have the friendliest of interfaces.\n\naside from get_ansi_color(), there were other pieces of code that used\nthe same (out*10+(*in-\'0\')) pattern, like the parse_size() and\nparse_time_interval() functions, which are mostly used for settings.\nthose are interesting cases, since they multiply the parsed number\n(resulting in more overflows) and they write to a signed integer\nparameter (which can accidentally make the uints negative without ub)\n\nthanks to pascal cuoq for enlightening me about the undefined behavior\nof parse_size (and, in particular, the implementation-defined behavior\nof one of the wip versions of this commit, where something like signed\ninteger overflow happened, but it was legal). also for writing\ntis-interpreter, which is better than ubsan to verify these things.','special-vars.c','540','160','6','3','MODIFY','@@ -275,6 +275,8 @@ static char *get_special_value(char **cmd, SERVER_REC *server, void *item,\n static int get_alignment_args(char **data, int *align, int *flags, char *pad)\n {\n 	char *str;\n+	char *endptr;\n+	guint align_;\n \n 	*align = 0;\n 	*flags = ALIGN_CUT|ALIGN_PAD;\n@@ -295,10 +297,11 @@ static int get_alignment_args(char **data, int *align, int *flags, char *pad)\n 		return FALSE; /* expecting number */\n \n 	/* get the alignment size */\n-	while (i_isdigit(*str)) {\n-		*align = (*align) * 10 + (*str-\'0\');\n-		str++;\n+	if (!parse_uint(str, &endptr, 10, &align_)) {\n+		return FALSE;\n 	}\n+	str = endptr;\n+	*align = align_;\n \n 	/* get the pad character */\n 	while (*str != \'\\0\' && *str != \']\') {\n','false','false','none'),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','add parse_uint function to improve integer overflow handling\n\noriginally found by oss-fuzz (issue 525) in get_ansi_color using ubsan.\nafter a lot of analysis i\'m 99% sure this isn\'t security relevant so\nit\'s fine to handle this publicly.\n\nthe fix is mainly adding a function that does it right and use it\neverywhere. this is harder than it seems because the strtol() family of\nfunctions doesn\'t have the friendliest of interfaces.\n\naside from get_ansi_color(), there were other pieces of code that used\nthe same (out*10+(*in-\'0\')) pattern, like the parse_size() and\nparse_time_interval() functions, which are mostly used for settings.\nthose are interesting cases, since they multiply the parsed number\n(resulting in more overflows) and they write to a signed integer\nparameter (which can accidentally make the uints negative without ub)\n\nthanks to pascal cuoq for enlightening me about the undefined behavior\nof parse_size (and, in particular, the implementation-defined behavior\nof one of the wip versions of this commit, where something like signed\ninteger overflow happened, but it was legal). also for writing\ntis-interpreter, which is better than ubsan to verify these things.','formats.c','1133','357','20','8','MODIFY','@@ -33,6 +33,7 @@\n #include \"themes.h\"\n #include \"recode.h\"\n #include \"utf8.h\"\n+#include \"misc.h\"\n \n static const char *format_backs = \"04261537\";\n static const char *format_fores = \"kbgcrmyw\";\n@@ -870,8 +871,9 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,\n {\n 	static char ansitab[8] = { 0, 4, 2, 6, 1, 5, 3, 7 };\n 	const char *start;\n-	int fg, bg, flags, num, i;\n-	unsigned int num2;\n+	char *endptr;\n+	int fg, bg, flags, i;\n+	guint num, num2;\n \n 	if (*str != \'[\')\n 		return str;\n@@ -886,8 +888,10 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,\n 		if (*str == \'\\0\') return start;\n \n 		if (i_isdigit(*str)) {\n-			num = num*10 + (*str-\'0\');\n-			continue;\n+			if (!parse_uint(str, &endptr, 10, &num)) {\n+				return start;\n+			}\n+			str = endptr;\n 		}\n \n 		if (*str != \';\' && *str != \'m\')\n@@ -958,8 +962,12 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,\n 			/* ANSI indexed color or RGB color */\n 			if (*str != \';\') break;\n 			str++;\n-			for (num2 = 0; i_isdigit(*str); str++)\n-				num2 = num2*10 + (*str-\'0\');\n+\n+			if (!parse_uint(str, &endptr, 10, &num2)) {\n+				return start;\n+			}\n+			str = endptr;\n+\n 			if (*str == \'\\0\') return start;\n \n 			switch (num2) {\n@@ -1006,8 +1014,12 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,\n 				/* indexed */\n 				if (*str != \';\') break;\n 				str++;\n-				for (num2 = 0; i_isdigit(*str); str++)\n-					num2 = num2*10 + (*str-\'0\');\n+\n+				if (!parse_uint(str, &endptr, 10, &num2)) {\n+					return start;\n+				}\n+				str = endptr;\n+\n 				if (*str == \'\\0\') return start;\n \n 				if (num == 38) {\n','false','false','none'),('irssi','1.0.2','d61c54c32b6383186a8f32d852594cc4e10240d9','ailin-nemui','do not reset true colour bit on colour reset\n\nfixes #710','textbuffer-view.c','1043','252','0','2','MODIFY','@@ -114,7 +114,6 @@ static void update_cmd_color(unsigned char cmd, int *color)\n 		if (cmd & LINE_COLOR_BG) {\n 			/* set background color */\n 			*color &= FGATTR;\n-			*color &= ~ATTR_FGCOLOR24;\n 			if ((cmd & LINE_COLOR_DEFAULT) == 0)\n 				*color |= (cmd & 0x0f) << BG_SHIFT;\n 			else {\n@@ -123,7 +122,6 @@ static void update_cmd_color(unsigned char cmd, int *color)\n 		} else {\n 			/* set foreground color */\n 			*color &= BGATTR;\n-			*color &= ~ATTR_BGCOLOR24;\n 			if ((cmd & LINE_COLOR_DEFAULT) == 0)\n 				*color |= cmd & 0x0f;\n 			else {\n','false','false','none'),('irssi','1.0.2','601be187746234c36c407a17ca54b17c82264e1b','ailin-nemui','update list.in\n\nadd a more detailed paragraph about service bots\r\n\r\nfixes #699\r\n\r\ni would like to add another paragraph about how freenode is \r\nbroken and spits at you the whole list instead of empty list \r\nif you attempt to use network side filtering......','list.in','22','0','7','3','MODIFY','@@ -24,11 +24,15 @@\n \n %9Remarks:%9\n \n-    Not all networks support server-side filtering and may provide a network\n+    Not all networks support server-side filtering. Some provide a network\n     service or service bot instead; on IRCnet, you may use the List service:\n \n-    /SQUERY List HELP\n-    /MSG ALIS HELP\n+    /SQUERY Alis HELP\n+\n+    Other networks with service bots (like ChanServ) may also provide a list\n+    service bot (confirm with /WHOIS ALIS):\n+\n+    /MSG Alis HELP\n \n %9See also:%9 STATS, SQUERY, WHOIS\n \n','false','false','none'),('irssi','1.0.2','30a92754bb650c3dedd507d41110443142899a65','Joseph Bisch','fix oob read of one byte in get_file_params_count{,_resume}\n\nwe can use continue to handle cases such as:\n\"ab<space><space>c\"','dcc-get.c','426','94','2','0','MODIFY','@@ -382,6 +382,8 @@ int get_file_params_count(char **params, int paramcount)\n 	if (*params[0] == \'\"\') {\n 		/* quoted file name? */\n 		for (pos = 0; pos < paramcount-3; pos++) {\n+			if (strlen(params[pos]) == 0)\n+				continue;\n 			if (params[pos][strlen(params[pos])-1] == \'\"\' &&\n 			    get_params_match(params, pos+1))\n 				return pos+1;\n','true','false','none'),('irssi','1.0.2','30a92754bb650c3dedd507d41110443142899a65','Joseph Bisch','fix oob read of one byte in get_file_params_count{,_resume}\n\nwe can use continue to handle cases such as:\n\"ab<space><space>c\"','dcc-resume.c','174','47','2','0','MODIFY','@@ -62,6 +62,8 @@ int get_file_params_count_resume(char **params, int paramcount)\n 	if (*params[0] == \'\"\') {\n 		/* quoted file name? */\n 		for (pos = 0; pos < paramcount-2; pos++) {\n+			if (strlen(params[pos]) == 0)\n+				continue;\n 			if (params[pos][strlen(params[pos])-1] == \'\"\' &&\n 			    get_params_match_resume(params, pos+1))\n 				return pos+1;\n','true','false','none'),('irssi','1.0.2','528f51bfbe5c65c5b24546faa244009dd5b3c586','Joseph Bisch','fix dcc_request where addr is null','dcc-get.c','427','94','4','0','MODIFY','@@ -428,6 +428,10 @@ static void ctcp_msg_dcc_send(IRC_SERVER_REC *server, const char *data,\n 	int p_id = -1;\n 	int passive = FALSE;\n \n+	if (addr == NULL) {\n+		addr = \"\";\n+	}\n+\n 	/* SEND <file name> <address> <port> <size> [...] */\n 	/* SEND <file name> <address> 0 <size> <id> (DCC SEND passive protocol) */\n 	params = g_strsplit(data, \" \", -1);\n','true','true','none'),('irssi','1.0.2','1ce9e07be0ad33fbdac9413e9045c45e66afff37','Joseph Bisch','use cxx for fe-fuzz linking','Makefile.am','18','0','2','2','MODIFY','@@ -1,7 +1,7 @@\n bin_PROGRAMS = irssi-fuzz\n \n-# Force link with clang++ for libfuzzer support\n-CCLD=clang++ $(CXXFLAGS)\n+# Force link with CXX for libfuzzer support\n+CCLD=$(CXX) $(CXXFLAGS)\n \n AM_CPPFLAGS = \\\n 	-I$(top_srcdir)/src \\\n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','configure.ac','671','4','1','0','MODIFY','@@ -505,6 +505,7 @@ AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\")\n AM_CONDITIONAL(BUILD_IRSSIFUZZER, test \"$want_irssifuzzer\" = \"yes\")\n AM_CONDITIONAL(BUILD_IRSSIPROXY, test \"$want_irssiproxy\" = \"yes\")\n AM_CONDITIONAL(HAVE_PERL, test \"$want_perl\" != \"no\")\n+AM_CONDITIONAL(USE_GREGEX, test \"x$want_gregex\" = \"xyes\")\n \n # move LIBS to PROG_LIBS so they\'re not tried to be used when linking eg. perl libraries\n PROG_LIBS=$LIBS\n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','Makefile.am','106','0','8','0','MODIFY','@@ -7,6 +7,12 @@ AM_CPPFLAGS = \\\n 	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\\n 	-DMODULEDIR=\\\"\"$(libdir)/irssi/modules\"\\\"\n \n+if USE_GREGEX\n+regex_impl=iregex-gregex.c\n+else\n+regex_impl=iregex-regexh.c\n+endif\n+\n libcore_a_SOURCES = \\\n 	args.c \\\n 	channels.c \\\n@@ -45,6 +51,7 @@ libcore_a_SOURCES = \\\n 	signals.c \\\n 	special-vars.c \\\n 	utf8.c \\\n+	$(regex_impl) \\\n 	wcwidth.c \\\n 	tls.c \\\n 	write-buffer.c\n@@ -97,6 +104,7 @@ pkginc_core_HEADERS = \\\n 	signals.h \\\n 	special-vars.h \\\n 	utf8.h \\\n+	iregex.h \\\n 	window-item-def.h \\\n 	tls.h \\\n 	write-buffer.h \\\n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','ignore.c','351','132','5','35','MODIFY','@@ -24,6 +24,7 @@\n #include \"levels.h\"\n #include \"lib-config/iconfig.h\"\n #include \"settings.h\"\n+#include \"iregex.h\"\n \n #include \"masks.h\"\n #include \"servers.h\"\n@@ -67,13 +68,8 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)\n 		return FALSE;\n \n 	if (rec->regexp) {\n-#ifdef USE_GREGEX\n 		return rec->preg != NULL &&\n-			g_regex_match(rec->preg, text, 0, NULL);\n-#else\n-		return rec->regexp_compiled &&\n-			regexec(&rec->preg, text, 0, NULL, 0) == 0;\n-#endif\n+			i_regex_match(rec->preg, text, 0, NULL, NULL);\n 	}\n \n 	return rec->fullword ?\n@@ -327,41 +323,19 @@ static void ignore_remove_config(IGNORE_REC *rec)\n \n static void ignore_init_rec(IGNORE_REC *rec)\n {\n-#ifdef USE_GREGEX\n 	if (rec->preg != NULL)\n-		g_regex_unref(rec->preg);\n+		i_regex_unref(rec->preg);\n \n 	if (rec->regexp && rec->pattern != NULL) {\n 		GError *re_error = NULL;\n \n-		rec->preg = g_regex_new(rec->pattern, G_REGEX_OPTIMIZE | G_REGEX_RAW | G_REGEX_CASELESS, 0, &re_error);\n+		rec->preg = i_regex_new(rec->pattern, G_REGEX_OPTIMIZE | G_REGEX_CASELESS, 0, &re_error);\n \n 		if (rec->preg == NULL) {\n 			g_warning(\"Failed to compile regexp \'%s\': %s\", rec->pattern, re_error->message);\n 			g_error_free(re_error);\n 		}\n 	}\n-#else\n-	char *errbuf;\n-	int errcode, errbuf_len;\n-\n-	if (rec->regexp_compiled) regfree(&rec->preg);\n-	rec->regexp_compiled = FALSE;\n-\n-	if (rec->regexp && rec->pattern != NULL) {\n-		errcode = regcomp(&rec->preg, rec->pattern,\n-				REG_EXTENDED|REG_ICASE|REG_NOSUB);\n-		if (errcode != 0) {\n-			errbuf_len = regerror(errcode, &rec->preg, 0, 0);\n-			errbuf = g_malloc(errbuf_len);\n-			regerror(errcode, &rec->preg, errbuf, errbuf_len);\n-			g_warning(\"Failed to compile regexp \'%s\': %s\", rec->pattern, errbuf);\n-			g_free(errbuf);\n-		} else {\n-			rec->regexp_compiled = TRUE;\n-		}\n-	}\n-#endif\n }\n \n void ignore_add_rec(IGNORE_REC *rec)\n@@ -381,11 +355,7 @@ static void ignore_destroy(IGNORE_REC *rec, int send_signal)\n 	if (send_signal)\n 		signal_emit(\"ignore destroyed\", 1, rec);\n \n-#ifdef USE_GREGEX\n-	if (rec->preg != NULL) g_regex_unref(rec->preg);\n-#else\n-	if (rec->regexp_compiled) regfree(&rec->preg);\n-#endif\n+	if (rec->preg != NULL) i_regex_unref(rec->preg);\n 	if (rec->channels != NULL) g_strfreev(rec->channels);\n 	g_free_not_null(rec->mask);\n 	g_free_not_null(rec->servertag);\n','false','false','use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','ignore.h','30','0','2','9','MODIFY','@@ -1,9 +1,7 @@\n #ifndef __IGNORE_H\n #define __IGNORE_H\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n+#include \"iregex.h\"\n \n typedef struct _IGNORE_REC IGNORE_REC;\n \n@@ -20,12 +18,7 @@ struct _IGNORE_REC {\n 	unsigned int regexp:1;\n 	unsigned int fullword:1;\n 	unsigned int replies:1; /* ignore replies to nick in channel */\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n };\n \n extern GSList *ignores;\n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','ignore.h','30','0','2','9','MODIFY','@@ -1,9 +1,7 @@\n #ifndef __IGNORE_H\n #define __IGNORE_H\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n+#include \"iregex.h\"\n \n typedef struct _IGNORE_REC IGNORE_REC;\n \n@@ -20,12 +18,7 @@ struct _IGNORE_REC {\n 	unsigned int regexp:1;\n 	unsigned int fullword:1;\n 	unsigned int replies:1; /* ignore replies to nick in channel */\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n };\n \n extern GSList *ignores;\n','false','false','not use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','ignore.h','30','0','2','9','MODIFY','@@ -1,9 +1,7 @@\n #ifndef __IGNORE_H\n #define __IGNORE_H\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n+#include \"iregex.h\"\n \n typedef struct _IGNORE_REC IGNORE_REC;\n \n@@ -20,12 +18,7 @@ struct _IGNORE_REC {\n 	unsigned int regexp:1;\n 	unsigned int fullword:1;\n 	unsigned int replies:1; /* ignore replies to nick in channel */\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n };\n \n extern GSList *ignores;\n','false','false','use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','iregex-gregex.c','111','24','137','0','ADD','@@ -0,0 +1,137 @@\n+#include <string.h>\n+\n+#include \"iregex.h\"\n+\n+const gchar *\n+make_valid_utf8(const gchar *text, gboolean *free_ret)\n+{\n+	GString *str;\n+	const gchar *ptr;\n+	if (g_utf8_validate(text, -1, NULL)) {\n+		if (free_ret)\n+			*free_ret = FALSE;\n+		return text;\n+	}\n+\n+	str = g_string_sized_new(strlen(text) + 12);\n+\n+	ptr = text;\n+	while (*ptr) {\n+		gunichar c = g_utf8_get_char_validated(ptr, -1);\n+		/* the unicode is invalid */\n+		if (c == (gunichar)-1 || c == (gunichar)-2) {\n+			/* encode the byte into PUA-A */\n+			g_string_append_unichar(str, (gunichar) (0xfff00 | (*ptr & 0xff)));\n+			ptr++;\n+		} else {\n+			g_string_append_unichar(str, c);\n+			ptr = g_utf8_next_char(ptr);\n+		}\n+	}\n+\n+	if (free_ret)\n+		*free_ret = TRUE;\n+	return g_string_free(str, FALSE);\n+}\n+\n+Regex *\n+i_regex_new (const gchar *pattern,\n+             GRegexCompileFlags compile_options,\n+             GRegexMatchFlags match_options,\n+             GError **error)\n+{\n+	const gchar *valid_pattern;\n+	gboolean free_valid_pattern;\n+	Regex *ret = NULL;\n+\n+	valid_pattern = make_valid_utf8(pattern, &free_valid_pattern);\n+	ret = g_regex_new(valid_pattern, compile_options, match_options, error);\n+\n+	if (free_valid_pattern)\n+		g_free_not_null((gchar *)valid_pattern);\n+\n+	return ret;\n+}\n+\n+void\n+i_regex_unref (Regex *regex)\n+{\n+	g_regex_unref(regex);\n+}\n+\n+/* if new_string is present, the caller must free new_string.\n+   otherwise, g_match_info_get_string must not be used. */\n+gboolean\n+i_regex_match (const Regex *regex,\n+               const gchar *string,\n+               GRegexMatchFlags match_options,\n+               MatchInfo **match_info,\n+               const gchar **new_string)\n+{\n+	gboolean ret;\n+	gboolean free_valid_string;\n+	const gchar *valid_string = make_valid_utf8(string, &free_valid_string);\n+\n+	ret = g_regex_match(regex, valid_string, match_options, match_info);\n+	if (free_valid_string) {\n+		if (new_string)\n+			*new_string = valid_string;\n+		else\n+			g_free_not_null((gchar *)valid_string);\n+	}\n+	return ret;\n+}\n+\n+gsize\n+strlen_pua_oddly(const char *str)\n+{\n+	const gchar *ptr;\n+	gsize ret = 0;\n+	ptr = str;\n+\n+	while (*ptr) {\n+		const gchar *old;\n+		gunichar c = g_utf8_get_char(ptr);\n+		old = ptr;\n+		ptr = g_utf8_next_char(ptr);\n+\n+		/* it is our PUA encoded byte */\n+		if ((c & 0xfff00) == 0xfff00)\n+			ret++;\n+		else\n+			ret += ptr - old;\n+	}\n+\n+	return ret;\n+}\n+\n+gboolean\n+i_match_info_fetch_pos (const MatchInfo *match_info,\n+                        gint match_num,\n+                        gint *start_pos,\n+                        gint *end_pos,\n+                        const gchar *new_string)\n+{\n+	gint tmp_start, tmp_end, new_start_pos;\n+	gboolean ret;\n+\n+	if (!new_string || (!start_pos && !end_pos))\n+		return g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos);\n+\n+	ret = g_match_info_fetch_pos(match_info, match_num, &tmp_start, &tmp_end);\n+	if (start_pos || end_pos) {\n+		gchar *to_start = g_strndup(new_string, tmp_start);\n+		new_start_pos = strlen_pua_oddly(to_start);\n+		g_free_not_null(to_start);\n+\n+		if (start_pos)\n+			*start_pos = new_start_pos;\n+\n+		if (end_pos) {\n+			gchar *to_end = g_strndup(new_string + tmp_start, tmp_end - tmp_start);\n+			*end_pos = new_start_pos + strlen_pua_oddly(to_end);\n+			g_free_not_null(to_end);\n+		}\n+	}\n+	return ret;\n+}\n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','iregex-regexh.c','87','17','101','0','ADD','@@ -0,0 +1,101 @@\n+#include \"iregex.h\"\n+\n+Regex *\n+i_regex_new (const gchar *pattern,\n+             GRegexCompileFlags compile_options,\n+             GRegexMatchFlags match_options,\n+             GError **error)\n+{\n+	Regex *regex;\n+	char *errbuf;\n+	int cflags;\n+	int errcode, errbuf_len;\n+\n+	regex = g_new0(Regex, 1);\n+	cflags = REG_EXTENDED;\n+	if (compile_options & G_REGEX_CASELESS)\n+		cflags |= REG_ICASE;\n+	if (compile_options & G_REGEX_MULTILINE)\n+		cflags |= REG_NEWLINE;\n+	if (match_options & G_REGEX_MATCH_NOTBOL)\n+		cflags |= REG_NOTBOL;\n+	if (match_options & G_REGEX_MATCH_NOTEOL)\n+		cflags |= REG_NOTEOL;\n+\n+	errcode = regcomp(regex, pattern, cflags);\n+	if (errcode != 0) {\n+		errbuf_len = regerror(errcode, regex, 0, 0);\n+		errbuf = g_malloc(errbuf_len);\n+		regerror(errcode, regex, errbuf, errbuf_len);\n+		g_set_error(error, G_REGEX_ERROR, errcode, \"%s\", errbuf);\n+		g_free(errbuf);\n+		g_free(regex);\n+		return NULL;\n+	} else {\n+		return regex;\n+	}\n+}\n+\n+void\n+i_regex_unref (Regex *regex)\n+{\n+	regfree(regex);\n+	g_free(regex);\n+}\n+\n+gboolean\n+i_regex_match (const Regex *regex,\n+               const gchar *string,\n+               GRegexMatchFlags match_options,\n+               MatchInfo **match_info,\n+               const gchar **new_string)\n+{\n+	int groups;\n+	int eflags;\n+\n+	g_return_val_if_fail(regex != NULL, FALSE);\n+\n+	if (match_info != NULL) {\n+		groups = 1 + regex->re_nsub;\n+		*match_info = g_new0(MatchInfo, groups);\n+	} else {\n+		groups = 0;\n+	}\n+\n+	eflags = 0;\n+	if (match_options & G_REGEX_MATCH_NOTBOL)\n+		eflags |= REG_NOTBOL;\n+	if (match_options & G_REGEX_MATCH_NOTEOL)\n+		eflags |= REG_NOTEOL;\n+\n+	return regexec(regex, string, groups, groups ? *match_info : NULL, eflags) == 0;\n+}\n+\n+gboolean\n+i_match_info_fetch_pos (const MatchInfo *match_info,\n+                        gint match_num,\n+                        gint *start_pos,\n+                        gint *end_pos,\n+                        const gchar *new_string)\n+{\n+	if (start_pos != NULL)\n+		*start_pos = match_info[match_num].rm_so;\n+	if (end_pos != NULL)\n+		*end_pos = match_info[match_num].rm_eo;\n+\n+	return TRUE;\n+}\n+\n+gboolean\n+i_match_info_matches (const MatchInfo *match_info)\n+{\n+	g_return_val_if_fail(match_info != NULL, FALSE);\n+\n+	return match_info[0].rm_so != -1;\n+}\n+\n+void\n+i_match_info_free (MatchInfo *match_info)\n+{\n+	g_free(match_info);\n+}\n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','iregex.h','30','0','52','0','ADD','@@ -0,0 +1,52 @@\n+#ifndef __REGEX_H\n+#define __REGEX_H\n+\n+#include \"common.h\"\n+\n+#ifdef USE_GREGEX\n+\n+#include <glib.h>\n+typedef	GRegex Regex;\n+typedef	GMatchInfo MatchInfo;\n+\n+#define i_match_info_matches g_match_info_matches\n+#define i_match_info_free g_match_info_free\n+\n+#else\n+\n+#include <regex.h>\n+typedef	regex_t Regex;\n+typedef regmatch_t MatchInfo;\n+\n+gboolean\n+i_match_info_matches (const MatchInfo *match_info);\n+\n+void\n+i_match_info_free (MatchInfo *match_info);\n+\n+#endif\n+\n+Regex *\n+i_regex_new (const gchar *pattern,\n+             GRegexCompileFlags compile_options,\n+             GRegexMatchFlags match_options,\n+             GError **error);\n+\n+void\n+i_regex_unref (Regex *regex);\n+\n+gboolean\n+i_regex_match (const Regex *regex,\n+               const gchar *string,\n+               GRegexMatchFlags match_options,\n+               MatchInfo **match_info,\n+               const gchar **new_string);\n+\n+gboolean\n+i_match_info_fetch_pos (const MatchInfo *match_info,\n+                        gint match_num,\n+                        gint *start_pos,\n+                        gint *end_pos,\n+                        const gchar *new_string);\n+\n+#endif\n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','iregex.h','30','0','52','0','ADD','@@ -0,0 +1,52 @@\n+#ifndef __REGEX_H\n+#define __REGEX_H\n+\n+#include \"common.h\"\n+\n+#ifdef USE_GREGEX\n+\n+#include <glib.h>\n+typedef	GRegex Regex;\n+typedef	GMatchInfo MatchInfo;\n+\n+#define i_match_info_matches g_match_info_matches\n+#define i_match_info_free g_match_info_free\n+\n+#else\n+\n+#include <regex.h>\n+typedef	regex_t Regex;\n+typedef regmatch_t MatchInfo;\n+\n+gboolean\n+i_match_info_matches (const MatchInfo *match_info);\n+\n+void\n+i_match_info_free (MatchInfo *match_info);\n+\n+#endif\n+\n+Regex *\n+i_regex_new (const gchar *pattern,\n+             GRegexCompileFlags compile_options,\n+             GRegexMatchFlags match_options,\n+             GError **error);\n+\n+void\n+i_regex_unref (Regex *regex);\n+\n+gboolean\n+i_regex_match (const Regex *regex,\n+               const gchar *string,\n+               GRegexMatchFlags match_options,\n+               MatchInfo **match_info,\n+               const gchar **new_string);\n+\n+gboolean\n+i_match_info_fetch_pos (const MatchInfo *match_info,\n+                        gint match_num,\n+                        gint *start_pos,\n+                        gint *end_pos,\n+                        const gchar *new_string);\n+\n+#endif\n','false','false','use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','misc.c','770','255','0','4','MODIFY','@@ -22,10 +22,6 @@\n #include \"misc.h\"\n #include \"commands.h\"\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n-\n typedef struct {\n 	int condition;\n 	GInputFunction function;\n','false','false','not use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','fe-ignore.c','214','62','0','5','MODIFY','@@ -58,13 +58,8 @@ static void ignore_print(int index, IGNORE_REC *rec)\n 		g_string_append(options, \"-regexp \");\n 		if (rec->pattern == NULL)\n 			g_string_append(options, \"[INVALID! -pattern missing] \");\n-#ifdef USE_GREGEX\n 		else if (rec->preg == NULL)\n 			g_string_append(options, \"[INVALID!] \");\n-#else\n-		else if (!rec->regexp_compiled)\n-			g_string_append(options, \"[INVALID!] \");\n-#endif\n 	}\n 	if (rec->fullword) g_string_append(options, \"-full \");\n 	if (rec->replies) g_string_append(options, \"-replies \");\n','false','false','use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','hilight-text.c','542','154','11','40','MODIFY','@@ -26,6 +26,7 @@\n #include \"misc.h\"\n #include \"lib-config/iconfig.h\"\n #include \"settings.h\"\n+#include \"iregex.h\"\n \n #include \"servers.h\"\n #include \"channels.h\"\n@@ -101,11 +102,7 @@ static void hilight_destroy(HILIGHT_REC *rec)\n {\n 	g_return_if_fail(rec != NULL);\n \n-#ifdef USE_GREGEX\n-	if (rec->preg != NULL) g_regex_unref(rec->preg);\n-#else\n-	if (rec->regexp_compiled) regfree(&rec->preg);\n-#endif\n+	if (rec->preg != NULL) i_regex_unref(rec->preg);\n 	if (rec->channels != NULL) g_strfreev(rec->channels);\n 	g_free_not_null(rec->color);\n 	g_free_not_null(rec->act_color);\n@@ -122,19 +119,10 @@ static void hilights_destroy_all(void)\n \n static void hilight_init_rec(HILIGHT_REC *rec)\n {\n-#ifdef USE_GREGEX\n 	if (rec->preg != NULL)\n-		g_regex_unref(rec->preg);\n+		i_regex_unref(rec->preg);\n \n-	rec->preg = g_regex_new(rec->text, G_REGEX_OPTIMIZE | G_REGEX_RAW | G_REGEX_CASELESS, 0, NULL);\n-#else\n-	if (rec->regexp_compiled) regfree(&rec->preg);\n-	if (!rec->regexp)\n-		rec->regexp_compiled = FALSE;\n-	else\n-		rec->regexp_compiled = regcomp(&rec->preg, rec->text,\n-				rec->case_sensitive ? REG_EXTENDED : (REG_EXTENDED|REG_ICASE)) == 0;\n-#endif\n+	rec->preg = i_regex_new(rec->text, G_REGEX_OPTIMIZE | G_REGEX_CASELESS, 0, NULL);\n }\n \n void hilight_create(HILIGHT_REC *rec)\n@@ -207,30 +195,18 @@ static gboolean hilight_match_text(HILIGHT_REC *rec, const char *text,\n 	gboolean ret = FALSE;\n \n 	if (rec->regexp) {\n-#ifdef USE_GREGEX\n 		if (rec->preg != NULL) {\n-			GMatchInfo *match;\n+			MatchInfo *match;\n+			const char *new_text = NULL;\n \n-			g_regex_match (rec->preg, text, 0, &match);\n+			i_regex_match(rec->preg, text, 0, &match, &new_text);\n \n-			if (g_match_info_matches(match))\n-				ret = g_match_info_fetch_pos(match, 0, match_beg, match_end);\n+			if (i_match_info_matches(match))\n+				ret = i_match_info_fetch_pos(match, 0, match_beg, match_end, new_text);\n \n-			g_match_info_free(match);\n+			i_match_info_free(match);\n+			g_free_not_null((char *)new_text);\n 		}\n-#else\n-		regmatch_t rmatch[1];\n-\n-		if (rec->regexp_compiled &&\n-			regexec(&rec->preg, text, 1, rmatch, 0) == 0) {\n-			if (rmatch[0].rm_so > 0 &&\n-				match_beg != NULL && match_end != NULL) {\n-				*match_beg = rmatch[0].rm_so;\n-				*match_end = rmatch[0].rm_eo;\n-			}\n-			ret = TRUE;\n-		}\n-#endif\n 	} else {\n 		char *match;\n \n@@ -524,13 +500,8 @@ static void hilight_print(int index, HILIGHT_REC *rec)\n 	if (rec->case_sensitive) g_string_append(options, \"-matchcase \");\n 	if (rec->regexp) {\n 		g_string_append(options, \"-regexp \");\n-#ifdef USE_GREGEX\n 		if (rec->preg == NULL)\n 			g_string_append(options, \"[INVALID!] \");\n-#else\n-		if (!rec->regexp_compiled)\n-			g_string_append(options, \"[INVALID!] \");\n-#endif\n 	}\n \n 	if (rec->priority != 0)\n','false','false','use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','hilight-text.h','32','0','2','10','MODIFY','@@ -1,10 +1,7 @@\n #ifndef __HILIGHT_TEXT_H\n #define __HILIGHT_TEXT_H\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n-\n+#include \"iregex.h\"\n #include \"formats.h\"\n \n struct _HILIGHT_REC {\n@@ -24,12 +21,7 @@ struct _HILIGHT_REC {\n 	unsigned int fullword:1; /* match `text\' only for full words */\n 	unsigned int regexp:1; /* `text\' is a regular expression */\n 	unsigned int case_sensitive:1;/* `text\' must match case */\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n 	char *servertag;\n };\n \n','false','false','none'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','hilight-text.h','32','0','2','10','MODIFY','@@ -1,10 +1,7 @@\n #ifndef __HILIGHT_TEXT_H\n #define __HILIGHT_TEXT_H\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n-\n+#include \"iregex.h\"\n #include \"formats.h\"\n \n struct _HILIGHT_REC {\n@@ -24,12 +21,7 @@ struct _HILIGHT_REC {\n 	unsigned int fullword:1; /* match `text\' only for full words */\n 	unsigned int regexp:1; /* `text\' is a regular expression */\n 	unsigned int case_sensitive:1;/* `text\' must match case */\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n 	char *servertag;\n };\n \n','false','false','not use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','hilight-text.h','32','0','2','10','MODIFY','@@ -1,10 +1,7 @@\n #ifndef __HILIGHT_TEXT_H\n #define __HILIGHT_TEXT_H\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n-\n+#include \"iregex.h\"\n #include \"formats.h\"\n \n struct _HILIGHT_REC {\n@@ -24,12 +21,7 @@ struct _HILIGHT_REC {\n 	unsigned int fullword:1; /* match `text\' only for full words */\n 	unsigned int regexp:1; /* `text\' is a regular expression */\n 	unsigned int case_sensitive:1;/* `text\' must match case */\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n 	char *servertag;\n };\n \n','false','false','use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','textbuffer.c','473','141','8','29','MODIFY','@@ -24,13 +24,10 @@\n #include \"misc.h\"\n #include \"formats.h\"\n #include \"utf8.h\"\n+#include \"iregex.h\"\n \n #include \"textbuffer.h\"\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n-\n #define TEXT_CHUNK_USABLE_SIZE (LINE_TEXT_CHUNK_SIZE-2-(int)sizeof(char*))\n \n TEXT_BUFFER_REC *textbuffer_create(void)\n@@ -545,11 +542,7 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 			    int before, int after,\n 			    int regexp, int fullword, int case_sensitive)\n {\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n         LINE_REC *line, *pre_line;\n 	GList *matches;\n 	GString *str;\n@@ -559,23 +552,14 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 	g_return_val_if_fail(buffer != NULL, NULL);\n 	g_return_val_if_fail(text != NULL, NULL);\n \n-#ifdef USE_GREGEX\n 	preg = NULL;\n \n 	if (regexp) {\n-		preg = g_regex_new(text, G_REGEX_RAW | (case_sensitive ? 0 : G_REGEX_CASELESS), 0, NULL);\n+		preg = i_regex_new(text, case_sensitive ? 0 : G_REGEX_CASELESS, 0, NULL);\n \n 		if (preg == NULL)\n 			return NULL;\n 	}\n-#else\n-	if (regexp) {\n-		int flags = REG_EXTENDED | REG_NOSUB |\n-			(case_sensitive ? 0 : REG_ICASE);\n-		if (regcomp(&preg, text, flags) != 0)\n-			return NULL;\n-	}\n-#endif\n \n 	matches = NULL; match_after = 0;\n         str = g_string_new(NULL);\n@@ -592,17 +576,16 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 			(line->info.level & nolevel) == 0;\n \n 		if (*text != \'\\0\') {\n+			const char *tmp = NULL;\n 			textbuffer_line2text(line, FALSE, str);\n \n 			if (line_matched) {\n 				line_matched = regexp ?\n-#ifdef USE_GREGEX\n-				    g_regex_match(preg, str->str, 0, NULL)\n-#else\n-				    regexec(&preg, str->str, 0, NULL, 0) == 0\n-#endif\n+					i_regex_match(preg, str->str, 0, NULL, &tmp)\n 					: match_func(str->str, text) != NULL;\n 			}\n+			if (tmp && tmp != str->str)\n+				g_free_not_null((char *)tmp);\n 		}\n \n 		if (line_matched) {\n@@ -631,12 +614,8 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 		}\n 	}\n \n-#ifdef USE_GREGEX\n 	if (preg != NULL)\n-		g_regex_unref(preg);\n-#else\n-	if (regexp) regfree(&preg);\n-#endif\n+		i_regex_unref(preg);\n         g_string_free(str, TRUE);\n 	return matches;\n }\n','false','false','not use_gregex'),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','refactor regex and implement utf8 mode for gregex\n\n- with non-unicode byte to private use area a mapping\n- move all ifdefs to iregex.h file only','textbuffer.c','473','141','8','29','MODIFY','@@ -24,13 +24,10 @@\n #include \"misc.h\"\n #include \"formats.h\"\n #include \"utf8.h\"\n+#include \"iregex.h\"\n \n #include \"textbuffer.h\"\n \n-#ifndef USE_GREGEX\n-#  include <regex.h>\n-#endif\n-\n #define TEXT_CHUNK_USABLE_SIZE (LINE_TEXT_CHUNK_SIZE-2-(int)sizeof(char*))\n \n TEXT_BUFFER_REC *textbuffer_create(void)\n@@ -545,11 +542,7 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 			    int before, int after,\n 			    int regexp, int fullword, int case_sensitive)\n {\n-#ifdef USE_GREGEX\n-	GRegex *preg;\n-#else\n-	regex_t preg;\n-#endif\n+	Regex *preg;\n         LINE_REC *line, *pre_line;\n 	GList *matches;\n 	GString *str;\n@@ -559,23 +552,14 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 	g_return_val_if_fail(buffer != NULL, NULL);\n 	g_return_val_if_fail(text != NULL, NULL);\n \n-#ifdef USE_GREGEX\n 	preg = NULL;\n \n 	if (regexp) {\n-		preg = g_regex_new(text, G_REGEX_RAW | (case_sensitive ? 0 : G_REGEX_CASELESS), 0, NULL);\n+		preg = i_regex_new(text, case_sensitive ? 0 : G_REGEX_CASELESS, 0, NULL);\n \n 		if (preg == NULL)\n 			return NULL;\n 	}\n-#else\n-	if (regexp) {\n-		int flags = REG_EXTENDED | REG_NOSUB |\n-			(case_sensitive ? 0 : REG_ICASE);\n-		if (regcomp(&preg, text, flags) != 0)\n-			return NULL;\n-	}\n-#endif\n \n 	matches = NULL; match_after = 0;\n         str = g_string_new(NULL);\n@@ -592,17 +576,16 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 			(line->info.level & nolevel) == 0;\n \n 		if (*text != \'\\0\') {\n+			const char *tmp = NULL;\n 			textbuffer_line2text(line, FALSE, str);\n \n 			if (line_matched) {\n 				line_matched = regexp ?\n-#ifdef USE_GREGEX\n-				    g_regex_match(preg, str->str, 0, NULL)\n-#else\n-				    regexec(&preg, str->str, 0, NULL, 0) == 0\n-#endif\n+					i_regex_match(preg, str->str, 0, NULL, &tmp)\n 					: match_func(str->str, text) != NULL;\n 			}\n+			if (tmp && tmp != str->str)\n+				g_free_not_null((char *)tmp);\n 		}\n \n 		if (line_matched) {\n@@ -631,12 +614,8 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 		}\n 	}\n \n-#ifdef USE_GREGEX\n 	if (preg != NULL)\n-		g_regex_unref(preg);\n-#else\n-	if (regexp) regfree(&preg);\n-#endif\n+		i_regex_unref(preg);\n         g_string_free(str, TRUE);\n 	return matches;\n }\n','false','false','use_gregex'),('irssi','1.0.2','e84adeca15084a82c04ff6c3b5c7b8941c297322','Jari Matilainen','change ternary operator to if/else statements, add default ssl port support','common.h','42','0','1','0','MODIFY','@@ -9,6 +9,7 @@\n #define IRSSI_ABI_VERSION 9\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n+#define DEFAULT_SERVER_ADD_TLS_PORT 6697\n \n #ifdef HAVE_CONFIG_H\n #include \"irssi-config.h\"\n','false','false','none'),('irssi','1.0.2','e84adeca15084a82c04ff6c3b5c7b8941c297322','Jari Matilainen','change ternary operator to if/else statements, add default ssl port support','fe-server.c','374','108','9','4','MODIFY','@@ -119,10 +119,15 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 	if (*addr == \'\\0\') cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);\n \n 	value = g_hash_table_lookup(optlist, \"port\");\n-	port = *portstr == \'\\0\' ?\n-			(value != NULL && *value != \'\\0\' ?\n-			atoi(value) : DEFAULT_SERVER_ADD_PORT)\n-		: atoi(portstr);\n+\n+	if (*portstr != \'\\0\')\n+		port = atoi(portstr);\n+	else if (value != NULL && *value != \'\\0\')\n+		port = atoi(value);\n+	else if (g_hash_table_lookup(optlist, \"tls\"))\n+		port = DEFAULT_SERVER_ADD_TLS_PORT;\n+	else\n+		port = DEFAULT_SERVER_ADD_PORT;\n \n 	chatnet = g_hash_table_lookup(optlist, \"network\");\n \n','false','false','none'),('irssi','1.0.2','78a390f4796a97a3624feee2728018484c8485f8','ailin-nemui','abi up','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@\n #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */\n #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */\n \n-#define IRSSI_ABI_VERSION 9\n+#define IRSSI_ABI_VERSION 10\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n \n','false','false','none'),('irssi','1.0.2','f28c64a3dc1e66f9d1e49650d5b2ab15795b9e53','Jari Matilainen','make backward compatible with ssl flags','fe-server.c','375','109','2','1','MODIFY','@@ -124,7 +124,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n 		port = atoi(portstr);\n 	else if (value != NULL && *value != \'\\0\')\n 		port = atoi(value);\n-	else if (g_hash_table_lookup(optlist, \"tls\"))\n+	else if (g_hash_table_lookup(optlist, \"tls\") ||\n+		 g_hash_table_lookup(optlist, \"ssl\"))\n 		port = DEFAULT_SERVER_ADD_TLS_PORT;\n 	else\n 		port = DEFAULT_SERVER_ADD_PORT;\n','false','false','none'),('irssi','1.0.2','00354c365187cecb9bc3ce3c3b3482e32d04729a','ailin-nemui','update iregex-gregex.c\n\nmake helper functions static','iregex-gregex.c','111','24','2','2','MODIFY','@@ -2,7 +2,7 @@\n \n #include \"iregex.h\"\n \n-const gchar *\n+static const gchar *\n make_valid_utf8(const gchar *text, gboolean *free_ret)\n {\n 	GString *str;\n@@ -82,7 +82,7 @@ i_regex_match (const Regex *regex,\n 	return ret;\n }\n \n-gsize\n+static gsize\n strlen_pua_oddly(const char *str)\n {\n 	const gchar *ptr;\n','false','false','none'),('irssi','1.0.2','48899a123d68051fbc73acb8ad151e89fdcb6b31','ailin-nemui','update iregex-gregex.c\n\nadd 2 comments about new_string','iregex-gregex.c','111','24','6','1','MODIFY','@@ -60,7 +60,9 @@ i_regex_unref (Regex *regex)\n }\n \n /* if new_string is present, the caller must free new_string.\n-   otherwise, g_match_info_get_string must not be used. */\n+   otherwise, g_match_info_get_string must not be used.\n+   if string is not vali utf8, new_string will be assigned\n+   a similar, but valid utf8, string */\n gboolean\n i_regex_match (const Regex *regex,\n                const gchar *string,\n@@ -105,6 +107,9 @@ strlen_pua_oddly(const char *str)\n 	return ret;\n }\n \n+/* new_string should be passed in here from the i_regex_match call. \n+   The start_pos and end_pos will then be calculated as if they were on\n+   the original string */\n gboolean\n i_match_info_fetch_pos (const MatchInfo *match_info,\n                         gint match_num,\n','false','false','none'),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','ignore.c','351','132','1','1','MODIFY','@@ -69,7 +69,7 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)\n \n 	if (rec->regexp) {\n 		return rec->preg != NULL &&\n-			i_regex_match(rec->preg, text, 0, NULL, NULL);\n+			i_regex_match(rec->preg, text, 0, NULL);\n 	}\n \n 	return rec->fullword ?\n','false','false','none'),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','iregex-gregex.c','131','28','39','16','MODIFY','@@ -2,6 +2,11 @@\n \n #include \"iregex.h\"\n \n+struct _MatchInfo {\n+	const char *valid_string;\n+	GMatchInfo *g_match_info;\n+};\n+\n static const gchar *\n make_valid_utf8(const gchar *text, gboolean *free_ret)\n {\n@@ -59,28 +64,29 @@ i_regex_unref (Regex *regex)\n 	g_regex_unref(regex);\n }\n \n-/* if new_string is present, the caller must free new_string.\n-   otherwise, g_match_info_get_string must not be used.\n-   if string is not vali utf8, new_string will be assigned\n-   a similar, but valid utf8, string */\n gboolean\n i_regex_match (const Regex *regex,\n                const gchar *string,\n                GRegexMatchFlags match_options,\n-               MatchInfo **match_info,\n-               const gchar **new_string)\n+               MatchInfo **match_info)\n {\n 	gboolean ret;\n 	gboolean free_valid_string;\n 	const gchar *valid_string = make_valid_utf8(string, &free_valid_string);\n \n-	ret = g_regex_match(regex, valid_string, match_options, match_info);\n+	if (match_info != NULL)\n+		*match_info = g_new0(MatchInfo, 1);\n+\n+	ret = g_regex_match(regex, valid_string, match_options,\n+			    match_info != NULL ? &(*match_info)->g_match_info : NULL);\n+\n 	if (free_valid_string) {\n-		if (new_string)\n-			*new_string = valid_string;\n+		if (match_info != NULL)\n+			(*match_info)->valid_string = valid_string;\n 		else\n 			g_free_not_null((gchar *)valid_string);\n 	}\n+\n 	return ret;\n }\n \n@@ -114,18 +120,20 @@ gboolean\n i_match_info_fetch_pos (const MatchInfo *match_info,\n                         gint match_num,\n                         gint *start_pos,\n-                        gint *end_pos,\n-                        const gchar *new_string)\n+                        gint *end_pos)\n {\n 	gint tmp_start, tmp_end, new_start_pos;\n 	gboolean ret;\n \n-	if (!new_string || (!start_pos && !end_pos))\n-		return g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos);\n+	if (!match_info->valid_string || (!start_pos && !end_pos))\n+		return g_match_info_fetch_pos(match_info->g_match_info,\n+					      match_num, start_pos, end_pos);\n \n-	ret = g_match_info_fetch_pos(match_info, match_num, &tmp_start, &tmp_end);\n+	ret = g_match_info_fetch_pos(match_info->g_match_info,\n+				     match_num, &tmp_start, &tmp_end);\n 	if (start_pos || end_pos) {\n-		gchar *to_start = g_strndup(new_string, tmp_start);\n+		const gchar *str = match_info->valid_string;\n+		gchar *to_start = g_strndup(str, tmp_start);\n 		new_start_pos = strlen_pua_oddly(to_start);\n 		g_free_not_null(to_start);\n \n@@ -133,10 +141,25 @@ i_match_info_fetch_pos (const MatchInfo *match_info,\n 			*start_pos = new_start_pos;\n \n 		if (end_pos) {\n-			gchar *to_end = g_strndup(new_string + tmp_start, tmp_end - tmp_start);\n+			gchar *to_end = g_strndup(str + tmp_start, tmp_end - tmp_start);\n 			*end_pos = new_start_pos + strlen_pua_oddly(to_end);\n 			g_free_not_null(to_end);\n 		}\n 	}\n 	return ret;\n }\n+\n+gboolean\n+i_match_info_matches (const MatchInfo *match_info)\n+{\n+	g_return_val_if_fail(match_info != NULL, FALSE);\n+\n+	return g_match_info_matches(match_info->g_match_info);\n+}\n+\n+void\n+i_match_info_free (MatchInfo *match_info)\n+{\n+	g_match_info_free(match_info->g_match_info);\n+	g_free(match_info);\n+}\n','false','false','none'),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','iregex-regexh.c','85','17','2','4','MODIFY','@@ -47,8 +47,7 @@ gboolean\n i_regex_match (const Regex *regex,\n                const gchar *string,\n                GRegexMatchFlags match_options,\n-               MatchInfo **match_info,\n-               const gchar **new_string)\n+               MatchInfo **match_info)\n {\n 	int groups;\n 	int eflags;\n@@ -75,8 +74,7 @@ gboolean\n i_match_info_fetch_pos (const MatchInfo *match_info,\n                         gint match_num,\n                         gint *start_pos,\n-                        gint *end_pos,\n-                        const gchar *new_string)\n+                        gint *end_pos)\n {\n 	if (start_pos != NULL)\n 		*start_pos = match_info[match_num].rm_so;\n','false','false','none'),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','iregex.h','28','0','5','10','MODIFY','@@ -7,10 +7,7 @@\n \n #include <glib.h>\n typedef	GRegex Regex;\n-typedef	GMatchInfo MatchInfo;\n-\n-#define i_match_info_matches g_match_info_matches\n-#define i_match_info_free g_match_info_free\n+typedef	struct _MatchInfo MatchInfo;\n \n #else\n \n@@ -18,14 +15,14 @@ typedef	GMatchInfo MatchInfo;\n typedef	regex_t Regex;\n typedef regmatch_t MatchInfo;\n \n+#endif\n+\n gboolean\n i_match_info_matches (const MatchInfo *match_info);\n \n void\n i_match_info_free (MatchInfo *match_info);\n \n-#endif\n-\n Regex *\n i_regex_new (const gchar *pattern,\n              GRegexCompileFlags compile_options,\n@@ -39,14 +36,12 @@ gboolean\n i_regex_match (const Regex *regex,\n                const gchar *string,\n                GRegexMatchFlags match_options,\n-               MatchInfo **match_info,\n-               const gchar **new_string);\n+               MatchInfo **match_info);\n \n gboolean\n i_match_info_fetch_pos (const MatchInfo *match_info,\n                         gint match_num,\n                         gint *start_pos,\n-                        gint *end_pos,\n-                        const gchar *new_string);\n+                        gint *end_pos);\n \n #endif\n','false','false','none'),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','hilight-text.c','540','154','2','5','MODIFY','@@ -197,15 +197,12 @@ static gboolean hilight_match_text(HILIGHT_REC *rec, const char *text,\n 	if (rec->regexp) {\n 		if (rec->preg != NULL) {\n 			MatchInfo *match;\n-			const char *new_text = NULL;\n-\n-			i_regex_match(rec->preg, text, 0, &match, &new_text);\n+			i_regex_match(rec->preg, text, 0, &match);\n \n 			if (i_match_info_matches(match))\n-				ret = i_match_info_fetch_pos(match, 0, match_beg, match_end, new_text);\n+				ret = i_match_info_fetch_pos(match, 0, match_beg, match_end);\n \n 			i_match_info_free(match);\n-			g_free_not_null((char *)new_text);\n 		}\n 	} else {\n 		char *match;\n','false','false','none'),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','textbuffer.c','470','139','1','4','MODIFY','@@ -576,16 +576,13 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 			(line->info.level & nolevel) == 0;\n \n 		if (*text != \'\\0\') {\n-			const char *tmp = NULL;\n 			textbuffer_line2text(line, FALSE, str);\n \n 			if (line_matched) {\n 				line_matched = regexp ?\n-					i_regex_match(preg, str->str, 0, NULL, &tmp)\n+					i_regex_match(preg, str->str, 0, NULL)\n 					: match_func(str->str, text) != NULL;\n 			}\n-			if (tmp && tmp != str->str)\n-				g_free_not_null((char *)tmp);\n 		}\n \n 		if (line_matched) {\n','false','false','none'),('irssi','1.0.3','52bb06ccd9f9bd639a454045eba1235e4133b034','dequis','fe-dcc-(get|send): fix some -wpointer-compare with newer gcc\n\nthe warning itself:\n\n>warning: comparison between pointer and zero character constant [-wpointer-compare]\n\nharmless stuff as far as i can tell.\n\nthe fix adds a null check that probably isn\'t needed. the old code that\ncompared against \'\\0\' worked a lot like a null check so it makes sense\nto keep that, while also adding the intended check for empty string.\n\nthis was visible with \"/dcc close send a\" showing an empty filename.\nthe equivalent for get didn\'t show the filename in the format string.','fe-dcc-get.c','103','21','1','1','MODIFY','@@ -108,7 +108,7 @@ static void dcc_error_close_not_found(const char *type, const char *nick,\n 	g_return_if_fail(fname != NULL);\n 	if (g_ascii_strcasecmp(type, \"GET\") != 0) return;\n \n-	if (fname == \'\\0\') fname = \"(ANY)\";\n+	if (fname == NULL || *fname == \'\\0\') fname = \"(ANY)\";\n 	printformat(NULL, NULL, MSGLEVEL_DCC,\n 		    IRCTXT_DCC_GET_NOT_FOUND, nick, fname);\n }\n','true','false','none'),('irssi','1.0.3','52bb06ccd9f9bd639a454045eba1235e4133b034','dequis','fe-dcc-(get|send): fix some -wpointer-compare with newer gcc\n\nthe warning itself:\n\n>warning: comparison between pointer and zero character constant [-wpointer-compare]\n\nharmless stuff as far as i can tell.\n\nthe fix adds a null check that probably isn\'t needed. the old code that\ncompared against \'\\0\' worked a lot like a null check so it makes sense\nto keep that, while also adding the intended check for empty string.\n\nthis was visible with \"/dcc close send a\" showing an empty filename.\nthe equivalent for get didn\'t show the filename in the format string.','fe-dcc-send.c','132','25','1','1','MODIFY','@@ -108,7 +108,7 @@ static void dcc_error_close_not_found(const char *type, const char *nick,\n 	g_return_if_fail(fname != NULL);\n 	if (g_ascii_strcasecmp(type, \"SEND\") != 0) return;\n \n-	if (fname == \'\\0\') fname = \"(ANY)\";\n+	if (fname == NULL || *fname == \'\\0\') fname = \"(ANY)\";\n 	printformat(NULL, NULL, MSGLEVEL_DCC,\n 		    IRCTXT_DCC_SEND_NOT_FOUND, nick, fname);\n }\n','true','false','none'),('irssi','1.0.3','0e44ea891645044f47bf3754e141045ee3b24324','dequis','performance improvements for /lastlog with big result sets\n\nthis applies to \"/lastlog\" with no filters (or with filters that don\'t\nfilter a lot) and with large amounts of text in the scrollback.\n\ntest case:\n\n    /exec seq 1 500000\n    /lastlog -file log.txt\n\nthanks to morning for reporting this.','textbuffer.c','480','147','5','3','MODIFY','@@ -616,21 +616,23 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 			}\n \n 			for (; pre_line != line; pre_line = pre_line->next)\n-				matches = g_list_append(matches, pre_line);\n+				matches = g_list_prepend(matches, pre_line);\n \n 			match_after = after;\n 		}\n \n 		if (line_matched || match_after > 0) {\n 			/* matched */\n-			matches = g_list_append(matches, line);\n+			matches = g_list_prepend(matches, line);\n \n 			if ((!line_matched && --match_after == 0) ||\n 			    (line_matched && match_after == 0 && before > 0))\n-				matches = g_list_append(matches, NULL);\n+				matches = g_list_prepend(matches, NULL);\n 		}\n 	}\n \n+	matches = g_list_reverse(matches);\n+\n #ifdef USE_GREGEX\n 	if (preg != NULL)\n 		g_regex_unref(preg);\n','false','false','use_gregex'),('irssi','1.0.3','e498265328bd619b231ea4c985734ea43bf89696','dequis','performance improvements for /lastlog -before\n\nthis avoids the use of g_list_find() to find if a match was already\nadded to the list of results, by checking the last two added matches\ninstead.\n\nchecking just the last match isn\'t enough because a null match is added\nas a separator (shown as -- in the ui)','textbuffer.c','481','148','2','1','MODIFY','@@ -610,7 +610,8 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,\n 			pre_line = line;\n 			for (i = 0; i < before; i++) {\n 				if (pre_line->prev == NULL ||\n-				    g_list_find(matches, pre_line->prev) != NULL)\n+				    g_list_nth_data(matches, 0) == pre_line->prev ||\n+				    g_list_nth_data(matches, 1) == pre_line->prev)\n 					break;\n                                 pre_line = pre_line->prev;\n 			}\n','false','false','none'),('irssi','1.0.3','fc67fd5111ac84cd101d961fc9a5b0bc1b25613b','Ailin Nemui','merge tag \'1.0.3\'','NEWS','2895','0','18','0','MODIFY','@@ -1,5 +1,23 @@\n v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n \n+v1.0.3 2017-06-06  The Irssi team <staff@irssi.org>\n+	- Fix out of bounds read when scanning expandos (GL!11).\n+	- Fix invalid memory access with quoted filenames in DCC\n+	  (GL#8, GL!12).\n+	- Fix null-pointer dereference on DCC without address (GL#9, GL!13).\n+	- Improve integer overflow handling. Originally reported by\n+          oss-fuzz#525 (#706).\n+	- Improve nicklist performance from O(N^2) to O(N) (#705).\n+	- Fix initial screen redraw delay. By Stephen Oberholtzer\n+	  (#680, bdo#856201).\n+	- Fix incorrect reset of true colours when resetting background. (#711).\n+	- Fix missing -notls option in /SERVER. By Jari Matilainen (#117, #702).\n+	- Fix minor history glitch on overcounter (#462, #685).\n+	- Improved OpenSSL detection at compile time. By Rodrigo Rebello (#677).\n+	- Improved NetBSD Terminfo detection. By Maya Rashish (#694, #698).\n+	- Add missing syntax info for COMPLETION (#687, #688).\n+	- Minor typo correction in help. By Michael Hansen (#707).\n+\n v1.0.2 2017-03-10  The Irssi team <staff@irssi.org>\n 	- Prevent some null-pointer crashes (GL!9).\n 	- Fix compilation with OpenSSL 1.1.0 (#628, #597).\n','false','false','none'),('irssi','1.0.3','4b1c60b2ecb030550716647bffb0f9dd7e97c31a','dequis','term-terminfo: avoid switching out of alt screen on unexpected exits\n\nperl sucks and kills the whole process when there\'s a version mismatch\nin perl_xs_handshake(). our atexit handler catches the exit and\ndeinitializes the terminal, removing the error.\n\nthis commit uses the \'quitting\' global variable which is set when irssi\nis voluntarily quitting, and avoids sending ti_rmcup, which restores the\noriginal screen and makes the error invisible.','term-terminfo.c','530','168','12','1','MODIFY','@@ -102,6 +102,17 @@ static GSourceFuncs sigcont_funcs = {\n 	.dispatch = sigcont_dispatch\n };\n \n+static void term_atexit(void)\n+{\n+	if (!quitting && current_term && current_term->TI_rmcup) {\n+		/* Unexpected exit, avoid switching out of alternate screen\n+		   to keep any on-screen errors (like noperl_die()\'s) */\n+		current_term->TI_rmcup = NULL;\n+	}\n+\n+	term_deinit();\n+}\n+\n int term_init(void)\n {\n 	struct sigaction act;\n@@ -140,7 +151,7 @@ int term_init(void)\n \n         term_set_input_type(TERM_TYPE_8BIT);\n 	term_common_init();\n-        atexit(term_deinit);\n+	atexit(term_atexit);\n         return TRUE;\n }\n \n','false','false','none'),('irssi','1.0.3','7354a74c654f1717d08a37c2b118141655974bc0','dequis','parse_time_interval: allow negative time in settings\n\nthis splits sign parsing out of parse_time_interval_uint() so that the\nnegative sign is applied outside of the unsigned context where the\nnumber parsing is done, and after all the checks that it\'s lower than\n(1 << 31)\n\nthis fixes issues with settings like `server_reconnect_time`,\n`server_connect_timeout` and `lag_max_before_disconnect`, which accepted\n-1 as a valid value.','misc.c','778','256','25','13','MODIFY','@@ -781,24 +781,35 @@ int parse_uint(const char *nptr, char **endptr, int base, guint *number)\n 	return TRUE;\n }\n \n+static int parse_number_sign(const char *input, char **endptr, int *sign)\n+{\n+	int sign_ = 1;\n+\n+	while (i_isspace(*input))\n+		input++;\n+\n+	if (*input == \'-\') {\n+		sign_ = -sign_;\n+		input++;\n+	}\n+\n+	*sign = sign_;\n+	*endptr = (char *) input;\n+	return TRUE;\n+}\n+\n static int parse_time_interval_uint(const char *time, guint *msecs)\n {\n 	const char *desc;\n 	guint number;\n-	int sign, len, ret, digits;\n+	int len, ret, digits;\n \n 	*msecs = 0;\n \n 	/* max. return value is around 24 days */\n-	number = 0; sign = 1; ret = TRUE; digits = FALSE;\n+	number = 0; ret = TRUE; digits = FALSE;\n 	while (i_isspace(*time))\n 		time++;\n-	if (*time == \'-\') {\n-		sign = -sign;\n-		time++;\n-		while (i_isspace(*time))\n-			time++;\n-	}\n 	for (;;) {\n 		if (i_isdigit(*time)) {\n 			char *endptr;\n@@ -828,7 +839,6 @@ static int parse_time_interval_uint(const char *time, guint *msecs)\n 			if (*time != \'\\0\')\n 				return FALSE;\n 			*msecs += number * 1000; /* assume seconds */\n-			*msecs *= sign;\n 			return TRUE;\n 		}\n \n@@ -866,7 +876,6 @@ static int parse_time_interval_uint(const char *time, guint *msecs)\n 		digits = FALSE;\n 	}\n \n-	*msecs *= sign;\n 	return ret;\n }\n \n@@ -960,15 +969,18 @@ int parse_size(const char *size, int *bytes)\n int parse_time_interval(const char *time, int *msecs)\n {\n 	guint msecs_;\n-	int ret;\n+	char *number;\n+	int ret, sign;\n+\n+	parse_number_sign(time, &number, &sign);\n \n-	ret = parse_time_interval_uint(time, &msecs_);\n+	ret = parse_time_interval_uint(number, &msecs_);\n \n 	if (msecs_ > (1U << 31)) {\n 		return FALSE;\n 	}\n \n-	*msecs = msecs_;\n+	*msecs = msecs_ * sign;\n 	return ret;\n }\n \n','false','false','none'),('irssi','1.0.3','02a5d1a00b4f484b4b2422785944e022810bbbb0','ailin-nemui','fix weird n-fold unescaping','chat-completion.c','959','227','10','4','MODIFY','@@ -1011,13 +1011,17 @@ static void sig_complete_target(GList **list, WINDOW_REC *window,\n 	}\n }\n \n+static void event_text(const char *data, SERVER_REC *server, WI_ITEM_REC *item);\n+\n /* expand \\n, \\t and \\\\ */\n static char *expand_escapes(const char *line, SERVER_REC *server,\n 			    WI_ITEM_REC *item)\n {\n 	char *ptr, *ret;\n-        int chr;\n+	const char *prev;\n+	int chr;\n \n+	prev = line;\n 	ret = ptr = g_malloc(strlen(line)+1);\n 	for (; *line != \'\\0\'; line++) {\n 		if (*line != \'\\\\\') {\n@@ -1036,9 +1040,11 @@ static char *expand_escapes(const char *line, SERVER_REC *server,\n 			/* newline .. we need to send another \"send text\"\n 			   event to handle it (or actually the text before\n 			   the newline..) */\n-			if (ret != ptr) {\n-				*ptr = \'\\0\';\n-				signal_emit(\"send text\", 3, ret, server, item);\n+			if (prev != line) {\n+				const char *prev_line = g_strndup(prev, (line - prev) - 1);\n+				event_text(prev_line, server, item);\n+				g_free((char *)prev_line);\n+				prev = line + 1;\n 				ptr = ret;\n 			}\n 		} else if (chr != -1) {\n','true','false','none'),('irssi','1.0.3','12d671a05645d67e811264d5be06d9758458452f','Oscar Linderholm','escape nicks during nick completion when expand_escapes is enabled\n\nfixes #693','completion.c','645','182','20','5','MODIFY','@@ -137,8 +137,9 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i\n         int old_startpos, old_wordlen;\n \n 	GString *result;\n-	char *word, *wordstart, *linestart, *ret;\n-	int continue_complete, want_space;\n+	const char *cmdchars;\n+	char *word, *wordstart, *linestart, *ret, *data;\n+	int continue_complete, want_space, expand_escapes;\n \n 	g_return_val_if_fail(line != NULL, NULL);\n 	g_return_val_if_fail(pos != NULL, NULL);\n@@ -241,14 +242,24 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i\n 	if (complist == NULL)\n 		return NULL;\n \n+        /* get the cmd char */\n+	cmdchars = settings_get_str(\"cmdchars\");\n+\n+	/* get the expand_escapes setting */\n+	expand_escapes = settings_get_bool(\"expand_escapes\");\n+\n+	/* escape if the word doesn\'t begin with \'/\' and expand_escapes are turned on */\n+	data = strchr(cmdchars, *line) == NULL && expand_escapes ?\n+		escape_string(complist->data) : g_strdup(complist->data);\n+\n 	/* word completed */\n-	*pos = startpos+strlen(complist->data);\n+	*pos = startpos + strlen(data);\n \n 	/* replace the word in line - we need to return\n 	   a full new line */\n 	result = g_string_new(line);\n 	g_string_erase(result, startpos, wordlen);\n-	g_string_insert(result, startpos, complist->data);\n+	g_string_insert(result, startpos, data);\n \n 	if (want_space) {\n 		if (!isseparator(result->str[*pos]))\n@@ -256,13 +267,17 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i\n 		(*pos)++;\n 	}\n \n-	wordlen = strlen(complist->data);\n+	wordlen = strlen(data);\n 	last_line_pos = *pos;\n 	g_free_not_null(last_line);\n 	last_line = g_strdup(result->str);\n \n 	ret = result->str;\n 	g_string_free(result, FALSE);\n+\n+	/* free the data */\n+	g_free(data);\n+\n 	return ret;\n }\n \n','false','false','none'),('irssi','1.0.3','bbf8b860747c13a478657b9070c191735d35e00a','ailin-nemui','remove const','chat-completion.c','959','227','2','2','MODIFY','@@ -1041,9 +1041,9 @@ static char *expand_escapes(const char *line, SERVER_REC *server,\n 			   event to handle it (or actually the text before\n 			   the newline..) */\n 			if (prev != line) {\n-				const char *prev_line = g_strndup(prev, (line - prev) - 1);\n+				char *prev_line = g_strndup(prev, (line - prev) - 1);\n 				event_text(prev_line, server, item);\n-				g_free((char *)prev_line);\n+				g_free(prev_line);\n 				prev = line + 1;\n 				ptr = ret;\n 			}\n','false','false','none'),('irssi','1.0.3','b483ec5faa76dc38f2e338f89c54a6e4cd06c764','ailin-nemui','test trusty container','.travis.yml','48','0','9','2','MODIFY','@@ -1,8 +1,15 @@\n sudo: false\n+dist: trusty\n language: perl\n perl:\n-    - \"5.20-shrplib\"\n-    - \"5.18-shrplib\"\n+    # ~stretch\n+    - \"5.24-shrplib\"\n+    # ~xenial\n+    # - \"5.22-shrplib\"\n+    # ~jessie\n+    # - \"5.20-shrplib\"\n+    # ~trusty\n+    # - \"5.18-shrplib\"\n     - \"system-perl\"\n env:\n     - CC=clang\n','false','false','none'),('irssi','1.0.3','29ebac987da1da2c892aed5ed329256b7bc94bca','Nei','check return value of localtime\n\nfixes #10','misc.c','780','257','3','0','MODIFY','@@ -560,6 +560,9 @@ char *my_asctime(time_t t)\n         int len;\n \n 	tm = localtime(&t);\n+	if (tm == NULL)\n+	    return g_strdup(\"???\");\n+\n 	str = g_strdup(asctime(tm));\n \n 	len = strlen(str);\n','false','false','none'),('irssi','1.0.3','73b851c39c11d01199e6c040749fb20e468f6c8d','ailin-nemui','correct ghashtable usage','nicklist.c','425','105','10','7','MODIFY','@@ -54,23 +54,26 @@ static void nick_hash_add(CHANNEL_REC *channel, NICK_REC *nick)\n \n static void nick_hash_remove(CHANNEL_REC *channel, NICK_REC *nick)\n {\n-	NICK_REC *list;\n+	NICK_REC *list, *newlist;\n \n 	list = g_hash_table_lookup(channel->nicks, nick->nick);\n 	if (list == NULL)\n 		return;\n \n-	if (list == nick || list->next == NULL) {\n-		g_hash_table_remove(channel->nicks, nick->nick);\n-		if (list->next != NULL) {\n-			g_hash_table_insert(channel->nicks, nick->next->nick,\n-					    nick->next);\n-		}\n+	if (list == nick) {\n+		newlist = nick->next;\n 	} else {\n+		newlist = list;\n 		while (list->next != nick)\n 			list = list->next;\n 		list->next = nick->next;\n 	}\n+\n+	g_hash_table_remove(channel->nicks, nick->nick);\n+	if (newlist != NULL) {\n+		g_hash_table_insert(channel->nicks, newlist->nick,\n+				    newlist);\n+	}\n }\n \n /* Add new nick to list */\n','false','false','none'),('irssi','1.0.3','5d7e54cd998ab48b1dc5d82aa74896bc9a91b705','ailin-nemui','more accurately describe clear','clear.in','10','0','2','2','MODIFY','@@ -12,8 +12,8 @@\n \n %9Description:%9\n \n-    Clears the window of all text; you may use this to clear a windows that\n-    contains sensitive information or has rendered improperly.\n+    Scrolls up the text in the window and fill the window with blank lines; you\n+    may want to use this to make new text start at the top of the window again.\n \n %9See also:%9 REDRAW\n \n','false','false','none'),('irssi','1.0.3','8b82d741b79e1cbb68c9e01d85d344fa0dc817ca','ailin-nemui','update clear.in','clear.in','10','0','2','2','MODIFY','@@ -12,8 +12,8 @@\n \n %9Description:%9\n \n-    Scrolls up the text in the window and fill the window with blank lines; you\n+    Scrolls up the text in the window and fills the window with blank lines; you\n     may want to use this to make new text start at the top of the window again.\n \n-%9See also:%9 REDRAW\n+%9See also:%9 REDRAW, SCROLLBACK CLEAR\n \n','false','false','none'),('irssi','1.0.4','91ec153c7f89ed96fa592ebae7a931fe50a4bb42','Ailin Nemui','merge tag \'1.0.4\' into integrate/1.0.4','NEWS','2907','0','13','0','MODIFY','@@ -1,5 +1,18 @@\n v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n \n+v1.0.4 2017-07-07  The Irssi team <staff@irssi.org>\n+	- Fix null pointer dereference when parsing invalid timestamp (GL#10,\n+	  GL!15). Reported by Brian \'geeknik\' Carpenter.\n+	- Fix use-after-free condition when removing nicks from the internal\n+	  nicklist (GL#11, GL!16). Reported by Brian \'geeknik\' Carpenter.\n+	- Fix incorrect string comparison in DCC file names (#714).\n+	- Fix regression in Irssi 1.0.3 where it would claim \"Invalid time \'-1\'\"\n+	  (#716, #722).\n+	- Fix a bug when using \\n to separate lines with expand_escapes (#723).\n+	- Retain screen output on improper exit, to better see any error\n+	  messages (#287, #721).\n+	- Minor help update (#729).\n+\n v1.0.3 2017-06-06  The Irssi team <staff@irssi.org>\n 	- Fix out of bounds read when scanning expandos (GL!11).\n 	- Fix invalid memory access with quoted filenames in DCC\n','false','false','none'),('irssi','1.0.4','2bc10386610eba0fe5741228f143e89e1acd2a7d','Tristan','clarified ambiguous autogen.sh error\n\nautogen.sh now instructs the user to install elinks or lynx if needed','autogen.sh','51','4','1','0','MODIFY','@@ -39,6 +39,7 @@ elif type links >/dev/null 2>&1 ; then\n   links -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt\n else\n   echo \"**Error**: No lynx or elinks present\"\n+  echo \"Install lynx or elinks, then run autogen.sh again\"\n   exit 1\n fi\n \n','true','true','none'),('irssi','1.0.4','d971c0292082823182f333a412207a9a8f6ad008','LemonBoy','allow the user to clear the sasl-related fields\n\nthere was no easy way for the user to disable the sasl authentication or\nto clear the username/password once the network was created.\ncloses #718','network.in','53','0','1','0','MODIFY','@@ -36,6 +36,7 @@\n     -sasl_mechanism  Specifies the mechanism to use for the SASL authentication.\n                      At the moment irssi only supports the \'plain\' and the\n                      \'external\' mechanisms.\n+                     Use \'\' to disable the authentication.\n     -sasl_username   Specifies the username to use during the SASL authentication.\n     -sasl_password   Specifies the password to use during the SASL authentication.\n \n','false','false','none'),('irssi','1.0.4','d971c0292082823182f333a412207a9a8f6ad008','LemonBoy','allow the user to clear the sasl-related fields\n\nthere was no easy way for the user to disable the sasl authentication or\nto clear the username/password once the network was created.\ncloses #718','fe-ircnet.c','186','68','3','3','MODIFY','@@ -163,11 +163,11 @@ static void cmd_network_add_modify(const char *data, gboolean add)\n \n 	/* the validity of the parameters is checked in sig_server_setup_fill_chatnet */\n 	value = g_hash_table_lookup(optlist, \"sasl_mechanism\");\n-	if (value != NULL && *value != \'\\0\') rec->sasl_mechanism = g_strdup(value);\n+	if (value != NULL) rec->sasl_mechanism = *value != \'\\0\' ? g_strdup(value) : NULL;\n 	value = g_hash_table_lookup(optlist, \"sasl_username\");\n-	if (value != NULL && *value != \'\\0\') rec->sasl_username = g_strdup(value);\n+	if (value != NULL) rec->sasl_username = *value != \'\\0\' ? g_strdup(value) : NULL;\n 	value = g_hash_table_lookup(optlist, \"sasl_password\");\n-	if (value != NULL && *value != \'\\0\') rec->sasl_password = g_strdup(value);\n+	if (value != NULL) rec->sasl_password = *value != \'\\0\' ? g_strdup(value) : NULL;\n \n 	ircnet_create(rec);\n 	printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, IRCTXT_NETWORK_ADDED, name);\n','false','false','none'),('irssi','1.0.4','d971c0292082823182f333a412207a9a8f6ad008','LemonBoy','allow the user to clear the sasl-related fields\n\nthere was no easy way for the user to disable the sasl authentication or\nto clear the username/password once the network was created.\ncloses #718','irc-servers-setup.c','146','52','3','3','MODIFY','@@ -89,6 +89,8 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n \n 	/* Validate the SASL parameters filled by sig_chatnet_read() or cmd_network_add */\n 	conn->sasl_mechanism = SASL_MECHANISM_NONE;\n+	conn->sasl_username = NULL;\n+	conn->sasl_password = NULL;\n \n 	if (ircnet->sasl_mechanism != NULL) {\n 		if (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"plain\")) {\n@@ -102,9 +104,7 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n 				g_warning(\"The fields sasl_username and sasl_password are either missing or empty\");\n 		}\n 		else if (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"external\")) {\n-				conn->sasl_mechanism = SASL_MECHANISM_EXTERNAL;\n-				conn->sasl_username = NULL;\n-				conn->sasl_password = NULL;\n+			conn->sasl_mechanism = SASL_MECHANISM_EXTERNAL;\n 		}\n 		else\n 			g_warning(\"Unsupported SASL mechanism \\\"%s\\\" selected\", ircnet->sasl_mechanism);\n','false','false','none'),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','don\'t compute log_dir_create_mode in three different places.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.c','441','97','2','3','MODIFY','@@ -33,6 +33,8 @@\n #define DEFAULT_LOG_FILE_CREATE_MODE 600\n \n GSList *logs;\n+int log_file_create_mode;\n+int log_dir_create_mode;\n \n static const char *log_item_types[] = {\n 	\"target\",\n@@ -42,8 +44,6 @@ static const char *log_item_types[] = {\n };\n \n static char *log_timestamp;\n-static int log_file_create_mode;\n-static int log_dir_create_mode;\n static int rotate_tag;\n \n static int log_item_str2type(const char *type)\n@@ -562,7 +562,6 @@ static void read_settings(void)\n 	log_timestamp = g_strdup(settings_get_str(\"log_timestamp\"));\n \n 	log_file_create_mode = octal2dec(settings_get_int(\"log_create_mode\"));\n-\n 	log_dir_create_mode = log_file_create_mode;\n 	if (log_file_create_mode & 0400) log_dir_create_mode |= 0100;\n 	if (log_file_create_mode & 0040) log_dir_create_mode |= 0010;\n','false','false','none'),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','don\'t compute log_dir_create_mode in three different places.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.h','44','0','2','0','MODIFY','@@ -35,6 +35,8 @@ struct _LOG_REC {\n };\n \n extern GSList *logs;\n+extern int log_file_create_mode;\n+extern int log_dir_create_mode;\n \n /* Create log record - you still need to call log_update() to actually add it\n    into log list */\n','false','false','none'),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','don\'t compute log_dir_create_mode in three different places.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','169','37','1','8','MODIFY','@@ -20,6 +20,7 @@\n \n #include \"module.h\"\n #include \"rawlog.h\"\n+#include \"log.h\"\n #include \"modules.h\"\n #include \"signals.h\"\n #include \"commands.h\"\n@@ -31,8 +32,6 @@\n \n static int rawlog_lines;\n static int signal_rawlog;\n-static int log_file_create_mode;\n-static int log_dir_create_mode;\n \n RAWLOG_REC *rawlog_create(void)\n {\n@@ -174,12 +173,6 @@ void rawlog_set_size(int lines)\n static void read_settings(void)\n {\n 	rawlog_set_size(settings_get_int(\"rawlog_lines\"));\n-	log_file_create_mode = octal2dec(settings_get_int(\"log_create_mode\"));\n-        log_dir_create_mode = log_file_create_mode;\n-        if (log_file_create_mode & 0400) log_dir_create_mode |= 0100;\n-        if (log_file_create_mode & 0040) log_dir_create_mode |= 0010;\n-        if (log_file_create_mode & 0004) log_dir_create_mode |= 0001;\n-\n }\n \n static void cmd_rawlog(const char *data, SERVER_REC *server, void *item)\n','false','false','none'),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','don\'t compute log_dir_create_mode in three different places.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-log.c','583','148','0','9','MODIFY','@@ -49,8 +49,6 @@ static THEME_REC *log_theme;\n static int skip_next_printtext;\n static char *log_theme_name;\n \n-static int log_dir_create_mode;\n-\n static char **autolog_ignore_targets;\n \n static char *log_colorizer_strip(const char *str)\n@@ -676,7 +674,6 @@ static void sig_theme_destroyed(THEME_REC *theme)\n static void read_settings(void)\n {\n 	int old_autolog = autolog_level;\n-	int log_file_create_mode;\n \n 	g_free_not_null(autolog_path);\n 	autolog_path = g_strdup(settings_get_str(\"autolog_path\"));\n@@ -704,12 +701,6 @@ static void read_settings(void)\n 	log_theme = log_theme_name == NULL ? NULL :\n 		theme_load(log_theme_name);\n \n-	log_file_create_mode = octal2dec(settings_get_int(\"log_create_mode\"));\n-        log_dir_create_mode = log_file_create_mode;\n-        if (log_file_create_mode & 0400) log_dir_create_mode |= 0100;\n-        if (log_file_create_mode & 0040) log_dir_create_mode |= 0010;\n-        if (log_file_create_mode & 0004) log_dir_create_mode |= 0001;\n-\n 	if (autolog_ignore_targets != NULL)\n 		g_strfreev(autolog_ignore_targets);\n \n','false','false','none'),('irssi','1.0.4','42b5e89f6e9fba17111f67441e25db38a737a3bd','Edward Tomasz Napierala','add missing diagnostics for rawlog open().\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','172','38','3','0','MODIFY','@@ -128,6 +128,9 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)\n 	path = convert_home(fname);\n 	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT,\n 			      log_file_create_mode);\n+	if (rawlog->handle == -1) {\n+		g_warning(\"rawlog open() failed: %s\", strerror(errno));\n+	}\n 	g_free(path);\n \n 	rawlog_dump(rawlog, rawlog->handle);\n','false','false','none'),('irssi','1.0.4','08dc6734b90389c357c73544023ec614e43b0860','Edward Tomasz Napierala','when rawlog open fails, there\'s no point in trying to write.  don\'t.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','173','38','4','2','MODIFY','@@ -128,13 +128,15 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)\n 	path = convert_home(fname);\n 	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT,\n 			      log_file_create_mode);\n+	g_free(path);\n+\n 	if (rawlog->handle == -1) {\n 		g_warning(\"rawlog open() failed: %s\", strerror(errno));\n+		return;\n 	}\n-	g_free(path);\n \n 	rawlog_dump(rawlog, rawlog->handle);\n-	rawlog->logging = rawlog->handle != -1;\n+	rawlog->logging = TRUE;\n }\n \n void rawlog_close(RAWLOG_REC *rawlog)\n','false','false','none'),('irssi','1.0.4','2914498b291ea0ca432a320004aa3d2499e50eb5','Edward Tomasz Napierala','consistency: use false instead of 0.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','173','38','1','1','MODIFY','@@ -144,7 +144,7 @@ void rawlog_close(RAWLOG_REC *rawlog)\n 	if (rawlog->logging) {\n 		write_buffer_flush();\n 		close(rawlog->handle);\n-		rawlog->logging = 0;\n+		rawlog->logging = FALSE;\n 	}\n }\n \n','false','false','none'),('irssi','1.0.4','2907a82b446d9d0a25157aa4ab560b49853f80d2','Edward Tomasz Napierala','fix vertical alignment in ./configure --help output.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','configure.ac','671','4','1','1','MODIFY','@@ -158,7 +158,7 @@ AC_ARG_ENABLE(true-color,\n 	want_truecolor=no)\n \n AC_ARG_ENABLE(gregex,\n-[  --disable-gregex     Build without GRegex (fall back to regex.h)],\n+[  --disable-gregex        Build without GRegex (fall back to regex.h)],\n 	if test x$enableval = xno ; then\n 		want_gregex=no\n 	else\n','true','false','none'),('irssi','1.0.4','f468008b25c7218a03cc0b327082d4d69d5481ef','Edward Tomasz Napierala','make autotools detect capsicum.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','configure.ac','692','4','22','0','MODIFY','@@ -166,6 +166,15 @@ AC_ARG_ENABLE(gregex,\n 	fi,\n 	want_gregex=yes)\n \n+AC_ARG_WITH(capsicum,\n+[  --with-capsicum            Build with Capsicum support],\n+	if test x$withval = xno; then\n+		want_capsicum=no\n+	else\n+		want_capsicum=yes\n+	fi,\n+	want_capsicum=yes)\n+\n dnl **\n dnl ** just some generic stuff...\n dnl **\n@@ -499,6 +508,18 @@ if test \"$want_perl\" != \"no\"; then\n 	fi\n fi\n \n+dnl **\n+dnl ** check for capsicum\n+dnl **\n+\n+if test \"x$want_capsicum\" = \"xyes\"; then\n+	AC_CHECK_LIB(c, cap_enter, [\n+		AC_DEFINE(HAVE_CAPSICUM,, Build with Capsicum support)\n+	], [\n+		want_capsicum=\"no, cap_enter not found\"\n+	])\n+fi\n+\n dnl ** check what we want to build\n AM_CONDITIONAL(BUILD_TEXTUI, test \"$want_textui\" = \"yes\")\n AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\")\n@@ -713,6 +734,7 @@ echo\n echo \"Building with 64bit DCC support .. : $offt_64bit\"\n echo \"Building with true color support.. : $want_truecolor\"\n echo \"Building with GRegex ............. : $want_gregex\"\n+echo \"Building with Capsicum ........... : $want_capsicum\"\n \n echo\n echo \"If there are any problems, read the INSTALL file.\"\n','false','false','none'),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','implement /cap_enter.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','configure.ac','693','4','2','1','MODIFY','@@ -167,7 +167,7 @@ AC_ARG_ENABLE(gregex,\n 	want_gregex=yes)\n \n AC_ARG_WITH(capsicum,\n-[  --with-capsicum            Build with Capsicum support],\n+[  --with-capsicum         Build with Capsicum support],\n 	if test x$withval = xno; then\n 		want_capsicum=no\n 	else\n@@ -526,6 +526,7 @@ AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\")\n AM_CONDITIONAL(BUILD_IRSSIFUZZER, test \"$want_irssifuzzer\" = \"yes\")\n AM_CONDITIONAL(BUILD_IRSSIPROXY, test \"$want_irssiproxy\" = \"yes\")\n AM_CONDITIONAL(HAVE_PERL, test \"$want_perl\" != \"no\")\n+AM_CONDITIONAL(HAVE_CAPSICUM, test \"x$want_capsicum\" = \"xyes\")\n AM_CONDITIONAL(USE_GREGEX, test \"x$want_gregex\" = \"xyes\")\n \n # move LIBS to PROG_LIBS so they\'re not tried to be used when linking eg. perl libraries\n','false','false','none'),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','implement /cap_enter.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','Makefile.am','110','0','5','0','MODIFY','@@ -56,6 +56,11 @@ libcore_a_SOURCES = \\\n 	tls.c \\\n 	write-buffer.c\n \n+if HAVE_CAPSICUM\n+libcore_a_SOURCES += \\\n+	capsicum.c\n+endif\n+\n structure_headers = \\\n 	channel-rec.h \\\n 	channel-setup-rec.h \\\n','false','false','none'),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','implement /cap_enter.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','20','4','46','0','ADD','@@ -0,0 +1,46 @@\n+/*\n+ capsicum.c : Capsicum sandboxing support\n+\n+    Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org>\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+*/\n+\n+#include \"module.h\"\n+#include \"signals.h\"\n+#include \"commands.h\"\n+\n+#include <sys/capsicum.h>\n+#include <string.h>\n+\n+static void cmd_cap_enter(void)\n+{\n+	int error;\n+\n+	error = cap_enter();\n+	if (error != 0)\n+		g_error(\"cap_enter(2) failed: %s\", strerror(errno));\n+}\n+\n+void capsicum_init(void)\n+{\n+\n+	command_bind(\"cap_enter\", NULL, (SIGNAL_FUNC) cmd_cap_enter);\n+}\n+\n+void capsicum_deinit(void)\n+{\n+	command_unbind(\"cap_enter\", (SIGNAL_FUNC) cmd_cap_enter);\n+}\n','false','true','none'),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','implement /cap_enter.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.h','2','0','7','0','ADD','@@ -0,0 +1,7 @@\n+#ifndef __CAPSICUM_H\n+#define __CAPSICUM_H\n+\n+void capsicum_init(void);\n+void capsicum_deinit(void);\n+\n+#endif\n','false','false','none'),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','implement /cap_enter.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','core.c','224','24','3','0','MODIFY','@@ -29,6 +29,7 @@\n #include \"signals.h\"\n #include \"settings.h\"\n #include \"session.h\"\n+#include \"capsicum.h\"\n \n #include \"chat-protocols.h\"\n #include \"servers.h\"\n@@ -235,6 +236,7 @@ void core_init(void)\n 	commands_init();\n 	nickmatch_cache_init();\n         session_init();\n+	capsicum_init();\n \n 	chat_protocols_init();\n 	chatnets_init();\n@@ -292,6 +294,7 @@ void core_deinit(void)\n 	chatnets_deinit();\n 	chat_protocols_deinit();\n \n+	capsicum_deinit();\n         session_deinit();\n         nickmatch_cache_deinit();\n 	commands_deinit();\n','false','false','none'),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','add capability mode error/success messages.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','38','7','22','2','MODIFY','@@ -30,17 +30,37 @@ static void cmd_cap_enter(void)\n 	int error;\n \n 	error = cap_enter();\n-	if (error != 0)\n-		g_error(\"cap_enter(2) failed: %s\", strerror(errno));\n+	if (error != 0) {\n+		signal_emit(\"capability mode failed\", 1, strerror(errno));\n+	} else {\n+		signal_emit(\"capability mode enabled\", 0);\n+	}\n+}\n+\n+static void cmd_cap_getmode(void)\n+{\n+	u_int mode;\n+	int error;\n+\n+	error = cap_getmode(&mode);\n+	if (error != 0) {\n+		signal_emit(\"capability mode failed\", 1, strerror(errno));\n+	} else if (mode == 0) {\n+		signal_emit(\"capability mode disabled\", 0);\n+	} else {\n+		signal_emit(\"capability mode enabled\", 0);\n+	}\n }\n \n void capsicum_init(void)\n {\n \n 	command_bind(\"cap_enter\", NULL, (SIGNAL_FUNC) cmd_cap_enter);\n+	command_bind(\"cap_getmode\", NULL, (SIGNAL_FUNC) cmd_cap_getmode);\n }\n \n void capsicum_deinit(void)\n {\n 	command_unbind(\"cap_enter\", (SIGNAL_FUNC) cmd_cap_enter);\n+	command_unbind(\"cap_getmode\", (SIGNAL_FUNC) cmd_cap_getmode);\n }\n','true','false','none'),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','add capability mode error/success messages.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','Makefile.am','65','0','5','0','MODIFY','@@ -38,6 +38,11 @@ libfe_common_core_a_SOURCES = \\\n 	windows-layout.c \\\n 	fe-windows.c\n \n+if HAVE_CAPSICUM\n+libfe_common_core_a_SOURCES += \\\n+	fe-capsicum.c\n+endif\n+\n pkginc_fe_common_coredir=$(pkgincludedir)/src/fe-common/core\n pkginc_fe_common_core_HEADERS = \\\n 	command-history.h \\\n','true','false','none'),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','add capability mode error/success messages.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-capsicum.c','30','5','60','0','ADD','@@ -0,0 +1,60 @@\n+/*\n+ fe-capsicum.c : irssi\n+\n+    Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org>\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+*/\n+\n+#include \"module.h\"\n+#include \"module-formats.h\"\n+#include \"signals.h\"\n+#include \"printtext.h\"\n+\n+#include \"levels.h\"\n+#include \"servers.h\"\n+\n+static void capability_mode_enabled(void)\n+{\n+\n+	printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_CAPSICUM_ENABLED);\n+}\n+\n+static void capability_mode_disabled(void)\n+{\n+\n+	printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_CAPSICUM_DISABLED);\n+}\n+\n+static void capability_mode_failed(gchar *msg)\n+{\n+\n+	printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_CAPSICUM_FAILED, msg);\n+}\n+\n+void fe_capsicum_init(void)\n+{\n+\n+	signal_add(\"capability mode enabled\", (SIGNAL_FUNC) capability_mode_enabled);\n+	signal_add(\"capability mode disabled\", (SIGNAL_FUNC) capability_mode_disabled);\n+	signal_add(\"capability mode failed\", (SIGNAL_FUNC) capability_mode_failed);\n+}\n+\n+void fe_capsicum_deinit(void)\n+{\n+	signal_remove(\"capability mode enabled\", (SIGNAL_FUNC) capability_mode_enabled);\n+	signal_remove(\"capability mode disabled\", (SIGNAL_FUNC) capability_mode_disabled);\n+	signal_remove(\"capability mode failed\", (SIGNAL_FUNC) capability_mode_failed);\n+}\n','true','false','none'),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','add capability mode error/success messages.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-capsicum.h','2','0','7','0','ADD','@@ -0,0 +1,7 @@\n+#ifndef __FE_CAPSICUM_H\n+#define __FE_CAPSICUM_H\n+\n+void fe_capsicum_init(void);\n+void fe_capsicum_deinit(void);\n+\n+#endif\n','true','false','none'),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','add capability mode error/success messages.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-common-core.c','377','52','3','0','MODIFY','@@ -32,6 +32,7 @@\n #include \"special-vars.h\"\n #include \"fe-core-commands.h\"\n #include \"fe-queries.h\"\n+#include \"fe-capsicum.h\"\n #include \"hilight-text.h\"\n #include \"command-history.h\"\n #include \"completion.h\"\n@@ -179,6 +180,7 @@ void fe_common_core_init(void)\n 	fe_server_init();\n 	fe_settings_init();\n 	fe_tls_init();\n+	fe_capsicum_init();\n 	windows_init();\n 	window_activity_init();\n 	window_commands_init();\n@@ -221,6 +223,7 @@ void fe_common_core_deinit(void)\n 	fe_server_deinit();\n 	fe_settings_deinit();\n 	fe_tls_deinit();\n+	fe_capsicum_deinit();\n 	windows_deinit();\n 	window_activity_deinit();\n 	window_commands_deinit();\n','true','false','none'),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','add capability mode error/success messages.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','module-formats.c','244','0','3','0','MODIFY','@@ -290,6 +290,9 @@ FORMAT_REC fecommon_core_formats[] = {\n 	{ \"completion_header\", \"%#Key        Value                                    Auto\", 0 },\n 	{ \"completion_line\", \"%#$[10]0 $[!40]1 $2\", 3, { 0, 0, 0 } },\n 	{ \"completion_footer\", \"\", 0 },\n+	{ \"capsicum_enabled\", \"Capability mode enabled\", 0 },\n+	{ \"capsicum_disabled\", \"Capability mode not enabled\", 0 },\n+	{ \"capsicum_failed\", \"Capability mode failed: $0\", 1, { 0 } },\n \n 	/* ---- */\n 	{ NULL, \"TLS\", 0 },\n','true','false','none'),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','add capability mode error/success messages.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','module-formats.h','243','0','3','0','MODIFY','@@ -255,6 +255,9 @@ enum {\n 	TXT_COMPLETION_HEADER,\n         TXT_COMPLETION_LINE,\n 	TXT_COMPLETION_FOOTER,\n+	TXT_CAPSICUM_ENABLED,\n+	TXT_CAPSICUM_DISABLED,\n+	TXT_CAPSICUM_FAILED,\n \n 	TLS_FILL_15,\n \n','true','false','none'),('irssi','1.0.4','3200c381dbcb02e99c7667bd955c90ee859d15a0','Edward Tomasz Napierala','rename to \"/capability enter\" and \"/capability status\".\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','44','8','13','6','MODIFY','@@ -25,7 +25,12 @@\n #include <sys/capsicum.h>\n #include <string.h>\n \n-static void cmd_cap_enter(void)\n+static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n+{\n+	command_runsub(\"capsicum\", data, server, item);\n+}\n+\n+static void cmd_capsicum_enter(void)\n {\n 	int error;\n \n@@ -37,7 +42,7 @@ static void cmd_cap_enter(void)\n 	}\n }\n \n-static void cmd_cap_getmode(void)\n+static void cmd_capsicum_status(void)\n {\n 	u_int mode;\n 	int error;\n@@ -55,12 +60,14 @@ static void cmd_cap_getmode(void)\n void capsicum_init(void)\n {\n \n-	command_bind(\"cap_enter\", NULL, (SIGNAL_FUNC) cmd_cap_enter);\n-	command_bind(\"cap_getmode\", NULL, (SIGNAL_FUNC) cmd_cap_getmode);\n+	command_bind(\"capsicum\", NULL, (SIGNAL_FUNC) cmd_capsicum);\n+	command_bind(\"capsicum enter\", NULL, (SIGNAL_FUNC) cmd_capsicum_enter);\n+	command_bind(\"capsicum status\", NULL, (SIGNAL_FUNC) cmd_capsicum_status);\n }\n \n void capsicum_deinit(void)\n {\n-	command_unbind(\"cap_enter\", (SIGNAL_FUNC) cmd_cap_enter);\n-	command_unbind(\"cap_getmode\", (SIGNAL_FUNC) cmd_cap_getmode);\n+	command_unbind(\"capsicum\", (SIGNAL_FUNC) cmd_capsicum);\n+	command_unbind(\"capsicum enter\", (SIGNAL_FUNC) cmd_capsicum_enter);\n+	command_unbind(\"capsicum status\", (SIGNAL_FUNC) cmd_capsicum_status);\n }\n','false','false','none'),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with ip addresses.','configure.ac','698','4','6','1','MODIFY','@@ -514,7 +514,12 @@ dnl **\n \n if test \"x$want_capsicum\" = \"xyes\"; then\n 	AC_CHECK_LIB(c, cap_enter, [\n-		AC_DEFINE(HAVE_CAPSICUM,, Build with Capsicum support)\n+		AC_CHECK_LIB(nv, nvlist_create, [\n+			AC_DEFINE(HAVE_CAPSICUM,, Build with Capsicum support)\n+			LIBS=\"$LIBS -lnv\"\n+		], [\n+			want_capsicum=\"no, nvlist_create not found\"\n+		])\n 	], [\n 		want_capsicum=\"no, cap_enter not found\"\n 	])\n','false','false','none'),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with ip addresses.','capsicum.c','145','26','126','0','MODIFY','@@ -19,21 +19,147 @@\n */\n \n #include \"module.h\"\n+#include \"network.h\"\n #include \"signals.h\"\n #include \"commands.h\"\n \n+#include <sys/types.h>\n #include <sys/capsicum.h>\n+#include <sys/nv.h>\n+#include <sys/procdesc.h>\n+#include <sys/socket.h>\n #include <string.h>\n \n+static int symbiontfds[2];\n+\n+gboolean capsicum_enabled(void)\n+{\n+	u_int mode;\n+	int error;\n+\n+	error = cap_getmode(&mode);\n+	if (error != 0)\n+		return FALSE;\n+\n+	if (mode == 0)\n+		return FALSE;\n+\n+	return TRUE;\n+}\n+\n+int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n+{\n+	nvlist_t *nvl;\n+	int error, saved_errno, sock;\n+\n+	/* Send request to the symbiont. */\n+	nvl = nvlist_create(0);\n+	nvlist_add_binary(nvl, \"ip\", ip, sizeof(*ip));\n+	nvlist_add_number(nvl, \"port\", port);\n+	if (my_ip != NULL) {\n+		/* nvlist_add_binary(3) can\'t handle NULL values. */\n+		nvlist_add_binary(nvl, \"my_ip\", my_ip, sizeof(*my_ip));\n+	}\n+	error = nvlist_send(symbiontfds[1], nvl);\n+	nvlist_destroy(nvl);\n+	if (error != 0) {\n+		g_warning(\"nvlist_send: %s\", strerror(errno));\n+		return -1;\n+	}\n+\n+	/* Receive response. */\n+	nvl = nvlist_recv(symbiontfds[1], 0);\n+	if (nvl == NULL) {\n+		g_warning(\"nvlist_recv: %s\", strerror(errno));\n+		return -1;\n+	}\n+	if (nvlist_exists_descriptor(nvl, \"sock\")) {\n+		sock = nvlist_take_descriptor(nvl, \"sock\");\n+	} else {\n+		sock = -1;\n+	}\n+	saved_errno = nvlist_get_number(nvl, \"errno\");\n+	nvlist_destroy(nvl);\n+	errno = saved_errno;\n+\n+	return sock;\n+}\n+\n static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n {\n 	command_runsub(\"capsicum\", data, server, item);\n }\n \n+static int start_symbiont(void)\n+{\n+	pid_t pid;\n+	nvlist_t *nvl;\n+	IPADDR *ip, *my_ip;\n+	int childfd, error, port, saved_errno, sock;\n+\n+	error = socketpair(PF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, symbiontfds);\n+	if (error != 0) {\n+		g_warning(\"socketpair: %s\", strerror(errno));\n+		return 1;\n+	}\n+\n+	pid = pdfork(&childfd, PD_CLOEXEC);\n+	if (pid < 0) {\n+		g_warning(\"pdfork: %s\", strerror(errno));\n+		return 1;\n+	}\n+\n+	if (pid > 0) {\n+		close(symbiontfds[0]);\n+		return 0;\n+	}\n+\n+	/* We\'re the child, running outside the Capsicum sandbox. */\n+	setproctitle(\"capsicum symbiont\");\n+	close(symbiontfds[1]);\n+	close(0);\n+	close(1);\n+	close(2);\n+	for (;;) {\n+		/* Receive parameters from the main irssi process. */\n+		nvl = nvlist_recv(symbiontfds[0], 0);\n+		if (nvl == NULL)\n+			exit(1);\n+		ip = nvlist_get_binary(nvl, \"ip\", NULL);\n+		port = (int)nvlist_get_number(nvl, \"port\");\n+		if (nvlist_exists(nvl, \"my_ip\"))\n+			my_ip = nvlist_get_binary(nvl, \"my_ip\", NULL);\n+		else\n+			my_ip = NULL;\n+\n+		/* Connect. */\n+		sock = net_connect_ip_handle(ip, port, my_ip);\n+		saved_errno = errno;\n+\n+		/* Send back the socket fd. */\n+		nvlist_destroy(nvl);\n+		nvl = nvlist_create(0);\n+\n+		if (sock != -1)\n+			nvlist_move_descriptor(nvl, \"sock\", sock);\n+		nvlist_add_number(nvl, \"errno\", saved_errno);\n+		error = nvlist_send(symbiontfds[0], nvl);\n+		if (error != 0)\n+			exit(1);\n+		nvlist_destroy(nvl);\n+	}\n+}\n+\n static void cmd_capsicum_enter(void)\n {\n 	int error;\n \n+	error = start_symbiont();\n+	if (error != 0) {\n+		signal_emit(\"capability mode failed\", 1, strerror(errno));\n+		return;\n+	}\n+\n 	error = cap_enter();\n 	if (error != 0) {\n 		signal_emit(\"capability mode failed\", 1, strerror(errno));\n','false','false','none'),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with ip addresses.','capsicum.h','4','0','3','0','MODIFY','@@ -1,6 +1,9 @@\n #ifndef __CAPSICUM_H\n #define __CAPSICUM_H\n \n+gboolean capsicum_enabled(void);\n+int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);\n+\n void capsicum_init(void);\n void capsicum_deinit(void);\n \n','false','false','none'),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with ip addresses.','network.c','388','102','28','5','MODIFY','@@ -20,6 +20,9 @@\n \n #include \"module.h\"\n #include \"network.h\"\n+#ifdef HAVE_CAPSICUM\n+#include \"capsicum.h\"\n+#endif\n \n #include <sys/un.h>\n \n@@ -144,8 +147,7 @@ GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip)\n 	return net_connect_ip(ip, port, my_ip);\n }\n \n-/* Connect to socket with ip address */\n-GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n+int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip)\n {\n 	union sockaddr_union so;\n 	int handle, ret, opt = 1;\n@@ -161,7 +163,7 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n 	handle = socket(ip->family, SOCK_STREAM, 0);\n \n 	if (handle == -1)\n-		return NULL;\n+		return -1;\n \n 	/* set socket options */\n 	fcntl(handle, F_SETFL, O_NONBLOCK);\n@@ -176,7 +178,7 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n \n 			close(handle);\n 			errno = old_errno;\n-			return NULL;\n+			return -1;\n 		}\n 	}\n \n@@ -190,9 +192,30 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n 		int old_errno = errno;\n 		close(handle);\n 		errno = old_errno;\n-		return NULL;\n+		return -1;\n 	}\n \n+	return handle;\n+}\n+\n+\n+/* Connect to socket with ip address */\n+GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n+{\n+	int handle = -1;\n+\n+#ifdef HAVE_CAPSICUM\n+	if (capsicum_enabled())\n+		handle = capsicum_net_connect_ip(ip, port, my_ip);\n+	else\n+		handle = net_connect_ip_handle(ip, port, my_ip);\n+#else\n+	handle = net_connect_ip_handle(ip, port, my_ip);\n+#endif\n+\n+	if (handle == -1)\n+		return (NULL);\n+\n 	return g_io_channel_new(handle);\n }\n \n','false','true','have_capsicum'),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with ip addresses.','network.h','36','0','2','0','MODIFY','@@ -36,6 +36,8 @@ GIOChannel *g_io_channel_new(int handle);\n /* returns 1 if IPADDRs are the same */\n int net_ip_compare(IPADDR *ip1, IPADDR *ip2);\n \n+int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip);\n+\n /* Connect to socket */\n GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED;\n /* Connect to socket with ip address and SSL*/\n','false','true','none'),('irssi','1.0.4','925240155e5c0c20569bcb5fafe4d3047055768a','Edward Tomasz Napierala','config file support for \"capsicum\" parameter.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','154','28','13','1','MODIFY','@@ -19,9 +19,10 @@\n */\n \n #include \"module.h\"\n+#include \"commands.h\"\n #include \"network.h\"\n+#include \"settings.h\"\n #include \"signals.h\"\n-#include \"commands.h\"\n \n #include <sys/types.h>\n #include <sys/capsicum.h>\n@@ -183,8 +184,17 @@ static void cmd_capsicum_status(void)\n 	}\n }\n \n+void sig_init_finished(void)\n+{\n+	if (settings_get_bool(\"capsicum\"))\n+		cmd_capsicum_enter();\n+}\n+\n void capsicum_init(void)\n {\n+	settings_add_bool(\"misc\", \"capsicum\", FALSE);\n+\n+	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n \n 	command_bind(\"capsicum\", NULL, (SIGNAL_FUNC) cmd_capsicum);\n 	command_bind(\"capsicum enter\", NULL, (SIGNAL_FUNC) cmd_capsicum_enter);\n@@ -193,6 +203,8 @@ void capsicum_init(void)\n \n void capsicum_deinit(void)\n {\n+	signal_remove(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n+\n 	command_unbind(\"capsicum\", (SIGNAL_FUNC) cmd_capsicum);\n 	command_unbind(\"capsicum enter\", (SIGNAL_FUNC) cmd_capsicum_enter);\n 	command_unbind(\"capsicum status\", (SIGNAL_FUNC) cmd_capsicum_status);\n','false','false','none'),('irssi','1.0.4','f4546be7ecb8a0801fb0d30415586c15d721494a','Edward Tomasz Napierala','reorder functions.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','154','28','5','5','MODIFY','@@ -86,11 +86,6 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n 	return sock;\n }\n \n-static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n-{\n-	command_runsub(\"capsicum\", data, server, item);\n-}\n-\n static int start_symbiont(void)\n {\n 	pid_t pid;\n@@ -151,6 +146,11 @@ static int start_symbiont(void)\n 	}\n }\n \n+static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n+{\n+	command_runsub(\"capsicum\", data, server, item);\n+}\n+\n static void cmd_capsicum_enter(void)\n {\n 	int error;\n','false','false','none'),('irssi','1.0.4','509eca76f0755e94b5981f464f9f9a882499180a','Edward Tomasz Napierala','make dns work in capability mode.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','222','36','136','37','MODIFY','@@ -31,6 +31,9 @@\n #include <sys/socket.h>\n #include <string.h>\n \n+#define	OPCODE_CONNECT		1\n+#define	OPCODE_GETHOSTBYNAME	2\n+\n static int symbiontfds[2];\n \n gboolean capsicum_enabled(void)\n@@ -55,6 +58,7 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n \n 	/* Send request to the symbiont. */\n 	nvl = nvlist_create(0);\n+	nvlist_add_number(nvl, \"opcode\", OPCODE_CONNECT);\n 	nvlist_add_binary(nvl, \"ip\", ip, sizeof(*ip));\n 	nvlist_add_number(nvl, \"port\", port);\n 	if (my_ip != NULL) {\n@@ -86,12 +90,139 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n 	return sock;\n }\n \n-static int start_symbiont(void)\n+int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)\n {\n-	pid_t pid;\n 	nvlist_t *nvl;\n+	IPADDR *received_ip4, *received_ip6;\n+	int error, ret, saved_errno;\n+\n+	/* Send request to the symbiont. */\n+	nvl = nvlist_create(0);\n+	nvlist_add_number(nvl, \"opcode\", OPCODE_GETHOSTBYNAME);\n+	nvlist_add_string(nvl, \"addr\", addr);\n+	error = nvlist_send(symbiontfds[1], nvl);\n+	nvlist_destroy(nvl);\n+	if (error != 0) {\n+		g_warning(\"nvlist_send: %s\", strerror(errno));\n+		return -1;\n+	}\n+\n+	/* Receive response. */\n+	nvl = nvlist_recv(symbiontfds[1], 0);\n+	if (nvl == NULL) {\n+		g_warning(\"nvlist_recv: %s\", strerror(errno));\n+		return -1;\n+	}\n+\n+	received_ip4 = nvlist_get_binary(nvl, \"ip4\", NULL);\n+	received_ip6 = nvlist_get_binary(nvl, \"ip6\", NULL);\n+	memcpy(ip4, received_ip4, sizeof(*ip4));\n+	memcpy(ip6, received_ip6, sizeof(*ip6));\n+\n+	ret = nvlist_get_number(nvl, \"ret\");\n+	saved_errno = nvlist_get_number(nvl, \"errno\");\n+	nvlist_destroy(nvl);\n+	errno = saved_errno;\n+\n+	return ret;\n+}\n+\n+nvlist_t *symbiont_connect(const nvlist_t *request)\n+{\n+	nvlist_t *response;\n 	IPADDR *ip, *my_ip;\n-	int childfd, error, port, saved_errno, sock;\n+	int port, saved_errno, sock;\n+\n+	ip = nvlist_get_binary(request, \"ip\", NULL);\n+	port = (int)nvlist_get_number(request, \"port\");\n+	if (nvlist_exists(request, \"my_ip\"))\n+		my_ip = nvlist_get_binary(request, \"my_ip\", NULL);\n+	else\n+		my_ip = NULL;\n+\n+	/* Connect. */\n+	sock = net_connect_ip_handle(ip, port, my_ip);\n+	saved_errno = errno;\n+\n+	/* Send back the socket fd. */\n+	response = nvlist_create(0);\n+\n+	if (sock != -1)\n+		nvlist_move_descriptor(response, \"sock\", sock);\n+	nvlist_add_number(response, \"errno\", saved_errno);\n+\n+	return (response);\n+}\n+\n+nvlist_t *symbiont_gethostbyname(const nvlist_t *request)\n+{\n+	nvlist_t *response;\n+	IPADDR ip4, ip6;\n+	const char *addr;\n+	int ret, saved_errno;\n+\n+	addr = nvlist_get_string(request, \"addr\");\n+\n+	/* Connect. */\n+	ret = net_gethostbyname(addr, &ip4, &ip6);\n+	saved_errno = errno;\n+\n+	/* Send back the IPs. */\n+	response = nvlist_create(0);\n+\n+	nvlist_add_number(response, \"ret\", ret);\n+	nvlist_add_number(response, \"errno\", saved_errno);\n+	nvlist_add_binary(response, \"ip4\", &ip4, sizeof(ip4));\n+	nvlist_add_binary(response, \"ip6\", &ip6, sizeof(ip6));\n+\n+	return (response);\n+}\n+\n+/*\n+ * Child process, running outside the Capsicum sandbox.\n+ */\n+_Noreturn static void symbiont(void)\n+{\n+	nvlist_t *request, *response;\n+	int error, opcode;\n+\n+	setproctitle(\"capsicum symbiont\");\n+	close(symbiontfds[1]);\n+	close(0);\n+	close(1);\n+	close(2);\n+\n+	for (;;) {\n+		/* Receive parameters from the main irssi process. */\n+		request = nvlist_recv(symbiontfds[0], 0);\n+		if (request == NULL)\n+			exit(1);\n+\n+		opcode = nvlist_get_number(request, \"opcode\");\n+		switch (opcode) {\n+		case OPCODE_CONNECT:\n+			response = symbiont_connect(request);\n+			break;\n+		case OPCODE_GETHOSTBYNAME:\n+			response = symbiont_gethostbyname(request);\n+			break;\n+		default:\n+			exit(1);\n+		}\n+\n+		/* Send back the response. */\n+		error = nvlist_send(symbiontfds[0], response);\n+		if (error != 0)\n+			exit(1);\n+		nvlist_destroy(request);\n+		nvlist_destroy(response);\n+	}\n+}\n+\n+static int start_symbiont(void)\n+{\n+	int childfd, error;\n+	pid_t pid;\n \n 	error = socketpair(PF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, symbiontfds);\n 	if (error != 0) {\n@@ -110,40 +241,8 @@ static int start_symbiont(void)\n 		return 0;\n 	}\n \n-	/* We\'re the child, running outside the Capsicum sandbox. */\n-	setproctitle(\"capsicum symbiont\");\n-	close(symbiontfds[1]);\n-	close(0);\n-	close(1);\n-	close(2);\n-	for (;;) {\n-		/* Receive parameters from the main irssi process. */\n-		nvl = nvlist_recv(symbiontfds[0], 0);\n-		if (nvl == NULL)\n-			exit(1);\n-		ip = nvlist_get_binary(nvl, \"ip\", NULL);\n-		port = (int)nvlist_get_number(nvl, \"port\");\n-		if (nvlist_exists(nvl, \"my_ip\"))\n-			my_ip = nvlist_get_binary(nvl, \"my_ip\", NULL);\n-		else\n-			my_ip = NULL;\n-\n-		/* Connect. */\n-		sock = net_connect_ip_handle(ip, port, my_ip);\n-		saved_errno = errno;\n-\n-		/* Send back the socket fd. */\n-		nvlist_destroy(nvl);\n-		nvl = nvlist_create(0);\n-\n-		if (sock != -1)\n-			nvlist_move_descriptor(nvl, \"sock\", sock);\n-		nvlist_add_number(nvl, \"errno\", saved_errno);\n-		error = nvlist_send(symbiontfds[0], nvl);\n-		if (error != 0)\n-			exit(1);\n-		nvlist_destroy(nvl);\n-	}\n+	symbiont();\n+	/* NOTREACHED */\n }\n \n static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n','false','true','none'),('irssi','1.0.4','509eca76f0755e94b5981f464f9f9a882499180a','Edward Tomasz Napierala','make dns work in capability mode.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.h','5','0','1','0','MODIFY','@@ -3,6 +3,7 @@\n \n gboolean capsicum_enabled(void);\n int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);\n+int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);\n \n void capsicum_init(void);\n void capsicum_deinit(void);\n','false','false','none'),('irssi','1.0.4','509eca76f0755e94b5981f464f9f9a882499180a','Edward Tomasz Napierala','make dns work in capability mode.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','network.c','390','104','5','0','MODIFY','@@ -406,6 +406,11 @@ int net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)\n 	struct addrinfo hints, *ai, *ailist;\n 	int ret, count_v4, count_v6, use_v4, use_v6;\n \n+#ifdef HAVE_CAPSICUM\n+	if (capsicum_enabled())\n+		return (capsicum_net_gethostbyname(addr, ip4, ip6));\n+#endif\n+\n 	g_return_val_if_fail(addr != NULL, -1);\n \n 	memset(ip4, 0, sizeof(IPADDR));\n','false','false','have_capsicum'),('irssi','1.0.4','1f57ceec4c4e7c3d42f341921e36fe4aab612e57','Edward Tomasz Napierala','prevent the user from calling \"/capsicum enter\" twice.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','228','38','7','0','MODIFY','@@ -252,8 +252,15 @@ static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n \n static void cmd_capsicum_enter(void)\n {\n+	u_int mode;\n 	int error;\n \n+	error = cap_getmode(&mode);\n+	if (error == 0 && mode != 0) {\n+		g_warning(\"Already in capability mode\");\n+		return;\n+	}\n+\n 	error = start_symbiont();\n 	if (error != 0) {\n 		signal_emit(\"capability mode failed\", 1, strerror(errno));\n','false','false','none'),('irssi','1.0.4','939371aa1dfdbf11fe98648e1eafc4c95e80bb9e','Edward Tomasz Napierala','fix warnings.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','228','38','2','2','MODIFY','@@ -93,7 +93,7 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)\n {\n 	nvlist_t *nvl;\n-	IPADDR *received_ip4, *received_ip6;\n+	const IPADDR *received_ip4, *received_ip6;\n 	int error, ret, saved_errno;\n \n 	/* Send request to the symbiont. */\n@@ -130,7 +130,7 @@ int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)\n nvlist_t *symbiont_connect(const nvlist_t *request)\n {\n 	nvlist_t *response;\n-	IPADDR *ip, *my_ip;\n+	const IPADDR *ip, *my_ip;\n 	int port, saved_errno, sock;\n \n 	ip = nvlist_get_binary(request, \"ip\", NULL);\n','true','false','none'),('irssi','1.0.4','939371aa1dfdbf11fe98648e1eafc4c95e80bb9e','Edward Tomasz Napierala','fix warnings.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','network.c','390','104','1','1','MODIFY','@@ -147,7 +147,7 @@ GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip)\n 	return net_connect_ip(ip, port, my_ip);\n }\n \n-int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip)\n+int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip)\n {\n 	union sockaddr_union so;\n 	int handle, ret, opt = 1;\n','true','false','none'),('irssi','1.0.4','939371aa1dfdbf11fe98648e1eafc4c95e80bb9e','Edward Tomasz Napierala','fix warnings.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','network.h','36','0','1','1','MODIFY','@@ -36,7 +36,7 @@ GIOChannel *g_io_channel_new(int handle);\n /* returns 1 if IPADDRs are the same */\n int net_ip_compare(IPADDR *ip1, IPADDR *ip2);\n \n-int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip);\n+int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);\n \n /* Connect to socket */\n GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED;\n','true','false','none'),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','working /log and /rawlog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','255','45','33','0','MODIFY','@@ -20,6 +20,8 @@\n \n #include \"module.h\"\n #include \"commands.h\"\n+#include \"log.h\"\n+#include \"misc.h\"\n #include \"network.h\"\n #include \"settings.h\"\n #include \"signals.h\"\n@@ -34,6 +36,9 @@\n #define	OPCODE_CONNECT		1\n #define	OPCODE_GETHOSTBYNAME	2\n \n+static char *irclogs_path;\n+static size_t irclogs_path_len;\n+static int irclogs_fd;\n static int symbiontfds[2];\n \n gboolean capsicum_enabled(void)\n@@ -127,6 +132,23 @@ int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)\n 	return ret;\n }\n \n+int capsicum_open(const char *path, int flags, int mode)\n+{\n+	int fd;\n+\n+	/* +1 is for slash separating irclogs_path and the rest. */\n+	if (strlen(path) > irclogs_path_len + 1 && strncmp(path, irclogs_path, irclogs_path_len) == 0) {\n+		fd = openat(irclogs_fd, path + irclogs_path_len + 1, flags, mode);\n+	} else {\n+		fd = open(path, flags, mode);\n+	}\n+\n+	if (fd < 0 && (errno == ENOTCAPABLE || errno == ECAPMODE))\n+		g_warning(\"File system access restricted to %s due to capability mode\", irclogs_path);\n+\n+	return (fd);\n+}\n+\n nvlist_t *symbiont_connect(const nvlist_t *request)\n {\n 	nvlist_t *response;\n@@ -261,6 +283,16 @@ static void cmd_capsicum_enter(void)\n 		return;\n 	}\n \n+	irclogs_path = convert_home(settings_get_str(\"capsicum_irclogs_path\"));\n+	g_mkdir_with_parents(irclogs_path, log_dir_create_mode);\n+	irclogs_path_len = strlen(irclogs_path);\n+	irclogs_fd = open(irclogs_path, O_DIRECTORY | O_CLOEXEC);\n+	if (irclogs_fd < 0) {\n+		g_warning(\"Unable to open %s: %s\", irclogs_path, strerror(errno));\n+		signal_emit(\"capability mode failed\", 1, strerror(errno));\n+		return;\n+	}\n+\n 	error = start_symbiont();\n 	if (error != 0) {\n 		signal_emit(\"capability mode failed\", 1, strerror(errno));\n@@ -299,6 +331,7 @@ void sig_init_finished(void)\n void capsicum_init(void)\n {\n 	settings_add_bool(\"misc\", \"capsicum\", FALSE);\n+	settings_add_str(\"misc\", \"capsicum_irclogs_path\", \"~/irclogs\");\n \n 	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n \n','false','true','none'),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','working /log and /rawlog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.h','6','0','1','0','MODIFY','@@ -4,6 +4,7 @@\n gboolean capsicum_enabled(void);\n int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);\n int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);\n+int capsicum_open(const char *path, int flags, int mode);\n \n void capsicum_init(void);\n void capsicum_deinit(void);\n','false','false','none'),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','working /log and /rawlog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.c','448','100','14','1','MODIFY','@@ -26,6 +26,9 @@\n #include \"servers.h\"\n #include \"log.h\"\n #include \"write-buffer.h\"\n+#ifdef HAVE_CAPSICUM\n+#include \"capsicum.h\"\n+#endif\n \n #include \"lib-config/iconfig.h\"\n #include \"settings.h\"\n@@ -73,6 +76,16 @@ static void log_write_timestamp(int handle, const char *format,\n 	if (text != NULL) write_buffer(handle, text, strlen(text));\n }\n \n+static int log_open_wrapper(const char *path, int flags, int mode)\n+{\n+#ifdef HAVE_CAPSICUM\n+	if (capsicum_enabled())\n+		return capsicum_open(path, flags, mode);\n+#endif\n+\n+	return open(path, flags, mode);\n+}\n+\n static char *log_filename(LOG_REC *log)\n {\n 	char *str, fname[1024];\n@@ -119,7 +132,7 @@ int log_start_logging(LOG_REC *log)\n 	}\n \n 	log->handle = log->real_fname == NULL ? -1 :\n-		open(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,\n+		log_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,\n 		     log_file_create_mode);\n 	if (log->handle == -1) {\n 		signal_emit(\"log create failed\", 1, log);\n','false','false','have_capsicum'),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','working /log and /rawlog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.h','45','0','2','0','MODIFY','@@ -38,6 +38,8 @@ extern GSList *logs;\n extern int log_file_create_mode;\n extern int log_dir_create_mode;\n \n+extern int log_dir_create_mode;\n+\n /* Create log record - you still need to call log_update() to actually add it\n    into log list */\n LOG_REC *log_create_rec(const char *fname, int level);\n','false','false','none'),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','working /log and /rawlog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','network.c','390','104','0','1','MODIFY','@@ -198,7 +198,6 @@ int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip)\n 	return handle;\n }\n \n-\n /* Connect to socket with ip address */\n GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n {\n','false','false','none'),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','working /log and /rawlog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','180','41','15','2','MODIFY','@@ -27,12 +27,25 @@\n #include \"misc.h\"\n #include \"write-buffer.h\"\n #include \"settings.h\"\n+#ifdef HAVE_CAPSICUM\n+#include \"capsicum.h\"\n+#endif\n \n #include \"servers.h\"\n \n static int rawlog_lines;\n static int signal_rawlog;\n \n+static int rawlog_open_wrapper(const char *path, int flags, int mode)\n+{\n+#ifdef HAVE_CAPSICUM\n+	if (capsicum_enabled())\n+		return capsicum_open(path, flags, mode);\n+#endif\n+\n+	return open(path, flags, mode);\n+}\n+\n RAWLOG_REC *rawlog_create(void)\n {\n 	RAWLOG_REC *rec;\n@@ -126,7 +139,7 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)\n 		return;\n \n 	path = convert_home(fname);\n-	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT,\n+	rawlog->handle = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT,\n 			      log_file_create_mode);\n 	g_free(path);\n \n@@ -158,7 +171,7 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)\n         g_free(dir);\n \n 	path = convert_home(fname);\n-	f = open(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode);\n+	f = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode);\n 	g_free(path);\n \n 	if (f < 0) {\n','false','false','have_capsicum'),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','working autolog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','294','55','47','4','MODIFY','@@ -136,19 +136,62 @@ int capsicum_open(const char *path, int flags, int mode)\n {\n 	int fd;\n \n-	/* +1 is for slash separating irclogs_path and the rest. */\n-	if (strlen(path) > irclogs_path_len + 1 && strncmp(path, irclogs_path, irclogs_path_len) == 0) {\n-		fd = openat(irclogs_fd, path + irclogs_path_len + 1, flags, mode);\n+	/* +1 is for the slash separating irclogs_path and the rest. */\n+	if (strlen(path) > irclogs_path_len + 1 &&\n+	    strncmp(path, irclogs_path, irclogs_path_len) == 0) {\n+		fd = openat(irclogs_fd, path + irclogs_path_len + 1,\n+		    flags, mode);\n 	} else {\n 		fd = open(path, flags, mode);\n 	}\n \n 	if (fd < 0 && (errno == ENOTCAPABLE || errno == ECAPMODE))\n-		g_warning(\"File system access restricted to %s due to capability mode\", irclogs_path);\n+		g_warning(\"File system access restricted to %s \"\n+		    \"due to capability mode\", irclogs_path);\n \n 	return (fd);\n }\n \n+void capsicum_mkdir_with_parents(const char *path, int mode)\n+{\n+	char *component, *copy, *tofree;\n+	int error, fd, newfd;\n+\n+	/* +1 is for the slash separating irclogs_path and the rest. */\n+	if (strlen(path) <= irclogs_path_len + 1 ||\n+	    strncmp(path, irclogs_path, irclogs_path_len) != 0) {\n+		g_warning(\"Cannot create %s: file system access restricted \"\n+		    \"to %s due to capability mode\", path, irclogs_path);\n+		return;\n+	}\n+\n+	copy = tofree = g_strdup(path + irclogs_path_len + 1);\n+	fd = irclogs_fd;\n+	for (;;) {\n+		component = strsep(&copy, \"/\");\n+		if (component == NULL)\n+			break;\n+		error = mkdirat(fd, component, mode);\n+		if (error != 0 && errno != EEXIST) {\n+			g_warning(\"cannot create %s: %s\",\n+			    component, strerror(errno));\n+			break;\n+		}\n+		newfd = openat(fd, component, O_DIRECTORY);\n+		if (newfd < 0) {\n+			g_warning(\"cannot open %s: %s\",\n+			    component, strerror(errno));\n+			break;\n+		}\n+		if (fd != irclogs_fd)\n+			close(fd);\n+		fd = newfd;\n+	}\n+	g_free(tofree);\n+	if (fd != irclogs_fd)\n+		close(fd);\n+}\n+\n nvlist_t *symbiont_connect(const nvlist_t *request)\n {\n 	nvlist_t *response;\n','false','false','none'),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','working autolog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.h','7','0','1','0','MODIFY','@@ -5,6 +5,7 @@ gboolean capsicum_enabled(void);\n int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);\n int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);\n int capsicum_open(const char *path, int flags, int mode);\n+void capsicum_mkdir_with_parents(const char *path, int mode);\n \n void capsicum_init(void);\n void capsicum_deinit(void);\n','false','false','none'),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','working autolog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.c','452','102','7','0','MODIFY','@@ -127,7 +127,14 @@ int log_start_logging(LOG_REC *log)\n 		/* path may contain variables (%time, $vars),\n 		   make sure the directory is created */\n 		dir = g_path_get_dirname(log->real_fname);\n+#ifdef HAVE_CAPSICUM\n+		if (capsicum_enabled())\n+			capsicum_mkdir_with_parents(dir, log_dir_create_mode);\n+		else\n+			g_mkdir_with_parents(dir, log_dir_create_mode);\n+#else\n 		g_mkdir_with_parents(dir, log_dir_create_mode);\n+#endif\n 		g_free(dir);\n 	}\n \n','false','false','have_capsicum'),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','working autolog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','184','43','8','1','MODIFY','@@ -167,7 +167,14 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)\n 	int f;\n \n         dir = g_path_get_dirname(fname);\n-        g_mkdir_with_parents(dir, log_dir_create_mode);\n+#ifdef HAVE_CAPSICUM\n+	if (capsicum_enabled())\n+		capsicum_mkdir_with_parents(dir, log_dir_create_mode);\n+	else\n+		g_mkdir_with_parents(dir, log_dir_create_mode);\n+#else\n+	g_mkdir_with_parents(dir, log_dir_create_mode);\n+#endif\n         g_free(dir);\n \n 	path = convert_home(fname);\n','false','false','have_capsicum'),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','working autolog.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-log.c','588','150','10','0','MODIFY','@@ -30,6 +30,9 @@\n #include \"special-vars.h\"\n #include \"settings.h\"\n #include \"lib-config/iconfig.h\"\n+#ifdef HAVE_CAPSICUM\n+#include \"capsicum.h\"\n+#endif\n \n #include \"fe-windows.h\"\n #include \"window-items.h\"\n@@ -451,7 +454,14 @@ static void autolog_open(SERVER_REC *server, const char *server_tag,\n 		log_item_add(log, LOG_ITEM_TARGET, target, server_tag);\n \n 		dir = g_path_get_dirname(log->real_fname);\n+#ifdef HAVE_CAPSICUM\n+		if (capsicum_enabled())\n+			capsicum_mkdir_with_parents(dir, log_dir_create_mode);\n+		else\n+			g_mkdir_with_parents(dir, log_dir_create_mode);\n+#else\n 		g_mkdir_with_parents(dir, log_dir_create_mode);\n+#endif\n 		g_free(dir);\n \n 		log->temp = TRUE;\n','false','false','have_capsicum'),('irssi','1.0.4','c00d4753aee732b5a815f12dda3c9fced41ef1f5','Edward Tomasz Napierala','restrict port range available in capability mode.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','310','60','27','3','MODIFY','@@ -40,6 +40,8 @@ static char *irclogs_path;\n static size_t irclogs_path_len;\n static int irclogs_fd;\n static int symbiontfds[2];\n+static int port_min;\n+static int port_max;\n \n gboolean capsicum_enabled(void)\n {\n@@ -90,6 +92,13 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)\n 	}\n 	saved_errno = nvlist_get_number(nvl, \"errno\");\n 	nvlist_destroy(nvl);\n+\n+	if (sock == -1 && (port < port_min || port > port_max)) {\n+		g_warning(\"Access restricted to ports between %d and %d \"\n+		    \"due to capability mode\",\n+		    port_min, port_max);\n+	}\n+\n 	errno = saved_errno;\n \n 	return sock;\n@@ -205,9 +214,19 @@ nvlist_t *symbiont_connect(const nvlist_t *request)\n 	else\n 		my_ip = NULL;\n \n-	/* Connect. */\n-	sock = net_connect_ip_handle(ip, port, my_ip);\n-	saved_errno = errno;\n+	/*\n+	 * Check if the port is in allowed range.  This is to minimize\n+	 * the chance of the attacker rooting another system in case of\n+	 * compromise.\n+	 */\n+	if (port < port_min || port > port_max) {\n+		sock = -1;\n+		saved_errno = EPERM;\n+	} else {\n+		/* Connect. */\n+		sock = net_connect_ip_handle(ip, port, my_ip);\n+		saved_errno = errno;\n+	}\n \n 	/* Send back the socket fd. */\n 	response = nvlist_create(0);\n@@ -326,6 +345,9 @@ static void cmd_capsicum_enter(void)\n 		return;\n 	}\n \n+	port_min = settings_get_int(\"capsicum_port_min\");\n+	port_max = settings_get_int(\"capsicum_port_max\");\n+\n 	irclogs_path = convert_home(settings_get_str(\"capsicum_irclogs_path\"));\n 	g_mkdir_with_parents(irclogs_path, log_dir_create_mode);\n 	irclogs_path_len = strlen(irclogs_path);\n@@ -375,6 +397,8 @@ void capsicum_init(void)\n {\n 	settings_add_bool(\"misc\", \"capsicum\", FALSE);\n 	settings_add_str(\"misc\", \"capsicum_irclogs_path\", \"~/irclogs\");\n+	settings_add_int(\"misc\", \"capsicum_port_min\", 6667);\n+	settings_add_int(\"misc\", \"capsicum_port_max\", 6697);\n \n 	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n \n','false','false','none'),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','add wrappers to reduce #ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','325','64','17','0','MODIFY','@@ -161,6 +161,14 @@ int capsicum_open(const char *path, int flags, int mode)\n 	return (fd);\n }\n \n+int capsicum_open_wrapper(const char *path, int flags, int mode)\n+{\n+	if (capsicum_enabled()) {\n+		return capsicum_open(path, flags, mode);\n+	}\n+	return open(path, flags, mode);\n+}\n+\n void capsicum_mkdir_with_parents(const char *path, int mode)\n {\n 	char *component, *copy, *tofree;\n@@ -201,6 +209,15 @@ void capsicum_mkdir_with_parents(const char *path, int mode)\n 		close(fd);\n }\n \n+void capsicum_mkdir_with_parents_wrapper(const char *path, int mode)\n+{\n+	if (capsicum_enabled()) {\n+		capsicum_mkdir_with_parents(path, mode);\n+		return;\n+	}\n+	g_mkdir_with_parents(path, mode);\n+}\n+\n nvlist_t *symbiont_connect(const nvlist_t *request)\n {\n 	nvlist_t *response;\n','false','false','none'),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','add wrappers to reduce #ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.h','9','0','11','1','MODIFY','@@ -7,7 +7,17 @@ int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);\n int capsicum_open(const char *path, int flags, int mode);\n void capsicum_mkdir_with_parents(const char *path, int mode);\n \n+#ifdef HAVE_CAPSICUM\n+int capsicum_open_wrapper(const char *path, int flags, int mode);\n+void capsicum_mkdir_with_parents_wrapper(const char *path, int mode);\n+#else\n+#define	capsicum_open_wrapper(P, F, M)			\\\n+	open(P, F, M)\n+#define	capsicum_mkdir_with_parents_wrapper(P, M)	\\\n+	g_mkdir_with_parents(P, M)\n+#endif\n+\n void capsicum_init(void);\n void capsicum_deinit(void);\n \n-#endif\n+#endif /* !__CAPSICUM_H */\n','false','false','have_capsicum'),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','add wrappers to reduce #ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.c','442','97','2','21','MODIFY','@@ -26,9 +26,7 @@\n #include \"servers.h\"\n #include \"log.h\"\n #include \"write-buffer.h\"\n-#ifdef HAVE_CAPSICUM\n #include \"capsicum.h\"\n-#endif\n \n #include \"lib-config/iconfig.h\"\n #include \"settings.h\"\n@@ -76,16 +74,6 @@ static void log_write_timestamp(int handle, const char *format,\n 	if (text != NULL) write_buffer(handle, text, strlen(text));\n }\n \n-static int log_open_wrapper(const char *path, int flags, int mode)\n-{\n-#ifdef HAVE_CAPSICUM\n-	if (capsicum_enabled())\n-		return capsicum_open(path, flags, mode);\n-#endif\n-\n-	return open(path, flags, mode);\n-}\n-\n static char *log_filename(LOG_REC *log)\n {\n 	char *str, fname[1024];\n@@ -127,19 +115,12 @@ int log_start_logging(LOG_REC *log)\n 		/* path may contain variables (%time, $vars),\n 		   make sure the directory is created */\n 		dir = g_path_get_dirname(log->real_fname);\n-#ifdef HAVE_CAPSICUM\n-		if (capsicum_enabled())\n-			capsicum_mkdir_with_parents(dir, log_dir_create_mode);\n-		else\n-			g_mkdir_with_parents(dir, log_dir_create_mode);\n-#else\n-		g_mkdir_with_parents(dir, log_dir_create_mode);\n-#endif\n+		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n 		g_free(dir);\n 	}\n \n 	log->handle = log->real_fname == NULL ? -1 :\n-		log_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,\n+		capsicum_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,\n 		     log_file_create_mode);\n 	if (log->handle == -1) {\n 		signal_emit(\"log create failed\", 1, log);\n','false','false','have_capsicum'),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','add wrappers to reduce #ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','176','38','6','23','MODIFY','@@ -27,25 +27,13 @@\n #include \"misc.h\"\n #include \"write-buffer.h\"\n #include \"settings.h\"\n-#ifdef HAVE_CAPSICUM\n #include \"capsicum.h\"\n-#endif\n \n #include \"servers.h\"\n \n static int rawlog_lines;\n static int signal_rawlog;\n \n-static int rawlog_open_wrapper(const char *path, int flags, int mode)\n-{\n-#ifdef HAVE_CAPSICUM\n-	if (capsicum_enabled())\n-		return capsicum_open(path, flags, mode);\n-#endif\n-\n-	return open(path, flags, mode);\n-}\n-\n RAWLOG_REC *rawlog_create(void)\n {\n 	RAWLOG_REC *rec;\n@@ -139,8 +127,9 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)\n 		return;\n \n 	path = convert_home(fname);\n-	rawlog->handle = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT,\n-			      log_file_create_mode);\n+	rawlog->handle = capsicum_open_wrapper(path,\n+					       O_WRONLY | O_APPEND | O_CREAT,\n+					       log_file_create_mode);\n 	g_free(path);\n \n 	if (rawlog->handle == -1) {\n@@ -167,18 +156,12 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)\n 	int f;\n \n         dir = g_path_get_dirname(fname);\n-#ifdef HAVE_CAPSICUM\n-	if (capsicum_enabled())\n-		capsicum_mkdir_with_parents(dir, log_dir_create_mode);\n-	else\n-		g_mkdir_with_parents(dir, log_dir_create_mode);\n-#else\n-	g_mkdir_with_parents(dir, log_dir_create_mode);\n-#endif\n+	capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n         g_free(dir);\n \n 	path = convert_home(fname);\n-	f = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode);\n+	f = capsicum_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT,\n+				  log_file_create_mode);\n 	g_free(path);\n \n 	if (f < 0) {\n','false','false','have_capsicum'),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','add wrappers to reduce #ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-log.c','584','148','1','10','MODIFY','@@ -30,9 +30,7 @@\n #include \"special-vars.h\"\n #include \"settings.h\"\n #include \"lib-config/iconfig.h\"\n-#ifdef HAVE_CAPSICUM\n #include \"capsicum.h\"\n-#endif\n \n #include \"fe-windows.h\"\n #include \"window-items.h\"\n@@ -454,14 +452,7 @@ static void autolog_open(SERVER_REC *server, const char *server_tag,\n 		log_item_add(log, LOG_ITEM_TARGET, target, server_tag);\n \n 		dir = g_path_get_dirname(log->real_fname);\n-#ifdef HAVE_CAPSICUM\n-		if (capsicum_enabled())\n-			capsicum_mkdir_with_parents(dir, log_dir_create_mode);\n-		else\n-			g_mkdir_with_parents(dir, log_dir_create_mode);\n-#else\n-		g_mkdir_with_parents(dir, log_dir_create_mode);\n-#endif\n+		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n 		g_free(dir);\n \n 		log->temp = TRUE;\n','false','false','have_capsicum'),('irssi','1.0.4','8c04c2be14fc053bd7b5ff03b8e4ba8cb5023700','Edward Tomasz Napierala','fix build without capsicum.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','core.c','224','26','4','0','MODIFY','@@ -236,7 +236,9 @@ void core_init(void)\n 	commands_init();\n 	nickmatch_cache_init();\n         session_init();\n+#ifdef HAVE_CAPSICUM\n 	capsicum_init();\n+#endif\n \n 	chat_protocols_init();\n 	chatnets_init();\n@@ -294,7 +296,9 @@ void core_deinit(void)\n 	chatnets_deinit();\n 	chat_protocols_deinit();\n \n+#ifdef HAVE_CAPSICUM\n 	capsicum_deinit();\n+#endif\n         session_deinit();\n         nickmatch_cache_deinit();\n 	commands_deinit();\n','true','false','have_capsicum'),('irssi','1.0.4','8c04c2be14fc053bd7b5ff03b8e4ba8cb5023700','Edward Tomasz Napierala','fix build without capsicum.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-common-core.c','377','54','4','0','MODIFY','@@ -180,7 +180,9 @@ void fe_common_core_init(void)\n 	fe_server_init();\n 	fe_settings_init();\n 	fe_tls_init();\n+#ifdef HAVE_CAPSICUM\n 	fe_capsicum_init();\n+#endif\n 	windows_init();\n 	window_activity_init();\n 	window_commands_init();\n@@ -223,7 +225,9 @@ void fe_common_core_deinit(void)\n 	fe_server_deinit();\n 	fe_settings_deinit();\n 	fe_tls_deinit();\n+#ifdef HAVE_CAPSICUM\n 	fe_capsicum_deinit();\n+#endif\n 	windows_deinit();\n 	window_activity_deinit();\n 	window_commands_deinit();\n','true','false','have_capsicum'),('irssi','1.0.4','7f2697d30744d1f33cf67430aa48013b8f4ae9cd','Edward Tomasz Napierala','cosmetics.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.h','44','0','0','2','MODIFY','@@ -38,8 +38,6 @@ extern GSList *logs;\n extern int log_file_create_mode;\n extern int log_dir_create_mode;\n \n-extern int log_dir_create_mode;\n-\n /* Create log record - you still need to call log_update() to actually add it\n    into log list */\n LOG_REC *log_create_rec(const char *fname, int level);\n','false','false','none'),('irssi','1.0.4','7f2697d30744d1f33cf67430aa48013b8f4ae9cd','Edward Tomasz Napierala','cosmetics.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','176','38','1','1','MODIFY','@@ -156,7 +156,7 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)\n 	int f;\n \n         dir = g_path_get_dirname(fname);\n-	capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n+        capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n         g_free(dir);\n \n 	path = convert_home(fname);\n','false','false','none'),('irssi','1.0.4','a29eeaa9f2e85630b08fc46b3a2b8749b9719efd','Edward Tomasz Napierala','fix trailing slash handling for capsicum_irclogs_path.\n\nthis is mostly an anti-footshooting measure, but still.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','331','68','10','1','MODIFY','@@ -147,6 +147,7 @@ int capsicum_open(const char *path, int flags, int mode)\n \n 	/* +1 is for the slash separating irclogs_path and the rest. */\n 	if (strlen(path) > irclogs_path_len + 1 &&\n+	    path[irclogs_path_len] == \'/\' &&\n 	    strncmp(path, irclogs_path, irclogs_path_len) == 0) {\n 		fd = openat(irclogs_fd, path + irclogs_path_len + 1,\n 		    flags, mode);\n@@ -176,6 +177,7 @@ void capsicum_mkdir_with_parents(const char *path, int mode)\n \n 	/* +1 is for the slash separating irclogs_path and the rest. */\n 	if (strlen(path) <= irclogs_path_len + 1 ||\n+	    path[irclogs_path_len] != \'/\' ||\n 	    strncmp(path, irclogs_path, irclogs_path_len) != 0) {\n 		g_warning(\"Cannot create %s: file system access restricted \"\n 		    \"to %s due to capability mode\", path, irclogs_path);\n@@ -366,8 +368,15 @@ static void cmd_capsicum_enter(void)\n 	port_max = settings_get_int(\"capsicum_port_max\");\n \n 	irclogs_path = convert_home(settings_get_str(\"capsicum_irclogs_path\"));\n-	g_mkdir_with_parents(irclogs_path, log_dir_create_mode);\n 	irclogs_path_len = strlen(irclogs_path);\n+\n+	/* Strip trailing slashes, if any. */\n+	while (irclogs_path_len > 0 && irclogs_path[irclogs_path_len - 1] == \'/\') {\n+		irclogs_path[irclogs_path_len - 1] = \'\\0\';\n+		irclogs_path_len--;\n+	}\n+\n+	g_mkdir_with_parents(irclogs_path, log_dir_create_mode);\n 	irclogs_fd = open(irclogs_path, O_DIRECTORY | O_CLOEXEC);\n 	if (irclogs_fd < 0) {\n 		g_warning(\"Unable to open %s: %s\", irclogs_path, strerror(errno));\n','true','false','none'),('irssi','1.0.4','8bb392a3f47d74cccb9e2d7e3633e3e534306968','Edward Tomasz Napierala','hook up capsicum.h and fe-capsicum.h to autotools.\n\nthis hopefully fixes travis build.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','Makefile.am','111','0','1','0','MODIFY','@@ -74,6 +74,7 @@ structure_headers = \\\n pkginc_coredir=$(pkgincludedir)/src/core\n pkginc_core_HEADERS = \\\n 	args.h \\\n+	capsicum.h \\\n 	channels.h \\\n 	channels-setup.h \\\n 	commands.h \\\n','false','false','none'),('irssi','1.0.4','8bb392a3f47d74cccb9e2d7e3633e3e534306968','Edward Tomasz Napierala','hook up capsicum.h and fe-capsicum.h to autotools.\n\nthis hopefully fixes travis build.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','Makefile.am','66','0','1','0','MODIFY','@@ -48,6 +48,7 @@ pkginc_fe_common_core_HEADERS = \\\n 	command-history.h \\\n 	chat-completion.h \\\n 	completion.h \\\n+	fe-capsicum.h \\\n 	fe-channels.h \\\n 	fe-common-core.h \\\n 	fe-core-commands.h \\\n','false','false','none'),('irssi','1.0.4','5551b4fe9504f5d5b4e81a680741cab72bec82e9','Edward Tomasz Napierala','update copyrights.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','331','68','4','0','MODIFY','@@ -3,6 +3,10 @@\n \n     Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org>\n \n+    This software was developed by SRI International and the University of\n+    Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237\n+    (\"CTSRD\"), as part of the DARPA CRASH research programme.\n+\n     This program is free software; you can redistribute it and/or modify\n     it under the terms of the GNU General Public License as published by\n     the Free Software Foundation; either version 2 of the License, or\n','false','false','none'),('irssi','1.0.4','5551b4fe9504f5d5b4e81a680741cab72bec82e9','Edward Tomasz Napierala','update copyrights.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-capsicum.c','30','5','4','0','MODIFY','@@ -3,6 +3,10 @@\n \n     Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org>\n \n+    This software was developed by SRI International and the University of\n+    Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237\n+    (\"CTSRD\"), as part of the DARPA CRASH research programme.\n+\n     This program is free software; you can redistribute it and/or modify\n     it under the terms of the GNU General Public License as published by\n     the Free Software Foundation; either version 2 of the License, or\n','false','false','none'),('irssi','1.0.4','aeaa420ad330a528391ed149371b55581a808655','Edward Tomasz Napierala','clean up includes a bit.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','332','68','1','0','MODIFY','@@ -23,6 +23,7 @@\n */\n \n #include \"module.h\"\n+#include \"capsicum.h\"\n #include \"commands.h\"\n #include \"log.h\"\n #include \"misc.h\"\n','false','false','none'),('irssi','1.0.4','aeaa420ad330a528391ed149371b55581a808655','Edward Tomasz Napierala','clean up includes a bit.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-capsicum.c','30','5','3','4','MODIFY','@@ -23,12 +23,11 @@\n */\n \n #include \"module.h\"\n+#include \"fe-capsicum.h\"\n+#include \"levels.h\"\n #include \"module-formats.h\"\n-#include \"signals.h\"\n #include \"printtext.h\"\n-\n-#include \"levels.h\"\n-#include \"servers.h\"\n+#include \"signals.h\"\n \n static void capability_mode_enabled(void)\n {\n','false','false','none'),('irssi','1.0.4','96f4fe10c6081cf441122039c39eb6422eef13e8','Edward Tomasz Napierala','change the way we load default ca certificates so it works with capsicum.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','339','69','8','0','MODIFY','@@ -28,6 +28,7 @@\n #include \"log.h\"\n #include \"misc.h\"\n #include \"network.h\"\n+#include \"network-openssl.h\"\n #include \"settings.h\"\n #include \"signals.h\"\n \n@@ -361,6 +362,7 @@ static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n static void cmd_capsicum_enter(void)\n {\n 	u_int mode;\n+	gboolean inited;\n 	int error;\n \n 	error = cap_getmode(&mode);\n@@ -369,6 +371,12 @@ static void cmd_capsicum_enter(void)\n 		return;\n 	}\n \n+	inited = irssi_ssl_init();\n+	if (!inited) {\n+		signal_emit(\"capability mode failed\", 1, strerror(errno));\n+		return;\n+	}\n+\n 	port_min = settings_get_int(\"capsicum_port_min\");\n 	port_max = settings_get_int(\"capsicum_port_max\");\n \n','false','false','none'),('irssi','1.0.4','96f4fe10c6081cf441122039c39eb6422eef13e8','Edward Tomasz Napierala','change the way we load default ca certificates so it works with capsicum.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','network-openssl.c','672','144','20','3','MODIFY','@@ -20,6 +20,7 @@\n \n #include \"module.h\"\n #include \"network.h\"\n+#include \"network-openssl.h\"\n #include \"net-sendbuffer.h\"\n #include \"misc.h\"\n #include \"servers.h\"\n@@ -58,6 +59,7 @@ typedef struct\n } GIOSSLChannel;\n \n static int ssl_inited = FALSE;\n+static X509_STORE *store = NULL;\n \n static void irssi_ssl_free(GIOChannel *handle)\n {\n@@ -362,8 +364,10 @@ static GIOFuncs irssi_ssl_channel_funcs = {\n     irssi_ssl_get_flags\n };\n \n-static gboolean irssi_ssl_init(void)\n+gboolean irssi_ssl_init(void)\n {\n+	int success;\n+\n #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n 	if (!OPENSSL_init_ssl(OPENSSL_INIT_SSL_DEFAULT, NULL)) {\n 		g_error(\"Could not initialize OpenSSL\");\n@@ -374,6 +378,20 @@ static gboolean irssi_ssl_init(void)\n 	SSL_load_error_strings();\n 	OpenSSL_add_all_algorithms();\n #endif\n+	store = X509_STORE_new();\n+	if (store == NULL) {\n+		g_error(\"Could not initialize OpenSSL: X509_STORE_new() failed\");\n+		return FALSE;\n+	}\n+\n+	success = X509_STORE_set_default_paths(store);\n+	if (success == 0) {\n+		g_error(\"Could not load default certificates\");\n+		X509_STORE_free(store);\n+		store = NULL;\n+		return FALSE;\n+	}\n+\n 	ssl_inited = TRUE;\n \n 	return TRUE;\n@@ -492,8 +510,7 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_\n 		g_free(scapath);\n 		verify = TRUE;\n 	} else {\n-		if (!SSL_CTX_set_default_verify_paths(ctx))\n-			g_warning(\"Could not load default certificates\");\n+		SSL_CTX_set_cert_store(ctx, store);\n 	}\n \n 	if(!(ssl = SSL_new(ctx)))\n','false','true','none'),('irssi','1.0.4','96f4fe10c6081cf441122039c39eb6422eef13e8','Edward Tomasz Napierala','change the way we load default ca certificates so it works with capsicum.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','network-openssl.h','1','0','6','0','ADD','@@ -0,0 +1,6 @@\n+#ifndef __NETWORK_OPENSSL_H\n+#define __NETWORK_OPENSSL_H\n+\n+gboolean irssi_ssl_init(void);\n+\n+#endif /* !__NETWORK_OPENSSL_H */\n','false','false','none'),('irssi','1.0.4','5db6caee0d17eb125d8c7f3090c325ffbee35920','Edward Tomasz Napierala','attempt to fix build by adding the forgotten header.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','Makefile.am','112','0','1','0','MODIFY','@@ -95,6 +95,7 @@ pkginc_core_HEADERS = \\\n 	net-nonblock.h \\\n 	net-sendbuffer.h \\\n 	network.h \\\n+	network-openssl.h \\\n 	nick-rec.h \\\n 	nicklist.h \\\n 	nickmatch-cache.h \\\n','true','false','none'),('irssi','1.0.4','788e47032f9f6b7eea188a1a6e7fc1a19531c1b0','Paul Townsend','update /connect and /server syntax tags (-ssl -> -tls).','chat-commands.c','384','117','7','7','MODIFY','@@ -149,9 +149,9 @@ static SERVER_CONNECT_REC *get_server_connect(const char *data, int *plus_addr,\n         return conn;\n }\n \n-/* SYNTAX: CONNECT [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>] [-ssl_pass <password>]\n-                   [-ssl_verify] [-ssl_cafile <cafile>] [-ssl_capath <capath>]\n-                   [-ssl_ciphers <list>]\n+/* SYNTAX: CONNECT [-4 | -6] [-tls] [-tls_cert <cert>] [-tls_pkey <pkey>] [-tls_pass <password>]\n+                   [-tls_verify] [-tls_cafile <cafile>] [-tls_capath <capath>]\n+                   [-tls_ciphers <list>] [-tls_pinned_cert <fingerprint>] [-tls_pinned_pubkey <fingerprint>]\n                    [-!] [-noautosendcmd]\n 		   [-noproxy] [-network <network>] [-host <hostname>]\n 		   [-rawlog <file>]\n@@ -250,10 +250,10 @@ static void cmd_server(const char *data, SERVER_REC *server, WI_ITEM_REC *item)\n 	command_runsub(\"server\", data, server, item);\n }\n \n-/* SYNTAX: SERVER CONNECT [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>] \n-		  [-ssl_pass <password>] [-ssl_verify] [-ssl_cafile <cafile>] \n-		  [-ssl_capath <capath>]\n-		  [-ssl_ciphers <list>]\n+/* SYNTAX: SERVER CONNECT [-4 | -6] [-tls] [-tls_cert <cert>] [-tls_pkey <pkey>] \n+		  [-tls_pass <password>] [-tls_verify] [-tls_cafile <cafile>] \n+		  [-tls_capath <capath>]\n+		  [-tls_ciphers <list>] [-tls_pinned_cert <fingerprint>] [-tls_pinned_pubkey <fingerprint>]\n 		  [-!] [-noautosendcmd]\n 		  [-noproxy] [-network <network>] [-host <hostname>]\n 		  [-rawlog <file>]\n','false','false','none'),('irssi','1.0.4','947682e5dde85aa5e0277c01d7fb4afc1032ea04','ailin-nemui','revert \"merge pull request #452 from lemonboy/terminfo-cup\"\n\nfixes #733. the fix outlined in #452 had adverse effects for the\nfollowing reason. the code removed the restoration path that would go on\nthe code path from kill sigtstp. the problem is this: when irssi is not\nrunning in a controlling parent (like a shell), the tstp will in fact be\nignored. in that case, there is no process sending a cont either and\nthus the screen state never gets restored. luckily, the patch in #457 is\nsufficient to prevent the problem in #450 (which lead to the development\nof #452). to that end, we do end up with potentially calling\nterminfo_cont twice but that is better than not calling it at all.\n\nthis reverts commit b1ffd5f6472584aa3966746da9728c5afefcc4ce, reversing\nchanges made to 9cb0419435d1ad331c1f55361a003d9682fae9a8.','term-terminfo.c','532','168','7','0','MODIFY','@@ -629,6 +629,13 @@ void term_stop(void)\n {\n 	terminfo_stop(current_term);\n 	kill(getpid(), SIGTSTP);\n+	/* this call needs to stay here in case the TSTP was ignored,\n+	   because then we never see a CONT to call the restoration\n+	   code. On the other hand we also cannot remove the CONT\n+	   handler because then nothing would restore the screen when\n+	   Irssi is killed with TSTP/STOP from external. */\n+	terminfo_cont(current_term);\n+	irssi_redraw();\n }\n \n static int input_utf8(const unsigned char *buffer, int size, unichar *result)\n','false','false','none'),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','add back some ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.h','9','0','1','9','MODIFY','@@ -5,17 +5,9 @@ gboolean capsicum_enabled(void);\n int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);\n int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);\n int capsicum_open(const char *path, int flags, int mode);\n-void capsicum_mkdir_with_parents(const char *path, int mode);\n-\n-#ifdef HAVE_CAPSICUM\n int capsicum_open_wrapper(const char *path, int flags, int mode);\n+void capsicum_mkdir_with_parents(const char *path, int mode);\n void capsicum_mkdir_with_parents_wrapper(const char *path, int mode);\n-#else\n-#define	capsicum_open_wrapper(P, F, M)			\\\n-	open(P, F, M)\n-#define	capsicum_mkdir_with_parents_wrapper(P, M)	\\\n-	g_mkdir_with_parents(P, M)\n-#endif\n \n void capsicum_init(void);\n void capsicum_deinit(void);\n','false','false','have_capsicum'),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','add back some ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','core.c','224','26','2','0','MODIFY','@@ -29,7 +29,9 @@\n #include \"signals.h\"\n #include \"settings.h\"\n #include \"session.h\"\n+#ifdef HAVE_CAPSICUM\n #include \"capsicum.h\"\n+#endif\n \n #include \"chat-protocols.h\"\n #include \"servers.h\"\n','false','false','have_capsicum'),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','add back some ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','log.c','446','100','12','0','MODIFY','@@ -26,7 +26,9 @@\n #include \"servers.h\"\n #include \"log.h\"\n #include \"write-buffer.h\"\n+#ifdef HAVE_CAPSICUM\n #include \"capsicum.h\"\n+#endif\n \n #include \"lib-config/iconfig.h\"\n #include \"settings.h\"\n@@ -115,13 +117,23 @@ int log_start_logging(LOG_REC *log)\n 		/* path may contain variables (%time, $vars),\n 		   make sure the directory is created */\n 		dir = g_path_get_dirname(log->real_fname);\n+#ifdef HAVE_CAPSICUM\n 		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n+#else\n+		g_mkdir_with_parents(dir, log_dir_create_mode);\n+#endif\n 		g_free(dir);\n 	}\n \n+#ifdef HAVE_CAPSICUM\n 	log->handle = log->real_fname == NULL ? -1 :\n 		capsicum_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,\n 		     log_file_create_mode);\n+#else\n+	log->handle = log->real_fname == NULL ? -1 :\n+		open(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,\n+		     log_file_create_mode);\n+#endif\n 	if (log->handle == -1) {\n 		signal_emit(\"log create failed\", 1, log);\n 		log->failed = TRUE;\n','false','false','have_capsicum'),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','add back some ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','rawlog.c','180','41','16','0','MODIFY','@@ -27,7 +27,9 @@\n #include \"misc.h\"\n #include \"write-buffer.h\"\n #include \"settings.h\"\n+#ifdef HAVE_CAPSICUM\n #include \"capsicum.h\"\n+#endif\n \n #include \"servers.h\"\n \n@@ -127,9 +129,15 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)\n 		return;\n \n 	path = convert_home(fname);\n+#ifdef HAVE_CAPSICUM\n 	rawlog->handle = capsicum_open_wrapper(path,\n 					       O_WRONLY | O_APPEND | O_CREAT,\n 					       log_file_create_mode);\n+#else\n+	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT,\n+			      log_file_create_mode);\n+#endif\n+\n 	g_free(path);\n \n 	if (rawlog->handle == -1) {\n@@ -156,12 +164,20 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)\n 	int f;\n \n         dir = g_path_get_dirname(fname);\n+#ifdef HAVE_CAPSICUM\n         capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n+#else\n+        g_mkdir_with_parents(dir, log_dir_create_mode);\n+#endif\n         g_free(dir);\n \n 	path = convert_home(fname);\n+#ifdef HAVE_CAPSICUM\n 	f = capsicum_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT,\n 				  log_file_create_mode);\n+#else\n+	f = open(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode);\n+#endif\n 	g_free(path);\n \n 	if (f < 0) {\n','false','false','have_capsicum'),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','add back some ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-common-core.c','377','54','2','0','MODIFY','@@ -32,7 +32,9 @@\n #include \"special-vars.h\"\n #include \"fe-core-commands.h\"\n #include \"fe-queries.h\"\n+#ifdef HAVE_CAPSICUM\n #include \"fe-capsicum.h\"\n+#endif\n #include \"hilight-text.h\"\n #include \"command-history.h\"\n #include \"completion.h\"\n','false','false','have_capsicum'),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','add back some ifdefs.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-log.c','585','149','6','0','MODIFY','@@ -30,7 +30,9 @@\n #include \"special-vars.h\"\n #include \"settings.h\"\n #include \"lib-config/iconfig.h\"\n+#ifdef HAVE_CAPSICUM\n #include \"capsicum.h\"\n+#endif\n \n #include \"fe-windows.h\"\n #include \"window-items.h\"\n@@ -452,7 +454,11 @@ static void autolog_open(SERVER_REC *server, const char *server_tag,\n 		log_item_add(log, LOG_ITEM_TARGET, target, server_tag);\n \n 		dir = g_path_get_dirname(log->real_fname);\n+#ifdef HAVE_CAPSICUM\n 		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);\n+#else\n+		g_mkdir_with_parents(dir, log_dir_create_mode);\n+#endif\n 		g_free(dir);\n \n 		log->temp = TRUE;\n','false','false','have_capsicum'),('irssi','1.0.4','4bcbb41113bf23b1d121ad6fbd7b86473f7fa89d','Edward Tomasz Napierala','fix indentation; no functional changes.\n\n(take two.)\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','module-formats.h','240','0','25','25','MODIFY','@@ -12,21 +12,21 @@ enum {\n 	TXT_DAYCHANGE,\n 	TXT_TALKING_WITH,\n 	TXT_REFNUM_TOO_LOW,\n-        TXT_ERROR_SERVER_STICKY,\n-        TXT_SET_SERVER_STICKY,\n+	TXT_ERROR_SERVER_STICKY,\n+	TXT_SET_SERVER_STICKY,\n 	TXT_UNSET_SERVER_STICKY,\n-        TXT_WINDOW_NAME_NOT_UNIQUE,\n-        TXT_WINDOW_LEVEL,\n-        TXT_WINDOW_SET_IMMORTAL,\n-        TXT_WINDOW_UNSET_IMMORTAL,\n-        TXT_WINDOW_IMMORTAL_ERROR,\n+	TXT_WINDOW_NAME_NOT_UNIQUE,\n+	TXT_WINDOW_LEVEL,\n+	TXT_WINDOW_SET_IMMORTAL,\n+	TXT_WINDOW_UNSET_IMMORTAL,\n+	TXT_WINDOW_IMMORTAL_ERROR,\n 	TXT_WINDOWLIST_HEADER,\n 	TXT_WINDOWLIST_LINE,\n 	TXT_WINDOWLIST_FOOTER,\n 	TXT_WINDOWS_LAYOUT_SAVED,\n 	TXT_WINDOWS_LAYOUT_RESET,\n-        TXT_WINDOW_INFO_HEADER,\n-        TXT_WINDOW_INFO_FOOTER,\n+	TXT_WINDOW_INFO_HEADER,\n+	TXT_WINDOW_INFO_FOOTER,\n 	TXT_WINDOW_INFO_REFNUM,\n 	TXT_WINDOW_INFO_REFNUM_STICKY,\n 	TXT_WINDOW_INFO_NAME,\n@@ -34,22 +34,22 @@ enum {\n 	TXT_WINDOW_INFO_IMMORTAL,\n 	TXT_WINDOW_INFO_SIZE,\n 	TXT_WINDOW_INFO_LEVEL,\n-        TXT_WINDOW_INFO_SERVER,\n+	TXT_WINDOW_INFO_SERVER,\n 	TXT_WINDOW_INFO_SERVER_STICKY,\n-        TXT_WINDOW_INFO_THEME,\n+	TXT_WINDOW_INFO_THEME,\n 	TXT_WINDOW_INFO_BOUND_ITEMS_HEADER,\n 	TXT_WINDOW_INFO_BOUND_ITEM,\n 	TXT_WINDOW_INFO_BOUND_ITEMS_FOOTER,\n 	TXT_WINDOW_INFO_ITEMS_HEADER,\n 	TXT_WINDOW_INFO_ITEM,\n-        TXT_WINDOW_INFO_ITEMS_FOOTER,\n+	TXT_WINDOW_INFO_ITEMS_FOOTER,\n \n 	TXT_FILL_2,\n \n 	TXT_LOOKING_UP,\n 	TXT_CONNECTING,\n- 	TXT_RECONNECTING,\n-        TXT_CONNECTION_ESTABLISHED,\n+	TXT_RECONNECTING,\n+	TXT_CONNECTION_ESTABLISHED,\n 	TXT_CANT_CONNECT,\n 	TXT_CONNECTION_LOST,\n 	TXT_LAG_DISCONNECTED,\n@@ -100,7 +100,7 @@ enum {\n 	TXT_CHANSETUP_LINE,\n 	TXT_CHANSETUP_FOOTER,\n \n-        TXT_FILL_4,\n+	TXT_FILL_4,\n \n 	TXT_OWN_MSG,\n 	TXT_OWN_MSG_CHANNEL,\n@@ -162,7 +162,7 @@ enum {\n \n 	TXT_MODULE_HEADER,\n 	TXT_MODULE_LINE,\n-        TXT_MODULE_FOOTER,\n+	TXT_MODULE_FOOTER,\n 	TXT_MODULE_ALREADY_LOADED,\n 	TXT_MODULE_NOT_LOADED,\n 	TXT_MODULE_LOAD_ERROR,\n@@ -183,7 +183,7 @@ enum {\n 	TXT_NOT_JOINED,\n 	TXT_CHAN_NOT_FOUND,\n 	TXT_CHAN_NOT_SYNCED,\n-        TXT_ILLEGAL_PROTO,\n+	TXT_ILLEGAL_PROTO,\n 	TXT_NOT_GOOD_IDEA,\n 	TXT_INVALID_NUMBER,\n 	TXT_INVALID_TIME,\n@@ -232,8 +232,8 @@ enum {\n \n 	TXT_FILL_14,\n \n-        TXT_UNKNOWN_CHAT_PROTOCOL,\n-        TXT_UNKNOWN_CHATNET,\n+	TXT_UNKNOWN_CHAT_PROTOCOL,\n+	TXT_UNKNOWN_CHATNET,\n 	TXT_NOT_TOGGLE,\n 	TXT_PERL_ERROR,\n 	TXT_BIND_HEADER,\n@@ -245,15 +245,15 @@ enum {\n 	TXT_CONFIG_RELOADED,\n 	TXT_CONFIG_MODIFIED,\n 	TXT_GLIB_ERROR,\n-        TXT_OVERWRITE_CONFIG,\n-        TXT_SET_TITLE,\n-        TXT_SET_ITEM,\n-        TXT_SET_UNKNOWN,\n+	TXT_OVERWRITE_CONFIG,\n+	TXT_SET_TITLE,\n+	TXT_SET_ITEM,\n+	TXT_SET_UNKNOWN,\n 	TXT_SET_NOT_BOOLEAN,\n 	TXT_NO_COMPLETIONS,\n-        TXT_COMPLETION_REMOVED,\n+	TXT_COMPLETION_REMOVED,\n 	TXT_COMPLETION_HEADER,\n-        TXT_COMPLETION_LINE,\n+	TXT_COMPLETION_LINE,\n 	TXT_COMPLETION_FOOTER,\n \n 	TLS_FILL_15,\n','true','false','none'),('irssi','1.0.4','edee0ba587069a860eac43f9219f8ecfa49fe1fa','Edward Tomasz Napierala','don\'t error out on failure to load default certificate store.\n\nthis restores the previous behaviour.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','network-openssl.c','671','145','3','3','MODIFY','@@ -386,10 +386,10 @@ gboolean irssi_ssl_init(void)\n \n 	success = X509_STORE_set_default_paths(store);\n 	if (success == 0) {\n-		g_error(\"Could not load default certificates\");\n+		g_warning(\"Could not load default certificates\");\n 		X509_STORE_free(store);\n 		store = NULL;\n-		return FALSE;\n+		/* Don\'t return an error; the user might have their own cafile/capath. */\n 	}\n \n 	ssl_inited = TRUE;\n@@ -509,7 +509,7 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_\n 		g_free(scafile);\n 		g_free(scapath);\n 		verify = TRUE;\n-	} else {\n+	} else if (store != NULL) {\n 		SSL_CTX_set_cert_store(ctx, store);\n 	}\n \n','true','false','none'),('irssi','1.0.4','245a3fd4c1afb86b38eb17477a42c60c52cef793','Edward Tomasz Napierala','add docs/capsicum.txt.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','Makefile.am','15','0','1','0','MODIFY','@@ -2,6 +2,7 @@ man_MANS = \\\n 	irssi.1\n \n doc_DATA = \\\n+	capsicum.txt \\\n 	design.txt \\\n 	formats.txt \\\n 	manual.txt \\\n','false','false','none'),('irssi','1.0.4','245a3fd4c1afb86b38eb17477a42c60c52cef793','Edward Tomasz Napierala','add docs/capsicum.txt.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.txt','24','0','30','0','ADD','@@ -0,0 +1,30 @@\n+Capsicum is a lightweight OS capability and sandbox framework provided\n+by FreeBSD.  When built with Capsicum support - which is the default under\n+FreeBSD - Irssi can enter a Capsicum capability mode (a sandbox), greatly\n+limiting possible consequences of a potential security hole in Irssi\n+or the libraries it depends on.\n+\n+To make Irssi enter capability mode on startup, add\n+\n+capsicum = \"yes\";\n+\n+to your ~/.irssi/config and restart the client.  Alternatively you can\n+enter it \"by hand\", using the \"/capsicum enter\" command.  From the security\n+point of view it\'s strongly preferable to use the former method, to avoid\n+establishing connections without the sandbox protection; the \"/capsicum\"\n+command is only intended for experimentation, and in cases where you need\n+to do something that\'s not possible in capability mode - run scripts,\n+for example - before continuing.\n+\n+There is no way to leave the capability mode, apart from exiting Irssi.\n+When running in capability mode, there are certain restrictions - Irssi\n+won\'t be able to access any files outside the directory pointed to by\n+capsicum_irclogs_path (which defaults to ~/irclogs/).  If you change\n+the path when already in capability mode it won\'t be effective until\n+you restart Irssi.  Capability mode also makes it impossible to use\n+the \"/save\" command.\n+\n+Currently there is no way to use custom SSL certificates.  As a workaround\n+you can establish connections and enter the capability mode afterwards\n+using the \"/capsicum enter\" command.\n+\n','false','false','none'),('irssi','1.0.4','7086eae650a616615bc81e688cdfa44d444463e0','LemonBoy','complete filenames ending with a slash','completion.c','653','185','12','1','MODIFY','@@ -321,6 +321,10 @@ GList *filename_complete(const char *path, const char *default_path)\n \n 	g_return_val_if_fail(path != NULL, NULL);\n \n+	if (path[0] == \'\\0\') {\n+	    return NULL;\n+	}\n+\n 	list = NULL;\n \n 	/* get directory part of the path - expand ~/ */\n@@ -350,7 +354,14 @@ GList *filename_complete(const char *path, const char *default_path)\n 		g_free_and_null(dir);\n 	}\n \n-	basename = g_path_get_basename(path);\n+	len = strlen(path);\n+	/* g_path_get_basename() returns the component before the last slash if\n+	 * the path ends with a directory separator, that\'s not what we want */\n+	if (len > 0 && path[len - 1] == G_DIR_SEPARATOR) {\n+	    basename = g_strdup(\"\");\n+	} else {\n+	    basename = g_path_get_basename(path);\n+	}\n 	len = strlen(basename);\n \n 	/* add all files in directory to completion list */\n','false','false','none'),('irssi','1.0.4','b529e1a9df134bbc5618752abcf19af0110b6868','Edward Tomasz Napierala','fix /back in capsicum capability mode.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','fe-core-commands.c','255','53','14','0','MODIFY','@@ -28,6 +28,9 @@\n #include \"settings.h\"\n #include \"irssi-version.h\"\n #include \"servers.h\"\n+#ifdef HAVE_CAPSICUM\n+#include \"capsicum.h\"\n+#endif\n \n #include \"fe-windows.h\"\n #include \"printtext.h\"\n@@ -120,6 +123,9 @@ static void cmd_cat(const char *data)\n 	GIOChannel *handle;\n 	GString *buf;\n 	gsize tpos;\n+#ifdef HAVE_CAPSICUM\n+	int fd;\n+#endif\n \n 	if (!cmd_get_params(data, &free_arg, 2, &fname, &fposstr))\n 		return;\n@@ -128,7 +134,15 @@ static void cmd_cat(const char *data)\n 	fpos = atoi(fposstr);\n         cmd_params_free(free_arg);\n \n+#ifdef HAVE_CAPSICUM\n+	fd = capsicum_open_wrapper(fname, O_RDONLY, 0);\n+	if (fd > 0)\n+		handle = g_io_channel_unix_new(fd);\n+	else\n+		handle = NULL;\n+#else\n 	handle = g_io_channel_new_file(fname, \"r\", NULL);\n+#endif\n 	g_free(fname);\n \n 	if (handle == NULL) {\n','true','false','have_capsicum'),('irssi','1.0.4','96d5a4669d696d57a511119963ae5c651346e167','LemonBoy','increment the x509_store refcount during the connection\n\nopenssl doesn\'t increment the reference count when the store is assigned\nto a ssl_ctx.','network-openssl.c','672','145','4','0','MODIFY','@@ -510,6 +510,10 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_\n 		g_free(scapath);\n 		verify = TRUE;\n 	} else if (store != NULL) {\n+		/* Make sure to increment the refcount every time the store is\n+		 * used, that\'s essential not to get it free\'d by OpenSSL when\n+		 * the SSL_CTX is destroyed. */\n+		X509_STORE_up_ref(store);\n 		SSL_CTX_set_cert_store(ctx, store);\n 	}\n \n','false','false','none'),('irssi','1.0.4','36d8b974fc42ed8eb1ff88811e09d0910ae61187','LemonBoy','restore compatibility with old openssl versions\n\nlet\'s implement x509_store_up_ref on our own.','network-openssl.c','679','147','13','0','MODIFY','@@ -45,6 +45,19 @@\n #define ASN1_STRING_data(x)       ASN1_STRING_get0_data(x)\n #endif\n \n+/* OpenSSL 1.1.0 also introduced some useful additions to the api */\n+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined (LIBRESSL_VERSION_NUMBER)\n+static int X509_STORE_up_ref(X509_STORE *vfy)\n+{\n+    int n;\n+\n+    n = CRYPTO_add(&vfy->references, 1, CRYPTO_LOCK_X509_STORE);\n+    g_assert(n > 1);\n+\n+    return (n > 1) ? 1 : 0;\n+}\n+#endif\n+\n /* ssl i/o channel object */\n typedef struct\n {\n','false','false','none'),('irssi','1.0.4','624ef4a696fc736779c6b7af94c7e376b7033590','Edward Tomasz Napierala','get rid of the zombies in capsicum capability mode.\n\nsigned-off-by: edward tomasz napierala <trasz@freebsd.org>','capsicum.c','340','69','7','0','MODIFY','@@ -403,6 +403,13 @@ static void cmd_capsicum_enter(void)\n 		return;\n 	}\n \n+	/*\n+	 * XXX: We should use pdwait(2) to wait for children.  Unfortunately\n+	 *      it\'s not implemented yet.  Thus the workaround, to get rid\n+	 *      of the zombies at least.\n+	 */\n+	signal(SIGCHLD, SIG_IGN);\n+\n 	error = cap_enter();\n 	if (error != 0) {\n 		signal_emit(\"capability mode failed\", 1, strerror(errno));\n','false','false','none'),('irssi','1.0.4','0468c5d912fc8a89bd552611ef6243bd1c889df7','ailin-nemui','add new function to set the position in bytes\n\nfixes #752','gui-entry.c','799','249','20','0','MODIFY','@@ -936,6 +936,26 @@ void gui_entry_set_pos(GUI_ENTRY_REC *entry, int pos)\n 	gui_entry_draw(entry);\n }\n \n+void gui_entry_set_text_and_pos_bytes(GUI_ENTRY_REC *entry, const char *str, int pos_bytes)\n+{\n+	int pos;\n+	const char *ptr;\n+\n+	g_return_if_fail(entry != NULL);\n+\n+	gui_entry_set_text(entry, str);\n+\n+	if (entry->utf8) {\n+		g_utf8_validate(str, pos_bytes, &ptr);\n+		pos = g_utf8_pointer_to_offset(str, ptr);\n+	} else if (term_type == TERM_TYPE_BIG5)\n+		pos = strlen_big5((const unsigned char *)str) - strlen_big5((const unsigned char *)(str + pos_bytes));\n+	else\n+		pos = pos_bytes;\n+\n+	gui_entry_set_pos(entry, pos);\n+}\n+\n void gui_entry_move_pos(GUI_ENTRY_REC *entry, int pos)\n {\n         g_return_if_fail(entry != NULL);\n','false','false','none'),('irssi','1.0.4','0468c5d912fc8a89bd552611ef6243bd1c889df7','ailin-nemui','add new function to set the position in bytes\n\nfixes #752','gui-entry.h','56','0','1','0','MODIFY','@@ -50,6 +50,7 @@ void gui_entry_set_utf8(GUI_ENTRY_REC *entry, int utf8);\n void gui_entry_set_text(GUI_ENTRY_REC *entry, const char *str);\n char *gui_entry_get_text(GUI_ENTRY_REC *entry);\n char *gui_entry_get_text_and_pos(GUI_ENTRY_REC *entry, int *pos);\n+void gui_entry_set_text_and_pos_bytes(GUI_ENTRY_REC *entry, const char *str, int pos_bytes);\n \n void gui_entry_insert_text(GUI_ENTRY_REC *entry, const char *str);\n void gui_entry_insert_char(GUI_ENTRY_REC *entry, unichar chr);\n','false','false','none'),('irssi','1.0.4','0468c5d912fc8a89bd552611ef6243bd1c889df7','ailin-nemui','add new function to set the position in bytes\n\nfixes #752','gui-readline.c','1029','208','2','4','MODIFY','@@ -878,8 +878,7 @@ static void key_completion(int erase, int backward)\n 	g_free(text);\n \n 	if (line != NULL) {\n-		gui_entry_set_text(active_entry, line);\n-		gui_entry_set_pos(active_entry, pos);\n+		gui_entry_set_text_and_pos_bytes(active_entry, line, pos);\n 		g_free(line);\n 	}\n }\n@@ -909,8 +908,7 @@ static void key_check_replaces(void)\n 	g_free(text);\n \n 	if (line != NULL) {\n-		gui_entry_set_text(active_entry, line);\n-		gui_entry_set_pos(active_entry, pos);\n+		gui_entry_set_text_and_pos_bytes(active_entry, line, pos);\n 		g_free(line);\n 	}\n }\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@\n #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */\n #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */\n \n-#define IRSSI_ABI_VERSION 10\n+#define IRSSI_ABI_VERSION 11\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n #define DEFAULT_SERVER_ADD_TLS_PORT 6697\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','levels.c','132','39','11','10','MODIFY','@@ -21,6 +21,7 @@\n #include \"module.h\"\n #include \"levels.h\"\n \n+/* the order of these levels must match the bits in levels.h */\n static const char *levels[] = {\n 	\"CRAP\",\n 	\"MSGS\",\n@@ -44,9 +45,6 @@ static const char *levels[] = {\n 	\"CLIENTCRAP\",\n 	\"CLIENTERRORS\",\n 	\"HILIGHTS\",\n-\n-	\"NOHILIGHT\",\n-	\"NO_ACT\",\n 	NULL\n };\n \n@@ -63,6 +61,9 @@ int level_get(const char *level)\n 	if (g_ascii_strcasecmp(level, \"NO_ACT\") == 0)\n 		return MSGLEVEL_NO_ACT;\n \n+	if (g_ascii_strcasecmp(level, \"HIDDEN\") == 0)\n+		return MSGLEVEL_HIDDEN;\n+\n 	len = strlen(level);\n 	if (len == 0) return 0;\n \n@@ -138,17 +139,13 @@ char *bits2level(int bits)\n \n \n 	str = g_string_new(NULL);\n-	if (bits & MSGLEVEL_NEVER) {\n+	if (bits & MSGLEVEL_NEVER)\n 		g_string_append(str, \"NEVER \");\n-		bits &= ~MSGLEVEL_NEVER;\n-	}\n \n-	if (bits & MSGLEVEL_NO_ACT) {\n+	if (bits & MSGLEVEL_NO_ACT)\n 		g_string_append(str, \"NO_ACT \");\n-		bits &= ~MSGLEVEL_NO_ACT;\n-	}\n \n-	if (bits == MSGLEVEL_ALL) {\n+	if ((bits & MSGLEVEL_ALL) == MSGLEVEL_ALL) {\n 		g_string_append(str, \"ALL \");\n 	} else {\n 		for (n = 0; levels[n] != NULL; n++) {\n@@ -156,6 +153,10 @@ char *bits2level(int bits)\n 				g_string_append_printf(str, \"%s \", levels[n]);\n 		}\n 	}\n+\n+	if (bits & MSGLEVEL_HIDDEN)\n+		g_string_append(str, \"HIDDEN \");\n+\n         if (str->len > 0)\n 		g_string_truncate(str, str->len-1);\n \n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','levels.h','34','0','3','1','MODIFY','@@ -36,7 +36,9 @@ enum {\n 	MSGLEVEL_NOHILIGHT    = 0x1000000, /* Don\'t highlight this message */\n 	MSGLEVEL_NO_ACT       = 0x2000000, /* Don\'t trigger channel activity */\n 	MSGLEVEL_NEVER        = 0x4000000, /* never ignore / never log */\n-	MSGLEVEL_LASTLOG      = 0x8000000 /* never ignore / never log */\n+	MSGLEVEL_LASTLOG      = 0x8000000, /* used for /lastlog */\n+\n+	MSGLEVEL_HIDDEN       = 0x10000000 /* Hidden from view */\n };\n \n int level_get(const char *level);\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','gui-windows.c','221','51','4','0','MODIFY','@@ -23,6 +23,7 @@\n #include \"misc.h\"\n #include \"settings.h\"\n #include \"special-vars.h\"\n+#include \"levels.h\"\n \n #include \"term.h\"\n #include \"gui-entry.h\"\n@@ -50,6 +51,7 @@ static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,\n 					   !settings_get_bool(\"indent_always\"),\n 					   get_default_indent_func());\n 	textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));\n+	textbuffer_view_set_hidden_level(gui->view, MSGLEVEL_HIDDEN);\n 	if (parent->active == window)\n 		textbuffer_view_set_window(gui->view, parent->screen_win);\n 	return gui;\n@@ -204,6 +206,8 @@ void gui_windows_reset_settings(void)\n 		WINDOW_REC *rec = tmp->data;\n 		GUI_WINDOW_REC *gui = WINDOW_GUI(rec);\n \n+		textbuffer_view_set_hidden_level(gui->view, MSGLEVEL_HIDDEN);\n+\n 		textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));\n \n 		textbuffer_view_set_default_indent(gui->view,\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','mainwindows-layout.c','167','38','10','0','MODIFY','@@ -23,6 +23,7 @@\n #include \"misc.h\"\n #include \"lib-config/iconfig.h\"\n #include \"settings.h\"\n+#include \"levels.h\"\n \n #include \"mainwindows.h\"\n #include \"gui-windows.h\"\n@@ -41,6 +42,12 @@ static void sig_layout_window_save(WINDOW_REC *window, CONFIG_NODE *node)\n 			iconfig_node_set_int(node, \"parent\", active->refnum);\n 	}\n \n+	if (gui->view->hidden_level != MSGLEVEL_HIDDEN) {\n+		char *level = bits2level(gui->view->hidden_level);\n+		iconfig_node_set_str(node, \"hidelevel\", level);\n+		g_free(level);\n+	}\n+\n 	if (gui->use_scroll)\n                 iconfig_node_set_bool(node, \"scroll\", gui->scroll);\n }\n@@ -58,6 +65,9 @@ static void sig_layout_window_restore(WINDOW_REC *window, CONFIG_NODE *node)\n \n 	if (config_node_get_bool(node, \"sticky\", FALSE))\n 		gui_window_set_sticky(window);\n+\n+	textbuffer_view_set_hidden_level(gui->view, level2bits(config_node_get_str(node, \"hidelevel\", \"HIDDEN\"), NULL));\n+\n 	if (config_node_get_str(node, \"scroll\", NULL) != NULL) {\n 		gui->use_scroll = TRUE;\n 		gui->scroll = config_node_get_bool(node, \"scroll\", TRUE);\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','module-formats.c','49','0','1','0','MODIFY','@@ -50,6 +50,7 @@ FORMAT_REC gui_text_formats[] =\n 	{ \"window_info_scroll\", \"%#Scroll  : $0\", 1, { 0 } },\n 	{ \"window_scroll\", \"Window scroll mode is now $0\", 1, { 0 } },\n 	{ \"window_scroll_unknown\", \"Unknown scroll mode $0, must be ON, OFF or DEFAULT\", 1, { 0 } },\n+	{ \"window_hidelevel\", \"Window hidden level is now $0\", 1, { 0 } },\n \n 	/* ---- */\n 	{ NULL, \"Statusbars\", 0 },\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','module-formats.h','48','0','1','0','MODIFY','@@ -26,6 +26,7 @@ enum {\n         TXT_WINDOW_INFO_SCROLL,\n         TXT_WINDOW_SCROLL,\n         TXT_WINDOW_SCROLL_UNKNOWN,\n+	TXT_WINDOW_HIDELEVEL,\n \n 	TXT_FILL_3,\n \n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer-commands.c','300','68','21','0','MODIFY','@@ -89,6 +89,25 @@ static void cmd_window_scroll(const char *data)\n 				   gui->scroll : settings_get_bool(\"scroll\"));\n }\n \n+/* SYNTAX: WINDOW HIDELEVEL [<level>] */\n+static void cmd_window_hidelevel(const char *data)\n+{\n+	GUI_WINDOW_REC *gui;\n+	char *level;\n+\n+	g_return_if_fail(data != NULL);\n+\n+	gui = WINDOW_GUI(active_win);\n+	textbuffer_view_set_hidden_level(gui->view,\n+					 combine_level(gui->view->hidden_level, data));\n+	textbuffer_view_redraw(gui->view);\n+	level = gui->view->hidden_level == 0 ? g_strdup(\"NONE\") :\n+		bits2level(gui->view->hidden_level);\n+	printformat_window(active_win, MSGLEVEL_CLIENTNOTICE,\n+			   TXT_WINDOW_HIDELEVEL, level);\n+	g_free(level);\n+}\n+\n static void cmd_scrollback(const char *data, SERVER_REC *server,\n 			   WI_ITEM_REC *item)\n {\n@@ -358,6 +377,7 @@ void textbuffer_commands_init(void)\n {\n 	command_bind(\"clear\", NULL, (SIGNAL_FUNC) cmd_clear);\n 	command_bind(\"window scroll\", NULL, (SIGNAL_FUNC) cmd_window_scroll);\n+	command_bind(\"window hidelevel\", NULL, (SIGNAL_FUNC) cmd_window_hidelevel);\n 	command_bind(\"scrollback\", NULL, (SIGNAL_FUNC) cmd_scrollback);\n 	command_bind(\"scrollback clear\", NULL, (SIGNAL_FUNC) cmd_scrollback_clear);\n 	command_bind(\"scrollback levelclear\", NULL, (SIGNAL_FUNC) cmd_scrollback_levelclear);\n@@ -377,6 +397,7 @@ void textbuffer_commands_deinit(void)\n {\n 	command_unbind(\"clear\", (SIGNAL_FUNC) cmd_clear);\n 	command_unbind(\"window scroll\", (SIGNAL_FUNC) cmd_window_scroll);\n+	command_unbind(\"window hidelevel\", (SIGNAL_FUNC) cmd_window_hidelevel);\n 	command_unbind(\"scrollback\", (SIGNAL_FUNC) cmd_scrollback);\n 	command_unbind(\"scrollback clear\", (SIGNAL_FUNC) cmd_scrollback_clear);\n 	command_unbind(\"scrollback levelclear\", (SIGNAL_FUNC) cmd_scrollback_levelclear);\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer-view.c','1073','264','61','6','MODIFY','@@ -41,9 +41,15 @@ static GSList *views;\n #define view_is_bottom(view) \\\n         ((view)->ypos >= -1 && (view)->ypos < (view)->height)\n \n-#define view_get_linecount(view, line) \\\n+#define view_get_linecount_hidden(view, line) \\\n         textbuffer_view_get_line_cache(view, line)->count\n \n+#define view_line_is_hidden(view, line) \\\n+	(((line)->info.level & (view)->hidden_level) != 0)\n+\n+#define view_get_linecount(view, line) \\\n+	(view_line_is_hidden(view, line) ? 0 : view_get_linecount_hidden(view, line))\n+\n static GSList *textbuffer_get_views(TEXT_BUFFER_REC *buffer)\n {\n 	GSList *tmp, *list;\n@@ -552,6 +558,9 @@ static void textbuffer_view_init_bottom(TEXT_BUFFER_VIEW_REC *view)\n 	total = 0;\n         line = textbuffer_line_last(view->buffer);\n 	for (; line != NULL; line = line->prev) {\n+		if (view_line_is_hidden(view, line))\n+			continue;\n+\n 		linecount = view_get_linecount(view, line);\n 		if (line == view->bottom_startline) {\n 			/* keep the old one, make sure that subline is ok */\n@@ -614,6 +623,8 @@ TEXT_BUFFER_VIEW_REC *textbuffer_view_create(TEXT_BUFFER_REC *buffer,\n         view->subline = view->bottom_subline;\n 	view->bottom = TRUE;\n \n+	view->hidden_level = 0;\n+\n 	textbuffer_view_init_ypos(view);\n \n 	view->bookmarks = g_hash_table_new((GHashFunc) g_str_hash,\n@@ -726,8 +737,10 @@ static void view_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n                 return;\n \n 	while (line != NULL && lines > 0) {\n-                linecount = view_line_draw(view, line, subline, ypos, lines);\n-		ypos += linecount; lines -= linecount;\n+		if (!view_line_is_hidden(view, line)) {\n+			linecount = view_line_draw(view, line, subline, ypos, lines);\n+			ypos += linecount; lines -= linecount;\n+		}\n \n 		subline = 0;\n                 line = line->next;\n@@ -768,7 +781,12 @@ static void view_draw_bottom(TEXT_BUFFER_VIEW_REC *view, int lines)\n         view_draw(view, line, subline, maxline, lines, TRUE);\n }\n \n-/* Returns number of lines actually scrolled */\n+/* lines: this pointer is scrolled by scrollcount screen lines\n+   subline: this pointer contains the subline position\n+   scrollcount: the number of lines to scroll down (negative: up)\n+   draw_nonclean: whether to redraw the screen now\n+\n+   Returns number of lines actually scrolled */\n static int view_scroll(TEXT_BUFFER_VIEW_REC *view, LINE_REC **lines,\n 		       int *subline, int scrollcount, int draw_nonclean)\n {\n@@ -1027,7 +1045,7 @@ static void view_insert_line(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line)\n 			view->bottom = view_is_bottom(view);\n 		}\n \n-		if (view->window != NULL) {\n+		if (view->window != NULL && !view_line_is_hidden(view, line)) {\n 			ypos = view->ypos+1 - view_get_linecount(view, line);\n 			if (ypos >= 0)\n 				subline = 0;\n@@ -1042,7 +1060,7 @@ static void view_insert_line(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line)\n 		}\n 	}\n \n-        if (view->window != NULL)\n+        if (view->window != NULL && !view_line_is_hidden(view, line))\n 		term_refresh(view->window);\n }\n \n@@ -1122,6 +1140,12 @@ static int view_get_lines_height(TEXT_BUFFER_VIEW_REC *view,\n 	return height < view->height ? height : view->height;\n }\n \n+/* line: line to remove\n+   linecount: linecount of that line, to be offset when the line was in/below view\n+\n+   scroll the window maintaining the startline while removing line\n+   if startline is removed, make the previous line the new startline\n+*/\n static void view_remove_line_update_startline(TEXT_BUFFER_VIEW_REC *view,\n 					      LINE_REC *line, int linecount)\n {\n@@ -1318,6 +1342,37 @@ LINE_REC *textbuffer_view_get_bookmark(TEXT_BUFFER_VIEW_REC *view,\n         return g_hash_table_lookup(view->bookmarks, name);\n }\n \n+void textbuffer_view_set_hidden_level(TEXT_BUFFER_VIEW_REC *view, int level)\n+{\n+	g_return_if_fail(view != NULL);\n+\n+	if (view->hidden_level != level) {\n+		if (view->empty_linecount > 0 && view->startline != NULL) {\n+			int old_height, new_height;\n+			LINE_REC *hidden_start;\n+\n+			hidden_start = view->startline;\n+			while (hidden_start->prev != NULL && view_line_is_hidden(view, hidden_start->prev)) {\n+				hidden_start = hidden_start->prev;\n+			}\n+\n+			old_height = view_get_lines_height(view, hidden_start, view->subline, NULL);\n+			view->hidden_level = level;\n+			new_height = view_get_lines_height(view, hidden_start, view->subline, NULL);\n+\n+			view->empty_linecount -= new_height - old_height;\n+\n+			if (view->empty_linecount < 0)\n+				view->empty_linecount = 0;\n+			else if (view->empty_linecount > view->height)\n+				view->empty_linecount = view->height;\n+		} else {\n+			view->hidden_level = level;\n+		}\n+		textbuffer_view_resize(view, view->width, view->height);\n+	}\n+}\n+\n /* Specify window where the changes in view should be drawn,\n    NULL disables it. */\n void textbuffer_view_set_window(TEXT_BUFFER_VIEW_REC *view,\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer-view.h','84','0','24','12','MODIFY','@@ -49,41 +49,51 @@ typedef struct {\n \n struct _TEXT_BUFFER_VIEW_REC {\n 	TEXT_BUFFER_REC *buffer;\n-	GSList *siblings; /* other views that use the same buffer */\n+	/* other views that use the same buffer */\n+	GSList *siblings;\n \n         TERM_WINDOW *window;\n 	int width, height;\n \n 	int default_indent;\n         INDENT_FUNC default_indent_func;\n-	unsigned int longword_noindent:1;\n-	unsigned int scroll:1; /* scroll down automatically when at bottom */\n-	unsigned int utf8:1; /* use UTF8 in this view */\n-	unsigned int break_wide:1; /* Break wide chars in this view */\n \n 	TEXT_BUFFER_CACHE_REC *cache;\n-	int ypos; /* cursor position - visible area is 0..height-1 */\n+	/* cursor position - visible area is 0..height-1 */\n+	int ypos;\n \n-	LINE_REC *startline; /* line at the top of the screen */\n-	int subline; /* number of \"real lines\" to skip from `startline\' */\n+	 /* line at the top of the screen */\n+	LINE_REC *startline;\n+	/* number of \"real lines\" to skip from `startline\' */\n+	int subline;\n \n         /* marks the bottom of the text buffer */\n 	LINE_REC *bottom_startline;\n 	int bottom_subline;\n \n+	/* Bookmarks to the lines in the buffer - removed automatically\n+	   when the line gets removed from buffer */\n+        GHashTable *bookmarks;\n+\n+	/* these levels should be hidden */\n+	int hidden_level;\n 	/* how many empty lines are in screen. a screenful when started\n 	   or used /CLEAR */\n 	int empty_linecount;\n+\n+	unsigned int longword_noindent:1;\n+	/* scroll down automatically when at bottom */\n+	unsigned int scroll:1;\n+	/* use UTF8 in this view */\n+	unsigned int utf8:1;\n+	/* Break wide chars in this view */\n+	unsigned int break_wide:1;\n         /* window is at the bottom of the text buffer */\n 	unsigned int bottom:1;\n         /* if !bottom - new text has been printed since we were at bottom */\n 	unsigned int more_text:1;\n         /* Window needs a redraw */\n 	unsigned int dirty:1;\n-\n-	/* Bookmarks to the lines in the buffer - removed automatically\n-	   when the line gets removed from buffer */\n-        GHashTable *bookmarks;\n };\n \n /* Create new view. */\n@@ -143,6 +153,8 @@ void textbuffer_view_set_bookmark_bottom(TEXT_BUFFER_VIEW_REC *view,\n /* Return the line for bookmark */\n LINE_REC *textbuffer_view_get_bookmark(TEXT_BUFFER_VIEW_REC *view,\n 				       const char *name);\n+/* Set hidden level for view */\n+void textbuffer_view_set_hidden_level(TEXT_BUFFER_VIEW_REC *view, int level);\n \n /* Specify window where the changes in view should be drawn,\n    NULL disables it. */\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer.c','472','140','1','0','MODIFY','@@ -230,6 +230,7 @@ LINE_REC *textbuffer_line_last(TEXT_BUFFER_REC *buffer)\n 	return buffer->cur_line;\n }\n \n+/* returns TRUE if `search\' comes on or after `line\' in the buffer */\n int textbuffer_line_exists_after(LINE_REC *line, LINE_REC *search)\n {\n 	while (line != NULL) {\n','false','false','none'),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer.h','61','0','1','1','MODIFY','@@ -65,10 +65,10 @@ typedef struct {\n 	LINE_REC *cur_line;\n 	TEXT_CHUNK_REC *cur_text;\n \n-	unsigned int last_eol:1;\n 	int last_fg;\n 	int last_bg;\n 	int last_flags;\n+	unsigned int last_eol:1;\n } TEXT_BUFFER_REC;\n \n /* Create new buffer */\n','false','false','none'),('irssi','1.0.4','32f33e7bb34598e8603b9f6a931ef063f6bd31f2','Robert Bisewski','improving howto document','startup-HOWTO.html','463','0','5','5','MODIFY','@@ -635,7 +635,7 @@ separated by <code>:</code> from the actual proxy password.</p>\n \n <h2 id=\"statusbar\">12. Statusbar</h2>\n \n-<p><code>/STATUSBAR</code> displays a list of statusbars:</p>\n+<p><code>/STATUSBAR</code> displays a list of the current statusbars, along with their position and visibility:</p>\n \n <pre><code> Name                           Type   Placement Position Visible\n  window                         window bottom    0        always\n@@ -644,9 +644,9 @@ separated by <code>:</code> from the actual proxy password.</p>\n  topic                          root   top       1        always\n </code></pre>\n \n-<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings and it’s items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to it’s default settings, or if the statusbar was created by you, it will be removed.</p>\n+<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings (type, placement, position, visibility) as well as its items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to its default settings, or if the statusbar was created by you, it will be removed.</p>\n \n-<p>Type can be window or root, meaning if the statusbar should be created for each split window, or just once. Placement can be top or bottom. Position is a number, the higher the value the lower in screen it is. Visible can be always, active or inactive. Active/inactive is useful only with split windows, one split window is active and the rest are inactive. These settings can be changed with:</p>\n+<p>The statusbar type can be either window or root. If the type is window, then a statusbar will be created for each split window, otherwise it will be created only once. Placement can be top or bottom, which refers to the top or bottom of the screen. Position is a number, the higher the value the lower it will appear in-screen. Visible can be always, active or inactive. Active/inactive is useful only with split windows; one split window is active and the rest are inactive. To adjust these settings, the following commands are available:</p>\n \n <pre><code> /STATUSBAR &lt;name&gt; TYPE window|root\n  /STATUSBAR &lt;name&gt; PLACEMENT top|bottom\n@@ -654,10 +654,10 @@ separated by <code>:</code> from the actual proxy password.</p>\n  /STATUSBAR &lt;name&gt; VISIBLE always|active|inactive\n </code></pre>\n \n-<p>When loading a new statusbar scripts, you’ll need to also specify where you want to show it. Statusbar items can be modified with:</p>\n+<p>Statusbar items can also be added or removed via command. Note that when loading new statusbar scripts that add items, you will need to specify where you want to show the item and how it is aligned. This can be accomplished using the below commands:</p>\n \n <pre><code> /STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt;\n  /STATUSBAR &lt;name&gt; REMOVE &lt;item&gt;\n </code></pre>\n \n-<p>The item name with statusbar scripts is usually same as the script’s name. Script’s documentation should tell if this isn’t the case. So, to add mail.pl before the window activity item (see the list with <code>/STATUSBAR</code> window), use: <code>/STATUSBAR window ADD -before act mail</code>.</p>\n+<p>For statusbar scripts, the item name is usually equivalent to the script name. The documentation of the script ought to tell you if this is not the case. For example, to add mail.pl before the window activity item, use: <code>/STATUSBAR window ADD -before act mail</code>.</p>\n','false','false','none'),('irssi','1.0.4','1f7de4c3bd8cb03af76c14aff71fc535ce9f23de','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@\n #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */\n #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */\n \n-#define IRSSI_ABI_VERSION 10\n+#define IRSSI_ABI_VERSION 11\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n #define DEFAULT_SERVER_ADD_TLS_PORT 6697\n','false','false','none'),('irssi','1.0.4','e1e632d31e1d8efc3370db76ddcc4bda200e4d31','Robert Bisewski','correcting and expanding content of statusbar help text','statusbar.in','34','0','21','12','MODIFY','@@ -5,22 +5,31 @@\n \n %9Parameters:%9\n \n-    ENABLE:       Enables the statusbar.\n-    DISABLE:      Disabled the statusbar.\n+    ENABLE:       Adds a statusbar to the list of statusbars.\n+    DISABLE:      Removes a statusbar from the list.\n     RESET:        Restores the default statusbar configuration.\n-    TYPE:         Identifies the type of statusbar.\n-    PLACEMENT:    Identifies the placement of the statusbar.\n-    POSITION:     Identifies the position of the statusbar.\n-    VISIBLE:      Identifies the visibility of the statusbar.\n-    ADD:          Adds a statusbar into the configuration.\n-    REMOVE:       Removes a statusbar from the configuration.\n-\n-    The name of the statusbar; if no argument is given, the list of statusbars\n-    will be displayed.\n+    TYPE:         Refers to the type of statusbar, for each split window\n+                  or only for the current root screen.\n+    PLACEMENT:    Refers to the placement of the statusbar, either at the\n+                  top or the bottom of the screen.\n+    POSITION:     Refers to the position of the statusbar. Represented as\n+                  an unsigned integer, with 0 implying the first position.\n+    VISIBLE:      Refers to the visibility of the statusbar or item. If set\n+                  to always it is visible on all screens, otherwise if set\n+                  to inactive or active then it is only visible on inactive\n+                  or active screens, respectively.\n+    ADD:          Adds an item to the specified statusbar. It can be set to\n+                  appear before/after another item and left/right aligned\n+                  to a specified position on the screen.\n+    REMOVE:       Removes an item from the specified statusbar.\n+\n+    Where name refers to the name of the statusbar; if no argument is\n+    given, the entire list of statusbars will be displayed.\n \n %9Description:%9\n \n-    Modified the attributes of the statusbar.\n+    Allows adjustment of the attributes and items of a statusbar, as well\n+    as where it is located and whether or not it is currently visible.\n \n %9Examples:%9\n \n','false','false','none'),('irssi','1.0.4','0883ff8d320be47336e05aa38cf11427bd79b3af','Robert Bisewski','reverting changes to startup howto','startup-HOWTO.html','463','0','5','5','MODIFY','@@ -635,7 +635,7 @@ separated by <code>:</code> from the actual proxy password.</p>\n \n <h2 id=\"statusbar\">12. Statusbar</h2>\n \n-<p><code>/STATUSBAR</code> displays a list of the current statusbars, along with their position and visibility:</p>\n+<p><code>/STATUSBAR</code> displays a list of statusbars:</p>\n \n <pre><code> Name                           Type   Placement Position Visible\n  window                         window bottom    0        always\n@@ -644,9 +644,9 @@ separated by <code>:</code> from the actual proxy password.</p>\n  topic                          root   top       1        always\n </code></pre>\n \n-<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings (type, placement, position, visibility) as well as its items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to its default settings, or if the statusbar was created by you, it will be removed.</p>\n+<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings and it’s items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to it’s default settings, or if the statusbar was created by you, it will be removed.</p>\n \n-<p>The statusbar type can be either window or root. If the type is window, then a statusbar will be created for each split window, otherwise it will be created only once. Placement can be top or bottom, which refers to the top or bottom of the screen. Position is a number, the higher the value the lower it will appear in-screen. Visible can be always, active or inactive. Active/inactive is useful only with split windows; one split window is active and the rest are inactive. To adjust these settings, the following commands are available:</p>\n+<p>Type can be window or root, meaning if the statusbar should be created for each split window, or just once. Placement can be top or bottom. Position is a number, the higher the value the lower in screen it is. Visible can be always, active or inactive. Active/inactive is useful only with split windows, one split window is active and the rest are inactive. These settings can be changed with:</p>\n \n <pre><code> /STATUSBAR &lt;name&gt; TYPE window|root\n  /STATUSBAR &lt;name&gt; PLACEMENT top|bottom\n@@ -654,10 +654,10 @@ separated by <code>:</code> from the actual proxy password.</p>\n  /STATUSBAR &lt;name&gt; VISIBLE always|active|inactive\n </code></pre>\n \n-<p>Statusbar items can also be added or removed via command. Note that when loading new statusbar scripts that add items, you will need to specify where you want to show the item and how it is aligned. This can be accomplished using the below commands:</p>\n+<p>When loading a new statusbar scripts, you’ll need to also specify where you want to show it. Statusbar items can be modified with:</p>\n \n <pre><code> /STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt;\n  /STATUSBAR &lt;name&gt; REMOVE &lt;item&gt;\n </code></pre>\n \n-<p>For statusbar scripts, the item name is usually equivalent to the script name. The documentation of the script ought to tell you if this is not the case. For example, to add mail.pl before the window activity item, use: <code>/STATUSBAR window ADD -before act mail</code>.</p>\n+<p>The item name with statusbar scripts is usually same as the script’s name. Script’s documentation should tell if this isn’t the case. So, to add mail.pl before the window activity item (see the list with <code>/STATUSBAR</code> window), use: <code>/STATUSBAR window ADD -before act mail</code>.</p>\n','false','false','none'),('irssi','1.0.4','84bfea52af8776e13d754e2ee20387f07556fc90','Robert Bisewski','adjusting text content as per the pull-request discussion','statusbar.in','36','0','10','8','MODIFY','@@ -6,15 +6,17 @@\n %9Parameters:%9\n \n     ENABLE:       Adds a statusbar to the list of statusbars.\n-    DISABLE:      Removes a statusbar from the list.\n+    DISABLE:      Removes a statusbar from the list. Note that for\n+                  built-in statusbars they can be enabled again should the\n+                  user wish to add back the default statusbars.\n     RESET:        Restores the default statusbar configuration.\n-    TYPE:         Refers to the type of statusbar, for each split window\n-                  or only for the current root screen.\n-    PLACEMENT:    Refers to the placement of the statusbar, either at the\n-                  top or the bottom of the screen.\n-    POSITION:     Refers to the position of the statusbar. Represented as\n-                  an unsigned integer, with 0 implying the first position.\n-    VISIBLE:      Refers to the visibility of the statusbar or item. If set\n+    TYPE:         Sets the type of statusbar, for each split window or only\n+                  for the current root screen.\n+    PLACEMENT:    Sets the placement of the statusbar, either at the top or\n+                  the bottom of the screen.\n+    POSITION:     Sets the position of the statusbar. Represented as a\n+                  number, with 0 implying the first position.\n+    VISIBLE:      Sets the visibility of the statusbar or item. If set to\n                   to always it is visible on all screens, otherwise if set\n                   to inactive or active then it is only visible on inactive\n                   or active screens, respectively.\n','false','false','none'),('irssi','1.0.4','4b42eca7c57fdd3d5ded8d5b1d4c75d01fc28569','Robert Bisewski','minor word correction','statusbar.in','36','0','2','2','MODIFY','@@ -17,8 +17,8 @@\n     POSITION:     Sets the position of the statusbar. Represented as a\n                   number, with 0 implying the first position.\n     VISIBLE:      Sets the visibility of the statusbar or item. If set to\n-                  to always it is visible on all screens, otherwise if set\n-                  to inactive or active then it is only visible on inactive\n+                  always it is visible on all screens, otherwise if set to\n+                  inactive or active then it is only visible on inactive\n                   or active screens, respectively.\n     ADD:          Adds an item to the specified statusbar. It can be set to\n                   appear before/after another item and left/right aligned\n','false','false','none'),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list\n\nthis allows access to the global history even when a using /window history\nnamed or /set window_history on, and you want to recall something from one\nof the other windows\' histories.\n\nusage (default): ctrl+up/down','command-history.c','307','85','137','24','MODIFY','@@ -30,10 +30,93 @@\n #include \"command-history.h\"\n \n /* command history */\n+static GList *history_entries;\n static HISTORY_REC *global_history;\n static int window_history;\n static GSList *histories;\n \n+static HISTORY_ENTRY_REC *history_entry_new(HISTORY_REC *history, const char *text)\n+{\n+	HISTORY_ENTRY_REC *entry;\n+\n+	entry = g_new0(HISTORY_ENTRY_REC, 1);\n+	entry->text = g_strdup(text);\n+	entry->history = history;\n+	entry->time = time(NULL);\n+\n+	return entry;\n+}\n+\n+static void history_entry_destroy(HISTORY_ENTRY_REC *entry)\n+{\n+	g_free((char *)entry->text);\n+	g_free(entry);\n+}\n+\n+GList *command_history_list_last(HISTORY_REC *history)\n+{\n+	GList *link;\n+\n+	link = g_list_last(history_entries);\n+	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) {\n+		link = link->prev;\n+	}\n+\n+	return link;\n+}\n+\n+GList *command_history_list_first(HISTORY_REC *history)\n+{\n+	GList *link;\n+\n+	link = history_entries;\n+	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) {\n+		link = link->next;\n+	}\n+\n+	return link;\n+}\n+\n+GList *command_history_list_prev(HISTORY_REC *history, GList *pos)\n+{\n+	GList *link;\n+\n+	link = pos != NULL ? pos->prev : NULL;\n+	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) {\n+		link = link->prev;\n+	}\n+\n+	return link;\n+}\n+\n+GList *command_history_list_next(HISTORY_REC *history, GList *pos)\n+{\n+	GList *link;\n+\n+	link = pos != NULL ? pos->next : NULL;\n+	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) {\n+		link = link->next;\n+	}\n+\n+	return link;\n+}\n+\n+static void command_history_clear_pos_for_unlink_func(HISTORY_REC *history, GList* link)\n+{\n+	if (history->pos == link) {\n+		history->pos = command_history_list_next(history, link);\n+		history->redo = 1;\n+	}\n+}\n+\n+static void history_list_delete_link_and_destroy(GList *link)\n+{\n+	g_slist_foreach(histories,\n+		       (GFunc) command_history_clear_pos_for_unlink_func, link);\n+	history_entry_destroy(link->data);\n+	history_entries = g_list_delete_link(history_entries, link);\n+}\n+\n void command_history_add(HISTORY_REC *history, const char *text)\n {\n 	GList *link;\n@@ -41,21 +124,19 @@ void command_history_add(HISTORY_REC *history, const char *text)\n 	g_return_if_fail(history != NULL);\n 	g_return_if_fail(text != NULL);\n \n-	link = g_list_last(history->list);\n-	if (link != NULL && g_strcmp0(link->data, text) == 0)\n-	  return; /* same as previous entry */\n+	link = command_history_list_last(history);\n+	if (link != NULL && g_strcmp0(((HISTORY_ENTRY_REC *)link->data)->text, text) == 0)\n+		return; /* same as previous entry */\n \n 	if (settings_get_int(\"max_command_history\") < 1 ||\n 	    history->lines < settings_get_int(\"max_command_history\"))\n 		history->lines++;\n 	else {\n-		link = history->list;\n-		g_free(link->data);\n-		history->list = g_list_remove_link(history->list, link);\n-		g_list_free_1(link);\n+		link = command_history_list_first(history);\n+		history_list_delete_link_and_destroy(link);\n 	}\n \n-	history->list = g_list_append(history->list, g_strdup(text));\n+	history_entries = g_list_append(history_entries, history_entry_new(history, text));\n }\n \n HISTORY_REC *command_history_find(HISTORY_REC *history)\n@@ -104,32 +185,44 @@ HISTORY_REC *command_history_current(WINDOW_REC *window)\n 	return global_history;\n }\n \n-const char *command_history_prev(WINDOW_REC *window, const char *text)\n+static const char *command_history_prev_int(WINDOW_REC *window, const char *text, gboolean global)\n {\n 	HISTORY_REC *history;\n 	GList *pos;\n \n 	history = command_history_current(window);\n 	pos = history->pos;\n+	history->redo = 0;\n \n 	if (pos != NULL) {\n 		/* don\'t go past the first entry (no wrap around) */\n-		if (history->pos->prev != NULL)\n-			history->pos = history->pos->prev;\n+		GList *prev = command_history_list_prev(global ? NULL : history, history->pos);\n+		if (prev != NULL)\n+			history->pos = prev;\n 	} else {\n-		history->pos = g_list_last(history->list);\n+		history->pos = command_history_list_last(global ? NULL : history);\n 	}\n \n 	if (*text != \'\\0\' &&\n-	    (pos == NULL || g_strcmp0(pos->data, text) != 0)) {\n+	    (pos == NULL || g_strcmp0(((HISTORY_ENTRY_REC *)pos->data)->text, text) != 0)) {\n 		/* save the old entry to history */\n 		command_history_add(history, text);\n 	}\n \n-	return history->pos == NULL ? text : history->pos->data;\n+	return history->pos == NULL ? text : ((HISTORY_ENTRY_REC *)history->pos->data)->text;\n }\n \n-const char *command_history_next(WINDOW_REC *window, const char *text)\n+const char *command_history_prev(WINDOW_REC *window, const char *text)\n+{\n+	return command_history_prev_int(window, text, FALSE);\n+}\n+\n+const char *command_global_history_prev(WINDOW_REC *window, const char *text)\n+{\n+	return command_history_prev_int(window, text, TRUE);\n+}\n+\n+static const char *command_history_next_int(WINDOW_REC *window, const char *text, gboolean global)\n {\n 	HISTORY_REC *history;\n 	GList *pos;\n@@ -137,15 +230,26 @@ const char *command_history_next(WINDOW_REC *window, const char *text)\n 	history = command_history_current(window);\n 	pos = history->pos;\n \n-	if (pos != NULL)\n-		history->pos = history->pos->next;\n+	if (!(history->redo) && pos != NULL)\n+		history->pos = command_history_list_next(global ? NULL : history, history->pos);\n+	history->redo = 0;\n \n 	if (*text != \'\\0\' &&\n-	    (pos == NULL || g_strcmp0(pos->data, text) != 0)) {\n+	    (pos == NULL || g_strcmp0(((HISTORY_ENTRY_REC *)pos->data)->text, text) != 0)) {\n 		/* save the old entry to history */\n 		command_history_add(history, text);\n 	}\n-	return history->pos == NULL ? \"\" : history->pos->data;\n+	return history->pos == NULL ? \"\" : ((HISTORY_ENTRY_REC *)history->pos->data)->text;\n+}\n+\n+const char *command_history_next(WINDOW_REC *window, const char *text)\n+{\n+	return command_history_next_int(window, text, FALSE);\n+}\n+\n+const char *command_global_history_next(WINDOW_REC *window, const char *text)\n+{\n+	return command_history_next_int(window, text, TRUE);\n }\n \n void command_history_clear_pos_func(HISTORY_REC *history, gpointer user_data)\n@@ -175,12 +279,17 @@ HISTORY_REC *command_history_create(const char *name)\n \n void command_history_clear(HISTORY_REC *history)\n {\n+	GList *link, *next;\n+\n 	g_return_if_fail(history != NULL);\n \n 	command_history_clear_pos_func(history, NULL);\n-	g_list_foreach(history->list, (GFunc) g_free, NULL);\n-	g_list_free(history->list);\n-	history->list = NULL;\n+	link = command_history_list_first(history);\n+	while (link != NULL) {\n+		next = command_history_list_next(history, link);\n+		history_list_delete_link_and_destroy(link);\n+		link = next;\n+	}\n 	history->lines = 0;\n }\n \n@@ -264,8 +373,8 @@ static char *special_history_func(const char *text, void *item, int *free_ret)\n 	ret = NULL;\n \n 	history = command_history_current(window);\n-	for (tmp = history->list; tmp != NULL; tmp = tmp->next) {\n-		const char *line = tmp->data;\n+	for (tmp = command_history_list_first(history); tmp != NULL; tmp = command_history_list_next(history, tmp)) {\n+		const char *line = ((HISTORY_ENTRY_REC *)tmp->data)->text;\n \n 		if (match_wildcards(findtext, line)) {\n 			*free_ret = TRUE;\n@@ -289,6 +398,8 @@ void command_history_init(void)\n \n 	special_history_func_set(special_history_func);\n \n+	history_entries = NULL;\n+\n 	global_history = command_history_create(NULL);\n \n 	read_settings();\n@@ -308,4 +419,6 @@ void command_history_deinit(void)\n 	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);\n \n 	command_history_destroy(global_history);\n+\n+	g_list_free_full(history_entries, (GDestroyNotify) history_entry_destroy);\n }\n','false','false','none'),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list\n\nthis allows access to the global history even when a using /window history\nnamed or /set window_history on, and you want to recall something from one\nof the other windows\' histories.\n\nusage (default): ctrl+up/down','command-history.h','33','0','15','1','MODIFY','@@ -6,12 +6,19 @@\n typedef struct {\n 	char *name;\n \n-	GList *list, *pos;\n+	GList *pos;\n 	int lines;\n \n 	int refcount;\n+	int redo:1;\n } HISTORY_REC;\n \n+typedef struct {\n+	const char *text;\n+	HISTORY_REC *history;\n+	time_t time;\n+} HISTORY_ENTRY_REC;\n+\n HISTORY_REC *command_history_find(HISTORY_REC *history);\n HISTORY_REC *command_history_find_name(const char *name);\n \n@@ -22,8 +29,15 @@ void command_history_deinit(void);\n \n void command_history_add(HISTORY_REC *history, const char *text);\n \n+GList *command_history_list_last(HISTORY_REC *history);\n+GList *command_history_list_first(HISTORY_REC *history);\n+GList *command_history_list_prev(HISTORY_REC *history, GList *pos);\n+GList *command_history_list_next(HISTORY_REC *history, GList *pos);\n+\n const char *command_history_prev(WINDOW_REC *window, const char *text);\n const char *command_history_next(WINDOW_REC *window, const char *text);\n+const char *command_global_history_prev(WINDOW_REC *window, const char *text);\n+const char *command_global_history_next(WINDOW_REC *window, const char *text);\n \n void command_history_clear_pos(WINDOW_REC *window);\n \n','false','false','none'),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list\n\nthis allows access to the global history even when a using /window history\nnamed or /set window_history on, and you want to recall something from one\nof the other windows\' histories.\n\nusage (default): ctrl+up/down','gui-readline.c','1053','210','28','0','MODIFY','@@ -530,6 +530,28 @@ static void key_forward_history(void)\n         g_free(line);\n }\n \n+static void key_backward_global_history(void)\n+{\n+	const char *text;\n+	char *line;\n+\n+	line = gui_entry_get_text(active_entry);\n+	text = command_global_history_prev(active_win, line);\n+	gui_entry_set_text(active_entry, text);\n+	g_free(line);\n+}\n+\n+static void key_forward_global_history(void)\n+{\n+	const char *text;\n+	char *line;\n+\n+	line = gui_entry_get_text(active_entry);\n+	text = command_global_history_next(active_win, line);\n+	gui_entry_set_text(active_entry, text);\n+	g_free(line);\n+}\n+\n static void key_beginning_of_line(void)\n {\n         gui_entry_set_pos(active_entry, 0);\n@@ -1176,6 +1198,8 @@ void gui_readline_init(void)\n 	key_bind(\"key\", NULL, \"meta2-5C\", \"cright\", (SIGNAL_FUNC) key_combo);\n 	key_bind(\"key\", NULL, \"meta2-1;5D\", \"cleft\", (SIGNAL_FUNC) key_combo);\n 	key_bind(\"key\", NULL, \"meta2-1;5C\", \"cright\", (SIGNAL_FUNC) key_combo);\n+	key_bind(\"key\", NULL, \"meta2-1;5A\", \"cup\", (SIGNAL_FUNC) key_combo);\n+	key_bind(\"key\", NULL, \"meta2-1;5B\", \"cdown\", (SIGNAL_FUNC) key_combo);\n \n 	key_bind(\"key\", NULL, \"meta2-1;3A\", \"mup\", (SIGNAL_FUNC) key_combo);\n 	key_bind(\"key\", NULL, \"meta2-1;3B\", \"mdown\", (SIGNAL_FUNC) key_combo);\n@@ -1217,6 +1241,8 @@ void gui_readline_init(void)\n         /* history */\n 	key_bind(\"backward_history\", \"Go back one line in the history\", \"up\", NULL, (SIGNAL_FUNC) key_backward_history);\n 	key_bind(\"forward_history\", \"Go forward one line in the history\", \"down\", NULL, (SIGNAL_FUNC) key_forward_history);\n+	key_bind(\"backward_global_history\", \"Go back one line in the global history\", \"cup\", NULL, (SIGNAL_FUNC) key_backward_global_history);\n+	key_bind(\"forward_global_history\", \"Go forward one line in the global history\", \"cdown\", NULL, (SIGNAL_FUNC) key_forward_global_history);\n \n         /* line editing */\n 	key_bind(\"backspace\", \"Delete the previous character\", \"backspace\", NULL, (SIGNAL_FUNC) key_backspace);\n@@ -1310,6 +1336,8 @@ void gui_readline_deinit(void)\n \n 	key_unbind(\"backward_history\", (SIGNAL_FUNC) key_backward_history);\n 	key_unbind(\"forward_history\", (SIGNAL_FUNC) key_forward_history);\n+	key_unbind(\"backward_global_history\", (SIGNAL_FUNC) key_backward_global_history);\n+	key_unbind(\"forward_global_history\", (SIGNAL_FUNC) key_forward_global_history);\n \n 	key_unbind(\"backspace\", (SIGNAL_FUNC) key_backspace);\n 	key_unbind(\"delete_character\", (SIGNAL_FUNC) key_delete_character);\n','false','false','none'),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list\n\nthis allows access to the global history even when a using /window history\nnamed or /set window_history on, and you want to recall something from one\nof the other windows\' histories.\n\nusage (default): ctrl+up/down','Window.xs','248','2','3','2','MODIFY','@@ -252,8 +252,9 @@ PREINIT:\n 	GList *tmp;\n PPCODE:\n 	rec = command_history_current(window);\n-	for (tmp = rec->list; tmp != NULL; tmp = tmp->next)\n-		XPUSHs(sv_2mortal(new_pv(tmp->data)));\n+	for (tmp = command_history_list_first(rec); tmp != NULL; tmp = command_history_list_next(rec, tmp))\n+		XPUSHs(sv_2mortal(new_pv(((HISTORY_ENTRY_REC *)tmp->data)->text)));\n+\n \n #*******************************\n MODULE = Irssi::UI::Window  PACKAGE = Irssi::Windowitem  PREFIX = window_item_\n','false','false','none'),('irssi','1.0.4','16d68a86ca75b73c53aa81fe6d3d36361cb35b99','ailin-nemui','add two xsfuncs to manipulate command history entries\n\nit is possible to use irssi::ui::window::get_history_entries to save the\nhistory entries, load_history_entries to load entries into the command\nhistory and delete_history_entries to remove history entries (for example\nto remove history selectively)','command-history.c','351','96','55','0','MODIFY','@@ -168,6 +168,61 @@ HISTORY_REC *command_history_find_name(const char *name)\n 	return NULL;\n }\n \n+static int history_entry_after_time_sort(const HISTORY_ENTRY_REC *a, const HISTORY_ENTRY_REC *b)\n+{\n+	return a->time == b->time ? 1 : a->time - b->time;\n+}\n+\n+void command_history_load_entry(time_t history_time, HISTORY_REC *history, const char *text)\n+{\n+	HISTORY_ENTRY_REC *entry;\n+\n+	g_return_if_fail(history != NULL);\n+	g_return_if_fail(text != NULL);\n+\n+	entry = g_new0(HISTORY_ENTRY_REC, 1);\n+	entry->text = g_strdup(text);\n+	entry->history = history;\n+	entry->time = history_time;\n+\n+	history->lines++;\n+\n+	history_entries = g_list_insert_sorted(history_entries, entry, (GCompareFunc)history_entry_after_time_sort);\n+}\n+\n+static int history_entry_find_func(const HISTORY_ENTRY_REC *data, const HISTORY_ENTRY_REC *user_data)\n+{\n+	if ((user_data->time == -1 || (data->time == user_data->time)) &&\n+	    (user_data->history == NULL || (data->history == user_data->history)) &&\n+	    g_strcmp0(data->text, user_data->text) == 0) {\n+		return 0;\n+	} else {\n+		return -1;\n+	}\n+}\n+\n+gboolean command_history_delete_entry(time_t history_time, HISTORY_REC *history, const char *text)\n+{\n+	GList *link;\n+	HISTORY_ENTRY_REC entry;\n+\n+	g_return_val_if_fail(history != NULL, FALSE);\n+	g_return_val_if_fail(text != NULL, FALSE);\n+\n+	entry.text = text;\n+	entry.history = history;\n+	entry.time = history_time;\n+\n+	link = g_list_find_custom(history_entries, &entry, (GCompareFunc)history_entry_find_func);\n+	if (link != NULL) {\n+		((HISTORY_ENTRY_REC *)link->data)->history->lines--;\n+		history_list_delete_link_and_destroy(link);\n+		return TRUE;\n+	} else {\n+		return FALSE;\n+	}\n+}\n+\n HISTORY_REC *command_history_current(WINDOW_REC *window)\n {\n 	HISTORY_REC *rec;\n','false','false','none'),('irssi','1.0.4','16d68a86ca75b73c53aa81fe6d3d36361cb35b99','ailin-nemui','add two xsfuncs to manipulate command history entries\n\nit is possible to use irssi::ui::window::get_history_entries to save the\nhistory entries, load_history_entries to load entries into the command\nhistory and delete_history_entries to remove history entries (for example\nto remove history selectively)','command-history.h','35','0','2','0','MODIFY','@@ -28,6 +28,8 @@ void command_history_init(void);\n void command_history_deinit(void);\n \n void command_history_add(HISTORY_REC *history, const char *text);\n+void command_history_load_entry(time_t time, HISTORY_REC *history, const char *text);\n+gboolean command_history_delete_entry(time_t history_time, HISTORY_REC *history, const char *text);\n \n GList *command_history_list_last(HISTORY_REC *history);\n GList *command_history_list_first(HISTORY_REC *history);\n','false','false','none'),('irssi','1.0.4','16d68a86ca75b73c53aa81fe6d3d36361cb35b99','ailin-nemui','add two xsfuncs to manipulate command history entries\n\nit is possible to use irssi::ui::window::get_history_entries to save the\nhistory entries, load_history_entries to load entries into the command\nhistory and delete_history_entries to remove history entries (for example\nto remove history selectively)','Window.xs','377','35','139','0','MODIFY','@@ -255,6 +255,145 @@ PPCODE:\n 	for (tmp = command_history_list_first(rec); tmp != NULL; tmp = command_history_list_next(rec, tmp))\n 		XPUSHs(sv_2mortal(new_pv(((HISTORY_ENTRY_REC *)tmp->data)->text)));\n \n+void\n+window_get_history_entries(window)\n+	Irssi::UI::Window window\n+PREINIT:\n+	HISTORY_REC *rec;\n+	HISTORY_ENTRY_REC *ent;\n+	WINDOW_REC *win;\n+	GList *tmp;\n+	GSList *stmp;\n+	HV *hv;\n+PPCODE:\n+	rec = window == NULL ? NULL : command_history_current(window);\n+	for (tmp = command_history_list_first(rec); tmp != NULL; tmp = command_history_list_next(rec, tmp)) {\n+		hv = (HV*)sv_2mortal((SV*)newHV());\n+		ent = tmp->data;\n+		hv_store(hv, \"text\", 4, newSVpv(ent->text, 0), 0);\n+		hv_store(hv, \"time\", 4, newSViv(ent->time), 0);\n+		if (ent->history == command_history_current(NULL)) {\n+			hv_store(hv, \"history\", 7, newSV(0), 0);\n+			hv_store(hv, \"window\", 6, newSV(0), 0);\n+		} else {\n+			if (ent->history->name == NULL) {\n+				hv_store(hv, \"history\", 7, newSV(0), 0);\n+				for (stmp = windows; stmp != NULL; stmp = stmp->next) {\n+					win = stmp->data;\n+					if (win->history == ent->history) {\n+						hv_store(hv, \"window\", 6, newSViv(win->refnum), 0);\n+						break;\n+					}\n+				}\n+			} else {\n+				hv_store(hv, \"history\", 7, new_pv(ent->history->name), 0);\n+				hv_store(hv, \"window\", 6, newSV(0), 0);\n+			}\n+		}\n+		XPUSHs(sv_2mortal(newRV_inc((SV*)hv)));\n+	}\n+\n+void\n+window_load_history_entries(window, ...)\n+	Irssi::UI::Window window\n+PREINIT:\n+	HV *hv;\n+	SV **sv;\n+	HISTORY_REC *history;\n+	WINDOW_REC *tmp;\n+	const char *text;\n+	long hist_time;\n+	int i;\n+PPCODE:\n+	for (i = 1; i < items; i++) {\n+		if (!is_hvref(ST(i))) {\n+			croak(\"Usage: Irssi::UI::Window::load_history_entries(window, hash...)\");\n+		}\n+		hv = hvref(ST(i));\n+		if (hv != NULL) {\n+			tmp = NULL;\n+			text = NULL;\n+			hist_time = time(NULL);\n+			history = command_history_current(NULL);\n+\n+			sv = hv_fetch(hv, \"text\", 4, 0);\n+			if (sv != NULL) text = SvPV_nolen(*sv);\n+			sv = hv_fetch(hv, \"time\", 4, 0);\n+			if (sv != NULL && SvOK(*sv)) hist_time = SvIV(*sv);\n+\n+			if (window != NULL) {\n+				history = command_history_current(window);\n+			} else {\n+				sv = hv_fetch(hv, \"history\", 7, 0);\n+				if (sv != NULL && SvOK(*sv)) {\n+					history = command_history_find_name(SvPV_nolen(*sv));\n+				}\n+\n+				sv = hv_fetch(hv, \"window\", 6, 0);\n+				if (sv != NULL && SvOK(*sv)) {\n+					tmp = window_find_refnum(SvIV(*sv));\n+					if (tmp != NULL) {\n+						history = tmp->history;\n+					}\n+				}\n+			}\n+\n+			if (text != NULL && history != NULL) {\n+				command_history_load_entry(hist_time, history, text);\n+			}\n+		}\n+	}\n+\n+void\n+window_delete_history_entries(window, ...)\n+	Irssi::UI::Window window\n+PREINIT:\n+	HV *hv;\n+	SV **sv;\n+	HISTORY_REC *history;\n+	WINDOW_REC *tmp;\n+	const char *text;\n+	long hist_time;\n+	int i;\n+PPCODE:\n+	for (i = 1; i < items; i++) {\n+		if (!is_hvref(ST(i))) {\n+			croak(\"Usage: Irssi::UI::Window::delete_history_entries(window, hash...)\");\n+		}\n+		hv = hvref(ST(i));\n+		if (hv != NULL) {\n+			tmp = NULL;\n+			text = NULL;\n+			hist_time = -1;\n+			history = command_history_current(NULL);\n+\n+			sv = hv_fetch(hv, \"text\", 4, 0);\n+			if (sv != NULL) text = SvPV_nolen(*sv);\n+			sv = hv_fetch(hv, \"time\", 4, 0);\n+			if (sv != NULL && SvOK(*sv)) hist_time = SvIV(*sv);\n+\n+			if (window != NULL) {\n+				history = command_history_current(window);\n+			} else {\n+				sv = hv_fetch(hv, \"history\", 7, 0);\n+				if (sv != NULL && SvOK(*sv)) {\n+					history = command_history_find_name(SvPV_nolen(*sv));\n+				}\n+\n+				sv = hv_fetch(hv, \"window\", 6, 0);\n+				if (sv != NULL && SvOK(*sv)) {\n+					tmp = window_find_refnum(SvIV(*sv));\n+					if (tmp != NULL) {\n+						history = tmp->history;\n+					}\n+				}\n+			}\n+\n+			if (text != NULL && history != NULL) {\n+				XPUSHs(boolSV(command_history_delete_entry(hist_time, history, text)));\n+			}\n+		}\n+	}\n \n #*******************************\n MODULE = Irssi::UI::Window  PACKAGE = Irssi::Windowitem  PREFIX = window_item_\n','false','false','none'),('irssi','1.0.4','deac66f33c0fb1d6914d15ce63bde3f030a9c06d','ailin-nemui','add a key binding to erase history entries\n\nit is possible to delete the current history entry using the\nerase_history_entry key binding','command-history.c','364','100','17','0','MODIFY','@@ -307,6 +307,23 @@ const char *command_global_history_next(WINDOW_REC *window, const char *text)\n 	return command_history_next_int(window, text, TRUE);\n }\n \n+const char *command_history_delete_current(WINDOW_REC *window, const char *text)\n+{\n+	HISTORY_REC *history;\n+	GList *pos;\n+\n+	history = command_history_current(window);\n+	pos = history->pos;\n+\n+	if (pos != NULL && g_strcmp0(((HISTORY_ENTRY_REC *)pos->data)->text, text) == 0) {\n+		((HISTORY_ENTRY_REC *)pos->data)->history->lines--;\n+		history_list_delete_link_and_destroy(pos);\n+	}\n+\n+	history->redo = 0;\n+	return history->pos == NULL ? \"\" : ((HISTORY_ENTRY_REC *)history->pos->data)->text;\n+}\n+\n void command_history_clear_pos_func(HISTORY_REC *history, gpointer user_data)\n {\n 	history->pos = NULL;\n','false','false','none'),('irssi','1.0.4','deac66f33c0fb1d6914d15ce63bde3f030a9c06d','ailin-nemui','add a key binding to erase history entries\n\nit is possible to delete the current history entry using the\nerase_history_entry key binding','command-history.h','36','0','1','0','MODIFY','@@ -40,6 +40,7 @@ const char *command_history_prev(WINDOW_REC *window, const char *text);\n const char *command_history_next(WINDOW_REC *window, const char *text);\n const char *command_global_history_prev(WINDOW_REC *window, const char *text);\n const char *command_global_history_next(WINDOW_REC *window, const char *text);\n+const char *command_history_delete_current(WINDOW_REC *window, const char *text);\n \n void command_history_clear_pos(WINDOW_REC *window);\n \n','false','false','none'),('irssi','1.0.4','deac66f33c0fb1d6914d15ce63bde3f030a9c06d','ailin-nemui','add a key binding to erase history entries\n\nit is possible to delete the current history entry using the\nerase_history_entry key binding','gui-readline.c','1064','211','13','0','MODIFY','@@ -552,6 +552,17 @@ static void key_forward_global_history(void)\n 	g_free(line);\n }\n \n+static void key_erase_history_entry(void)\n+{\n+	const char *text;\n+	char *line;\n+\n+	line = gui_entry_get_text(active_entry);\n+	text = command_history_delete_current(active_win, line);\n+	gui_entry_set_text(active_entry, text);\n+	g_free(line);\n+}\n+\n static void key_beginning_of_line(void)\n {\n         gui_entry_set_pos(active_entry, 0);\n@@ -1243,6 +1254,7 @@ void gui_readline_init(void)\n 	key_bind(\"forward_history\", \"Go forward one line in the history\", \"down\", NULL, (SIGNAL_FUNC) key_forward_history);\n 	key_bind(\"backward_global_history\", \"Go back one line in the global history\", \"cup\", NULL, (SIGNAL_FUNC) key_backward_global_history);\n 	key_bind(\"forward_global_history\", \"Go forward one line in the global history\", \"cdown\", NULL, (SIGNAL_FUNC) key_forward_global_history);\n+	key_bind(\"erase_history_entry\", \"Erase the currently active entry from the history\", NULL, NULL, (SIGNAL_FUNC) key_erase_history_entry);\n \n         /* line editing */\n 	key_bind(\"backspace\", \"Delete the previous character\", \"backspace\", NULL, (SIGNAL_FUNC) key_backspace);\n@@ -1338,6 +1350,7 @@ void gui_readline_deinit(void)\n 	key_unbind(\"forward_history\", (SIGNAL_FUNC) key_forward_history);\n 	key_unbind(\"backward_global_history\", (SIGNAL_FUNC) key_backward_global_history);\n 	key_unbind(\"forward_global_history\", (SIGNAL_FUNC) key_forward_global_history);\n+	key_unbind(\"erase_history_entry\", (SIGNAL_FUNC) key_erase_history_entry);\n \n 	key_unbind(\"backspace\", (SIGNAL_FUNC) key_backspace);\n 	key_unbind(\"delete_character\", (SIGNAL_FUNC) key_delete_character);\n','false','false','none'),('irssi','1.0.4','5da0b73a12b3b319a2c7d6b18657ec13d52b6476','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@\n #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */\n #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */\n \n-#define IRSSI_ABI_VERSION 11\n+#define IRSSI_ABI_VERSION 12\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n #define DEFAULT_SERVER_ADD_TLS_PORT 6697\n','false','false','none'),('irssi','1.0.4','40ae8f5fa67cb7ec529f9fea5816fb8804c9bba8','Edward Tomasz Napierala','limit capsicum rights to stdio.\n\nthis requires freebsd fix (https://reviews.freebsd.org/d12622)\nto work properly.','capsicum.c','347','70','8','0','MODIFY','@@ -37,6 +37,7 @@\n #include <sys/nv.h>\n #include <sys/procdesc.h>\n #include <sys/socket.h>\n+#include <capsicum_helpers.h>\n #include <string.h>\n \n #define	OPCODE_CONNECT		1\n@@ -410,6 +411,13 @@ static void cmd_capsicum_enter(void)\n 	 */\n 	signal(SIGCHLD, SIG_IGN);\n \n+	error = caph_limit_stdio();\n+	if (error != 0) {\n+		g_warning(\"caph_limit_stdio(3) failed: %s\", strerror(errno));\n+		signal_emit(\"capability mode failed\", 1, strerror(errno));\n+		return;\n+	}\n+\n 	error = cap_enter();\n 	if (error != 0) {\n 		signal_emit(\"capability mode failed\", 1, strerror(errno));\n','false','true','none'),('irssi','1.0.4','00c80cb6fcca40cfc421fe3fc181115ac4907191','ailin-nemui','fix out of bounds read in compress_colors\n\nreported by hanno böck.\n\nfixes gl#12','themes.c','1125','277','6','1','MODIFY','@@ -587,7 +587,7 @@ static char *theme_format_compress_colors(THEME_REC *theme, const char *format)\n 			/* a normal character */\n 			g_string_append_c(str, *format);\n 			format++;\n-		} else {\n+		} else if (format[1] != \'\\0\') {\n 			/* %format */\n 			format++;\n 			if (IS_OLD_FORMAT(*format, last_fg, last_bg)) {\n@@ -614,6 +614,11 @@ static char *theme_format_compress_colors(THEME_REC *theme, const char *format)\n 					last_bg = \'\\0\';\n 			}\n 			format++;\n+		} else {\n+			/* % at end of string */\n+			format++;\n+			g_string_append_c(str, \'%\');\n+			g_string_append_c(str, \'%\');\n 		}\n 	}\n \n','true','false','none'),('irssi','1.0.4','49ace3251b79a9e97c6e4d0bc640f9143dc71b90','ailin-nemui','fix uaf in chanquery module\n\nthe chanquery needs to be removed in any case if a channel rec is\ndestroyed, regardless of any state\n\nfixes gl#13','channels-query.c','342','69','3','3','MODIFY','@@ -125,15 +125,15 @@ static void query_remove_all(IRC_CHANNEL_REC *channel)\n 		rec->queries[n] = g_slist_remove(rec->queries[n], channel);\n 	rec->current_queries = g_slist_remove(rec->current_queries, channel);\n \n-	query_check(channel->server);\n+	if (!channel->server->disconnected)\n+		query_check(channel->server);\n }\n \n static void sig_channel_destroyed(IRC_CHANNEL_REC *channel)\n {\n 	g_return_if_fail(channel != NULL);\n \n-	if (IS_IRC_CHANNEL(channel) && !channel->server->disconnected &&\n-	    !channel->synced)\n+	if (IS_IRC_CHANNEL(channel))\n 		query_remove_all(channel);\n }\n \n','true','false','none'),('irssi','1.0.4','2edd816e7db13b4ac0b20df9bf7fe55ee7718215','Joseph Bisch','fix segfault in query_remove_all\n\nit is possible for rec to be null in query_remove_all, resulting in a\nsegfault. so return without doing anything if rec is null.','channels-query.c','343','70','1','0','MODIFY','@@ -119,6 +119,7 @@ static void query_remove_all(IRC_CHANNEL_REC *channel)\n 	int n;\n \n 	rec = channel->server->chanqueries;\n+	if (rec == NULL) return;\n \n 	/* remove channel from query lists */\n 	for (n = 0; n < CHANNEL_QUERIES; n++)\n','true','false','none'),('irssi','1.0.4','4ccff71f678f79da71713a29d8528812379bb584','Will Storey','set host to an empty string on error\n\nwhile investigating #317, i noticed that it was possible we would access\nan uninitialized buffer due to failing to check the return value of\nnet_ip2host(). this is done in several places. to make such uses safe,\nset the host buffer to an empty string on error. it is possible callers\ncould be improved by handling the error in each spot, but this gives us\nsome safety.','network.c','394','104','10','1','MODIFY','@@ -489,7 +489,16 @@ int net_gethostbyaddr(IPADDR *ip, char **name)\n \n int net_ip2host(IPADDR *ip, char *host)\n {\n-	return inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN) ? 0 : -1;\n+	if (inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN)) {\n+		return 0;\n+	}\n+\n+	// For callers that do not check our return value and pass in an\n+	// uninitialized buffer assuming it will be set, ensure the buffer is a valid\n+	// string. Ideally callers should check what we return and handle\n+	// appropriately, but this at least gives us safety.\n+	host[0] = \'\\0\';\n+	return -1;\n }\n \n int net_host2ip(const char *host, IPADDR *ip)\n','true','false','none'),('irssi','1.0.4','cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d','Will Storey','delete unused function net_ip_compare()','network.c','382','101','0','12','MODIFY','@@ -60,18 +60,6 @@ IPADDR ip4_any = {\n #endif\n };\n \n-int net_ip_compare(IPADDR *ip1, IPADDR *ip2)\n-{\n-	if (ip1->family != ip2->family)\n-		return 0;\n-\n-	if (ip1->family == AF_INET6)\n-		return memcmp(&ip1->ip, &ip2->ip, sizeof(ip1->ip)) == 0;\n-\n-	return memcmp(&ip1->ip, &ip2->ip, 4) == 0;\n-}\n-\n-\n static void sin_set_ip(union sockaddr_union *so, const IPADDR *ip)\n {\n 	if (ip == NULL) {\n','false','false','none'),('irssi','1.0.4','cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d','Will Storey','delete unused function net_ip_compare()','network.h','35','0','0','3','MODIFY','@@ -33,9 +33,6 @@ extern IPADDR ip4_any;\n \n GIOChannel *g_io_channel_new(int handle);\n \n-/* returns 1 if IPADDRs are the same */\n-int net_ip_compare(IPADDR *ip1, IPADDR *ip2);\n-\n int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);\n \n /* Connect to socket */\n','false','false','none'),('irssi','1.0.4','3b3939b146bb2f80182d572a2afc08ba405037a1','Will Storey','delete commented out cygwin define','network.c','382','101','0','3','MODIFY','@@ -48,9 +48,6 @@ GIOChannel *g_io_channel_new(int handle)\n 	return chan;\n }\n \n-/* Cygwin need this, don\'t know others.. */\n-/*#define BLOCKING_SOCKETS 1*/\n-\n IPADDR ip4_any = {\n 	AF_INET,\n #if defined(IN6ADDR_ANY_INIT)\n','false','false','none'),('irssi','1.0.4','b8b90c76d4ea87d7e50c2a34fbc36ab732e3e89e','Will Storey','delete unused function net_connect()','network.c','357','94','0','34','MODIFY','@@ -98,40 +98,6 @@ static int sin_get_port(union sockaddr_union *so)\n 		     so->sin.sin_port);\n }\n \n-/* Connect to socket */\n-GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip)\n-{\n-	IPADDR ip4, ip6, *ip;\n-\n-	g_return_val_if_fail(addr != NULL, NULL);\n-\n-	if (net_gethostbyname(addr, &ip4, &ip6) == -1)\n-		return NULL;\n-\n-	if (my_ip == NULL) {\n-                /* prefer IPv4 addresses */\n-		ip = ip4.family != 0 ? &ip4 : &ip6;\n-	} else if (IPADDR_IS_V6(my_ip)) {\n-                /* my_ip is IPv6 address, use it if possible */\n-		if (ip6.family != 0)\n-			ip = &ip6;\n-		else {\n-			my_ip = NULL;\n-                        ip = &ip4;\n-		}\n-	} else {\n-                /* my_ip is IPv4 address, use it if possible */\n-		if (ip4.family != 0)\n-			ip = &ip4;\n-		else {\n-			my_ip = NULL;\n-                        ip = &ip6;\n-		}\n-	}\n-\n-	return net_connect_ip(ip, port, my_ip);\n-}\n-\n int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip)\n {\n 	union sockaddr_union so;\n','false','false','none'),('irssi','1.0.4','b8b90c76d4ea87d7e50c2a34fbc36ab732e3e89e','Will Storey','delete unused function net_connect()','network.h','34','0','0','2','MODIFY','@@ -35,8 +35,6 @@ GIOChannel *g_io_channel_new(int handle);\n \n int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);\n \n-/* Connect to socket */\n-GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED;\n /* Connect to socket with ip address and SSL*/\n GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server);\n /* Start TLS */\n','false','false','none'),('irssi','1.0.4','174adee9dd91c23615f79b979b3b3c5f72ad1240','Will Storey','always initialize the host string\n\nthis also removes a wordy comment','network.c','391','104','1','9','MODIFY','@@ -489,16 +489,8 @@ int net_gethostbyaddr(IPADDR *ip, char **name)\n \n int net_ip2host(IPADDR *ip, char *host)\n {\n-	if (inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN)) {\n-		return 0;\n-	}\n-\n-	// For callers that do not check our return value and pass in an\n-	// uninitialized buffer assuming it will be set, ensure the buffer is a valid\n-	// string. Ideally callers should check what we return and handle\n-	// appropriately, but this at least gives us safety.\n 	host[0] = \'\\0\';\n-	return -1;\n+	return inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN) ? 0 : -1;\n }\n \n int net_host2ip(const char *host, IPADDR *ip)\n','false','false','none'),('irssi','1.0.4','17b195021dc35b95b24c1cce6f2e891e0e6b85ec','Edward Tomasz Napierala','bump default capsicum_port_max to 9999.\n\nthis is needed for servers like ssl.efnet.org, which, per default\nconfig, listen on 9999.','capsicum.c','347','70','1','1','MODIFY','@@ -452,7 +452,7 @@ void capsicum_init(void)\n 	settings_add_bool(\"misc\", \"capsicum\", FALSE);\n 	settings_add_str(\"misc\", \"capsicum_irclogs_path\", \"~/irclogs\");\n 	settings_add_int(\"misc\", \"capsicum_port_min\", 6667);\n-	settings_add_int(\"misc\", \"capsicum_port_max\", 6697);\n+	settings_add_int(\"misc\", \"capsicum_port_max\", 9999);\n \n 	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n \n','false','false','none'),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','add alternate_nick as a network-specific property.','network.in','54','0','1','0','MODIFY','@@ -11,6 +11,7 @@\n     REMOVE:          Removes a network from your configuration.\n \n     -nick:           Specifies the nickname to use.\n+    -alternate_nick  Specifies the alternate nickname to use.\n     -user:           Specifies the user identity to use.\n     -realname:       Specifies the real name to use.\n     -host:           Specifies the hostname to use.\n','false','false','none'),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','add alternate_nick as a network-specific property.','chatnet-rec.h','10','0','1','0','MODIFY','@@ -4,6 +4,7 @@ int chat_type; /* chat_protocol_lookup(xx) */\n char *name;\n \n char *nick;\n+char *alternate_nick;\n char *username;\n char *realname;\n \n','false','false','none'),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','add alternate_nick as a network-specific property.','fe-ircnet.c','191','72','8','3','MODIFY','@@ -48,6 +48,8 @@ static void cmd_network_list(void)\n 		g_string_truncate(str, 0);\n 		if (rec->nick != NULL)\n 			g_string_append_printf(str, \"nick: %s, \", rec->nick);\n+		if (rec->alternate_nick != NULL)\n+			g_string_append_printf(str, \"alternate_nick: %s, \", rec->alternate_nick);\n 		if (rec->username != NULL)\n 			g_string_append_printf(str, \"username: %s, \", rec->username);\n 		if (rec->realname != NULL)\n@@ -114,6 +116,7 @@ static void cmd_network_add_modify(const char *data, gboolean add)\n 		rec->name = g_strdup(name);\n 	} else {\n 		if (g_hash_table_lookup(optlist, \"nick\")) g_free_and_null(rec->nick);\n+		if (g_hash_table_lookup(optlist, \"alternate_nick\")) g_free_and_null(rec->alternate_nick);\n 		if (g_hash_table_lookup(optlist, \"user\")) g_free_and_null(rec->username);\n 		if (g_hash_table_lookup(optlist, \"realname\")) g_free_and_null(rec->realname);\n 		if (g_hash_table_lookup(optlist, \"host\")) {\n@@ -145,6 +148,8 @@ static void cmd_network_add_modify(const char *data, gboolean add)\n \n 	value = g_hash_table_lookup(optlist, \"nick\");\n 	if (value != NULL && *value != \'\\0\') rec->nick = g_strdup(value);\n+	value = g_hash_table_lookup(optlist, \"alternate_nick\");\n+	if (value != NULL && *value != \'\\0\') rec->alternate_nick = g_strdup(value);\n 	value = g_hash_table_lookup(optlist, \"user\");\n 	if (value != NULL && *value != \'\\0\') rec->username = g_strdup(value);\n 	value = g_hash_table_lookup(optlist, \"realname\");\n@@ -175,7 +180,7 @@ static void cmd_network_add_modify(const char *data, gboolean add)\n 	cmd_params_free(free_arg);\n }\n \n-/* SYNTAX: NETWORK ADD|MODIFY [-nick <nick>] [-user <user>] [-realname <name>]\n+/* SYNTAX: NETWORK ADD|MODIFY [-nick <nick>] [-alternate_nick <nick>] [-user <user>] [-realname <name>]\n                               [-host <host>] [-usermode <mode>] [-autosendcmd <cmd>]\n                               [-querychans <count>] [-whois <count>] [-msgs <count>]\n                               [-kicks <count>] [-modes <count>] [-cmdspeed <ms>]\n@@ -228,9 +233,9 @@ void fe_ircnet_init(void)\n 	command_bind(\"network remove\", NULL, (SIGNAL_FUNC) cmd_network_remove);\n \n 	command_set_options(\"network add\", \"-kicks -msgs -modes -whois -cmdspeed \"\n-			    \"-cmdmax -nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\");\n+			    \"-cmdmax -nick -alternate_nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\");\n 	command_set_options(\"network modify\", \"-kicks -msgs -modes -whois -cmdspeed \"\n-			    \"-cmdmax -nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\");\n+			    \"-cmdmax -nick -alternate_nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\");\n }\n \n void fe_ircnet_deinit(void)\n','false','false','none'),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','add alternate_nick as a network-specific property.','irc-servers-setup.c','153','53','8','1','MODIFY','@@ -69,7 +69,14 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n 		return;\n 	g_return_if_fail(IS_IRCNET(ircnet));\n \n-	if (ircnet->nick != NULL) g_free_and_null(conn->alternate_nick);\n+	if (ircnet->nick != NULL) {\n+		g_free_and_null(conn->nick);\n+		conn->nick = g_strdup(ircnet->nick);\n+	}\n+	if (ircnet->alternate_nick != NULL) {\n+		g_free_and_null(conn->alternate_nick);\n+		conn->alternate_nick = g_strdup(ircnet->alternate_nick);\n+	}\n 	if (ircnet->usermode != NULL) {\n 		g_free_and_null(conn->usermode);\n 		conn->usermode = g_strdup(ircnet->usermode);\n','false','false','none'),('irssi','1.0.4','1e66cbd62e231f8ae47589cf4f1c0c6c62bb7ca8','Edward Tomasz Napierala','improve capsicum stdio limits to fix terminal state on exit.','capsicum.c','368','76','35','3','MODIFY','@@ -360,6 +360,38 @@ static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)\n 	command_runsub(\"capsicum\", data, server, item);\n }\n \n+/*\n+ * The main difference between this and caph_limit_stdio(3) is that this\n+ * one permits TIOCSETAW, which is requred for restoring the terminal state\n+ * on exit.\n+ */\n+static int\n+limit_stdio_fd(int fd)\n+{\n+	cap_rights_t rights;\n+	unsigned long cmds[] = { TIOCGETA, TIOCGWINSZ, TIOCSETAW, FIODTYPE };\n+\n+	cap_rights_init(&rights, CAP_READ, CAP_WRITE, CAP_EVENT, CAP_FCNTL,\n+	    CAP_FSTAT, CAP_IOCTL, CAP_SEEK);\n+\n+	if (cap_rights_limit(fd, &rights) < 0) {\n+		g_warning(\"cap_rights_limit(3) failed: %s\", strerror(errno));\n+		return (-1);\n+	}\n+\n+	if (cap_ioctls_limit(fd, cmds, nitems(cmds)) < 0) {\n+		g_warning(\"cap_ioctls_limit(3) failed: %s\", strerror(errno));\n+		return (-1);\n+	}\n+\n+	if (cap_fcntls_limit(fd, CAP_FCNTL_GETFL) < 0) {\n+		g_warning(\"cap_fcntls_limit(3) failed: %s\", strerror(errno));\n+		return (-1);\n+	}\n+\n+	return (0);\n+}\n+\n static void cmd_capsicum_enter(void)\n {\n 	u_int mode;\n@@ -411,9 +443,9 @@ static void cmd_capsicum_enter(void)\n 	 */\n 	signal(SIGCHLD, SIG_IGN);\n \n-	error = caph_limit_stdio();\n-	if (error != 0) {\n-		g_warning(\"caph_limit_stdio(3) failed: %s\", strerror(errno));\n+	if (limit_stdio_fd(STDIN_FILENO) != 0 ||\n+	    limit_stdio_fd(STDOUT_FILENO) != 0 ||\n+	    limit_stdio_fd(STDERR_FILENO) != 0) {\n 		signal_emit(\"capability mode failed\", 1, strerror(errno));\n 		return;\n 	}\n','true','false','none'),('irssi','1.0.4','5c0b4aeb0572827877654b65bb05fb7b37a3117a','Edward Tomasz Napierala','sort capsicum headers.','capsicum.c','369','76','3','2','MODIFY','@@ -32,13 +32,14 @@\n #include \"settings.h\"\n #include \"signals.h\"\n \n-#include <sys/types.h>\n+#include <sys/param.h>\n #include <sys/capsicum.h>\n+#include <sys/filio.h>\n #include <sys/nv.h>\n #include <sys/procdesc.h>\n #include <sys/socket.h>\n-#include <capsicum_helpers.h>\n #include <string.h>\n+#include <termios.h>\n \n #define	OPCODE_CONNECT		1\n #define	OPCODE_GETHOSTBYNAME	2\n','false','false','none'),('irssi','1.0.4','9895e7b28a3767bbe4430cbffd3662b4ef92b37f','Edward Tomasz Napierala','silence down a warning that would appear on \"/away\" in capability mode.','capsicum.c','371','77','4','0','MODIFY','@@ -183,6 +183,10 @@ void capsicum_mkdir_with_parents(const char *path, int mode)\n 	char *component, *copy, *tofree;\n 	int error, fd, newfd;\n \n+	/* The directory already exists, nothing to do. */\n+	if (strcmp(path, irclogs_path) == 0)\n+		return;\n+\n 	/* +1 is for the slash separating irclogs_path and the rest. */\n 	if (strlen(path) <= irclogs_path_len + 1 ||\n 	    path[irclogs_path_len] != \'/\' ||\n','false','false','none'),('irssi','1.0.4','711b2d7df7da4a3010214909ed1b260c55f6befa','Edward Tomasz Napierala','document that one needs to change the awaylog_file path for \"/away\"\nto work with capsicum.','capsicum.txt','25','0','1','0','MODIFY','@@ -7,6 +7,7 @@ or the libraries it depends on.\n To make Irssi enter capability mode on startup, add\n \n capsicum = \"yes\";\n+awaylog_file = \"~/irclogs/away.log\";\n \n to your ~/.irssi/config and restart the client.  Alternatively you can\n enter it \"by hand\", using the \"/capsicum enter\" command.  From the security\n','false','false','none'),('irssi','1.0.4','da59fd7c2dd0641f623db2c67a244ddca3013d65','Will Storey','revert \"delete unused function net_ip_compare()\"\n\nthis reverts commit cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d.','network.c','365','97','12','0','MODIFY','@@ -57,6 +57,18 @@ IPADDR ip4_any = {\n #endif\n };\n \n+int net_ip_compare(IPADDR *ip1, IPADDR *ip2)\n+{\n+	if (ip1->family != ip2->family)\n+		return 0;\n+\n+	if (ip1->family == AF_INET6)\n+		return memcmp(&ip1->ip, &ip2->ip, sizeof(ip1->ip)) == 0;\n+\n+	return memcmp(&ip1->ip, &ip2->ip, 4) == 0;\n+}\n+\n+\n static void sin_set_ip(union sockaddr_union *so, const IPADDR *ip)\n {\n 	if (ip == NULL) {\n','false','false','none'),('irssi','1.0.4','da59fd7c2dd0641f623db2c67a244ddca3013d65','Will Storey','revert \"delete unused function net_ip_compare()\"\n\nthis reverts commit cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d.','network.h','35','0','3','0','MODIFY','@@ -33,6 +33,9 @@ extern IPADDR ip4_any;\n \n GIOChannel *g_io_channel_new(int handle);\n \n+/* returns 1 if IPADDRs are the same */\n+int net_ip_compare(IPADDR *ip1, IPADDR *ip2);\n+\n int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);\n \n /* Connect to socket with ip address and SSL*/\n','false','false','none'),('irssi','1.0.4','233be9f580290ff3efa66e6256e46303b01781da','Will Storey','mark net_ip_compare() deprecated','network.h','35','0','3','2','MODIFY','@@ -33,8 +33,9 @@ extern IPADDR ip4_any;\n \n GIOChannel *g_io_channel_new(int handle);\n \n-/* returns 1 if IPADDRs are the same */\n-int net_ip_compare(IPADDR *ip1, IPADDR *ip2);\n+/* Returns 1 if IPADDRs are the same. */\n+/* Deprecated since it is unused. It will be deleted in a later release. */\n+int net_ip_compare(IPADDR *ip1, IPADDR *ip2) G_GNUC_DEPRECATED;\n \n int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);\n \n','false','false','none'),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','changes based on comments in pull #771.','chatnet-rec.h','9','0','0','1','MODIFY','@@ -4,7 +4,6 @@ int chat_type; /* chat_protocol_lookup(xx) */\n char *name;\n \n char *nick;\n-char *alternate_nick;\n char *username;\n char *realname;\n \n','false','false','none'),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','changes based on comments in pull #771.','irc-chatnets.c','89','27','7','0','MODIFY','@@ -43,6 +43,9 @@ static void sig_chatnet_read(IRC_CHATNET_REC *rec, CONFIG_NODE *node)\n 	value = config_node_get_str(node, \"usermode\", NULL);\n 	rec->usermode = (value != NULL && *value != \'\\0\') ? g_strdup(value) : NULL;\n \n+	value = config_node_get_str(node, \"alternate_nick\", NULL);\n+	rec->alternate_nick = (value != NULL && *value != \'\\0\') ? g_strdup(value) : NULL;\n+\n 	rec->max_cmds_at_once = config_node_get_int(node, \"cmdmax\", 0);\n 	rec->cmd_queue_speed = config_node_get_int(node, \"cmdspeed\", 0);\n 	rec->max_query_chans = config_node_get_int(node, \"max_query_chans\", 0);\n@@ -65,6 +68,9 @@ static void sig_chatnet_saved(IRC_CHATNET_REC *rec, CONFIG_NODE *node)\n 	if (rec->usermode != NULL)\n 		iconfig_node_set_str(node, \"usermode\", rec->usermode);\n \n+	if (rec->alternate_nick != NULL)\n+		iconfig_node_set_str(node, \"alternate_nick\", rec->alternate_nick);\n+\n 	if (rec->max_cmds_at_once > 0)\n 		iconfig_node_set_int(node, \"cmdmax\", rec->max_cmds_at_once);\n 	if (rec->cmd_queue_speed > 0)\n@@ -93,6 +99,7 @@ static void sig_chatnet_destroyed(IRC_CHATNET_REC *rec)\n {\n 	if (IS_IRC_CHATNET(rec)) {\n 		g_free(rec->usermode);\n+		g_free(rec->alternate_nick);\n 		g_free(rec->sasl_mechanism);\n 		g_free(rec->sasl_username);\n 		g_free(rec->sasl_password);\n','false','false','none'),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','changes based on comments in pull #771.','irc-chatnets.h','17','0','1','0','MODIFY','@@ -18,6 +18,7 @@ struct _IRC_CHATNET_REC {\n #include \"chatnet-rec.h\"\n \n 	char *usermode;\n+	char *alternate_nick;\n \n 	char *sasl_mechanism;\n 	char *sasl_username;\n','false','false','none'),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','changes based on comments in pull #771.','irc-servers-setup.c','149','52','0','4','MODIFY','@@ -69,10 +69,6 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n 		return;\n 	g_return_if_fail(IS_IRCNET(ircnet));\n \n-	if (ircnet->nick != NULL) {\n-		g_free_and_null(conn->nick);\n-		conn->nick = g_strdup(ircnet->nick);\n-	}\n 	if (ircnet->alternate_nick != NULL) {\n 		g_free_and_null(conn->alternate_nick);\n 		conn->alternate_nick = g_strdup(ircnet->alternate_nick);\n','false','false','none'),('irssi','1.0.4','45dfe2ba3889c5dc23a9bea3214f158cc651a043','LemonBoy','prevent a oob read when parsing ircnet ! channels\n\nmake sure the string has enough data.\nfixes #16','channel-events.c','271','67','1','1','MODIFY','@@ -37,7 +37,7 @@ static void check_join_failure(IRC_SERVER_REC *server, const char *channel)\n 		channel++; /* server didn\'t understand !channels */\n \n 	chanrec = channel_find(SERVER(server), channel);\n-	if (chanrec == NULL && channel[0] == \'!\') {\n+	if (chanrec == NULL && channel[0] == \'!\' && strlen(channel) > 6) {\n 		/* it probably replied with the full !channel name,\n 		   find the channel with the short name.. */\n 		chan2 = g_strdup_printf(\"!%s\", channel+6);\n','false','false','none'),('irssi','1.0.4','9f0dc4766c7aa80e34aa2cde94323fb49971abdf','ailin-nemui','fix dcc issue','dcc-chat.c','620','143','21','0','MODIFY','@@ -66,6 +66,13 @@ CHAT_DCC_REC *dcc_chat_create(IRC_SERVER_REC *server,\n         dcc->id = dcc_chat_get_new_id(nick);\n \n 	dcc_init_rec(DCC(dcc), server, chat, nick, arg);\n+	if (dcc->module_data == NULL) {\n+		/* failed to successfully init; TODO: change init_rec API */\n+		g_free(dcc->id);\n+		g_free(dcc);\n+		return NULL;\n+	}\n+\n         return dcc;\n }\n \n@@ -471,6 +478,7 @@ static void cmd_dcc_chat(const char *data, IRC_SERVER_REC *server)\n 			/* We are accepting a passive DCC CHAT. */\n 			dcc_chat_passive(dcc);\n 		}\n+		cmd_params_free(free_arg);\n 		return;\n 	}\n \n@@ -485,6 +493,11 @@ static void cmd_dcc_chat(const char *data, IRC_SERVER_REC *server)\n 		cmd_param_error(CMDERR_NOT_CONNECTED);\n \n 	dcc = dcc_chat_create(server, NULL, nick, \"chat\");\n+	if (dcc == NULL) {\n+		cmd_params_free(free_arg);\n+		g_warn_if_reached();\n+		return;\n+	}\n \n 	if (g_hash_table_lookup(optlist, \"passive\") == NULL) {\n 		/* Standard DCC CHAT... let\'s listen for incoming connections */\n@@ -627,6 +640,9 @@ static void ctcp_msg_dcc_chat(IRC_SERVER_REC *server, const char *data,\n 	}\n 	passive = paramcount == 4 && g_strcmp0(params[2], \"0\") == 0;\n \n+	if (nick == NULL)\n+		nick = \"\";\n+\n 	dcc = DCC_CHAT(dcc_find_request(DCC_CHAT_TYPE, nick, NULL));\n 	if (dcc != NULL) {\n 		if (dcc_is_listening(dcc)) {\n@@ -658,6 +674,11 @@ static void ctcp_msg_dcc_chat(IRC_SERVER_REC *server, const char *data,\n 	}\n \n 	dcc = dcc_chat_create(server, chat, nick, params[0]);\n+	if (dcc == NULL) {\n+		g_strfreev(params);\n+		g_warn_if_reached();\n+		return;\n+	}\n 	dcc->target = g_strdup(target);\n 	dcc->port = atoi(params[2]);\n \n','true','false','none'),('irssi','1.0.4','9f0dc4766c7aa80e34aa2cde94323fb49971abdf','ailin-nemui','fix dcc issue','dcc-get.c','440','98','15','2','MODIFY','@@ -43,6 +43,12 @@ GET_DCC_REC *dcc_get_create(IRC_SERVER_REC *server, CHAT_DCC_REC *chat,\n 	dcc->fhandle = -1;\n \n 	dcc_init_rec(DCC(dcc), server, chat, nick, arg);\n+	if (dcc->module_data == NULL) {\n+		/* failed to successfully init; TODO: change API */\n+		g_free(dcc);\n+		return NULL;\n+	}\n+\n         return dcc;\n }\n \n@@ -430,9 +436,10 @@ static void ctcp_msg_dcc_send(IRC_SERVER_REC *server, const char *data,\n 	int p_id = -1;\n 	int passive = FALSE;\n \n-	if (addr == NULL) {\n+	if (addr == NULL)\n 		addr = \"\";\n-	}\n+	if (nick == NULL)\n+		nick = \"\";\n \n 	/* SEND <file name> <address> <port> <size> [...] */\n 	/* SEND <file name> <address> 0 <size> <id> (DCC SEND passive protocol) */\n@@ -512,6 +519,12 @@ static void ctcp_msg_dcc_send(IRC_SERVER_REC *server, const char *data,\n 		dcc_destroy(DCC(dcc)); /* remove the old DCC */\n \n 	dcc = dcc_get_create(server, chat, nick, fname);\n+	if (dcc == NULL) {\n+		g_free(address);\n+		g_free(fname);\n+		g_warn_if_reached();\n+		return;\n+	}\n 	dcc->target = g_strdup(target);\n \n 	if (passive && port == 0)\n','true','false','none'),('irssi','1.0.4','9f0dc4766c7aa80e34aa2cde94323fb49971abdf','ailin-nemui','fix dcc issue','dcc-send.c','352','75','10','0','MODIFY','@@ -237,6 +237,12 @@ static SEND_DCC_REC *dcc_send_create(IRC_SERVER_REC *server,\n 	dcc->queue = -1;\n \n 	dcc_init_rec(DCC(dcc), server, chat, nick, arg);\n+	if (dcc->module_data == NULL) {\n+		/* failed to successfully init; TODO: change API */\n+		g_free(dcc);\n+		return NULL;\n+	}\n+\n         return dcc;\n }\n \n@@ -417,6 +423,10 @@ static int dcc_send_one_file(int queue, const char *target, const char *fname,\n \n 	dcc = dcc_send_create(server, chat, target, str);\n 	g_free(str);\n+	if (dcc == NULL) {\n+		g_warn_if_reached();\n+		return FALSE;\n+	}\n \n 	dcc->handle = handle;\n 	dcc->port = port;\n','true','false','none'),('irssi','1.0.4','73d7b9d7753d35c63f24defe6d26c7c06ffa3cce','Joseph Bisch','don\'t proceed with cmd_msg if there was an error splitting msg\n\nthere may be cases (such as if target or server->nick is very long)\nwhere the split_message function returns null, indicating an error. to\navoid a potential segfault, we now check to see if splitmsgs is null.','chat-commands.c','385','117','4','1','MODIFY','@@ -404,7 +404,10 @@ static void cmd_msg(const char *data, SERVER_REC *server, WI_ITEM_REC *item)\n 		else\n 			splitmsgs = singlemsg;\n \n-		while ((m = splitmsgs[n++])) {\n+		/* splitmsgs may be NULL if there was an error */\n+		g_warn_if_fail(splitmsgs != NULL);\n+\n+		while (splitmsgs && (m = splitmsgs[n++])) {\n 			signal_emit(\"server sendmsg\", 4, server, target, m,\n 				    GINT_TO_POINTER(target_type));\n 			signal_emit(target_type == SEND_TARGET_CHANNEL ?\n','true','true','none'),('irssi','1.0.4','beb2beba3b4802c6969a5595197e25e7a5483fa3','Joseph Bisch','revert \"don\'t proceed with cmd_msg if there was an error splitting msg\"\n\nthis reverts commit bd83852d646de28f2e0fe01efe7c9236aa4074d4.','chat-commands.c','384','117','1','4','MODIFY','@@ -404,10 +404,7 @@ static void cmd_msg(const char *data, SERVER_REC *server, WI_ITEM_REC *item)\n 		else\n 			splitmsgs = singlemsg;\n \n-		/* splitmsgs may be NULL if there was an error */\n-		g_warn_if_fail(splitmsgs != NULL);\n-\n-		while (splitmsgs && (m = splitmsgs[n++])) {\n+		while ((m = splitmsgs[n++])) {\n 			signal_emit(\"server sendmsg\", 4, server, target, m,\n 				    GINT_TO_POINTER(target_type));\n 			signal_emit(target_type == SEND_TARGET_CHANNEL ?\n','true','false','none'),('irssi','1.0.4','0840eaec7bf56740029aae614e393f8cf76f6946','Joseph Bisch','make split functions return an array with null instead of null\n\nthis avoids undefined behavior in functions that call these split\nfunctions and expect an array back instead of just a null pointer.','recode.c','229','62','6','1','MODIFY','@@ -198,7 +198,12 @@ char **recode_split(const SERVER_REC *server, const char *str,\n 	int n = 0;\n 	char **ret;\n \n-	g_return_val_if_fail(str != NULL, NULL);\n+	g_warn_if_fail(str != NULL);\n+	if (str == NULL) {\n+		ret = g_new(char *, 1);\n+		ret[0] = NULL;\n+		return ret;\n+	}\n \n 	if (settings_get_bool(\"recode\")) {\n 		to = find_conversion(server, target);\n','false','false','none'),('irssi','1.0.4','0840eaec7bf56740029aae614e393f8cf76f6946','Joseph Bisch','make split functions return an array with null instead of null\n\nthis avoids undefined behavior in functions that call these split\nfunctions and expect an array back instead of just a null pointer.','irc-servers.c','780','195','4','1','MODIFY','@@ -116,11 +116,14 @@ static char **split_line(const SERVER_REC *server, const char *line,\n 	 * the code much simpler.  It\'s worth it.\n 	 */\n 	len -= strlen(recoded_start) + strlen(recoded_end);\n+	g_warn_if_fail(len > 0);\n 	if (len <= 0) {\n 		/* There is no room for anything. */\n 		g_free(recoded_start);\n 		g_free(recoded_end);\n-		return NULL;\n+		lines = g_new(char *, 1);\n+		lines[0] = NULL;\n+		return lines;\n 	}\n \n 	lines = recode_split(server, line, target, len, onspace);\n','false','false','none'),('irssi','1.0.5','956bc592a94d5f4cce03f5762f1976d98de637ef','Will Storey','fix a typo in the readme\n\nalso uppercase irssi in a couple places, and escape an argument not\nshown due to looking like an html tag','README.md','99','0','4','4','MODIFY','@@ -28,7 +28,7 @@ think of currently:\n    queries when msgs/notices are received or when you send a msg, closing\n    queries when it\'s been idle for some time, etc.\n \n- - **Multiserver friendy** - I think Irssi has clearly the best support\n+ - **Multiserver friendly** - I think Irssi has clearly the best support\n    for handling multiple server connections. You can have as many as you\n    want in as many ircnets as you want. Having several connections in one\n    server works too, for example when you hit the (ircnet\'s) 10\n@@ -84,7 +84,7 @@ think of currently:\n    search command that jumps around in scrollback in GUI-style is still\n    missing from Irssi, but there\'s something that\'s almost as good as it.\n    /LASTLOG always shows timestamps when the line was printed, even if you\n-   didn\'t have timestamps on. Now doing /SB GOTO <timestamp> jumps\n+   didn\'t have timestamps on. Now doing /SB GOTO \\<timestamp\\> jumps\n    directly to the position in scrollback you wanted. Great feature when\n    you want to browse a bit of the discussion what happened when someone\n    said your name (as seen in awaylog) or topic was changed (/last\n@@ -96,9 +96,9 @@ think of currently:\n     - `startup-HOWTO.txt` - new users should read this\n     - `manual.txt` - manual I started writing but didn\'t get it very far :)\n     - `perl.txt` - Perl scripting help\n-    - `formats.txt` - How to use colors, etc. with irssi\n+    - `formats.txt` - How to use colors, etc. with Irssi\n     - `faq.txt` - Frequently Asked Questions\n-    - `special_vars.txt` - some predefined $variables you can use with irssi\n+    - `special_vars.txt` - some predefined $variables you can use with Irssi\n \n ## Bugs / Suggestions\n \n','true','false','none'),('irssi','1.0.5','816df6d153e937734bdac258ad6bf43173361451','ailin-nemui','merge tag \'1.0.5\' into integrate/1.0.5','NEWS','2923','0','18','0','MODIFY','@@ -1,5 +1,23 @@\n v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n \n+v1.0.5 2017-10-23  The Irssi team <staff@irssi.org>\n+	- Fix missing -sasl_method \'\' in /NETWORK (#718, #719).\n+	- Fix incorrect restoration of term state when hitting SUSP\n+          inside screen (#737, #733).\n+	- Fix out of bounds read when compressing colour\n+          sequences. Found by Hanno Böck (GL#12, GL!18).\n+	- Fix use after free condition during a race condition when\n+          waiting on channel sync during a rejoin (GL#13, GL!19).\n+	- Fix null pointer dereference when parsing certain malformed\n+          CTCP DCC messages (GL#14, GL!20).\n+	- Fix crash due to null pointer dereference when failing to\n+          split messages due to overlong nick or target (GL#15, GL!21).\n+	- Fix out of bounds read when trying to skip a safe channel ID\n+          without verifying that the ID is long enough (GL#16, GL!22).\n+	- Fix return of random memory when inet_ntop failed (#769).\n+	- Minor statusbar help update. By Robert Bisewski (#758,\n+          #763).\n+\n v1.0.4 2017-07-07  The Irssi team <staff@irssi.org>\n 	- Fix null pointer dereference when parsing invalid timestamp (GL#10,\n 	  GL!15). Reported by Brian \'geeknik\' Carpenter.\n','false','false','none'),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','add event_get_params to fe-fuzz','.gitignore','54','0','1','0','MODIFY','@@ -33,6 +33,7 @@ docs/help/in/Makefile.am\n \n src/fe-text/irssi\n src/fe-fuzz/irssi-fuzz\n+src/fe-fuzz/irc/core/event-get-params-fuzz\n \n src/fe-common/irc/irc-modules.c\n src/irc/irc.c\n','false','false','none'),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','add event_get_params to fe-fuzz','configure.ac','700','4','2','0','MODIFY','@@ -648,6 +648,8 @@ src/fe-common/irc/Makefile\n src/fe-common/irc/dcc/Makefile\n src/fe-common/irc/notifylist/Makefile\n src/fe-fuzz/Makefile\n+src/fe-fuzz/irc/Makefile\n+src/fe-fuzz/irc/core/Makefile\n src/fe-none/Makefile\n src/fe-text/Makefile\n src/lib-config/Makefile\n','false','false','none'),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','add event_get_params to fe-fuzz','Makefile.am','19','0','2','0','MODIFY','@@ -1,3 +1,5 @@\n+SUBDIRS = irc\n+\n bin_PROGRAMS = irssi-fuzz\n \n # Force link with CXX for libfuzzer support\n','false','false','none'),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','add event_get_params to fe-fuzz','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@\n+SUBDIRS = core\n','false','false','none'),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','add event_get_params to fe-fuzz','Makefile.am','39','0','46','0','ADD','@@ -0,0 +1,46 @@\n+bin_PROGRAMS = event-get-params-fuzz\n+\n+# Force link with CXX for libfuzzer support\n+CCLD=$(CXX) $(CXXFLAGS)\n+\n+AM_CPPFLAGS = \\\n+	-I$(top_srcdir)/src \\\n+	-I$(top_srcdir)/src/core/ \\\n+	-I$(top_srcdir)/src/irc/core/ \\\n+	-I$(top_srcdir)/src/fe-common/core/ \\\n+	$(GLIB_CFLAGS)\n+\n+AM_DEPENDENCIES = \\\n+	../../../core/libcore.a \\\n+	../../../lib-config/libirssi_config.a \\\n+	../../../irc/libirc.a \\\n+	../../../irc/core/libirc_core.a \\\n+	../../../irc/dcc/libirc_dcc.a \\\n+	../../../irc/flood/libirc_flood.a \\\n+	../../../irc/notifylist/libirc_notifylist.a \\\n+	../../../fe-common/core/libfe_common_core.a \\\n+	../../../fe-common/irc/libfe_common_irc.a \\\n+	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\\n+	../../../fe-common/irc/notifylist/libfe_irc_notifylist a\n+\n+LDADD = \\\n+	../../../irc/libirc.a \\\n+	../../../irc/core/libirc_core.a \\\n+	../../../irc/dcc/libirc_dcc.a \\\n+	../../../irc/flood/libirc_flood.a \\\n+	../../../irc/notifylist/libirc_notifylist.a \\\n+	../../../fe-common/core/libfe_common_core.a \\\n+	../../../fe-common/irc/libfe_common_irc.a \\\n+	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\\n+	../../../fe-common/irc/notifylist/libfe_irc_notifylist.a \\\n+	../../../core/libcore.a \\\n+	../../../lib-config/libirssi_config.a \\\n+	@PROG_LIBS@ \\\n+	$(FUZZER_LIBS)\n+\n+event_get_params_fuzz_SOURCES = \\\n+        event-get-params.c \\\n+	$(top_srcdir)/src/fe-text/module-formats.c\n+\n+noinst_HEADERS = \\\n+	$(top_srcdir)/src/fe-text/module-formats.h\n','false','false','none'),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','add event_get_params to fe-fuzz','event-get-params.c','61','11','86','0','ADD','@@ -0,0 +1,86 @@\n+/*\n+ event-get-params.c : irssi\n+\n+    Copyright (C) 2017 Joseph Bisch\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+*/\n+\n+#include \"module.h\"\n+#include \"modules-load.h\"\n+#include \"levels.h\"\n+#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text\n+#include \"themes.h\"\n+#include \"core.h\"\n+#include \"fe-common-core.h\"\n+#include \"args.h\"\n+#include \"printtext.h\"\n+#include \"irc.h\"\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int LLVMFuzzerInitialize(int *argc, char ***argv) {\n+	core_register_options();\n+	fe_common_core_register_options();\n+	/* no args */\n+	args_execute(0, NULL);\n+	core_preinit((*argv)[0]);\n+	core_init();\n+	fe_common_core_init();\n+	theme_register(gui_text_formats);\n+	module_register(\"core\", \"fe-fuzz\");\n+	return 0;\n+}\n+\n+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n+	if (size < 1) {\n+		return 0;\n+	}\n+	uint8_t count = *data;\n+	char *copy = (char *)malloc(sizeof(char)*(size-1+1));\n+	memcpy(copy, data+1, size-1);\n+	copy[size-1] = \'\\0\';\n+\n+	char *output0;\n+	char *output1;\n+	char *output2;\n+	char *output3;\n+	char *params;\n+	if (count % 8 == 0) {\n+		params = event_get_params(copy, 1 | PARAM_FLAG_GETREST, &output0);\n+	} else if (count % 8 == 1) {\n+		params = event_get_params(copy, 2 | PARAM_FLAG_GETREST, &output0, &output1);\n+	} else if (count % 8 == 2) {\n+		params = event_get_params(copy, 3 | PARAM_FLAG_GETREST, &output0, &output1, &output2);\n+	} else if (count % 8 == 3) {\n+		params = event_get_params(copy, 4 | PARAM_FLAG_GETREST, &output0, &output1, &output2, &output3);\n+	} else if (count % 8 == 4) {\n+		params = event_get_params(copy, 1, &output0);\n+	} else if (count % 8 == 5) {\n+		params = event_get_params(copy, 2, &output0, &output1);\n+	} else if (count % 8 == 6) {\n+		params = event_get_params(copy, 3, &output0, &output1, &output2);\n+	} else if (count % 8 == 7) {\n+		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);\n+	} else {\n+		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);\n+	}\n+	g_free(params);\n+	free(copy);\n+	return 0;\n+}\n','false','false','none'),('irssi','1.0.5','87550541e745627cc78507ce573d68b8453959c9','ailin-nemui','fix key length checker to actually do some work','autogen.sh','44','1','1','15','MODIFY','@@ -29,20 +29,6 @@ cat docs/help/in/Makefile.am.gen|sed \"s/@HELPFILES@/$files/g\"|sed \'s/?/\\\\?/g\'|tr\n files=`echo $files|sed \'s/\\.in//g\'`\n cat docs/help/Makefile.am.gen|sed \"s/@HELPFILES@/$files/g\"|sed \'s/?/\\\\?/g\'|tr \'!?\' \'\\t\\n\' > docs/help/Makefile.am\n \n-# .html -> .txt with lynx or elinks\n-echo \"Documentation: html -> txt...\"\n-if type lynx >/dev/null 2>&1 ; then\n-  LC_ALL=en_IE.utf8 lynx -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt\n-elif type elinks >/dev/null 2>&1 ; then\n-  elinks -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt\n-elif type links >/dev/null 2>&1 ; then\n-  links -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt\n-else\n-  echo \"**Error**: No lynx or elinks present\"\n-  echo \"Install lynx or elinks, then run autogen.sh again\"\n-  exit 1\n-fi\n-\n if test x$NOCONFIGURE = x && test -z \"$*\"; then\n   echo \"**Warning**: I am going to run \\`configure\' with no arguments.\"\n   echo \"If you wish to pass any to it, please specify them on the\"\n@@ -65,4 +51,4 @@ else\n fi\n \n # make sure perl hashes have correct length\n-find src/perl -name *.c -o -name *.xs | xargs grep -n hv_store | perl -ne \'if (/\"(\\w+)\",\\s*(\\d+)/) { print unless $2 == length $1 }\'\n+find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\'\n','true','false','none'),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','.gitignore','52','0','0','1','MODIFY','@@ -11,7 +11,6 @@ config.status\n configure\n default-config.h\n default-theme.h\n-faq.txt\n irssi-config\n irssi-config.h\n irssi-config.h.in\n','false','false','none'),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','Makefile.am','16','0','2','1','MODIFY','@@ -11,7 +11,8 @@ doc_DATA = \\\n 	perl.txt \\\n 	signals.txt \\\n 	special_vars.txt \\\n-	startup-HOWTO.html\n+	startup-HOWTO.html \\\n+	startup-HOWTO.txt\n \n EXTRA_DIST = $(doc_DATA) $(man_MANS)\n \n','false','false','none'),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','faq.html','42','0','3','1','MODIFY','@@ -1,4 +1,6 @@\n+<base href=\'https://irssi.org/documentation/faq/\'>\n <h1>Frequently Asked Questions</h1>\n+\n <h3 id=\"q-why-doesnt-irssi-display-colors-even-when-ircii-etc-displays-them\">Q: Why doesn’t irssi display colors even when ircii etc. displays them?</h3>\n \n <p>A: They force ANSI colors even if terminal doesn’t support them. By default, irssi uses colors only if terminfo/termcap so says. The correct way to fix this would be to change your TERM environment to a value where colors work, like xterm-color or color_xterm (eg. <code>TERM=xterm-color irssi</code>). If this doesn’t help, then use the evil way of <code>/SET term_force_colors ON</code>.</p>\n@@ -77,4 +79,4 @@\n \n <h3 id=\"q-how-to-pronounce-irssi\">Q: How to pronounce Irssi?</h3>\n \n-<p>A: Check <a href=\"https://irssi.org/assets/irssi.wav\">here</a></p>\n+<p>A: Check <a href=\"/assets/irssi.wav\">here</a></p>\n\\ No newline at end of file\n','false','false','none'),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','faq.txt','99','0','124','0','ADD','@@ -0,0 +1,124 @@\n+   Frequently Asked Questions\n+\n+Q: Why doesn’t irssi display colors even when ircii etc. displays them?\n+A: They force ANSI colors even if terminal doesn’t support them. By default,\n+   irssi uses colors only if terminfo/termcap so says. The correct way to fix this\n+   would be to change your TERM environment to a value where colors work, like\n+   xterm-color or color_xterm (eg. TERM=xterm-color irssi). If this doesn’t help,\n+   then use the evil way of /SET term_force_colors ON.\n+\n+Q: How do I easily write text to channel that starts with ‘/’ character?\n+A: / /text\n+\n+Q: Why doesn’t irssi update my realname (or whatever) after I change it with /\n+   SET realname and reconnect with /RECONNECT or /SERVER?\n+A: Irssi is trying to be too smart. This will be fixed in future, but for now\n+   you should use /DISCONNECT and /CONNECT.\n+\n+Q: I connected to some server which isn’t responding but now irssi tries to\n+   connect back to it all the time! How can I stop it?\n+A: Two ways. The “good way” to do it is with /DISCONNECT. Check the server tags\n+   first with /SERVER without giving it any parameters, reconnections are those\n+   that have tag starting with “recon” text. So most probably you’re going to do /\n+   DISCONNECT recon-1. The other way is to remove all the reconnections with /\n+   RMRECONNS, easier but may remove some connections you actually wanted to\n+   reconnect (if you used multiple servers..).\n+\n+Q: How do I add seconds to timestamp?\n+A: /FORMAT timestamp {timestamp %%H:%%M:%%S} - and remember to add the trailing\n+   space :)\n+\n+Q: Why does irssi say “Irssi: Channel not fully synchronized yet, try again\n+   after a while” when I try to use /BAN etc?\n+A: Possibly a bug in irssi, or ircd you’re using does something that irssi\n+   didn’t really notice. The new code should make this happen far less often than\n+   before, but one known reason for this is when irssi doesn’t notice that you\n+   were unable to join some channel. Currently however I don’t know of any such\n+   events irssi doesn’t know about.\n+\n+   Anyway, if this does happen, do /RAWLOG SAVE ~/rawlog soon after joining to\n+   channel, and either try to figure out yourself why irssi didn’t get reply to\n+   WHO request, or open a Github issue with the full log included. Note that the\n+   rawlog is by default only 200 lines and it may not be enough to show all needed\n+   information, so you might want to do /SET rawlog_lines 1000 or so.\n+\n+   MODE +b still works fine though.\n+\n+Q: Where’s the GUI version?\n+A: There was one on [1]irssi-import/xirssi but it has not been maintained for a\n+   long time.\n+\n+Q: How do I autorejoin channels after being kicked?\n+A: That’s evil and you shouldn’t do it. If you get kicked, you should stay out,\n+   at least until the channel forgot you existed :) Most channels I’ve joined just\n+   ban you if you autorejoin after kick. If you’re joined to channels who kick\n+   people for fun, try changing channels or something.\n+\n+   Anyway, if you REALLY want to do that, and you understand that you’re doing\n+   evilness, you can use the autorejoin.pl script that comes with irssi. You’ll\n+   still need to specify the channels you wish to rejoin with /SET\n+   autorejoin_channels #chan1 #chan2 ...\n+\n+Q: How do I announce that I’m away/back in all channels I’ve joined? Or how do\n+   I change my nick when setting myself away/back?\n+A: That’s even worse than autorejoin. Who could possibly care every time you\n+   come and go? Many channels will kick you for using this, and I for example have\n+   added several ignores so I’d never need to see these messages. Learn to use /\n+   AWAY command properly and tell its existence to people who don’t know about it.\n+   /WII yournick shows your away reason much better for people who actually want\n+   to know if you’re there or not.\n+\n+Q: Why does irssi autojoin on invite by default?\n+A: The setting is /SET join_auto_chans_on_invite - it’s not the same as regular\n+   autojoin-on-invite, which irssi doesn’t even have. The only channels that are\n+   joined on invite, are the ones you’ve added to config with /CHANNEL ADD -auto.\n+   This is very useful with +i channels when you need to first send an invite\n+   request to bot, or if you get accidentally kicked from channel, the kicker can\n+   invite you back immediately.\n+\n+   I don’t see any bad side effects with this feature, so it’s ON by default. I\n+   guess someone could start kicking/inviting you all the time but server\n+   connection shouldn’t drop because of that, and you shouldn’t join channels\n+   whose operators are that evil.\n+\n+Q: How to make UTF-8 support work with irssi?\n+A: Make sure your terminal supports UTF-8 (for example, xterm -u8). If you use\n+   screen, you may have to do screen -U. And in Irssi do /SET term_charset utf-8.\n+   (for 0.8.9 and older: /SET term_type utf-8)\n+\n+Q: Will there be /DETACH-like feature?\n+A: [2]tmux, [3]screen and [4]dtach can be used to do it just fine.\n+\n+Q: How do I run scripts automatically at startup?\n+A: Put them into ~/.irssi/scripts/autorun/ directory. Or better would be if you\n+   placed them in ~/.irssi/scripts/ and created symlinks to autorun directory (eg.\n+   cd ~/.irssi/scripts/autorun/ ; ln -s ../script.pl .)\n+\n+Q: How do I execute commands automatically at startup?\n+A: Put them into ~/.irssi/startup file, each command on its own line. The\n+   preceding slash (/) is not necessary.\n+\n+Q: How do I easily edit existing topic?\n+A: /TOPIC <tab>\n+\n+Q: How can I have /WHOIS replies to active window?\n+A: You can disable the status window, or do /WINDOW LEVEL -CRAP in it which\n+   would also make several other messages show up in active window. You can also\n+   use a [5]script.\n+\n+Q: How do I add the active network to the statusbar\n+A: Modify the window-line in statusbar section in config file to window = \"{sb\n+   $winref:$tag/$T{sbmode $M}}\";\n+\n+Q: How to pronounce Irssi?\n+A: Check [6]here\n+\n+\n+   References:\n+\n+   [1] https://github.com/irssi-import/xirssi\n+   [2] http://tmux.github.io/\n+   [3] http://www.gnu.org/software/screen/screen.html\n+   [4] http://dtach.sf.net/\n+   [5] http://dgl.cx/irssi/hack-whois-in-current-window.pl\n+   [6] https://irssi.org/assets/irssi.wav\n','false','false','none'),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','startup-HOWTO.html','475','0','267','243','MODIFY','@@ -1,4 +1,6 @@\n-                    <h1>Startup How-To</h1>\n+<base href=\'https://irssi.org/documentation/startup/\'>\n+<h1>Startup How-To</h1>\n+\n <h3 id=\"to-new-irssi-users-not-to-new-irc-users-\">To new Irssi users (not to new IRC users ..)</h3>\n \n <p>Copyright (c) 2000-2002 by Timo Sirainen, release under <a href=\"http://www.gnu.org/licenses/fdl.html\">GNU FDL</a> 1.1 license.</p>\n@@ -6,11 +8,7 @@\n <p>Index with some FAQ questions that are answered in the chapter:</p>\n \n <ol>\n-  <li><a href=\"#for-all-the-ircii-people\">For all the ircII people</a>\n-    <ul>\n-      <li>This window management is just weird, I want it exactly like ircII</li>\n-    </ul>\n-  </li>\n+  <li><a href=\"#first-steps\">First steps</a></li>\n   <li><a href=\"#basic-user-interface-usage\">Basic user interface usage</a>\n     <ul>\n       <li>Split windows work in weird way</li>\n@@ -50,7 +48,11 @@\n     </ul>\n   </li>\n   <li><a href=\"#proxies-and-irc-bouncers\">Proxies and IRC bouncers</a></li>\n-  <li><a href=\"#irssis-settings\">Irssi’s settings</a></li>\n+  <li><a href=\"#irssis-settings\">Irssi’s settings</a>\n+    <ul>\n+      <li><a href=\"#for-all-the-ircii-people\">For all the ircII people</a></li>\n+    </ul>\n+  </li>\n   <li><a href=\"#statusbar\">Statusbar</a>\n     <ul>\n       <li>I loaded a statusbar script but it’s not visible anywhere!</li>\n@@ -58,169 +60,176 @@\n   </li>\n </ol>\n \n-<h2 id=\"for-all-the-ircii-people\">1. For all the ircII people</h2>\n+<h2 id=\"first-steps\">1. First steps</h2>\n \n-<p>These settings should give you pretty good defaults (the ones I use):</p>\n+<p>IRC Networks are made of servers, and servers have channels. The default config has a few predefined networks, to list them:</p>\n \n-<p>If colors don’t work, and you know you’re not going to use some weird non-VT compatible terminal (you most probably aren’t), just say:</p>\n+<div><div><pre><code>/NETWORK LIST\n+</code></pre></div></div>\n \n-<pre><code> /SET term_force_colors ON\n-</code></pre>\n+<p>And to connect to one of those networks and join a channel:</p>\n \n-<p>I don’t like automatic query windows, I don’t like status window, I do like msgs window where all messages go:</p>\n+<div><div><pre><code>/CONNECT Freenode\n+/JOIN #irssi\n+</code></pre></div></div>\n \n-<pre><code> /SET autocreate_own_query OFF\n- /SET autocreate_query_level DCCMSGS\n- /SET use_status_window OFF\n- /SET use_msgs_window ON\n-</code></pre>\n+<p>To add more networks:</p>\n \n-<p>Disable automatic window closing when <code>/PART</code>ing channel or <code>/UNQUERY</code>ing query:</p>\n+<div><div><pre><code>/NETWORK ADD ExampleNet\n+</code></pre></div></div>\n \n-<pre><code> /SET autoclose_windows OFF\n- /SET reuse_unused_windows ON\n-</code></pre>\n+<p>Then add some servers (with -auto to automatically connect):</p>\n \n-<p>Here’s the settings that make irssi work exactly like ircII in window management (send me a note if you can think of more):</p>\n+<div><div><pre><code>/SERVER ADD -auto -network ExampleNet irc.example.net\n+</code></pre></div></div>\n \n-<pre><code> /SET autocreate_own_query OFF\n- /SET autocreate_query_level NONE\n- /SET use_status_window OFF\n- /SET use_msgs_window OFF\n- /SET reuse_unused_windows ON\n- /SET windows_auto_renumber OFF\n+<p>Automatically join to channels after connected to server:</p>\n \n- /SET autostick_split_windows OFF\n- /SET autoclose_windows OFF\n- /SET print_active_channel ON\n-</code></pre>\n+<div><div><pre><code>/CHANNEL ADD -auto #lounge ExampleNet\n+</code></pre></div></div>\n \n-<p>And example how to add servers:</p>\n+<p>To modify existing networks (or servers, or channels) just ADD again using the same name as before. This configures a network to identify with nickserv and wait for 2 seconds before joining channels:</p>\n \n-<p>(OFTC network, identify with nickserv and wait for 2 seconds before joining channels)</p>\n+<div><div><pre><code>/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" ExampleNet\n+</code></pre></div></div>\n \n-<pre><code> /NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC\n-</code></pre>\n+<p>If you have irssi 0.8.18 or higher and the irc network supports it, you can use SASL instead of nickserv, which is more reliable:</p>\n \n-<p>(NOTE: use /IRCNET with 0.8.9 and older)</p>\n+<div><div><pre><code>/NETWORK ADD -sasl_username yourname -sasl_password yourpassword -sasl_mechanism PLAIN Freenode\n+</code></pre></div></div>\n \n-<p>Then add some servers to different networks (network is already set up for them), irc.kpnqwest.fi is used by default for IRCNet but if it fails, irc.funet.fi is tried next:</p>\n+<p>These commands have many more options, see their help for details:</p>\n \n-<pre><code> /SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667\n- /SERVER ADD -network IRCnet irc.funet.fi 6667\n- /SERVER ADD -auto -network efnet efnet.cs.hut.fi 6667\n-</code></pre>\n+<div><div><pre><code>/HELP NETWORK\n+/HELP SERVER\n+/HELP CHANNEL\n+/HELP\n+</code></pre></div></div>\n \n-<p>Automatically join to channels after connected to server, send op request to bot after joined to efnet/#irssi:</p>\n+<p>If you want lines containing your nick to hilight:</p>\n \n-<pre><code> /CHANNEL ADD -auto #irssi IRCnet\n- /CHANNEL ADD -auto -bots *!*bot@host.org -botcmd \"/^msg $0 op pass\" #irssi efnet\n-</code></pre>\n+<div><div><pre><code>/HILIGHT nick\n+</code></pre></div></div>\n \n-<p>If you want lines containing your nick to hilight:</p>\n+<p>Or, for irssi 0.8.18 or higher:</p>\n+\n+<div><div><pre><code>/SET hilight_nick_matches_everywhere ON\n+</code></pre></div></div>\n+\n+<p>To get beeps on private messages or highlights:</p>\n+\n+<div><div><pre><code>/SET beep_msg_level MSGS HILIGHT DCCMSGS\n+</code></pre></div></div>\n \n-<pre><code> /HILIGHT nick\n-</code></pre>\n+<p>No other irssi settings are needed (don’t enable bell_beeps), but there may be settings to change in your terminal multiplexer (screen/tmux), your terminal, or your desktop environment.</p>\n \n <h2 id=\"basic-user-interface-usage\">2. Basic user interface usage</h2>\n \n <p>Windows can be scrolled up/down with PgUp and PgDown keys. If they don’t work for you, use Meta-p and Meta-n keys. For jumping to beginning or end of the buffer, use <code>/SB HOME</code> and <code>/SB END</code> commands.</p>\n \n-<p>By default, irssi uses “hidden windows” for everything. Hidden window is created every time you <code>/JOIN</code> a channel or <code>/QUERY</code> someone. There’s several ways you can change between these windows:</p>\n+<p>By default, irssi uses “hidden windows” for everything. Hidden windows are created every time you <code>/JOIN</code> a channel or <code>/QUERY</code> someone. There’s several ways you can change between these windows:</p>\n \n-<pre><code> Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10\n- Meta-q .. Meta-o          - Jump directly between windows 11-19\n- /WINDOW &lt;number&gt;          - Jump to any window with specified number\n- Ctrl-P, Ctrl-N            - Jump to previous / next window\n-</code></pre>\n+<div><div><pre><code>Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10\n+Meta-q .. Meta-o          - Jump directly between windows 11-19\n+/WINDOW &lt;number&gt;          - Jump to any window with specified number\n+Ctrl-P, Ctrl-N            - Jump to previous / next window\n+</code></pre></div></div>\n \n-<p>Clearly the easiest way is to use Meta-number keys. And what is the Meta key? ESC key always works as Meta, but there’s also easier ways. ALT could work as Meta, or if you have Windows keyboard, left Windows key might work as Meta. If they don’t work directly, you’ll need to set a few X resources (NOTE: these work with both xterm and rxvt):</p>\n+<p>Clearly the easiest way is to use Meta-number keys. Meta usually means the ALT key, but if that doesn’t work, you can use ESC.</p>\n \n-<pre><code> XTerm*eightBitInput:   false\n+<p>Mac OS X users with ALT key issues might prefer using <a href=\"https://www.iterm2.com/\">iTerm2</a> instead of the default terminal emulator.</p>\n+\n+<h3 id=\"alt-key-as-meta-for-xtermrxvt-users\">Alt key as meta, for xterm/rxvt users</h3>\n+\n+<p>If you use xterm or rxvt, you may need to set a few X resources:</p>\n+\n+<div><div><pre><code> XTerm*eightBitInput:   false\n  XTerm*metaSendsEscape: true\n-</code></pre>\n+</code></pre></div></div>\n \n <p>With rxvt, you can also specify which key acts as Meta key. So if you want to use ALT instead of Windows key for it, use:</p>\n \n-<pre><code> rxvt*modifier: alt\n-</code></pre>\n+<div><div><pre><code> rxvt*modifier: alt\n+</code></pre></div></div>\n \n <p>You could do this by changing the X key mappings:</p>\n \n-<pre><code> xmodmap -e \"keysym Alt_L = Meta_L Alt_L\"\n-</code></pre>\n+<div><div><pre><code> xmodmap -e \"keysym Alt_L = Meta_L Alt_L\"\n+</code></pre></div></div>\n \n <p>And how exactly do you set these X resources? For Debian, there’s <code>/etc/X11/Xresources/xterm</code> file where you can put them and it’s read automatically when X starts. <code>~/.Xresources</code> and <code>~/.Xdefaults</code> files might also work. If you can’t get anything else to work, just copy and paste those lines to <code>~/.Xresources</code> and directly call <code>xrdb -merge ~/.Xresources</code> in some xterm. The resources affect only the new xterms you start, not existing ones.</p>\n \n-<p>Many windows SSH clients also don’t allow usage of ALT. One excellent client that does allow is putty, you can download it from <a href=\"http://www.chiark.greenend.org.uk/~sgtatham/putty/\"> http://www.chiark.greenend.org.uk/~sgtatham/putty/</a>.</p>\n+<h3 id=\"split-windows-and-window-items\">Split windows and window items</h3>\n+\n+<p><em>Note: <a href=\"http://quadpoint.org/articles/irssisplit/\">this guide</a> might be a better introduction to window splits</em></p>\n \n <p>Irssi also supports split windows, they’ve had some problems in past but I think they should work pretty well now :) Here’s some commands related to them:</p>\n \n-<pre><code> /WINDOW NEW                    - Create new split window\n- /WINDOW NEW HIDE               - Create new hidden window\n- /WINDOW CLOSE                  - Close split or hidden window\n+<div><div><pre><code>/WINDOW NEW                    - Create new split window\n+/WINDOW NEW HIDE               - Create new hidden window\n+/WINDOW CLOSE                  - Close split or hidden window\n \n- /WINDOW HIDE [&lt;number&gt;|&lt;name&gt;] - Make the split window hidden window\n- /WINDOW SHOW &lt;number&gt;|&lt;name&gt;   - Make the hidden window a split window\n+/WINDOW HIDE [&lt;number&gt;|&lt;name&gt;] - Make the split window hidden window\n+/WINDOW SHOW &lt;number&gt;|&lt;name&gt;   - Make the hidden window a split window\n \n- /WINDOW SHRINK [&lt;lines&gt;]       - Shrink the split window\n- /WINDOW GROW [&lt;lines&gt;]         - Grow the split window\n- /WINDOW BALANCE                - Balance the sizes of all split windows\n-</code></pre>\n+/WINDOW SHRINK [&lt;lines&gt;]       - Shrink the split window\n+/WINDOW GROW [&lt;lines&gt;]         - Grow the split window\n+/WINDOW BALANCE                - Balance the sizes of all split windows\n+</code></pre></div></div>\n \n <p>By default, irssi uses “sticky windowing” for split windows. This means that windows created inside one split window cannot be moved to another split window without some effort. For example you could have following window layout:</p>\n \n-<pre><code> Split window 1: win#1 - Status window, win#2 - Messages window\n+<div><div><pre><code> Split window 1: win#1 - Status window, win#2 - Messages window\n  Split window 2: win#3 - IRCnet/#channel1, win#4 - IRCnet/#channel2\n  Split window 3: win#5 - efnet/#channel1, win#6 - efnet/#channel2\n-</code></pre>\n+</code></pre></div></div>\n \n <p>When you are in win#1 and press ALT-6, irssi jumps to split window #3 and moves the efnet/#channel2 the active window.</p>\n \n <p>With non-sticky windowing the windows don’t have any relationship with split windows, pressing ALT-6 in win#1 moves win#6 to split window 1 and sets it active, except if win#6 was already visible in some other split window irssi just changes to that split window. This it the way windows work with ircii, if you prefer it you can set it with</p>\n \n-<pre><code> /SET autostick_split_windows OFF\n-</code></pre>\n+<div><div><pre><code>/SET autostick_split_windows OFF\n+</code></pre></div></div>\n \n <p>Each window can have multiple channels, queries and other “window items” inside them. If you don’t like windows at all, you disable automatic creating of them with</p>\n \n-<pre><code> /SET autocreate_windows OFF\n-</code></pre>\n+<div><div><pre><code>/SET autocreate_windows OFF\n+</code></pre></div></div>\n \n <p>And if you keep all channels in one window, you most probably want the channel name printed in each line:</p>\n \n-<pre><code> /SET print_active_channel ON\n-</code></pre>\n+<div><div><pre><code>/SET print_active_channel ON\n+</code></pre></div></div>\n \n <p>If you want to group only some channels or queries in one window, use</p>\n \n-<pre><code> /JOIN -window #channel\n- /QUERY -window nick\n-</code></pre>\n+<div><div><pre><code>/JOIN -window #channel\n+/QUERY -window nick\n+</code></pre></div></div>\n \n <h2 id=\"server-and-channel-automation\">3. Server and channel automation</h2>\n \n <p>Irssi’s multiple IRC network support is IMHO very good - at least compared to other clients :) Even if you’re only in one IRC network you should group all your servers to be in the same IRC network as this helps with reconnecting if your primary server breaks and is probably useful in some other ways too :) For information how to actually use irssi correctly with multiple servers see the chapter 6.</p>\n \n-<p>First you need to have your IRC network set, use <code>/NETWORK</code> command to see if it’s already there. If it isn’t, use <code>/NETWORK ADD yournetwork</code>. If you want to execute some commands automatically when you’re connected to some network, use <code>-autosendcmd</code> option. (NOTE: use /IRCNET with 0.8.9 and older.) Here’s some examples:</p>\n+<p>First you need to have your IRC network set, use <code>/NETWORK</code> command to see if it’s already there. If it isn’t, use <code>/NETWORK ADD yournetwork</code>. If you want to execute some commands automatically when you’re connected to some network, use <code>-autosendcmd</code> option. Here’s some examples:</p>\n \n-<pre><code> /NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet\n- /NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC\n-</code></pre>\n+<div><div><pre><code>/NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet\n+/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC\n+</code></pre></div></div>\n \n <p>After that you need to add your servers. For example:</p>\n \n-<pre><code> /SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667\n- /SERVER ADD -auto -network worknet irc.mycompany.com 6667 password\n-</code></pre>\n+<div><div><pre><code>/SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667\n+/SERVER ADD -auto -network worknet irc.mycompany.com 6667 password\n+</code></pre></div></div>\n \n <p>The <code>-auto</code> option specifies that this server is automatically connected at startup. You don’t need to make more than one server with <code>-auto</code> option to one IRC network, other servers are automatically connected in same network if the <code>-auto</code> server fails.</p>\n \n <p>And finally channels:</p>\n \n-<pre><code> /CHANNEL ADD -auto -bots *!*bot@host.org -botcmd \"/^msg $0 op pass\" #irssi efnet\n- /CHANNEL ADD -auto #secret IRCnet password\n-</code></pre>\n+<div><div><pre><code>/CHANNEL ADD -auto -bots *!*user@host -botcmd \"/^msg $0 op pass\" #irssi efnet\n+/CHANNEL ADD -auto #secret IRCnet password\n+</code></pre></div></div>\n \n <p><code>-bots</code> and <code>-botcmd</code> should be the only ones needing a bit of explaining. They’re used to send commands automatically to bot when channel is joined, usually to get ops automatically. You can specify multiple bot masks with <code>-bots</code> option separated with spaces (and remember to quote the string then). The $0 in <code>-botcmd</code> specifies the first found bot in the list. If you don’t need the bot masks (ie. the bot is always with the same nick, like chanserv) you can give only the <code>-botcmd</code> option and the command is always sent.</p>\n \n@@ -228,9 +237,9 @@\n \n <p>First connect to all the servers, join the channels and create the queries you want. If you want to move the windows or channels around use commands:</p>\n \n-<pre><code> /WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere\n- /WINDOW ITEM MOVE &lt;number&gt;|&lt;name&gt; - move channel/query to another window\n-</code></pre>\n+<div><div><pre><code>/WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere\n+/WINDOW ITEM MOVE &lt;number&gt;|&lt;name&gt; - move channel/query to another window\n+</code></pre></div></div>\n \n <p>When everything looks the way you like, use <code>/LAYOUT SAVE</code> command (and <code>/SAVE</code>, if you don’t have autosaving enabled) and when you start irssi next time, irssi remembers the positions of the channels, queries and everything. This “remembering” doesn’t mean that simply using <code>/LAYOUT SAVE</code> would automatically make irssi reconnect to all servers and join all channels, you’ll need the <code>/SERVER ADD -auto</code> and <code>/CHANNEL ADD -auto</code> commands to do that.</p>\n \n@@ -240,32 +249,32 @@\n \n <p>By default, all the “extra messages” go to status window. This means pretty much all messages that don’t clearly belong to some channel or query. Some people like it, some don’t. If you want to remove it, use</p>\n \n-<pre><code> /SET use_status_window OFF\n-</code></pre>\n+<div><div><pre><code>/SET use_status_window OFF\n+</code></pre></div></div>\n \n <p>This doesn’t have any effect until you restart irssi. If you want to remove it immediately, just <code>/WINDOW CLOSE</code> it.</p>\n \n <p>Another common window is “messages window”, where all private messages go. By default it’s disabled and query windows are created instead. To make all private messages go to msgs window, say:</p>\n \n-<pre><code> /SET use_msgs_window ON\n- /SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to\n+<div><div><pre><code>/SET use_msgs_window ON\n+/SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to\n  				      dcc chats either, say NONE)\n-</code></pre>\n+</code></pre></div></div>\n \n <p>use_msgs_window either doesn’t have any effect until restarting irssi. To create it immediately say:</p>\n \n-<pre><code> /WINDOW NEW HIDE     - create the window\n- /WINDOW NAME (msgs)  - name it to \"(msgs)\"\n- /WINDOW LEVEL MSGS   - make all private messages go to this window\n- /WINDOW MOVE 1       - move it to first window\n-</code></pre>\n+<div><div><pre><code>/WINDOW NEW HIDE     - create the window\n+/WINDOW NAME (msgs)  - name it to \"(msgs)\"\n+/WINDOW LEVEL MSGS   - make all private messages go to this window\n+/WINDOW MOVE 1       - move it to first window\n+</code></pre></div></div>\n \n <p>Note that neither use_msgs_window nor use_status_window have any effect at all if <code>/LAYOUT SAVE</code> has been used.</p>\n \n <p>This brings us to message levels.. What are they? All messages that irssi prints have one or more “message levels”. Most common are PUBLIC for public messages in channels, MSGS for private messages and CRAP for all sorts of messages with no real classification. You can get a whole list of levels with</p>\n \n-<pre><code> /HELP levels\n-</code></pre>\n+<div><div><pre><code>/HELP levels\n+</code></pre></div></div>\n \n <p>Status window has message level <code>ALL -MSGS</code>, meaning that all messages, except private messages, without more specific place go to status window. The <code>-MSGS</code> is there so it doesn’t conflict with messages window.</p>\n \n@@ -273,15 +282,15 @@\n \n <p>ircii and several other clients support multiple servers by placing the connection into some window. IRSSI DOES NOT. There is no required relationship between window and server. You can connect to 10 servers and manage them all in just one window, or join channel in each one of them to one single window if you really want to. That being said, here’s how you do connect to new server without closing the old connection:</p>\n \n-<pre><code> /CONNECT irc.server.org\n-</code></pre>\n+<div><div><pre><code>/CONNECT irc.server.org\n+</code></pre></div></div>\n \n <p>Instead of the <code>/SERVER</code> which disconnects the existing connection. To see list of all active connections, use <code>/SERVER</code> without any parameters. You should see a list of something like:</p>\n \n-<pre><code> -!- IRCNet: irc.song.fi:6667 (IRCNet)\n+<div><div><pre><code> -!- IRCNet: irc.song.fi:6667 (IRCNet)\n  -!- OFTC: irc.oftc.net:6667 (OFTC)\n  -!- RECON-1: 192.168.0.1:6667 () (02:59 left before reconnecting)\n-</code></pre>\n+</code></pre></div></div>\n \n <p>Here you see that we’re connected to IRCNet and OFTC networks. The IRCNet at the beginning is called the “server tag” while the (IRCnet) at the end shows the IRC network. Server tag specifies unique tag to refer to the server, usually it’s the same as the IRC network. When the IRC network isn’t known it’s some part of the server name. When there’s multiple connections to same IRC network or server, irssi adds a number after the tag so there could be network, network2, network3 etc.</p>\n \n@@ -289,63 +298,63 @@\n \n <p>To disconnect one of the servers, or to stop irssi from reconnecting, use</p>\n \n-<pre><code> /DISCONNECT network   - disconnect server with tag \"network\"\n- /DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server\n- /RMRECONNS           - stop all server reconnections\n+<div><div><pre><code>/DISCONNECT network   - disconnect server with tag \"network\"\n+/DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server\n+/RMRECONNS           - stop all server reconnections\n \n- /RECONNECT recon-1   - immediately try reconnecting back to RECON-1\n- /RECONNECT ALL       - immediately try reconnecting back to all\n+/RECONNECT recon-1   - immediately try reconnecting back to RECON-1\n+/RECONNECT ALL       - immediately try reconnecting back to all\n  		       servers in reconnection queue\n-</code></pre>\n+</code></pre></div></div>\n \n <p>Now that you’re connected to all your servers, you’ll have to know how to specify which one of them you want to use. One way is to have an empty window, like status or msgs window. In it, you can specify which server to set active with</p>\n \n-<pre><code> /WINDOW SERVER tag    - set server \"tag\" active\n- Ctrl-X                - set the next server in list active\n-</code></pre>\n+<div><div><pre><code>/WINDOW SERVER tag    - set server \"tag\" active\n+Ctrl-X                - set the next server in list active\n+</code></pre></div></div>\n \n <p>When the server is active, you can use it normally. When there’s multiple connected servers, irssi adds [servertag] prefix to all messages in non-channel/query messages so you’ll know where it came from.</p>\n \n <p>Several commands also accept <code>-servertag</code> option to specify which server it should use:</p>\n \n-<pre><code> /MSG -tag nick message\n- /JOIN -tag #channel\n- /QUERY -tag nick\n-</code></pre>\n+<div><div><pre><code>/MSG -tag nick message\n+/JOIN -tag #channel\n+/QUERY -tag nick\n+</code></pre></div></div>\n \n <p><code>/MSG</code> tab completion also automatically adds the <code>-tag</code> option when nick isn’t in active server.</p>\n \n <p>Window’s server can be made sticky. When sticky, it will never automatically change to anything else, and if server gets disconnected, the window won’t have any active server. When the server gets connected again, it is automatically set active in the window. To set the window’s server sticky use</p>\n \n-<pre><code> /WINDOW SERVER -sticky tag\n-</code></pre>\n+<div><div><pre><code>/WINDOW SERVER -sticky tag\n+</code></pre></div></div>\n \n <p>This is useful if you wish to have multiple status or msgs windows, one for each server. Here’s how to do them (repeat for each server)</p>\n \n-<pre><code> /WINDOW NEW HIDE\n- /WINDOW NAME (status)\n- /WINDOW LEVEL ALL -MSGS\n- /WINDOW SERVER -sticky network\n+<div><div><pre><code>/WINDOW NEW HIDE\n+/WINDOW NAME (status)\n+/WINDOW LEVEL ALL -MSGS\n+/WINDOW SERVER -sticky network\n \n- /WINDOW NEW HIDE\n- /WINDOW NAME (msgs)\n- /WINDOW LEVEL MSGS\n- /WINDOW SERVER -sticky network\n-</code></pre>\n+/WINDOW NEW HIDE\n+/WINDOW NAME (msgs)\n+/WINDOW LEVEL MSGS\n+/WINDOW SERVER -sticky network\n+</code></pre></div></div>\n \n <h2 id=\"lastlog-and-jumping-around-in-scrollback\">7. /LASTLOG and jumping around in scrollback</h2>\n \n <p><code>/LASTLOG</code> command can be used for searching texts in scrollback buffer. Simplest usages are</p>\n \n-<pre><code> /LASTLOG word     - print all lines with \"word\" in them\n- /LASTLOG word 10  - print last 10 occurances of \"word\"\n- /LASTLOG -topics  - print all topic changes\n-</code></pre>\n+<div><div><pre><code>/LASTLOG word     - print all lines with \"word\" in them\n+/LASTLOG word 10  - print last 10 occurances of \"word\"\n+/LASTLOG -topics  - print all topic changes\n+</code></pre></div></div>\n \n <p>If there’s more than 1000 lines to be printed, irssi thinks that you probably made some mistake and won’t print them without <code>-force</code> option. If you want to save the full lastlog to file, use</p>\n \n-<pre><code> /LASTLOG -file ~/irc.log\n-</code></pre>\n+<div><div><pre><code>/LASTLOG -file ~/irc.log\n+</code></pre></div></div>\n \n <p>With <code>-file</code> option you don’t need <code>-force</code> even if there’s more than 1000 lines. <code>/LASTLOG</code> has a lot of other options too, see <code>/HELP lastlog</code> for details.</p>\n \n@@ -355,29 +364,29 @@\n \n <p>Irssi can automatically log important messages when you’re set away (<code>/AWAY reason</code>). When you set yourself unaway (<code>/AWAY</code>), the new messages in away log are printed to screen. You can configure it with:</p>\n \n-<pre><code> /SET awaylog_level MSGS HILIGHT     - Specifies what messages to log\n- /SET awaylog_file ~/.irssi/away.log - Specifies the file to use\n-</code></pre>\n+<div><div><pre><code>/SET awaylog_level MSGS HILIGHT     - Specifies what messages to log\n+/SET awaylog_file ~/.irssi/away.log - Specifies the file to use\n+</code></pre></div></div>\n \n <p>Easiest way to start logging with Irssi is to use autologging. With it Irssi logs all channels and private messages to specified directory. You can turn it on with</p>\n \n-<pre><code> /SET autolog ON\n-</code></pre>\n+<div><div><pre><code>/SET autolog ON\n+</code></pre></div></div>\n \n <p>By default it logs pretty much everything execept CTCPS or CRAP (<code>/WHOIS</code> requests, etc). You can specify the logging level yourself with</p>\n \n-<pre><code> /SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default)\n-</code></pre>\n+<div><div><pre><code>/SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default)\n+</code></pre></div></div>\n \n <p>By default irssi logs to ~/irclogs/<servertag>/<target>.log. You can change this with</target></servertag></p>\n \n-<pre><code> /SET autolog_path ~/irclogs/$tag/$0.log (this is the default)\n-</code></pre>\n+<div><div><pre><code>/SET autolog_path ~/irclogs/$tag/$0.log (this is the default)\n+</code></pre></div></div>\n \n <p>The path is automatically created if it doesn’t exist. $0 specifies the target (channel/nick). You can make irssi automatically rotate the logs by adding date/time formats to the file name. The formats are in “man strftime” format. For example</p>\n \n-<pre><code> /SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log\n-</code></pre>\n+<div><div><pre><code>/SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log\n+</code></pre></div></div>\n \n <p>For logging only some specific channels or nicks, see <code>/HELP log</code></p>\n \n@@ -387,16 +396,16 @@\n \n <p><code>/HELP bind</code> tells pretty much everything there is to know about keyboard bindings. However, there’s the problem of how to bind some non-standard keys. They might differ a bit with each terminal, so you’ll need to find out what exactly the keypress produces. Easiest way to check that would be to see what it prints in <code>cat</code>. Here’s an example for pressing F1 key:</p>\n \n-<pre><code> [cras@hurina] ~% cat\n+<div><div><pre><code> [user@host] ~% cat\n  ^[OP\n-</code></pre>\n+</code></pre></div></div>\n \n <p>So in irssi you would use <code>/BIND ^[OP /ECHO F1 pressed</code>. If you use multiple terminals which have different bindings for the key, it would be better to use eg.:</p>\n \n-<pre><code> /BIND ^[OP key F1\n- /BIND ^[11~ key F1\n- /BIND F1 /ECHO F1 pressed.\n-</code></pre>\n+<div><div><pre><code>/BIND ^[OP key F1\n+/BIND ^[11~ key F1\n+/BIND F1 /ECHO F1 pressed.\n+</code></pre></div></div>\n \n <h2 id=\"proxies-and-irc-bouncers\">10. Proxies and IRC bouncers</h2>\n \n@@ -404,20 +413,20 @@\n \n <p>Here’s an example: You have your bouncer (lets say, BNC or BNC-like) listening in irc.bouncer.org port 5000. You want to use it to connect to servers irc.dalnet and irc.efnet.org. First you’d need to setup the bouncer:</p>\n \n-<pre><code> /SET use_proxy ON\n- /SET proxy_address irc.bouncer.org\n- /SET proxy_port 5000\n+<div><div><pre><code>/SET use_proxy ON\n+/SET proxy_address irc.bouncer.org\n+/SET proxy_port 5000\n \n- /SET proxy_password YOUR_BNC_PASSWORD_HERE\n- /SET -clear proxy_string\n- /SET proxy_string_after conn %s %d\n-</code></pre>\n+/SET proxy_password YOUR_BNC_PASSWORD_HERE\n+/SET -clear proxy_string\n+/SET proxy_string_after conn %s %d\n+</code></pre></div></div>\n \n <p>Then you’ll need to add the server connections. These are done exactly as if you’d want to connect directly to them. Nothing special about them:</p>\n \n-<pre><code> /SERVER ADD -auto -network dalnet irc.dal.net\n- /SERVER ADD -auto -network efnet irc.efnet.org\n-</code></pre>\n+<div><div><pre><code>/SERVER ADD -auto -network dalnet irc.dal.net\n+/SERVER ADD -auto -network efnet irc.efnet.org\n+</code></pre></div></div>\n \n <p>With the proxy <code>/SET</code>s however, irssi now connects to those servers through your BNC. All server connections are made through them so you can just forget that your bouncer even exists.</p>\n \n@@ -427,36 +436,36 @@\n \n <p>All proxies have these settings in common:</p>\n \n-<pre><code> /SET use_proxy ON\n- /SET proxy_address &lt;Proxy host address&gt;\n- /SET proxy_port &lt;Proxy port&gt;\n-</code></pre>\n+<div><div><pre><code>/SET use_proxy ON\n+/SET proxy_address &lt;Proxy host address&gt;\n+/SET proxy_port &lt;Proxy port&gt;\n+</code></pre></div></div>\n \n <p><strong>HTTP proxy</strong></p>\n \n <p>Use these settings with HTTP proxies:</p>\n \n-<pre><code> /SET -clear proxy_password\n- /EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n\n-</code></pre>\n+<div><div><pre><code>/SET -clear proxy_password\n+/EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n\n+</code></pre></div></div>\n \n <p><strong>BNC</strong></p>\n \n-<pre><code> /SET proxy_password your_pass\n- /SET -clear proxy_string\n- /SET proxy_string_after conn %s %d\n-</code></pre>\n+<div><div><pre><code>/SET proxy_password your_pass\n+/SET -clear proxy_string\n+/SET proxy_string_after conn %s %d\n+</code></pre></div></div>\n \n <p><strong>dircproxy</strong></p>\n \n <p>dircproxy separates the server connections by passwords. So, if you for example have network connection with password ircpass and OFTC connection with oftcpass, you would do something like this:</p>\n \n-<pre><code> /SET -clear proxy_password\n- /SET -clear proxy_string\n+<div><div><pre><code>/SET -clear proxy_password\n+/SET -clear proxy_string\n \n- /SERVER ADD -auto -network IRCnet fake.network 6667 ircpass\n- /SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass\n-</code></pre>\n+/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass\n+/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass\n+</code></pre></div></div>\n \n <p>The server name and port you give isn’t used anywhere, so you can put anything you want in there.</p>\n \n@@ -464,19 +473,17 @@\n \n <p>psyBNC has internal support for multiple servers. However, it could be a bit annoying to use, and some people just use different users for connecting to different servers. You can manage this in a bit same way as with dircproxy, by creating fake connections:</p>\n \n-<pre><code> /SET -clear proxy_password\n- /SET -clear proxy_string\n+<div><div><pre><code>/SET -clear proxy_password\n+/SET -clear proxy_string\n \n- /NETWORK ADD -user networkuser IRCnet\n- /SERVER ADD -auto -network IRCnet fake.network 6667 ircpass\n- /NETWORK ADD -user oftcuser OFTC\n- /SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass\n-</code></pre>\n+/NETWORK ADD -user networkuser IRCnet\n+/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass\n+/NETWORK ADD -user oftcuser OFTC\n+/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass\n+</code></pre></div></div>\n \n <p>So, you’ll specify the usernames with <code>/NETWORK ADD</code> command, and the user’s password with <code>/SERVER ADD</code>.</p>\n \n-<p>(NOTE: use /IRCNET with 0.8.9 and older.)</p>\n-\n <p><strong>Irssi proxy</strong></p>\n \n <p>Irssi contains it’s own proxy which you can build giving <code>\\--with-proxy</code> option to configure. You’ll still need to run irssi in a screen to use it though.</p>\n@@ -487,65 +494,52 @@\n \n <p>Usage in proxy side:</p>\n \n-<pre><code> /LOAD proxy\n- /SET irssiproxy_password &lt;password&gt;\n- /SET irssiproxy_ports &lt;network&gt;=&lt;port&gt; ... (eg. IRCnet=2777 efnet=2778)\n-</code></pre>\n+<div><div><pre><code>/LOAD proxy\n+/SET irssiproxy_password &lt;password&gt;\n+/SET irssiproxy_ports &lt;network&gt;=&lt;port&gt; ... (eg. IRCnet=2777 efnet=2778)\n+</code></pre></div></div>\n \n <p><strong>NOTE</strong>: you <strong>MUST</strong> add all the servers you are using to server and network lists with <code>/SERVER ADD</code> and <code>/NETWORK ADD</code>. ..Except if you really don’t want to for some reason, and you only use one server connection, you may simply set:</p>\n \n-<pre><code> /SET irssiproxy_ports *=2777\n-</code></pre>\n-\n-<p>The special network name <code>?</code> allows the client to select the\n-network dynamically on connect (see below):</p>\n-\n-<pre>\n-/SET irssiproxy_ports ?=2777\n-</pre>\n+<div><div><pre><code>/SET irssiproxy_ports *=2777\n+</code></pre></div></div>\n \n <p>Usage in client side:</p>\n \n <p>Just connect to the irssi proxy like it is a normal server with password specified in <code>/SET irssiproxy_password</code>. For example:</p>\n \n-<pre><code> /SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret\n- /SERVER ADD -network efnet my.irssi-proxy.org 2778 secret\n-</code></pre>\n-\n-<p>Or, if you used <code>?</code> in <code>irssiproxy_ports</code>:</p>\n-\n-<pre>\n-/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 IRCnet:secret\n-/SERVER ADD -network efnet my.irssi-proxy.org 2777 efnet:secret\n-</pre>\n-\n-<p>I.e. the network to connect to is specified as part of the password,\n-separated by <code>:</code> from the actual proxy password.</p>\n+<div><div><pre><code>/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret\n+/SERVER ADD -network efnet my.irssi-proxy.org 2778 secret\n+</code></pre></div></div>\n \n <p>Irssi proxy works fine with other IRC clients as well.</p>\n \n <p><strong>SOCKS</strong></p>\n \n-<p>Irssi can be compiled with socks support (<code>\\--with-socks</code> option to configure), but I don’t really know how it works, if at all. <code>/SET proxy</code> settings don’t have anything to do with socks however.</p>\n+<p>Irssi can be compiled with socks support (<code>\\--with-socks</code> option to configure), which requires “dante” and routes all connections through the proxy specified in the system-wide /etc/socks.conf. This method is known to have issues in Mac OS X.</p>\n+\n+<p>Note that <code>/SET proxy</code> settings don’t have anything to do with socks.</p>\n+\n+<p>Using <a href=\"https://github.com/rofl0r/proxychains-ng\">proxychains-ng</a> is recommended over recompiling irssi.</p>\n \n <p><strong>Others</strong></p>\n \n <p>IRC bouncers usually work like IRC servers, and want a password. You can give it with:</p>\n \n-<pre><code> /SET proxy_password &lt;password&gt;\n-</code></pre>\n+<div><div><pre><code>/SET proxy_password &lt;password&gt;\n+</code></pre></div></div>\n \n <p>Irssi’s defaults for connect strings are</p>\n \n-<pre><code> /SET proxy_string CONNECT %s %d\n- /SET proxy_string_after\n-</code></pre>\n+<div><div><pre><code>/SET proxy_string CONNECT %s %d\n+/SET proxy_string_after\n+</code></pre></div></div>\n \n <p>The proxy_string is sent before NICK/USER commands, the proxy_string_after is sent after them. %s and %d can be used with both of them.</p>\n \n <h2 id=\"irssis-settings\">11. Irssi’s settings</h2>\n \n-<p>You probably don’t like Irssi’s default settings. I don’t like them. But I’m still convinced that they’re pretty good defaults. Here’s some of them you might want to change (the default value is shown): Also check the <a href=\"/documentation/settings/\">Settings Documentation</a></p>\n+<p>Here’s some settings you might want to change (the default value is shown): Also check the <a href=\"/documentation/settings/\">Settings Documentation</a></p>\n \n <p><strong>Queries</strong></p>\n \n@@ -633,31 +627,61 @@ separated by <code>:</code> from the actual proxy password.</p>\n   <dd>Completion character to use.</dd>\n </dl>\n \n+<h3 id=\"for-all-the-ircii-people\">For all the ircII people</h3>\n+\n+<p>I don’t like automatic query windows, I don’t like status window, I do like msgs window where all messages go:</p>\n+\n+<div><div><pre><code>/SET autocreate_own_query OFF\n+/SET autocreate_query_level DCCMSGS\n+/SET use_status_window OFF\n+/SET use_msgs_window ON\n+</code></pre></div></div>\n+\n+<p>Disable automatic window closing when <code>/PART</code>ing channel or <code>/UNQUERY</code>ing query:</p>\n+\n+<div><div><pre><code>/SET autoclose_windows OFF\n+/SET reuse_unused_windows ON\n+</code></pre></div></div>\n+\n+<p>Here’s the settings that make irssi work exactly like ircII in window management (send me a note if you can think of more):</p>\n+\n+<div><div><pre><code>/SET autocreate_own_query OFF\n+/SET autocreate_query_level NONE\n+/SET use_status_window OFF\n+/SET use_msgs_window OFF\n+/SET reuse_unused_windows ON\n+/SET windows_auto_renumber OFF\n+\n+/SET autostick_split_windows OFF\n+/SET autoclose_windows OFF\n+/SET print_active_channel ON\n+</code></pre></div></div>\n+\n <h2 id=\"statusbar\">12. Statusbar</h2>\n \n-<p><code>/STATUSBAR</code> displays a list of statusbars:</p>\n+<p><code>/STATUSBAR</code> displays a list of the current statusbars, along with their position and visibility:</p>\n \n-<pre><code> Name                           Type   Placement Position Visible\n+<div><div><pre><code> Name                           Type   Placement Position Visible\n  window                         window bottom    0        always\n  window_inact                   window bottom    1        inactive\n  prompt                         root   bottom    100      always\n  topic                          root   top       1        always\n-</code></pre>\n+</code></pre></div></div>\n \n-<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings and it’s items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to it’s default settings, or if the statusbar was created by you, it will be removed.</p>\n+<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings (type, placement, position, visibility) as well as its items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to its default settings, or if the statusbar was created by you, it will be removed.</p>\n \n-<p>Type can be window or root, meaning if the statusbar should be created for each split window, or just once. Placement can be top or bottom. Position is a number, the higher the value the lower in screen it is. Visible can be always, active or inactive. Active/inactive is useful only with split windows, one split window is active and the rest are inactive. These settings can be changed with:</p>\n+<p>The statusbar type can be either window or root. If the type is window, then a statusbar will be created for each split window, otherwise it will be created only once. Placement can be top or bottom, which refers to the top or bottom of the screen. Position is a number, the higher the value the lower it will appear in-screen. Visible can be always, active or inactive. Active/inactive is useful only with split windows; one split window is active and the rest are inactive. To adjust these settings, the following commands are available:</p>\n \n-<pre><code> /STATUSBAR &lt;name&gt; TYPE window|root\n- /STATUSBAR &lt;name&gt; PLACEMENT top|bottom\n- /STATUSBAR &lt;name&gt; POSITION &lt;num&gt;\n- /STATUSBAR &lt;name&gt; VISIBLE always|active|inactive\n-</code></pre>\n+<div><div><pre><code>/STATUSBAR &lt;name&gt; TYPE window|root\n+/STATUSBAR &lt;name&gt; PLACEMENT top|bottom\n+/STATUSBAR &lt;name&gt; POSITION &lt;num&gt;\n+/STATUSBAR &lt;name&gt; VISIBLE always|active|inactive\n+</code></pre></div></div>\n \n-<p>When loading a new statusbar scripts, you’ll need to also specify where you want to show it. Statusbar items can be modified with:</p>\n+<p>Statusbar items can also be added or removed via command. Note that when loading new statusbar scripts that add items, you will need to specify where you want to show the item and how it is aligned. This can be accomplished using the below commands:</p>\n \n-<pre><code> /STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt;\n- /STATUSBAR &lt;name&gt; REMOVE &lt;item&gt;\n-</code></pre>\n+<div><div><pre><code>/STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt;\n+/STATUSBAR &lt;name&gt; REMOVE &lt;item&gt;\n+</code></pre></div></div>\n \n-<p>The item name with statusbar scripts is usually same as the script’s name. Script’s documentation should tell if this isn’t the case. So, to add mail.pl before the window activity item (see the list with <code>/STATUSBAR</code> window), use: <code>/STATUSBAR window ADD -before act mail</code>.</p>\n+<p>For statusbar scripts, the item name is usually equivalent to the script name. The documentation of the script ought to tell you if this is not the case. For example, to add mail.pl before the window activity item, use: <code>/STATUSBAR window ADD -before act mail</code>.</p>\n\\ No newline at end of file\n','false','false','none'),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','startup-HOWTO.txt','582','0','797','0','ADD','@@ -0,0 +1,797 @@\n+Startup How-To\n+\n+To new Irssi users (not to new IRC users ..)\n+\n+Copyright (c) 2000-2002 by Timo Sirainen, release under [1]GNU FDL 1.1 license.\n+\n+Index with some FAQ questions that are answered in the chapter:\n+\n+ 1. First steps\n+ 2. Basic user interface usage\n+      □ Split windows work in weird way\n+      □ How can I easily switch between windows?\n+      □ But alt-1 etc. don’t work!\n+ 3. Server and channel automation\n+      □ How do I automatically connect to servers at startup?\n+      □ How do I automatically join to channels at startup?\n+      □ How do I automatically send commands to server at connect?\n+ 4. Setting up windows and automatically restoring them at startup\n+ 5. Status and msgs windows & message levels\n+      □ I want /WHOIS to print reply to current window\n+      □ I want all messages to go to one window, not create new windows\n+ 6. How support for multiple servers works in irssi\n+      □ I connected to some server that doesn’t respond and now irssi keeps\n+        trying to reconnect to it again and again, how can I stop it??\n+      □ I want to have own status and/or msgs window for each servers\n+ 7. /LASTLOG and jumping around in scrollback\n+      □ How can I save all texts in a window to file?\n+ 8. Logging\n+ 9. Changing keyboard bindings\n+      □ How do I make F1 key do something?\n+10. Proxies and IRC bouncers\n+11. Irssi’s settings\n+      □ For all the ircII people\n+12. Statusbar\n+      □ I loaded a statusbar script but it’s not visible anywhere!\n+\n+1. First steps\n+\n+IRC Networks are made of servers, and servers have channels. The default config\n+has a few predefined networks, to list them:\n+\n+/NETWORK LIST\n+\n+And to connect to one of those networks and join a channel:\n+\n+/CONNECT Freenode\n+/JOIN #irssi\n+\n+To add more networks:\n+\n+/NETWORK ADD ExampleNet\n+\n+Then add some servers (with -auto to automatically connect):\n+\n+/SERVER ADD -auto -network ExampleNet irc.example.net\n+\n+Automatically join to channels after connected to server:\n+\n+/CHANNEL ADD -auto #lounge ExampleNet\n+\n+To modify existing networks (or servers, or channels) just ADD again using the\n+same name as before. This configures a network to identify with nickserv and\n+wait for 2 seconds before joining channels:\n+\n+/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" ExampleNet\n+\n+If you have irssi 0.8.18 or higher and the irc network supports it, you can use\n+SASL instead of nickserv, which is more reliable:\n+\n+/NETWORK ADD -sasl_username yourname -sasl_password yourpassword -sasl_mechanism PLAIN Freenode\n+\n+These commands have many more options, see their help for details:\n+\n+/HELP NETWORK\n+/HELP SERVER\n+/HELP CHANNEL\n+/HELP\n+\n+If you want lines containing your nick to hilight:\n+\n+/HILIGHT nick\n+\n+Or, for irssi 0.8.18 or higher:\n+\n+/SET hilight_nick_matches_everywhere ON\n+\n+To get beeps on private messages or highlights:\n+\n+/SET beep_msg_level MSGS HILIGHT DCCMSGS\n+\n+No other irssi settings are needed (don’t enable bell_beeps), but there may be\n+settings to change in your terminal multiplexer (screen/tmux), your terminal,\n+or your desktop environment.\n+\n+2. Basic user interface usage\n+\n+Windows can be scrolled up/down with PgUp and PgDown keys. If they don’t work\n+for you, use Meta-p and Meta-n keys. For jumping to beginning or end of the\n+buffer, use /SB HOME and /SB END commands.\n+\n+By default, irssi uses “hidden windows” for everything. Hidden windows are\n+created every time you /JOIN a channel or /QUERY someone. There’s several ways\n+you can change between these windows:\n+\n+Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10\n+Meta-q .. Meta-o          - Jump directly between windows 11-19\n+/WINDOW <number>          - Jump to any window with specified number\n+Ctrl-P, Ctrl-N            - Jump to previous / next window\n+\n+Clearly the easiest way is to use Meta-number keys. Meta usually means the ALT\n+key, but if that doesn’t work, you can use ESC.\n+\n+Mac OS X users with ALT key issues might prefer using [2]iTerm2 instead of the\n+default terminal emulator.\n+\n+Alt key as meta, for xterm/rxvt users\n+\n+If you use xterm or rxvt, you may need to set a few X resources:\n+\n+ XTerm*eightBitInput:   false\n+ XTerm*metaSendsEscape: true\n+\n+With rxvt, you can also specify which key acts as Meta key. So if you want to\n+use ALT instead of Windows key for it, use:\n+\n+ rxvt*modifier: alt\n+\n+You could do this by changing the X key mappings:\n+\n+ xmodmap -e \"keysym Alt_L = Meta_L Alt_L\"\n+\n+And how exactly do you set these X resources? For Debian, there’s /etc/X11/\n+Xresources/xterm file where you can put them and it’s read automatically when X\n+starts. ~/.Xresources and ~/.Xdefaults files might also work. If you can’t get\n+anything else to work, just copy and paste those lines to ~/.Xresources and\n+directly call xrdb -merge ~/.Xresources in some xterm. The resources affect\n+only the new xterms you start, not existing ones.\n+\n+Split windows and window items\n+\n+Note: [3]this guide might be a better introduction to window splits\n+\n+Irssi also supports split windows, they’ve had some problems in past but I\n+think they should work pretty well now :) Here’s some commands related to them:\n+\n+/WINDOW NEW                    - Create new split window\n+/WINDOW NEW HIDE               - Create new hidden window\n+/WINDOW CLOSE                  - Close split or hidden window\n+\n+/WINDOW HIDE [<number>|<name>] - Make the split window hidden window\n+/WINDOW SHOW <number>|<name>   - Make the hidden window a split window\n+\n+/WINDOW SHRINK [<lines>]       - Shrink the split window\n+/WINDOW GROW [<lines>]         - Grow the split window\n+/WINDOW BALANCE                - Balance the sizes of all split windows\n+\n+By default, irssi uses “sticky windowing” for split windows. This means that\n+windows created inside one split window cannot be moved to another split window\n+without some effort. For example you could have following window layout:\n+\n+ Split window 1: win#1 - Status window, win#2 - Messages window\n+ Split window 2: win#3 - IRCnet/#channel1, win#4 - IRCnet/#channel2\n+ Split window 3: win#5 - efnet/#channel1, win#6 - efnet/#channel2\n+\n+When you are in win#1 and press ALT-6, irssi jumps to split window #3 and moves\n+the efnet/#channel2 the active window.\n+\n+With non-sticky windowing the windows don’t have any relationship with split\n+windows, pressing ALT-6 in win#1 moves win#6 to split window 1 and sets it\n+active, except if win#6 was already visible in some other split window irssi\n+just changes to that split window. This it the way windows work with ircii, if\n+you prefer it you can set it with\n+\n+/SET autostick_split_windows OFF\n+\n+Each window can have multiple channels, queries and other “window items” inside\n+them. If you don’t like windows at all, you disable automatic creating of them\n+with\n+\n+/SET autocreate_windows OFF\n+\n+And if you keep all channels in one window, you most probably want the channel\n+name printed in each line:\n+\n+/SET print_active_channel ON\n+\n+If you want to group only some channels or queries in one window, use\n+\n+/JOIN -window #channel\n+/QUERY -window nick\n+\n+3. Server and channel automation\n+\n+Irssi’s multiple IRC network support is IMHO very good - at least compared to\n+other clients :) Even if you’re only in one IRC network you should group all\n+your servers to be in the same IRC network as this helps with reconnecting if\n+your primary server breaks and is probably useful in some other ways too :) For\n+information how to actually use irssi correctly with multiple servers see the\n+chapter 6.\n+\n+First you need to have your IRC network set, use /NETWORK command to see if\n+it’s already there. If it isn’t, use /NETWORK ADD yournetwork. If you want to\n+execute some commands automatically when you’re connected to some network, use\n+-autosendcmd option. Here’s some examples:\n+\n+/NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet\n+/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC\n+\n+After that you need to add your servers. For example:\n+\n+/SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667\n+/SERVER ADD -auto -network worknet irc.mycompany.com 6667 password\n+\n+The -auto option specifies that this server is automatically connected at\n+startup. You don’t need to make more than one server with -auto option to one\n+IRC network, other servers are automatically connected in same network if the\n+-auto server fails.\n+\n+And finally channels:\n+\n+/CHANNEL ADD -auto -bots *!*user@host -botcmd \"/^msg $0 op pass\" #irssi efnet\n+/CHANNEL ADD -auto #secret IRCnet password\n+\n+-bots and -botcmd should be the only ones needing a bit of explaining. They’re\n+used to send commands automatically to bot when channel is joined, usually to\n+get ops automatically. You can specify multiple bot masks with -bots option\n+separated with spaces (and remember to quote the string then). The $0 in\n+-botcmd specifies the first found bot in the list. If you don’t need the bot\n+masks (ie. the bot is always with the same nick, like chanserv) you can give\n+only the -botcmd option and the command is always sent.\n+\n+4. Setting up windows and automatically restoring them at startup\n+\n+First connect to all the servers, join the channels and create the queries you\n+want. If you want to move the windows or channels around use commands:\n+\n+/WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere\n+/WINDOW ITEM MOVE <number>|<name> - move channel/query to another window\n+\n+When everything looks the way you like, use /LAYOUT SAVE command (and /SAVE, if\n+you don’t have autosaving enabled) and when you start irssi next time, irssi\n+remembers the positions of the channels, queries and everything. This\n+“remembering” doesn’t mean that simply using /LAYOUT SAVE would automatically\n+make irssi reconnect to all servers and join all channels, you’ll need the /\n+SERVER ADD -auto and /CHANNEL ADD -auto commands to do that.\n+\n+If you want to change the layout, you just rearrange the layout like you want\n+it and use /LAYOUT SAVE again. If you want to remove the layout for some\n+reason, use /LAYOUT RESET.\n+\n+5. Status and msgs windows & message levels\n+\n+By default, all the “extra messages” go to status window. This means pretty\n+much all messages that don’t clearly belong to some channel or query. Some\n+people like it, some don’t. If you want to remove it, use\n+\n+/SET use_status_window OFF\n+\n+This doesn’t have any effect until you restart irssi. If you want to remove it\n+immediately, just /WINDOW CLOSE it.\n+\n+Another common window is “messages window”, where all private messages go. By\n+default it’s disabled and query windows are created instead. To make all\n+private messages go to msgs window, say:\n+\n+/SET use_msgs_window ON\n+/SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to\n+                                      dcc chats either, say NONE)\n+\n+use_msgs_window either doesn’t have any effect until restarting irssi. To\n+create it immediately say:\n+\n+/WINDOW NEW HIDE     - create the window\n+/WINDOW NAME (msgs)  - name it to \"(msgs)\"\n+/WINDOW LEVEL MSGS   - make all private messages go to this window\n+/WINDOW MOVE 1       - move it to first window\n+\n+Note that neither use_msgs_window nor use_status_window have any effect at all\n+if /LAYOUT SAVE has been used.\n+\n+This brings us to message levels.. What are they? All messages that irssi\n+prints have one or more “message levels”. Most common are PUBLIC for public\n+messages in channels, MSGS for private messages and CRAP for all sorts of\n+messages with no real classification. You can get a whole list of levels with\n+\n+/HELP levels\n+\n+Status window has message level ALL -MSGS, meaning that all messages, except\n+private messages, without more specific place go to status window. The -MSGS is\n+there so it doesn’t conflict with messages window.\n+\n+6. How support for multiple servers works in irssi\n+\n+ircii and several other clients support multiple servers by placing the\n+connection into some window. IRSSI DOES NOT. There is no required relationship\n+between window and server. You can connect to 10 servers and manage them all in\n+just one window, or join channel in each one of them to one single window if\n+you really want to. That being said, here’s how you do connect to new server\n+without closing the old connection:\n+\n+/CONNECT irc.server.org\n+\n+Instead of the /SERVER which disconnects the existing connection. To see list\n+of all active connections, use /SERVER without any parameters. You should see a\n+list of something like:\n+\n+ -!- IRCNet: irc.song.fi:6667 (IRCNet)\n+ -!- OFTC: irc.oftc.net:6667 (OFTC)\n+ -!- RECON-1: 192.168.0.1:6667 () (02:59 left before reconnecting)\n+\n+Here you see that we’re connected to IRCNet and OFTC networks. The IRCNet at\n+the beginning is called the “server tag” while the (IRCnet) at the end shows\n+the IRC network. Server tag specifies unique tag to refer to the server,\n+usually it’s the same as the IRC network. When the IRC network isn’t known it’s\n+some part of the server name. When there’s multiple connections to same IRC\n+network or server, irssi adds a number after the tag so there could be network,\n+network2, network3 etc.\n+\n+Server tags beginning with RECON- mean server reconnections. Above we see that\n+connection to server at 192.168.0.1 wasn’t successful and irssi will try to\n+connect it again in 3 minutes.\n+\n+To disconnect one of the servers, or to stop irssi from reconnecting, use\n+\n+/DISCONNECT network   - disconnect server with tag \"network\"\n+/DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server\n+/RMRECONNS           - stop all server reconnections\n+\n+/RECONNECT recon-1   - immediately try reconnecting back to RECON-1\n+/RECONNECT ALL       - immediately try reconnecting back to all\n+                       servers in reconnection queue\n+\n+Now that you’re connected to all your servers, you’ll have to know how to\n+specify which one of them you want to use. One way is to have an empty window,\n+like status or msgs window. In it, you can specify which server to set active\n+with\n+\n+/WINDOW SERVER tag    - set server \"tag\" active\n+Ctrl-X                - set the next server in list active\n+\n+When the server is active, you can use it normally. When there’s multiple\n+connected servers, irssi adds [servertag] prefix to all messages in non-channel\n+/query messages so you’ll know where it came from.\n+\n+Several commands also accept -servertag option to specify which server it\n+should use:\n+\n+/MSG -tag nick message\n+/JOIN -tag #channel\n+/QUERY -tag nick\n+\n+/MSG tab completion also automatically adds the -tag option when nick isn’t in\n+active server.\n+\n+Window’s server can be made sticky. When sticky, it will never automatically\n+change to anything else, and if server gets disconnected, the window won’t have\n+any active server. When the server gets connected again, it is automatically\n+set active in the window. To set the window’s server sticky use\n+\n+/WINDOW SERVER -sticky tag\n+\n+This is useful if you wish to have multiple status or msgs windows, one for\n+each server. Here’s how to do them (repeat for each server)\n+\n+/WINDOW NEW HIDE\n+/WINDOW NAME (status)\n+/WINDOW LEVEL ALL -MSGS\n+/WINDOW SERVER -sticky network\n+\n+/WINDOW NEW HIDE\n+/WINDOW NAME (msgs)\n+/WINDOW LEVEL MSGS\n+/WINDOW SERVER -sticky network\n+\n+7. /LASTLOG and jumping around in scrollback\n+\n+/LASTLOG command can be used for searching texts in scrollback buffer. Simplest\n+usages are\n+\n+/LASTLOG word     - print all lines with \"word\" in them\n+/LASTLOG word 10  - print last 10 occurances of \"word\"\n+/LASTLOG -topics  - print all topic changes\n+\n+If there’s more than 1000 lines to be printed, irssi thinks that you probably\n+made some mistake and won’t print them without -force option. If you want to\n+save the full lastlog to file, use\n+\n+/LASTLOG -file ~/irc.log\n+\n+With -file option you don’t need -force even if there’s more than 1000 lines. /\n+LASTLOG has a lot of other options too, see /HELP lastlog for details.\n+\n+Once you’ve found the lines you were interested in, you might want to check the\n+discussion around them. Irssi has /SCROLLBACK (or alias /SB) command for\n+jumping around in scrollback buffer. Since /LASTLOG prints the timestamp when\n+the message was originally printed, you can use /SB GOTO hh:mm to jump directly\n+there. To get back to the bottom of scrollback, use /SB END command.\n+\n+8. Logging\n+\n+Irssi can automatically log important messages when you’re set away (/AWAY\n+reason). When you set yourself unaway (/AWAY), the new messages in away log are\n+printed to screen. You can configure it with:\n+\n+/SET awaylog_level MSGS HILIGHT     - Specifies what messages to log\n+/SET awaylog_file ~/.irssi/away.log - Specifies the file to use\n+\n+Easiest way to start logging with Irssi is to use autologging. With it Irssi\n+logs all channels and private messages to specified directory. You can turn it\n+on with\n+\n+/SET autolog ON\n+\n+By default it logs pretty much everything execept CTCPS or CRAP (/WHOIS\n+requests, etc). You can specify the logging level yourself with\n+\n+/SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default)\n+\n+By default irssi logs to ~/irclogs//.log. You can change this with\n+\n+/SET autolog_path ~/irclogs/$tag/$0.log (this is the default)\n+\n+The path is automatically created if it doesn’t exist. $0 specifies the target\n+(channel/nick). You can make irssi automatically rotate the logs by adding date\n+/time formats to the file name. The formats are in “man strftime” format. For\n+example\n+\n+/SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log\n+\n+For logging only some specific channels or nicks, see /HELP log\n+\n+9. Changing keyboard bindings\n+\n+You can change any keyboard binding that terminal lets irssi know about. It\n+doesn’t let irssi know everything, so for example shift-backspace can’t be\n+bound unless you modify xterm resources somehow.\n+\n+/HELP bind tells pretty much everything there is to know about keyboard\n+bindings. However, there’s the problem of how to bind some non-standard keys.\n+They might differ a bit with each terminal, so you’ll need to find out what\n+exactly the keypress produces. Easiest way to check that would be to see what\n+it prints in cat. Here’s an example for pressing F1 key:\n+\n+ [user@host] ~% cat\n+ ^[OP\n+\n+So in irssi you would use /BIND ^[OP /ECHO F1 pressed. If you use multiple\n+terminals which have different bindings for the key, it would be better to use\n+eg.:\n+\n+/BIND ^[OP key F1\n+/BIND ^[11~ key F1\n+/BIND F1 /ECHO F1 pressed.\n+\n+10. Proxies and IRC bouncers\n+\n+Irssi supports connecting to IRC servers via a proxy. All server connections\n+are then made through it, and if you’ve set up everything properly, you don’t\n+need to do any /QUOTE SERVER commands manually.\n+\n+Here’s an example: You have your bouncer (lets say, BNC or BNC-like) listening\n+in irc.bouncer.org port 5000. You want to use it to connect to servers\n+irc.dalnet and irc.efnet.org. First you’d need to setup the bouncer:\n+\n+/SET use_proxy ON\n+/SET proxy_address irc.bouncer.org\n+/SET proxy_port 5000\n+\n+/SET proxy_password YOUR_BNC_PASSWORD_HERE\n+/SET -clear proxy_string\n+/SET proxy_string_after conn %s %d\n+\n+Then you’ll need to add the server connections. These are done exactly as if\n+you’d want to connect directly to them. Nothing special about them:\n+\n+/SERVER ADD -auto -network dalnet irc.dal.net\n+/SERVER ADD -auto -network efnet irc.efnet.org\n+\n+With the proxy /SETs however, irssi now connects to those servers through your\n+BNC. All server connections are made through them so you can just forget that\n+your bouncer even exists.\n+\n+If you don’t want to use the proxy for some reason, there’s -noproxy option\n+which you can give to /SERVER and /SERVER ADD commands.\n+\n+Proxy specific settings:\n+\n+All proxies have these settings in common:\n+\n+/SET use_proxy ON\n+/SET proxy_address <Proxy host address>\n+/SET proxy_port <Proxy port>\n+\n+HTTP proxy\n+\n+Use these settings with HTTP proxies:\n+\n+/SET -clear proxy_password\n+/EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n\n+\n+BNC\n+\n+/SET proxy_password your_pass\n+/SET -clear proxy_string\n+/SET proxy_string_after conn %s %d\n+\n+dircproxy\n+\n+dircproxy separates the server connections by passwords. So, if you for example\n+have network connection with password ircpass and OFTC connection with\n+oftcpass, you would do something like this:\n+\n+/SET -clear proxy_password\n+/SET -clear proxy_string\n+\n+/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass\n+/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass\n+\n+The server name and port you give isn’t used anywhere, so you can put anything\n+you want in there.\n+\n+psyBNC\n+\n+psyBNC has internal support for multiple servers. However, it could be a bit\n+annoying to use, and some people just use different users for connecting to\n+different servers. You can manage this in a bit same way as with dircproxy, by\n+creating fake connections:\n+\n+/SET -clear proxy_password\n+/SET -clear proxy_string\n+\n+/NETWORK ADD -user networkuser IRCnet\n+/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass\n+/NETWORK ADD -user oftcuser OFTC\n+/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass\n+\n+So, you’ll specify the usernames with /NETWORK ADD command, and the user’s\n+password with /SERVER ADD.\n+\n+Irssi proxy\n+\n+Irssi contains it’s own proxy which you can build giving \\--with-proxy option\n+to configure. You’ll still need to run irssi in a screen to use it though.\n+\n+Irssi proxy is a bit different than most proxies, normally proxies create a new\n+connection to IRC server when you connect to it, but irssi proxy shares your\n+existing IRC connection(s) to multiple clients. And even more clearly: You can\n+use only one IRC server connection to IRC with as many clients as you want. Can\n+anyone figure out even more easier ways to say this, so I wouldn’t need to try\n+to explain this thing for minutes every time? :)\n+\n+Irssi proxy supports sharing multiple server connections in different ports,\n+like you can share network in port 2777 and efnet in port 2778.\n+\n+Usage in proxy side:\n+\n+/LOAD proxy\n+/SET irssiproxy_password <password>\n+/SET irssiproxy_ports <network>=<port> ... (eg. IRCnet=2777 efnet=2778)\n+\n+NOTE: you MUST add all the servers you are using to server and network lists\n+with /SERVER ADD and /NETWORK ADD. ..Except if you really don’t want to for\n+some reason, and you only use one server connection, you may simply set:\n+\n+/SET irssiproxy_ports *=2777\n+\n+Usage in client side:\n+\n+Just connect to the irssi proxy like it is a normal server with password\n+specified in /SET irssiproxy_password. For example:\n+\n+/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret\n+/SERVER ADD -network efnet my.irssi-proxy.org 2778 secret\n+\n+Irssi proxy works fine with other IRC clients as well.\n+\n+SOCKS\n+\n+Irssi can be compiled with socks support (\\--with-socks option to configure),\n+which requires “dante” and routes all connections through the proxy specified\n+in the system-wide /etc/socks.conf. This method is known to have issues in Mac\n+OS X.\n+\n+Note that /SET proxy settings don’t have anything to do with socks.\n+\n+Using [4]proxychains-ng is recommended over recompiling irssi.\n+\n+Others\n+\n+IRC bouncers usually work like IRC servers, and want a password. You can give\n+it with:\n+\n+/SET proxy_password <password>\n+\n+Irssi’s defaults for connect strings are\n+\n+/SET proxy_string CONNECT %s %d\n+/SET proxy_string_after\n+\n+The proxy_string is sent before NICK/USER commands, the proxy_string_after is\n+sent after them. %s and %d can be used with both of them.\n+\n+11. Irssi’s settings\n+\n+Here’s some settings you might want to change (the default value is shown):\n+Also check the [5]Settings Documentation\n+\n+Queries\n+\n+/SET autocreate_own_query ON\n+    Should new query window be created when you send message to someone (with /\n+    MSG).\n+/SET autocreate_query_level MSGS\n+    New query window should be created when receiving messages with this level.\n+    MSGS, DCCMSGS and NOTICES levels work currently. You can disable this with\n+    /SET -clear autocreate_query_level.\n+/SET autoclose_query 0\n+    Query windows can be automatically closed after certain time of inactivity.\n+    Queries with unread messages aren’t closed and active window is neither\n+    never closed. The value is given in seconds.\n+\n+Windows\n+\n+/SET use_msgs_window OFF\n+    Create messages window at startup. All private messages go to this window.\n+    This only makes sense if you’ve disabled automatic query windows. Message\n+    window can also be created manually with /WINDOW LEVEL MSGS, /WINDOW NAME\n+    (msgs).\n+/SET use_status_window ON\n+    Create status window at startup. All messages that don’t really have better\n+    place go here, like all /WHOIS replies etc. Status window can also be\n+    created manually with /WINDOW LEVEL ALL -MSGS, /WINDOW NAME (status).\n+/SET autocreate_windows ON\n+    Should we create new windows for new window items or just place everything\n+    in one window\n+/SET autoclose_windows ON\n+    Should window be automatically closed when the last item in them is removed\n+    (ie. /PART, /UNQUERY).\n+/SET reuse_unused_windows OFF\n+    When finding where to place new window item (channel, query) Irssi first\n+    tries to use already existing empty windows. If this is set ON, new window\n+    will always be created for all window items. This setting is ignored if\n+    autoclose_windows is set ON.\n+/SET window_auto_change OFF\n+    Should Irssi automatically change to automatically created windows -\n+    usually queries when someone sends you a message. To prevent accidentally\n+    sending text meant to some other channel/nick, Irssi clears the input\n+    buffer when changing the window. The text is still in scrollback buffer,\n+    you can get it back with pressing arrow up key.\n+/SET print_active_channel OFF\n+    When you keep more than one channel in same window, Irssi prints the\n+    messages coming to active channel as <nick> text and other channels as\n+    <nick:channel> text. If this setting is set ON, the messages to active\n+    channels are also printed in the latter way.\n+/SET window_history OFF\n+    Should command history be kept separate for each window.\n+\n+User information\n+\n+/SET nick\n+    Your nick name\n+/SET alternate_nick\n+    Your alternate nick.\n+/SET user_name\n+    Your username, if you have ident enabled this doesn’t affect anything\n+/SET real_name\n+    Your real name.\n+\n+Server information\n+\n+/SET skip_motd OFF\n+    Should we hide server’s MOTD (Message Of The Day).\n+/SET server_reconnect_time 300\n+    Seconds to wait before connecting to same server again. Don’t set this too\n+    low since it usually doesn’t help at all - if the host is down, the few\n+    extra minutes of waiting won’t hurt much.\n+/SET lag_max_before_disconnect 300\n+    Maximum server lag in seconds before disconnecting and trying to reconnect.\n+    This happens mostly only when network breaks between you and IRC server.\n+\n+Appearance\n+\n+/SET timestamps ON\n+    Show timestamps before each message.\n+/SET hide_text_style OFF\n+    Hide all bolds, underlines, MIRC colors, etc.\n+/SET show_nickmode ON\n+    Show the nick’s mode before nick in channels, ie. ops have <@nick>, voices\n+    <+nick> and others < nick>\n+/SET show_nickmode_empty ON\n+    If the nick doesn’t have a mode, use one space. ie. ON: < nick>, OFF:\n+    <nick>\n+/SET show_quit_once OFF\n+    Show quit message only once in some of the channel windows the nick was in\n+    instead of in all windows.\n+/SET lag_min_show 100\n+    Show the server lag in status bar if it’s bigger than this, the unit is 1/\n+    100 of seconds (ie. the default value of 100 = 1 second).\n+/SET indent 10\n+    When lines are longer than screen width they have to be split to multiple\n+    lines. This specifies how much space to put at the beginning of the line\n+    before the text begins. This can be overridden in text formats with %|\n+    format.\n+/SET activity_hide_targets\n+    If you don’t want to see window activity in some certain channels or\n+    queries, list them here. For example #boringchannel =bot1 =bot2. If any\n+    highlighted text or message for you appears in that window, this setting is\n+    ignored and the activity is shown.\n+\n+Nick completion\n+\n+/SET completion_auto OFF\n+    Automatically complete the nick if line begins with start of nick and the\n+    completion character. Learn to use the tab-completion instead, it’s a lot\n+    better ;)\n+/SET completion_char :\n+    Completion character to use.\n+\n+For all the ircII people\n+\n+I don’t like automatic query windows, I don’t like status window, I do like\n+msgs window where all messages go:\n+\n+/SET autocreate_own_query OFF\n+/SET autocreate_query_level DCCMSGS\n+/SET use_status_window OFF\n+/SET use_msgs_window ON\n+\n+Disable automatic window closing when /PARTing channel or /UNQUERYing query:\n+\n+/SET autoclose_windows OFF\n+/SET reuse_unused_windows ON\n+\n+Here’s the settings that make irssi work exactly like ircII in window\n+management (send me a note if you can think of more):\n+\n+/SET autocreate_own_query OFF\n+/SET autocreate_query_level NONE\n+/SET use_status_window OFF\n+/SET use_msgs_window OFF\n+/SET reuse_unused_windows ON\n+/SET windows_auto_renumber OFF\n+\n+/SET autostick_split_windows OFF\n+/SET autoclose_windows OFF\n+/SET print_active_channel ON\n+\n+12. Statusbar\n+\n+/STATUSBAR displays a list of the current statusbars, along with their position\n+and visibility:\n+\n+ Name                           Type   Placement Position Visible\n+ window                         window bottom    0        always\n+ window_inact                   window bottom    1        inactive\n+ prompt                         root   bottom    100      always\n+ topic                          root   top       1        always\n+\n+/STATUSBAR <name> prints the statusbar settings (type, placement, position,\n+visibility) as well as its items. /STATUSBAR <name> ENABLE|DISABLE enables/\n+disables the statusbar. /STATUSBAR <name> RESET resets the statusbar to its\n+default settings, or if the statusbar was created by you, it will be removed.\n+\n+The statusbar type can be either window or root. If the type is window, then a\n+statusbar will be created for each split window, otherwise it will be created\n+only once. Placement can be top or bottom, which refers to the top or bottom of\n+the screen. Position is a number, the higher the value the lower it will appear\n+in-screen. Visible can be always, active or inactive. Active/inactive is useful\n+only with split windows; one split window is active and the rest are inactive.\n+To adjust these settings, the following commands are available:\n+\n+/STATUSBAR <name> TYPE window|root\n+/STATUSBAR <name> PLACEMENT top|bottom\n+/STATUSBAR <name> POSITION <num>\n+/STATUSBAR <name> VISIBLE always|active|inactive\n+\n+Statusbar items can also be added or removed via command. Note that when\n+loading new statusbar scripts that add items, you will need to specify where\n+you want to show the item and how it is aligned. This can be accomplished using\n+the below commands:\n+\n+/STATUSBAR <name> ADD [-before | -after <item>] [-priority #] [-alignment left|right] <item>\n+/STATUSBAR <name> REMOVE <item>\n+\n+For statusbar scripts, the item name is usually equivalent to the script name.\n+The documentation of the script ought to tell you if this is not the case. For\n+example, to add mail.pl before the window activity item, use: /STATUSBAR window\n+ADD -before act mail.\n+\n+\n+References:\n+\n+[1] http://www.gnu.org/licenses/fdl.html\n+[2] https://www.iterm2.com/\n+[3] http://quadpoint.org/articles/irssisplit/\n+[4] https://github.com/rofl0r/proxychains-ng\n+[5] https://irssi.org/documentation/settings/\n','false','false','none'),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','syncdocs.sh','79','7','101','0','ADD','@@ -0,0 +1,101 @@\n+#!/bin/sh -e\n+# Run this to download FAQ and startup-HOWTO from irssi.org\n+\n+PKG_NAME=\"Irssi\"\n+\n+site=https://irssi.org\n+\n+faq=$site/documentation/faq/\n+howto=$site/documentation/startup/\n+\n+# remove everything until H1 and optionally 2 DIVs before the\n+# FOOTER. May need to be adjusted as the source pages change\n+pageclean_regex=\'s{.*(?=<h1)}{}s;\n+s{\\s*(</div>\\s*)?(</div>\\s*)?<footer.*}{}s;\n+s{(<.*?)\\sclass=\"(?:highlighter-rouge|highlight)\"(.*?>)}{\\1\\2}g;\'\n+\n+srcdir=`dirname \"$0\"`\n+test -z \"$srcdir\" && srcdir=.\n+\n+if test ! -f \"$srcdir\"/configure.ac; then\n+    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\"\n+    echo \" top-level $PKG_NAME directory\"\n+    exit 1\n+fi\n+\n+# detect downloader app\n+downloader=false\n+\n+if type curl >/dev/null 2>&1 ; then\n+    downloader=\"curl -Ssf\"\n+elif type wget >/dev/null 2>&1 ; then\n+    downloader=\"wget -nv -O-\"\n+else\n+    echo \"**Error**: No wget or curl present\"\n+    echo \"Install wget or curl, then run syncdocs.sh again\"\n+fi\n+\n+# detect html converter app\n+converter=false\n+if [ \"$1\" = \"-any\" ]; then\n+    any=true\n+else\n+    any=false\n+fi\n+\n+if type w3m >/dev/null 2>&1 ; then\n+    converter=\"w3m -o display_link_number=1 -dump -T text/html\"\n+    any=true\n+elif type lynx >/dev/null 2>&1 ; then\n+    converter=\"lynx -dump -stdin -force_html\"\n+elif type elinks >/dev/null 2>&1 ; then\n+    converter=\"elinks -dump -force-html\"\n+else\n+    echo \"**Error**: Neither w3m, nor lynx or elinks present\"\n+    echo \"Install w3m, then run syncdocs.sh again\"\n+    exit 1\n+fi\n+\n+if ! $any ; then\n+    echo \"**Error**: w3m not present\"\n+    echo \"If you want to use lynx or elinks, run syncdocs.sh -any\"\n+    exit 1\n+fi\n+\n+check_download() {\n+    if test \"$1\" -ne 0 || test ! -e \"$2\" || test \"$(wc -l \"$2\" | awk \'{print $1}\')\" -le 1 ; then\n+	rm -f \"$2\"\n+	echo \"... download failed ( $1 )\"\n+	exit 2\n+    fi\n+}\n+\n+download_it() {\n+    echo \"Downloading $1 from $2 ...\"\n+    ret=0\n+    $downloader \"$2\" > \"$3\".tmp || ret=$?\n+    check_download \"$ret\" \"$3\".tmp\n+    perl -i -0777 -p -e \"$pageclean_regex\" \"$3\".tmp\n+    perl -i -0777 -p -e \'s{\\A}{\'\"<base href=\'$2\'>\"\'\\n}\' \"$3\".tmp\n+    perl -i -0777 -p -e \'s{<a href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\".*?\">\\[email&#160;protected\\]</a>}{user\\@host}g\' \"$3\".tmp\n+    mv \"$3\".tmp \"$3\"\n+}\n+\n+download_it \"FAQ\" \"$faq\" \"$srcdir\"/docs/faq.html\n+download_it \"Startup How-To\" \"$howto\" \"$srcdir\"/docs/startup-HOWTO.html\n+\n+# .html -> .txt with lynx or elinks\n+echo \"Documentation: html -> txt...\"\n+\n+cat \"$srcdir\"/docs/faq.html \\\n+    | LC_ALL=en_IE.utf8 $converter \\\n+    | perl -pe \'\n+	s/^ *//;\n+	if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; }\n+	elsif (/^([QA]):/) { $state = $1 }\n+	elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\n+\' > docs/faq.txt\n+\n+cat \"$srcdir\"/docs/startup-HOWTO.html \\\n+    | perl -pe \"s/\\\\bhref=([\\\"\\\'])#.*?\\\\1//\" \\\n+    | LC_ALL=en_IE.utf8 $converter > \"$srcdir\"/docs/startup-HOWTO.txt\n','false','false','none'),('irssi','1.0.5','9a3c0bce48d3f172d5638ecb37967528812129b1','ailin-nemui','add a script to sync scripts as well','syncscripts.sh','30','1','38','0','ADD','@@ -0,0 +1,38 @@\n+#!/bin/sh -e\n+# Run this script to sync dual lived scripts from scripts.irssi.org to scripts/\n+\n+PKG_NAME=\"Irssi\"\n+\n+scriptbase=https://scripts.irssi.org/scripts\n+\n+srcdir=`dirname \"$0\"`\n+test -z \"$srcdir\" && srcdir=.\n+\n+if test ! -f \"$srcdir\"/configure.ac; then\n+    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\"\n+    echo \" top-level $PKG_NAME directory\"\n+    exit 1\n+fi\n+\n+dl2=\'curl -Ssf\'\n+\n+dl_it() {\n+    echo \"$1\"\n+    $dl2 -o \"$srcdir/scripts/$1\" \"$scriptbase/$1\"\n+}\n+\n+for script in \\\n+    autoop.pl \\\n+    autorejoin.pl \\\n+    buf.pl \\\n+    dns.pl \\\n+    kills.pl \\\n+    mail.pl \\\n+    mlock.pl \\\n+    quitmsg.pl \\\n+    scriptassist.pl \\\n+    usercount.pl \\\n+    ;\n+do\n+    dl_it $script\n+done\n','false','false','none'),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','strip : from <trailing> parameters\n\nthis is to fix #601. the function used to extract the mode string\nassumed that \":\" would only occur in a particular spot. this lead to the\npossibility that \":\" could be treated as part of things like nicknames\nor mode arguments, where it should have been stripped as part of\nprotocol escaping.','fe-events.c','376','58','1','1','MODIFY','@@ -224,7 +224,7 @@ static void event_nick(IRC_SERVER_REC *server, const char *data,\n static void event_mode(IRC_SERVER_REC *server, const char *data,\n 		       const char *nick, const char *addr)\n {\n-	char *params, *channel, *mode;\n+	char *params = NULL, *channel = NULL, *mode = NULL;\n \n 	g_return_if_fail(data != NULL);\n \n','false','false','none'),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','strip : from <trailing> parameters\n\nthis is to fix #601. the function used to extract the mode string\nassumed that \":\" would only occur in a particular spot. this lead to the\npossibility that \":\" could be treated as part of things like nicknames\nor mode arguments, where it should have been stripped as part of\nprotocol escaping.','irc.c','316','74','30','2','MODIFY','@@ -40,6 +40,8 @@ static int signal_server_incoming;\n #  define MAX_SOCKET_READS 5\n #endif\n \n+static void strip_params_colon(char *const);\n+\n /* The core of the irc_send_cmd* functions. If `raw\' is TRUE, the `cmd\'\n    won\'t be checked at all if it\'s 512 bytes or not, or if it contains\n    line feeds or not. Use with extreme caution! */\n@@ -269,8 +271,9 @@ char *event_get_params(const char *data, int count, ...)\n 	while (count-- > 0) {\n 		str = (char **) va_arg(args, char **);\n 		if (count == 0 && rest) {\n-			/* put the rest to last parameter */\n-			tmp = *datad == \':\' ? datad+1 : datad;\n+			/* Put the rest into the last parameter. */\n+			strip_params_colon(datad);\n+			tmp = datad;\n 		} else {\n 			tmp = event_get_param(&datad);\n 		}\n@@ -281,6 +284,31 @@ char *event_get_params(const char *data, int count, ...)\n 	return duprec;\n }\n \n+/* Given a string containing <params>, strip any colon prefixing <trailing>. */\n+static void strip_params_colon(char *const params)\n+{\n+	if (!params) {\n+		return;\n+	}\n+\n+	char *s = params;\n+	while (*s != \'\\0\') {\n+		if (*s == \':\') {\n+			memmove(s, s+1, strlen(s+1)+1);\n+			return;\n+		}\n+\n+		s = strchr(s, \' \');\n+		if (!s) {\n+			return;\n+		}\n+\n+		while (*s == \' \') {\n+			s++;\n+		}\n+	}\n+}\n+\n static void irc_server_event(IRC_SERVER_REC *server, const char *line,\n 			     const char *nick, const char *address)\n {\n','false','false','none'),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','strip : from <trailing> parameters\n\nthis is to fix #601. the function used to extract the mode string\nassumed that \":\" would only occur in a particular spot. this lead to the\npossibility that \":\" could be treated as part of things like nicknames\nor mode arguments, where it should have been stripped as part of\nprotocol escaping.','modes.c','700','195','2','2','MODIFY','@@ -480,8 +480,8 @@ static void event_user_mode(IRC_SERVER_REC *server, const char *data)\n static void event_mode(IRC_SERVER_REC *server, const char *data,\n 		       const char *nick)\n {\n-	IRC_CHANNEL_REC *chanrec;\n-	char *params, *channel, *mode;\n+	IRC_CHANNEL_REC *chanrec = NULL;\n+	char *params = NULL, *channel = NULL, *mode = NULL;\n \n 	g_return_if_fail(data != NULL);\n \n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','22','0','7','14','MODIFY','@@ -7,33 +7,26 @@ CLEANFILES = default-config.h default-theme.h\n @MAINTAINER_MODE_TRUE@.PHONY: irssi-version.h\n \n default-config.h: $(srcdir)/irssi.conf\n-	$(srcdir)/file2header.sh $(srcdir)/irssi.conf default_config > default-config.h\n+	$(srcdir)/utils/file2header.sh $(srcdir)/irssi.conf default_config > default-config.h\n \n-default-theme.h: $(srcdir)/default.theme\n-	$(srcdir)/file2header.sh $(srcdir)/default.theme default_theme > default-theme.h\n+default-theme.h: $(srcdir)/themes/default.theme\n+	$(srcdir)/utils/file2header.sh $(srcdir)/themes/default.theme default_theme > default-theme.h\n \n irssi-version.h:\n-	VERSION=\"$(VERSION)\" $(srcdir)/irssi-version.sh $(srcdir) | \\\n-		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/irssi-version.sh $(srcdir) >$@\n+	VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) | \\\n+		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) >$@\n \n-SUBDIRS = src docs scripts\n+SUBDIRS = src docs scripts themes utils\n \n confdir = $(sysconfdir)\n conf_DATA = irssi.conf\n \n-themedir = $(datadir)/irssi/themes\n-theme_DATA = default.theme colorless.theme\n-\n pkginclude_HEADERS = irssi-config.h irssi-version.h\n \n EXTRA_DIST = \\\n 	ChangeLog \\\n 	autogen.sh \\\n 	README.md \\\n-	file2header.sh \\\n 	$(conf_DATA) \\\n-	$(theme_DATA) \\\n 	irssi-config.in \\\n-	irssi-icon.png \\\n-	irssi-version.sh \\\n-	syntax.pl\n+	irssi-icon.png\n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','autogen.sh','45','1','16','11','MODIFY','@@ -3,21 +3,24 @@\n \n PKG_NAME=\"Irssi\"\n \n-srcdir=`dirname $0`\n+srcdir=`dirname \"$0\"`\n test -z \"$srcdir\" && srcdir=.\n+mydir=`pwd`\n \n-if test ! -f $srcdir/configure.ac; then\n-    echo -n \"**Error**: Directory \\`$srcdir\\\' does not look like the\"\n+if test ! -f \"$srcdir\"/configure.ac; then\n+    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\"\n     echo \" top-level $PKG_NAME directory\"\n     exit 1\n fi\n \n+cd \"$srcdir\"\n+\n # create help files\n echo \"Creating help files...\"\n-perl syntax.pl\n+perl utils/syntax.pl\n \n echo \"Creating ChangeLog...\"\n-git log > $srcdir/ChangeLog\n+git log > ChangeLog\n if test \"$?\" -ne 0; then\n     echo \"**Error**: ${PKG_NAME} Autogen must be run in a git clone, cannot proceed.\"\n     exit 1\n@@ -38,17 +41,19 @@ fi\n \n rm -f aclocal.m4\n echo \"Running autoreconf ...\"\n-autoreconf -i || exit 1\n+autoreconf -i || exit $?\n+\n+# make sure perl hashes have correct length\n+find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\'\n+\n+cd \"$mydir\"\n \n conf_flags=\"--enable-maintainer-mode\"\n \n if test x$NOCONFIGURE = x; then\n-  echo Running $srcdir/configure $conf_flags \"$@\" ...\n-  $srcdir/configure $conf_flags \"$@\" \\\n+  echo Running \"$srcdir\"/configure $conf_flags \"$@\" ...\n+  \"$srcdir\"/configure $conf_flags \"$@\" \\\n   && echo Now type \\`make\\\' to compile $PKG_NAME || exit 1\n else\n   echo Skipping configure process.\n fi\n-\n-# make sure perl hashes have correct length\n-find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\'\n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','configure.ac','700','4','2','0','MODIFY','@@ -661,6 +661,8 @@ scripts/examples/Makefile\n docs/Makefile\n docs/help/Makefile\n docs/help/in/Makefile\n+utils/Makefile\n+themes/Makefile\n irssi-config\n ])\n \n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','4','0','5','0','ADD','@@ -0,0 +1,5 @@\n+themedir = $(datadir)/irssi/themes\n+theme_DATA = default.theme colorless.theme\n+\n+EXTRA_DIST = \\\n+	$(theme_DATA)\n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','colorless.theme','None','None','0','0','RENAME','','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','default.theme','None','None','0','0','RENAME','','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','4','0','4','0','ADD','@@ -0,0 +1,4 @@\n+EXTRA_DIST = \\\n+	file2header.sh \\\n+	irssi-version.sh \\\n+	syntax.pl\n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','file2header.sh','None','None','0','0','RENAME','','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','irssi-version.sh','None','None','0','0','RENAME','','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syncdocs.sh','80','7','2','1','RENAME','@@ -16,6 +16,7 @@ s{(<.*?)\\sclass=\"(?:highlighter-rouge|highlight)\"(.*?>)}{\\1\\2}g;\'\n \n srcdir=`dirname \"$0\"`\n test -z \"$srcdir\" && srcdir=.\n+srcdir=\"$srcdir\"/..\n \n if test ! -f \"$srcdir\"/configure.ac; then\n     echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\"\n@@ -94,7 +95,7 @@ cat \"$srcdir\"/docs/faq.html \\\n 	if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; }\n 	elsif (/^([QA]):/) { $state = $1 }\n 	elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\n-\' > docs/faq.txt\n+\' > \"$srcdir\"/docs/faq.txt\n \n cat \"$srcdir\"/docs/startup-HOWTO.html \\\n     | perl -pe \"s/\\\\bhref=([\\\"\\\'])#.*?\\\\1//\" \\\n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syncscripts.sh','31','1','1','0','RENAME','@@ -7,6 +7,7 @@ scriptbase=https://scripts.irssi.org/scripts\n \n srcdir=`dirname \"$0\"`\n test -z \"$srcdir\" && srcdir=.\n+srcdir=\"$srcdir\"/..\n \n if test ! -f \"$srcdir\"/configure.ac; then\n     echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\"\n','false','false','none'),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syntax.pl','None','None','0','0','RENAME','','false','false','none'),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','autorejoin.pl','67','0','32','17','MODIFY','@@ -1,6 +1,9 @@\n-# automatically rejoin to channel after kick\n+# automatically rejoin to channel after kicked\n # delayed rejoin: Lam 28.10.2001 (lam@lac.pl)\n \n+# /SET autorejoin_channels #channel1 #channel2 ...\n+# /SET autorejoin_delay 5\n+\n # NOTE: I personally don\'t like this feature, in most channels I\'m in it\n # will just result as ban. You\'ve probably misunderstood the idea of /KICK\n # if you kick/get kicked all the time \"just for fun\" ...\n@@ -9,31 +12,22 @@ use Irssi;\n use Irssi::Irc;\n use strict;\n use vars qw($VERSION %IRSSI);\n-$VERSION = \"1.0.0\";\n+$VERSION = \"1.1.0\";\n %IRSSI = (\n 	authors => \"Timo \'cras\' Sirainen, Leszek Matok\",\n 	contact => \"lam\\@lac.pl\",\n 	name => \"autorejoin\",\n-	description => \"Automatically rejoin to channel after being kick, after a (short) user-defined delay\",\n+	description => \"Automatically rejoin to channel after being kicked, after a (short) user-defined delay\",\n 	license => \"GPLv2\",\n 	changed => \"10.3.2002 14:00\"\n );\n \n-\n-# How many seconds to wait before the rejoin?\n-# TODO: make this a /setting\n-my $delay = 5;\n-\n-my @tags;\n-my $acttag = 0;\n-\n sub rejoin {\n 	my ( $data ) = @_;\n-	my ( $tag, $servtag, $channel, $pass ) = split( / +/, $data );\n+	my ( $servtag, $channel, $pass ) = @{$data};\n \n 	my $server = Irssi::server_find_tag( $servtag );\n 	$server->send_raw( \"JOIN $channel $pass\" ) if ( $server );\n-	Irssi::timeout_remove( $tags[$tag] );\n }\n \n sub event_rejoin_kick {\n@@ -48,10 +42,31 @@ sub event_rejoin_kick {\n 	my $rejoinchan = $chanrec->{ name } if ( $chanrec );\n 	my $servtag = $server->{ tag };\n \n-	Irssi::print \"Rejoining $rejoinchan in $delay seconds.\";\n-	$tags[$acttag] = Irssi::timeout_add( $delay * 1000, \"rejoin\", \"$acttag $servtag $rejoinchan $password\" );\n-	$acttag++;\n-	$acttag = 0 if ( $acttag > 60 );\n+	# check if we want to autorejoin this channel\n+	my $chans = Irssi::settings_get_str( \'autorejoin_channels\' );\n+\n+	if ( $chans ) {\n+		my $found = 0;\n+		foreach my $chan ( split( /[ ,]/, $chans ) ) {\n+			if ( lc( $chan ) eq lc( $channel ) ) {\n+				$found = 1;\n+				last;\n+			}\n+		}\n+		return unless $found;\n+	}\n+\n+	my @args = ($servtag, $rejoinchan, $password);\n+	my $delay = Irssi::settings_get_int( \"autorejoin_delay\" );\n+\n+	if ($delay) {\n+		Irssi::print \"Rejoining $rejoinchan in $delay seconds.\";\n+		Irssi::timeout_add_once( $delay * 1000, \"rejoin\", \\@args );\n+	} else {\n+		rejoin( \\@args );\n+	}\n }\n \n+Irssi::settings_add_int(\'misc\', \'autorejoin_delay\', 5);\n+Irssi::settings_add_str(\'misc\', \'autorejoin_channels\', \'\');\n Irssi::signal_add( \'event kick\', \'event_rejoin_kick\' );\n','false','false','none'),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','mail.pl','389','0','1','0','MODIFY','@@ -6,6 +6,7 @@ $VERSION = \"2.92\";\n     contact     => \"tss\\@iki.fi, matti\\@hiljanen.com, joost\\@carnique.nl, bart\\@dreamflow.nl\",\n     name        => \"mail\",\n     description => \"Fully customizable mail counter statusbar item with multiple mailbox and multiple Maildir support\",\n+    sbitems     => \"mail\",\n     license     => \"Public Domain\",\n     url         => \"http://irssi.org, http://scripts.irssi.de\",\n );\n','false','false','none'),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','usercount.pl','150','9','1','0','MODIFY','@@ -7,6 +7,7 @@ $VERSION = \"1.19\";\n     contact     => \'dgl@dgl.cx, tss@iki.fi, georg@boerde.de\',\n     name        => \'usercount\',\n     description => \'Adds a usercount for a channel as a statusbar item\',\n+    sbitems     => \'usercount\',\n     license     => \'GNU GPLv2 or later\',\n     url         => \'http://irssi.dgl.cx/\',\n     changes     => \'Only show halfops if server supports them\',\n','false','false','none'),('irssi','1.0.5','96c7f68b3579ae5f83b635d946dc705d6322a16c','ailin-nemui','clean up file path after move','Makefile.am','156','0','1','1','MODIFY','@@ -59,7 +59,7 @@ perl-signals-list.h: $(top_srcdir)/docs/signals.txt $(srcdir)/get-signals.pl\n 	cat $(top_srcdir)/docs/signals.txt | $(perlpath) $(srcdir)/get-signals.pl > perl-signals-list.h\n \n irssi-core.pl.h: irssi-core.pl\n-	$(top_srcdir)/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code > irssi-core.pl.h\n+	$(top_srcdir)/utils/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code > irssi-core.pl.h\n \n common_sources = \\\n 	common/Irssi.xs \\\n','false','false','none'),('irssi','1.0.5','7e619ed990503faf45fc1ae1e28a3a6062dc7532','ailin-nemui','update readme.md','README.md','51','0','62','98','MODIFY','@@ -1,109 +1,73 @@\n-# Irssi\n+# [Irssi](https://irssi.org/)\n \n [![Build Status](https://travis-ci.org/irssi/irssi.svg?branch=master)](https://travis-ci.org/irssi/irssi)\n \n Irssi is a modular chat client that is most commonly known for its\n text mode user interface, but 80% of the code isn\'t text mode\n-specific. We have a working but currently unmaintained GTK2 frontend\n-called xirssi. Irssi comes with IRC support built in, and there are\n+specific. Irssi comes with IRC support built in, and there are\n third party [ICB](https://github.com/jperkin/irssi-icb),\n [SILC](http://www.silcnet.org/),\n [XMPP](http://cybione.org/~irssi-xmpp/) (Jabber),\n-[PSYC](https://github.com/electric-blue/irssyc) and\n+[PSYC](http://about.psyc.eu/Irssyc) and\n [Quassel](https://github.com/phhusson/quassel-irssi) protocol modules\n available.\n \n-## Installation\n-\n-See the `INSTALL` file.\n-\n-## Features\n-\n-So what\'s so great about Irssi? Here\'s a list of some features I can\n-think of currently:\n-\n- - **Optional automation** - There\'s lots of things Irssi does for you\n-   automatically that some people like and others just hate. Things like:\n-   nick completion, creating new window for newly joined channel, creating\n-   queries when msgs/notices are received or when you send a msg, closing\n-   queries when it\'s been idle for some time, etc.\n-\n- - **Multiserver friendly** - I think Irssi has clearly the best support\n-   for handling multiple server connections. You can have as many as you\n-   want in as many ircnets as you want. Having several connections in one\n-   server works too, for example when you hit the (ircnet\'s) 10\n-   channels/connection limit you can just create another connection and\n-   you hardly notice it. If connection to server is lost, Irssi tries to\n-   connect back until it\'s successful. Also channels you were joined\n-   before disconnection are restored, even if they\'re \"temporarily\n-   unavailable\" because of netsplits, Irssi keeps rejoining back to them.\n-   Also worth noticing - there\'s not that stupid \"server is bound to this\n-   window, if this window gets closed the connection closes\" thing that\n-   ircII based clients have.\n-\n- - **Channel automation** - You can specify what channels to join to\n-   immediately after connected to some server or IRC network. After joined\n-   to channel, Irssi can automatically request ops for you (or do\n-   anything, actually) from channel\'s bots.\n-\n- - **Window content saving** - Say /LAYOUT SAVE when you\'ve put all the\n-   channels and queries to their correct place, and after restarting\n-   Irssi, the channels will be joined back into windows where they were\n-   saved.\n-\n- - **Tab completing anything** - You can complete lots of things with tab:\n-   nicks, commands, command -options, file names, settings, text format\n-   names, channels and server names. There\'s also an excellent /msg\n-   completion that works transparently with multiple IRC networks.\n-   Completing channel nicks is also pretty intelligent, it first goes\n-   through the people who have talked to you recently, then the people who\n-   have talked to anyone recently and only then it fallbacks to rest of\n-   the nicks. You can also complete a set of words you\'ve specified, for\n-   example homepage<tab> changes it to your actual home page URL.\n-\n- - **Excellent logging** - You can log any way you want and as easily or\n-   hard as you want. With autologging Irssi logs everything to specified\n-   directory, one file per channel/nick. ircII style /WINDOW LOG ON is\n-   also supported. There\'s also the \"hard way\" of logging - /LOG command\n-   which lets you specify exactly what you wish to log and where. Log\n-   rotating is supported with all the different logging methods, you can\n-   specify how often you want it to rotate and what kind of time stamp to\n-   use.\n-\n- - **Excellent ignoring** - You can most probably ignore anything any way\n-   you want. Nick masks, words, regular expressions. You can add\n-   exceptions to ignores. You can ignore other people\'s replies in\n-   channels to nicks you have ignored. You can also specify that the\n-   specific ignores work only in specific channel(s).\n-\n- - **Lastlog and scrollback handling** - /LASTLOG command has some new\n-   features: -new option checks only lines that came since you last did\n-   /LASTLOG command, -away option checks new lines since you last went\n-   away. Regular expression matches work also, of course. Going to some\n-   wanted place at scrollback has always been hard with non-GUI clients. A\n-   search command that jumps around in scrollback in GUI-style is still\n-   missing from Irssi, but there\'s something that\'s almost as good as it.\n-   /LASTLOG always shows timestamps when the line was printed, even if you\n-   didn\'t have timestamps on. Now doing /SB GOTO \\<timestamp\\> jumps\n-   directly to the position in scrollback you wanted. Great feature when\n-   you want to browse a bit of the discussion what happened when someone\n-   said your name (as seen in awaylog) or topic was changed (/last\n-   -topics)\n-\n-## Files\n-\n- - The `docs/` directory contains several documents:\n-    - `startup-HOWTO.txt` - new users should read this\n-    - `manual.txt` - manual I started writing but didn\'t get it very far :)\n-    - `perl.txt` - Perl scripting help\n-    - `formats.txt` - How to use colors, etc. with Irssi\n-    - `faq.txt` - Frequently Asked Questions\n-    - `special_vars.txt` - some predefined $variables you can use with Irssi\n-\n-## Bugs / Suggestions\n-\n-See the `TODO` file, http://bugs.irssi.org and the GitHub issues if it is\n-already listed in there; if not, open an issue on GitHub or send a mail to\n-[staff@irssi.org](mailto:staff@irssi.org).\n-\n-You can also contact the Irssi developers in #irssi on freenode.\n+![irssi](https://user-images.githubusercontent.com/5665186/32180643-cf127f60-bd92-11e7-8aa2-882313ce1d8e.png)\n+\n+## [Download information](https://irssi.org/download/)\n+\n+#### Development source installation\n+\n+```\n+git clone https://github.com/irssi/irssi\n+cd irssi\n+./autogen.sh\n+make && sudo make install\n+```\n+\n+#### Release source installation\n+\n+* Download [release](https://github.com/irssi/irssi/releases)\n+* [Verify](https://irssi.org/download/#release-sources) signature\n+```\n+tar xJf irssi-*.tar.xz\n+cd irssi-*\n+./configure\n+make && sudo make install\n+```\n+\n+### Requirements\n+\n+- [glib-2.28](https://wiki.gnome.org/Projects/GLib) or greater\n+- [openssl](https://www.openssl.org/)\n+- [perl-5.6](https://www.perl.org/) or greater (for perl support)\n+- terminfo or ncurses (for text frontend)\n+\n+#### See the [INSTALL](INSTALL) file for details\n+\n+## [Documentation](https://irssi.org/documentation/)\n+\n+* [Frequently Asked Questions](https://irssi.org/documentation/faq)\n+* [Startup How-To](https://irssi.org/documentation/startup)\n+* Check the built-in `/HELP`, it has all the details on command syntax\n+\n+## [Themes](https://irssi-import.github.io/themes/)\n+\n+## [Scripts](http://scripts.irssi.org/)\n+\n+## [Modules](https://irssi.org/modules/)\n+\n+## [Security information](https://irssi.org/security/)\n+\n+Please report security issues to staff@irssi.org. Thanks!\n+\n+## [Bugs](https://github.com/irssi/irssi/issues) / Suggestions / [Contributing](https://irssi.org/development/)\n+\n+Check the GitHub issues if it is already listed in there; if not, open\n+an issue on GitHub or send a mail to [staff@irssi.org](mailto:staff@irssi.org).\n+\n+Irssi is always looking for developers. Feel free to submit patches through\n+GitHub pull requests.\n+\n+You can also contact the Irssi developers in\n+[#irssi](https://irssi.org/support/irc/) on freenode.\n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','settings.c','693','161','10','0','MODIFY','@@ -39,6 +39,7 @@ static GString *last_errors;\n static GSList *last_invalid_modules;\n static int fe_initialized;\n static int config_changed; /* FIXME: remove after .98 (unless needed again) */\n+static int user_settings_changed;\n \n static GHashTable *settings;\n static int timeout_tag;\n@@ -464,6 +465,11 @@ SETTINGS_REC *settings_get_record(const char *key)\n 	return g_hash_table_lookup(settings, key);\n }\n \n+static void sig_init_userinfo_changed(gpointer changedp)\n+{\n+	user_settings_changed = GPOINTER_TO_INT(changedp);\n+}\n+\n static void sig_init_finished(void)\n {\n 	fe_initialized = TRUE;\n@@ -479,6 +485,8 @@ static void sig_init_finished(void)\n 			  \"updated, please /SAVE\");\n 		signal_emit(\"setup changed\", 0);\n 	}\n+\n+	signal_emit(\"settings userinfo changed\", 1, GINT_TO_POINTER(user_settings_changed));\n }\n \n static void settings_clean_invalid_module(const char *module)\n@@ -875,6 +883,7 @@ void settings_init(void)\n 	timeout_tag = g_timeout_add(SETTINGS_AUTOSAVE_TIMEOUT,\n 				    (GSourceFunc) sig_autosave, NULL);\n 	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n+	signal_add(\"irssi init userinfo changed\", (SIGNAL_FUNC) sig_init_userinfo_changed);\n 	signal_add(\"gui exit\", (SIGNAL_FUNC) sig_autosave);\n }\n \n@@ -887,6 +896,7 @@ void settings_deinit(void)\n {\n         g_source_remove(timeout_tag);\n 	signal_remove(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);\n+	signal_remove(\"irssi init userinfo changed\", (SIGNAL_FUNC) sig_init_userinfo_changed);\n 	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_autosave);\n \n 	g_slist_foreach(last_invalid_modules, (GFunc) g_free, NULL);\n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','Makefile.am','67','0','1','0','MODIFY','@@ -55,6 +55,7 @@ pkginc_fe_common_core_HEADERS = \\\n 	fe-exec.h \\\n 	fe-messages.h \\\n 	fe-queries.h \\\n+	fe-settings.h \\\n 	fe-tls.h \\\n 	formats.h \\\n 	hilight-text.h \\\n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','fe-settings.c','328','91','6','1','MODIFY','@@ -26,7 +26,7 @@\n #include \"misc.h\"\n #include \"lib-config/iconfig.h\"\n #include \"settings.h\"\n-\n+#include \"fe-settings.h\"\n #include \"levels.h\"\n #include \"printtext.h\"\n #include \"keyboard.h\"\n@@ -41,6 +41,11 @@ static void set_print(SETTINGS_REC *rec)\n 	g_free(value);\n }\n \n+void fe_settings_set_print(const char *key)\n+{\n+	set_print(settings_get_record(key));\n+}\n+\n static void set_print_pattern(const char *pattern)\n {\n 	GSList *sets, *tmp;\n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','fe-settings.h','1','0','6','0','ADD','@@ -0,0 +1,6 @@\n+#ifndef __FE_CHANNELS_H\n+#define __FE_CHANNELS_H\n+\n+void fe_settings_set_print(const char *key);\n+\n+#endif\n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','irssi.c','224','30','25','24','MODIFY','@@ -31,6 +31,7 @@\n \n #include \"printtext.h\"\n #include \"fe-common-core.h\"\n+#include \"fe-settings.h\"\n #include \"themes.h\"\n \n #include \"term.h\"\n@@ -79,25 +80,8 @@ static int dirty, full_redraw;\n static GMainLoop *main_loop;\n int quitting;\n \n-static const char *banner_text =\n-	\" ___           _\\n\"\n-	\"|_ _|_ _ _____(_)\\n\"\n- 	\" | || \'_(_-<_-< |\\n\"\n-	\"|___|_| /__/__/_|\\n\"\n-	\"Irssi v\" PACKAGE_VERSION \" - http://www.irssi.org\";\n-\n-static const char *firsttimer_text =\n-	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n\"\n-	\"Hi there! If this is your first time using Irssi, you\\n\"\n-	\"might want to go to our website and read the startup\\n\"\n-	\"documentation to get you going.\\n\\n\"\n-	\"Our community and staff are available to assist you or\\n\"\n-	\"to answer any questions you may have.\\n\\n\"\n-	\"Use the /HELP command to get detailed information about\\n\"\n-	\"the available commands.\\n\"\n-	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\";\n-\n static int display_firsttimer = FALSE;\n+static int user_settings_changed = 0;\n \n \n static void sig_exit(void)\n@@ -105,6 +89,11 @@ static void sig_exit(void)\n         quitting = TRUE;\n }\n \n+static void sig_settings_userinfo_changed(gpointer changedp)\n+{\n+	user_settings_changed = GPOINTER_TO_INT(changedp);\n+}\n+\n /* redraw irssi\'s screen.. */\n void irssi_redraw(void)\n {\n@@ -161,6 +150,7 @@ static void textui_init(void)\n 	fe_common_irc_init();\n \n 	theme_register(gui_text_formats);\n+	signal_add(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);\n 	signal_add_last(\"gui exit\", (SIGNAL_FUNC) sig_exit);\n }\n \n@@ -199,14 +189,24 @@ static void textui_finish_init(void)\n 	statusbar_redraw(NULL, TRUE);\n \n 	if (servers == NULL && lookup_servers == NULL) {\n-		printtext(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT,\n-			  \"%s\", banner_text);\n+		printformat(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, TXT_IRSSI_BANNER);\n 	}\n \n 	if (display_firsttimer) {\n-		printtext(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT,\n-			  \"%s\", firsttimer_text);\n+		printformat(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, TXT_WELCOME_FIRSTTIME);\n 	}\n+\n+	/* see irc-servers-setup.c:init_userinfo */\n+	if (user_settings_changed)\n+		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_WELCOME_INIT_SETTINGS);\n+	if (user_settings_changed & (1<<0))\n+		fe_settings_set_print(\"real_name\");\n+	if (user_settings_changed & (1<<1))\n+		fe_settings_set_print(\"user_name\");\n+	if (user_settings_changed & (1<<2))\n+		fe_settings_set_print(\"nick\");\n+	if (user_settings_changed & (1<<3))\n+		fe_settings_set_print(\"hostname\");\n }\n \n static void textui_deinit(void)\n@@ -223,6 +223,7 @@ static void textui_deinit(void)\n #endif\n \n         dirty_check(); /* one last time to print any quit messages */\n+	signal_remove(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);\n 	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_exit);\n \n 	lastlog_deinit();\n@@ -249,6 +250,7 @@ static void textui_deinit(void)\n 	core_deinit();\n }\n \n+\n static void check_files(void)\n {\n 	struct stat statbuf;\n@@ -259,12 +261,11 @@ static void check_files(void)\n 	}\n }\n \n-\n int main(int argc, char **argv)\n {\n 	static int version = 0;\n 	static GOptionEntry options[] = {\n-		{ \"version\", \'v\', 0, G_OPTION_ARG_NONE, &version, \"Display irssi version\", NULL },\n+		{ \"version\", \'v\', 0, G_OPTION_ARG_NONE, &version, \"Display Irssi version\", NULL },\n 		{ NULL }\n 	};\n 	int loglev;\n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','module-formats.c','66','0','21','0','MODIFY','@@ -78,5 +78,26 @@ FORMAT_REC gui_text_formats[] =\n 	{ \"paste_warning\", \"Pasting $0 lines to $1. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.\", 2, { 1, 0 } },\n 	{ \"paste_prompt\", \"Hit Ctrl-K to paste, Ctrl-C to abort?\", 0 },\n \n+	/* ---- */\n+	{ NULL, \"Welcome\", 0 },\n+\n+	{ \"irssi_banner\",\n+	  \" ___           _%:\"\n+	  \"|_ _|_ _ _____(_)%:\"\n+	  \" | || \'_(_-<_-< |%:\"\n+	  \"|___|_| /__/__/_|%:\"\n+	  \"Irssi v$J - http://www.irssi.org\", 0 },\n+	{ \"welcome_firsttime\",\n+	  \"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n\"\n+	  \"Hi there! If this is your first time using Irssi, you%:\"\n+	  \"might want to go to our website and read the startup%:\"\n+	  \"documentation to get you going.%:%:\"\n+	  \"Our community and staff are available to assist you or%:\"\n+	  \"to answer any questions you may have.%:%:\"\n+	  \"Use the /HELP command to get detailed information about%:\"\n+	  \"the available commands.%:\"\n+	  \"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\", 0 },\n+	{ \"welcome_init_settings\", \"The following settings were initialized\", 0 },\n+\n 	{ NULL, NULL, 0 }\n };\n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','module-formats.h','51','0','6','0','MODIFY','@@ -52,6 +52,12 @@ enum {\n 	TXT_PASTE_WARNING,\n 	TXT_PASTE_PROMPT,\n \n+	TXT_FILL_5, /* Welcome */\n+\n+	TXT_IRSSI_BANNER,\n+	TXT_WELCOME_FIRSTTIME,\n+	TXT_WELCOME_INIT_SETTINGS,\n+\n 	TXT_COUNT\n };\n \n','false','false','none'),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','irc-servers-setup.c','157','52','10','1','MODIFY','@@ -116,14 +116,17 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n \n static void init_userinfo(void)\n {\n+	int changed;\n 	const char *set, *nick, *user_name, *str;\n \n+	changed = 0;\n 	/* check if nick/username/realname wasn\'t read from setup.. */\n         set = settings_get_str(\"real_name\");\n 	if (set == NULL || *set == \'\\0\') {\n 		str = g_getenv(\"IRCNAME\");\n 		settings_set_str(\"real_name\",\n 				 str != NULL ? str : g_get_real_name());\n+		changed |= 1<<0;\n 	}\n \n 	/* username */\n@@ -134,6 +137,7 @@ static void init_userinfo(void)\n 				 str != NULL ? str : g_get_user_name());\n \n 		user_name = settings_get_str(\"user_name\");\n+		changed |= 1<<1;\n 	}\n \n 	/* nick */\n@@ -143,15 +147,20 @@ static void init_userinfo(void)\n 		settings_set_str(\"nick\", str != NULL ? str : user_name);\n \n 		nick = settings_get_str(\"nick\");\n+		changed |= 1<<2;\n 	}\n \n 	/* host name */\n         set = settings_get_str(\"hostname\");\n 	if (set == NULL || *set == \'\\0\') {\n 		str = g_getenv(\"IRCHOST\");\n-		if (str != NULL)\n+		if (str != NULL) {\n 			settings_set_str(\"hostname\", str);\n+			changed |= 1<<3;\n+		}\n 	}\n+\n+	signal_emit(\"irssi init userinfo changed\", 1, GINT_TO_POINTER(changed));\n }\n \n static void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node)\n','false','false','none'),('irssi','1.0.5','4d6822b1c43d876856a5df07ce69fb4e67c3591a','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@\n #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */\n #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */\n \n-#define IRSSI_ABI_VERSION 11\n+#define IRSSI_ABI_VERSION 12\n \n #define DEFAULT_SERVER_ADD_PORT 6667\n #define DEFAULT_SERVER_ADD_TLS_PORT 6697\n','false','false','none'),('irssi','1.0.5','56013367983b61d8ee4d2e905767ce50b25ffb82','LemonBoy','turn the style guide into a clang-format file','.clang-format','35','0','37','0','ADD','@@ -0,0 +1,37 @@\n+# IndentPPDirectives: None\n+# SpaceInParentheses: false\n+AlignAfterOpenBracket: Align\n+AlignConsecutiveAssignments: false\n+AlignConsecutiveDeclarations: false\n+AlignOperands: true\n+AlignTrailingComments: true\n+AllowAllParametersOfDeclarationOnNextLine: true\n+AllowShortBlocksOnASingleLine: false\n+AllowShortCaseLabelsOnASingleLine: false\n+AllowShortFunctionsOnASingleLine: Empty\n+AllowShortIfStatementsOnASingleLine: false\n+AllowShortLoopsOnASingleLine: false\n+AlwaysBreakAfterReturnType: None\n+AlwaysBreakBeforeMultilineStrings: true\n+BinPackArguments: true\n+BinPackParameters: true\n+BreakBeforeBinaryOperators: None\n+BreakBeforeBraces: Attach\n+BreakBeforeTernaryOperators: true\n+ColumnLimit: 100\n+IndentCaseLabels: true\n+IndentWidth: 8\n+IndentWrappedFunctionNames: true\n+KeepEmptyLinesAtTheStartOfBlocks: false\n+Language: Cpp\n+MaxEmptyLinesToKeep: 1\n+PointerAlignment: Right\n+SortIncludes: true\n+SpaceAfterCStyleCast: false\n+SpaceBeforeAssignmentOperators: true\n+SpaceBeforeParens: ControlStatements\n+SpaceInEmptyParentheses: false\n+SpacesInCStyleCastParentheses: false\n+SpacesInSquareBrackets: false\n+TabWidth: 8\n+UseTab: ForIndentation\n','false','false','none'),('irssi','1.0.5','60c31219a278330498e695e4d7fca05ea69962e4','Jari Matilainen','allow selection of what kind of activity targets to ignore\n\ninitialize tagtarget on declaration\n\nmove code around for better flow, extra checks for uninitialized values\n\nremove unnecessary item->type checks\n\ndon\'t strdup sign\n\nadd braces around if statements, use strcmp0 with single characters and remove g_str_has_prefix\n\nrefactoring\n\nchanged g_ascii_strcasecmp to g_strcmp0\n\nadd networktag/ shorthand\n\nfixed memory leaks\n\nchanged from #@= to ::channels, ::queries and ::dccqueries\n\ncheck for empty string and continue; if found\n\nfixed bug with empty string check\n\nclean up code','fe-common-core.c','389','62','31','14','MODIFY','@@ -461,26 +461,43 @@ void fe_common_core_finish_init(void)\n \n gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)\n {\n+	int channel_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"CHANNEL\");\n+	int query_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"QUERY\");\n+	char **tmp;\n+\n 	g_return_val_if_fail(array != NULL, FALSE);\n+	g_return_val_if_fail(dest != NULL, FALSE);\n+	g_return_val_if_fail(dest->window != NULL, FALSE);\n+	g_return_val_if_fail(dest->target != NULL, FALSE);\n \n-	if (strarray_find(array, \"*\") != -1)\n-		return TRUE;\n+	WI_ITEM_REC *item = window_item_find_window(dest->window, dest->server, dest->target);\n+	if (item == NULL) {\n+		return FALSE;\n+	}\n \n-	if (strarray_find(array, dest->target) != -1)\n-		return TRUE;\n+	int server_tag_len = dest->server_tag ? strlen(dest->server_tag) : 0;\n+	for (tmp = array; *tmp != NULL; tmp++) {\n+		char *str = *tmp;\n+		if (*str == \'\\0\') {\n+			continue;\n+		}\n \n-	if (dest->server_tag != NULL) {\n-		char *tagtarget = g_strdup_printf(\"%s/%s\", dest->server_tag, \"*\");\n-		int ret = strarray_find(array, tagtarget);\n-		g_free(tagtarget);\n-		if (ret != -1)\n-			return TRUE;\n+		if (server_tag_len && !g_ascii_strncasecmp(str, dest->server_tag, server_tag_len) && str[server_tag_len] == \'/\') {\n+			str += server_tag_len + 1;\n+		}\n \n-		tagtarget = g_strdup_printf(\"%s/%s\", dest->server_tag, dest->target);\n-		ret = strarray_find(array, tagtarget);\n-		g_free(tagtarget);\n-		if (ret != -1)\n+		if (!g_strcmp0(str, \"\") || !g_strcmp0(str, \"::all\")) {\n 			return TRUE;\n+		} else if (!g_ascii_strcasecmp(str, dest->target)) {\n+			return TRUE;\n+		} else if (item->type == query_type &&\n+			!g_strcmp0(str, (dest->target[0] == \'=\') ? \"::dccqueries\" : \"::queries\")) {\n+			return TRUE;\n+		} else if (item->type == channel_type &&\n+			!g_strcmp0(str, \"::channels\")) {\n+			return TRUE;\n+		}\n 	}\n+\n 	return FALSE;\n }\n','false','false','none'),('irssi','1.0.5','f9d69597ef1e204640d5ce104061717aca0d213a','Joseph Bisch','remove unnecessary malloc cast in fe-fuzz\n\nwe compile this as c code, so the cast is unnecessary.','event-get-params.c','61','11','1','1','MODIFY','@@ -52,7 +52,7 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n 		return 0;\n 	}\n 	uint8_t count = *data;\n-	char *copy = (char *)malloc(sizeof(char)*(size-1+1));\n+	char *copy = malloc(sizeof(char)*(size-1+1));\n 	memcpy(copy, data+1, size-1);\n 	copy[size-1] = \'\\0\';\n \n','false','true','none'),('irssi','1.0.5','f4b89044f075038d29089435f7620a068507d80e','Joseph Bisch','fix malloc parameter in fe-fuzz\n\nit is fairly safe to assume that sizeof(char) will always be 1 anyway\nand replace the size calculation with a comment explaining the\ncalculation.','event-get-params.c','61','11','2','1','MODIFY','@@ -52,7 +52,8 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n 		return 0;\n 	}\n 	uint8_t count = *data;\n-	char *copy = malloc(sizeof(char)*(size-1+1));\n+	/* malloc(size) instead of size+1, because we already used one byte of data */\n+	char *copy = malloc(size);\n 	memcpy(copy, data+1, size-1);\n 	copy[size-1] = \'\\0\';\n \n','true','false','none'),('irssi','1.0.5','532527ffa6a5eaccdbf607a2dc3d0e6ef884fce9','Joseph Bisch','use gchar and g_strndup in fe-fuzz','event-get-params.c','59','11','2','4','MODIFY','@@ -53,9 +53,7 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n 	}\n 	uint8_t count = *data;\n 	/* malloc(size) instead of size+1, because we already used one byte of data */\n-	char *copy = malloc(size);\n-	memcpy(copy, data+1, size-1);\n-	copy[size-1] = \'\\0\';\n+	gchar *copy = g_strndup((const gchar *)data+1, size-1);\n \n 	char *output0;\n 	char *output1;\n@@ -82,6 +80,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n 		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);\n 	}\n 	g_free(params);\n-	free(copy);\n+	g_free(copy);\n 	return 0;\n }\n','false','false','none'),('irssi','1.0.5','66b2c9bc91a3b6e34ba59491c95747db75d21c6b','LemonBoy','keep a copy of the strings coming from the config\n\nthe \"hilight_rec\" structure used to keep a pointer to the \"servertag\"\nstring, owned by the \"config_node\", causing a double-free.','hilight-text.c','543','156','5','2','MODIFY','@@ -106,6 +106,7 @@ static void hilight_destroy(HILIGHT_REC *rec)\n 	if (rec->channels != NULL) g_strfreev(rec->channels);\n 	g_free_not_null(rec->color);\n 	g_free_not_null(rec->act_color);\n+	g_free_not_null(rec->servertag);\n 	g_free(rec->text);\n 	g_free(rec);\n }\n@@ -424,7 +425,7 @@ static void read_hilight_config(void)\n 	CONFIG_NODE *node;\n 	HILIGHT_REC *rec;\n 	GSList *tmp;\n-	char *text, *color;\n+	char *text, *color, *servertag;\n \n 	hilights_destroy_all();\n \n@@ -467,7 +468,9 @@ static void read_hilight_config(void)\n 		rec->nickmask = config_node_get_bool(node, \"mask\", FALSE);\n 		rec->fullword = config_node_get_bool(node, \"fullword\", FALSE);\n 		rec->regexp = config_node_get_bool(node, \"regexp\", FALSE);\n-		rec->servertag = config_node_get_str(node, \"servertag\", NULL);\n+		servertag = config_node_get_str(node, \"servertag\", NULL);\n+		rec->servertag = servertag == NULL || *servertag == \'\\0\' ? NULL :\n+			g_strdup(servertag);\n 		hilight_init_rec(rec);\n \n 		node = iconfig_node_section(node, \"channels\", -1);\n','false','false','none'),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','settings.c','693','161','3','3','MODIFY','@@ -39,7 +39,7 @@ static GString *last_errors;\n static GSList *last_invalid_modules;\n static int fe_initialized;\n static int config_changed; /* FIXME: remove after .98 (unless needed again) */\n-static int user_settings_changed;\n+static unsigned int user_settings_changed;\n \n static GHashTable *settings;\n static int timeout_tag;\n@@ -467,7 +467,7 @@ SETTINGS_REC *settings_get_record(const char *key)\n \n static void sig_init_userinfo_changed(gpointer changedp)\n {\n-	user_settings_changed = GPOINTER_TO_INT(changedp);\n+	user_settings_changed |= GPOINTER_TO_UINT(changedp);\n }\n \n static void sig_init_finished(void)\n@@ -486,7 +486,7 @@ static void sig_init_finished(void)\n 		signal_emit(\"setup changed\", 0);\n 	}\n \n-	signal_emit(\"settings userinfo changed\", 1, GINT_TO_POINTER(user_settings_changed));\n+	signal_emit(\"settings userinfo changed\", 1, GUINT_TO_POINTER(user_settings_changed));\n }\n \n static void settings_clean_invalid_module(const char *module)\n','false','false','none'),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','settings.h','73','0','7','0','MODIFY','@@ -30,6 +30,13 @@ typedef struct {\n 	char **choices;\n } SETTINGS_REC;\n \n+enum {\n+	USER_SETTINGS_REAL_NAME = 0x1,\n+	USER_SETTINGS_USER_NAME = 0x2,\n+	USER_SETTINGS_NICK	= 0x4,\n+	USER_SETTINGS_HOSTNAME	= 0x8,\n+};\n+\n /* macros for handling the default Irssi configuration */\n #define iconfig_get_str(a, b, c) config_get_str(mainconfig, a, b, c)\n #define iconfig_get_int(a, b, c) config_get_int(mainconfig, a, b, c)\n','false','false','none'),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','irssi.c','224','30','7','8','MODIFY','@@ -81,7 +81,7 @@ static GMainLoop *main_loop;\n int quitting;\n \n static int display_firsttimer = FALSE;\n-static int user_settings_changed = 0;\n+static unsigned int user_settings_changed = 0;\n \n \n static void sig_exit(void)\n@@ -91,7 +91,7 @@ static void sig_exit(void)\n \n static void sig_settings_userinfo_changed(gpointer changedp)\n {\n-	user_settings_changed = GPOINTER_TO_INT(changedp);\n+	user_settings_changed = GPOINTER_TO_UINT(changedp);\n }\n \n /* redraw irssi\'s screen.. */\n@@ -199,13 +199,13 @@ static void textui_finish_init(void)\n 	/* see irc-servers-setup.c:init_userinfo */\n 	if (user_settings_changed)\n 		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_WELCOME_INIT_SETTINGS);\n-	if (user_settings_changed & (1<<0))\n+	if (user_settings_changed & USER_SETTINGS_REAL_NAME)\n 		fe_settings_set_print(\"real_name\");\n-	if (user_settings_changed & (1<<1))\n+	if (user_settings_changed & USER_SETTINGS_USER_NAME)\n 		fe_settings_set_print(\"user_name\");\n-	if (user_settings_changed & (1<<2))\n+	if (user_settings_changed & USER_SETTINGS_NICK)\n 		fe_settings_set_print(\"nick\");\n-	if (user_settings_changed & (1<<3))\n+	if (user_settings_changed & USER_SETTINGS_HOSTNAME)\n 		fe_settings_set_print(\"hostname\");\n }\n \n@@ -222,7 +222,7 @@ static void textui_deinit(void)\n         fe_perl_deinit();\n #endif\n \n-        dirty_check(); /* one last time to print any quit messages */\n+	dirty_check(); /* one last time to print any quit messages */\n 	signal_remove(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);\n 	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_exit);\n \n@@ -250,7 +250,6 @@ static void textui_deinit(void)\n 	core_deinit();\n }\n \n-\n static void check_files(void)\n {\n 	struct stat statbuf;\n','false','false','none'),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','irc-servers-setup.c','157','52','6','6','MODIFY','@@ -116,7 +116,7 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,\n \n static void init_userinfo(void)\n {\n-	int changed;\n+	unsigned int changed;\n 	const char *set, *nick, *user_name, *str;\n \n 	changed = 0;\n@@ -126,7 +126,7 @@ static void init_userinfo(void)\n 		str = g_getenv(\"IRCNAME\");\n 		settings_set_str(\"real_name\",\n 				 str != NULL ? str : g_get_real_name());\n-		changed |= 1<<0;\n+		changed |= USER_SETTINGS_REAL_NAME;\n 	}\n \n 	/* username */\n@@ -137,7 +137,7 @@ static void init_userinfo(void)\n 				 str != NULL ? str : g_get_user_name());\n \n 		user_name = settings_get_str(\"user_name\");\n-		changed |= 1<<1;\n+		changed |= USER_SETTINGS_USER_NAME;\n 	}\n \n 	/* nick */\n@@ -147,7 +147,7 @@ static void init_userinfo(void)\n 		settings_set_str(\"nick\", str != NULL ? str : user_name);\n \n 		nick = settings_get_str(\"nick\");\n-		changed |= 1<<2;\n+		changed |= USER_SETTINGS_NICK;\n 	}\n \n 	/* host name */\n@@ -156,11 +156,11 @@ static void init_userinfo(void)\n 		str = g_getenv(\"IRCHOST\");\n 		if (str != NULL) {\n 			settings_set_str(\"hostname\", str);\n-			changed |= 1<<3;\n+			changed |= USER_SETTINGS_HOSTNAME;\n 		}\n 	}\n \n-	signal_emit(\"irssi init userinfo changed\", 1, GINT_TO_POINTER(changed));\n+	signal_emit(\"irssi init userinfo changed\", 1, GUINT_TO_POINTER(changed));\n }\n \n static void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node)\n','false','false','none'),('irssi','1.0.5','596fa6b51ed2ab6be80041684ad805f7b22256ac','LemonBoy','take into account nei\'s suggestions','.clang-format','36','0','6','5','MODIFY','@@ -1,4 +1,4 @@\n-# IndentPPDirectives: None\n+# IndentPPDirectives: AfterHash\n # SpaceInParentheses: false\n AlignAfterOpenBracket: Align\n AlignConsecutiveAssignments: false\n@@ -12,22 +12,23 @@ AllowShortFunctionsOnASingleLine: Empty\n AllowShortIfStatementsOnASingleLine: false\n AllowShortLoopsOnASingleLine: false\n AlwaysBreakAfterReturnType: None\n-AlwaysBreakBeforeMultilineStrings: true\n+AlwaysBreakBeforeMultilineStrings: false\n BinPackArguments: true\n BinPackParameters: true\n BreakBeforeBinaryOperators: None\n-BreakBeforeBraces: Attach\n-BreakBeforeTernaryOperators: true\n+BreakBeforeBraces: Linux\n+BreakBeforeTernaryOperators: false\n ColumnLimit: 100\n IndentCaseLabels: true\n IndentWidth: 8\n IndentWrappedFunctionNames: true\n KeepEmptyLinesAtTheStartOfBlocks: false\n Language: Cpp\n+Cpp11BracedListStyle: false\n MaxEmptyLinesToKeep: 1\n PointerAlignment: Right\n SortIncludes: true\n-SpaceAfterCStyleCast: false\n+SpaceAfterCStyleCast: true\n SpaceBeforeAssignmentOperators: true\n SpaceBeforeParens: ControlStatements\n SpaceInEmptyParentheses: false\n','false','false','none'),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','prevent a uaf error during the execution of some commands\n\nsome arguments were free\'d first and then printed, leading to gibberish\nbeing output to screen or a crash.\n\nfound by joseph bisch.\ncloses: !gl17','fe-channels.c','520','131','1','1','MODIFY','@@ -278,9 +278,9 @@ static void cmd_channel_add_modify(const char *data, gboolean add)\n 	rec = channel_setup_find(channel, chatnet);\n 	if (rec == NULL) {\n 		if (add == FALSE) {\n-			cmd_params_free(free_arg);\n 			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,\n 				TXT_CHANSETUP_NOT_FOUND, channel, chatnet);\n+			cmd_params_free(free_arg);\n 			return;\n 		}\n \n','true','false','none'),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','prevent a uaf error during the execution of some commands\n\nsome arguments were free\'d first and then printed, leading to gibberish\nbeing output to screen or a crash.\n\nfound by joseph bisch.\ncloses: !gl17','fe-server.c','382','113','1','1','MODIFY','@@ -136,9 +136,9 @@ static void cmd_server_add_modify(const char *data, gboolean add)\n \n 	if (rec == NULL) {\n 		if (add == FALSE) {\n-			cmd_params_free(free_arg);\n 			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,\n 				TXT_SETUPSERVER_NOT_FOUND, addr, port);\n+			cmd_params_free(free_arg);\n 			return;\n 		}\n \n','true','false','none'),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','prevent a uaf error during the execution of some commands\n\nsome arguments were free\'d first and then printed, leading to gibberish\nbeing output to screen or a crash.\n\nfound by joseph bisch.\ncloses: !gl17','fe-ircnet.c','191','72','1','1','MODIFY','@@ -106,9 +106,9 @@ static void cmd_network_add_modify(const char *data, gboolean add)\n 	rec = ircnet_find(name);\n 	if (rec == NULL) {\n 		if (add == FALSE) {\n-			cmd_params_free(free_arg);\n 			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,\n 				IRCTXT_NETWORK_NOT_FOUND, name);\n+			cmd_params_free(free_arg);\n 			return;\n 		}\n \n','true','false','none'),('irssi','1.0.5','3acc72f842a021ffcff8809c1f245ca614f68598','ailin-nemui','reset colour at comma, like mirc\n\nfixes #742 and #740','formats.c','1129','356','3','6','MODIFY','@@ -1072,7 +1072,8 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)\n 	fg = fg_ret == NULL ? -1 : *fg_ret;\n 	bg = bg_ret == NULL ? -1 : *bg_ret;\n \n-	if (!i_isdigit(**str) && **str != \',\') {\n+	if (!i_isdigit(**str)) {\n+		/* turn off color */\n 		fg = -1;\n 		bg = -1;\n 	} else {\n@@ -1085,11 +1086,8 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)\n 				(*str)++;\n 			}\n 		}\n-		if (**str == \',\') {\n+		if ((*str)[0] == \',\' && i_isdigit((*str)[1])) {\n 			/* background color */\n-			if (!i_isdigit((*str)[1]))\n-				bg = -1;\n-			else {\n 				(*str)++;\n 				bg = **str-\'0\';\n 				(*str)++;\n@@ -1097,7 +1095,6 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)\n 					bg = bg*10 + (**str-\'0\');\n 					(*str)++;\n 				}\n-			}\n 		}\n 	}\n \n','false','false','none'),('irssi','1.0.5','ba3c5801a4bb175fe1e0d0fd273ae15318dd2b03','ailin-nemui','update .clang-format\n\ndo not indent case deeper','.clang-format','36','0','1','1','MODIFY','@@ -19,7 +19,7 @@ BreakBeforeBinaryOperators: None\n BreakBeforeBraces: Linux\n BreakBeforeTernaryOperators: false\n ColumnLimit: 100\n-IndentCaseLabels: true\n+IndentCaseLabels: false\n IndentWidth: 8\n IndentWrappedFunctionNames: true\n KeepEmptyLinesAtTheStartOfBlocks: false\n','false','false','none'),('irssi','1.0.5','47400d405a0680bfe4d69ce8b06ecbfd09931999','ailin-nemui','update formats.c\n\nremove now useless check for ,','formats.c','1127','355','11','12','MODIFY','@@ -1078,23 +1078,22 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)\n 		bg = -1;\n 	} else {\n 		/* foreground color */\n-		if (**str != \',\') {\n-			fg = **str-\'0\';\n+		fg = **str-\'0\';\n+		(*str)++;\n+		if (i_isdigit(**str)) {\n+			fg = fg*10 + (**str-\'0\');\n 			(*str)++;\n-			if (i_isdigit(**str)) {\n-				fg = fg*10 + (**str-\'0\');\n-				(*str)++;\n-			}\n 		}\n+\n 		if ((*str)[0] == \',\' && i_isdigit((*str)[1])) {\n 			/* background color */\n+			(*str)++;\n+			bg = **str-\'0\';\n+			(*str)++;\n+			if (i_isdigit(**str)) {\n+				bg = bg*10 + (**str-\'0\');\n 				(*str)++;\n-				bg = **str-\'0\';\n-				(*str)++;\n-				if (i_isdigit(**str)) {\n-					bg = bg*10 + (**str-\'0\');\n-					(*str)++;\n-				}\n+			}\n 		}\n 	}\n \n','false','false','none'),('irssi','1.0.5','1a49787ef25103d1a393c81e35fb949322fe0523','Will Storey','revert initializing pointers to null\n\nto maintain c89 compatibility','fe-events.c','376','58','1','1','MODIFY','@@ -224,7 +224,7 @@ static void event_nick(IRC_SERVER_REC *server, const char *data,\n static void event_mode(IRC_SERVER_REC *server, const char *data,\n 		       const char *nick, const char *addr)\n {\n-	char *params = NULL, *channel = NULL, *mode = NULL;\n+	char *params, *channel, *mode;\n \n 	g_return_if_fail(data != NULL);\n \n','false','false','none'),('irssi','1.0.5','1a49787ef25103d1a393c81e35fb949322fe0523','Will Storey','revert initializing pointers to null\n\nto maintain c89 compatibility','modes.c','700','195','2','2','MODIFY','@@ -480,8 +480,8 @@ static void event_user_mode(IRC_SERVER_REC *server, const char *data)\n static void event_mode(IRC_SERVER_REC *server, const char *data,\n 		       const char *nick)\n {\n-	IRC_CHANNEL_REC *chanrec = NULL;\n-	char *params = NULL, *channel = NULL, *mode = NULL;\n+	IRC_CHANNEL_REC *chanrec;\n+	char *params, *channel, *mode;\n \n 	g_return_if_fail(data != NULL);\n \n','false','false','none'),('irssi','1.0.5','b2ca8c04778866bd07cf1b612adf0df55f45b78e','ailin-nemui','check for declaration-after-statement on travis','.travis.yml','48','0','1','1','MODIFY','@@ -31,7 +31,7 @@ before_install:\n \n install:\n     - ./configure --with-proxy --with-bot --with-perl=module --prefix=$HOME/irssi-build\n-    - make CFLAGS=\"-Wall -Werror\"\n+    - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"\n     - make install\n \n before_script:\n','false','false','none'),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','ignore.h','30','0','3','3','MODIFY','@@ -27,14 +27,14 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,\n 		 const char *channel, const char *text, int level);\n \n enum {\n-	IGNORE_FIND_PATTERN = 0x01, // Match the pattern\n-	IGNORE_FIND_NOACT   = 0x02, // Exclude the targets with NOACT level\n+	IGNORE_FIND_PATTERN = 0x01, /* Match the pattern */\n+	IGNORE_FIND_NOACT   = 0x02, /* Exclude the targets with NOACT level */\n };\n \n IGNORE_REC *ignore_find_full (const char *servertag, const char *mask, const char *pattern,\n                 char **channels, const int flags);\n \n-// Convenience wrappers around ignore_find_full, for compatibility purpose\n+/* Convenience wrappers around ignore_find_full, for compatibility purpose */\n \n IGNORE_REC *ignore_find(const char *servertag, const char *mask, char **channels);\n IGNORE_REC *ignore_find_noact(const char *servertag, const char *mask, char **channels, int noact);\n','true','false','none'),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','network-openssl.c','679','147','10','10','MODIFY','@@ -600,7 +600,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n 	tls_rec_set_certificate_fingerprint(tls, cert_fingerprint_hex);\n 	tls_rec_set_certificate_fingerprint_algorithm(tls, \"SHA256\");\n \n-	// Show algorithm.\n+	/* Show algorithm. */\n 	switch (EVP_PKEY_id(pubkey)) {\n 		case EVP_PKEY_RSA:\n 			tls_rec_set_public_key_algorithm(tls, \"RSA\");\n@@ -624,7 +624,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n 	tls_rec_set_public_key_size(tls, EVP_PKEY_bits(pubkey));\n 	tls_rec_set_public_key_fingerprint_algorithm(tls, \"SHA256\");\n \n-	// Read the NotBefore timestamp.\n+	/* Read the NotBefore timestamp. */\n 	bio = BIO_new(BIO_s_mem());\n 	ASN1_TIME_print(bio, X509_get_notBefore(cert));\n 	length = BIO_read(bio, buffer, sizeof(buffer));\n@@ -632,7 +632,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n 	BIO_free(bio);\n 	tls_rec_set_not_before(tls, buffer);\n \n-	// Read the NotAfter timestamp.\n+	/* Read the NotAfter timestamp. */\n 	bio = BIO_new(BIO_s_mem());\n 	ASN1_TIME_print(bio, X509_get_notAfter(cert));\n 	length = BIO_read(bio, buffer, sizeof(buffer));\n@@ -670,7 +670,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)\n 	for (i = 0; i < sk_X509_num(chain); i++) {\n 		cert_rec = tls_cert_create_rec();\n \n-		// Subject.\n+		/* Subject. */\n 		name = X509_get_subject_name(sk_X509_value(chain, i));\n \n 		for (j = 0; j < X509_NAME_entry_count(name); j++) {\n@@ -689,7 +689,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)\n 			tls_cert_rec_append_subject_entry(cert_rec, tls_cert_entry_rec);\n 		}\n \n-		// Issuer.\n+		/* Issuer. */\n 		name = X509_get_issuer_name(sk_X509_value(chain, i));\n \n 		for (j = 0; j < X509_NAME_entry_count(name); j++) {\n@@ -718,10 +718,10 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n 	g_return_if_fail(ssl != NULL);\n \n #ifdef SSL_get_server_tmp_key\n-	// Show ephemeral key information.\n+	/* Show ephemeral key information. */\n 	EVP_PKEY *ephemeral_key = NULL;\n \n-	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598\n+	/* OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 */\n #ifndef OPENSSL_NO_EC\n 	EC_KEY *ec_key = NULL;\n #endif\n@@ -759,7 +759,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n \n 		EVP_PKEY_free(ephemeral_key);\n 	}\n-#endif // SSL_get_server_tmp_key.\n+#endif /* SSL_get_server_tmp_key. */\n }\n \n GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server)\n@@ -866,7 +866,7 @@ int irssi_ssl_handshake(GIOChannel *handle)\n 	set_peer_cert_chain_info(tls, chan->ssl);\n 	set_server_temporary_key_info(tls, chan->ssl);\n \n-	// Emit the TLS rec.\n+	/* Emit the TLS rec. */\n 	signal_emit(\"tls handshake finished\", 2, chan->server, tls);\n \n 	ret = 1;\n@@ -893,7 +893,7 @@ int irssi_ssl_handshake(GIOChannel *handle)\n 		ret = irssi_ssl_verify(chan->ssl, chan->ctx, chan->server->connrec->address, chan->port, cert, chan->server, tls);\n \n 		if (! ret) {\n-			// irssi_ssl_verify emits a warning itself.\n+			/* irssi_ssl_verify emits a warning itself. */\n 			goto done;\n 		}\n 	}\n','true','false','ssl_get_server_tmp_key'),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','network-openssl.c','679','147','10','10','MODIFY','@@ -600,7 +600,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n 	tls_rec_set_certificate_fingerprint(tls, cert_fingerprint_hex);\n 	tls_rec_set_certificate_fingerprint_algorithm(tls, \"SHA256\");\n \n-	// Show algorithm.\n+	/* Show algorithm. */\n 	switch (EVP_PKEY_id(pubkey)) {\n 		case EVP_PKEY_RSA:\n 			tls_rec_set_public_key_algorithm(tls, \"RSA\");\n@@ -624,7 +624,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n 	tls_rec_set_public_key_size(tls, EVP_PKEY_bits(pubkey));\n 	tls_rec_set_public_key_fingerprint_algorithm(tls, \"SHA256\");\n \n-	// Read the NotBefore timestamp.\n+	/* Read the NotBefore timestamp. */\n 	bio = BIO_new(BIO_s_mem());\n 	ASN1_TIME_print(bio, X509_get_notBefore(cert));\n 	length = BIO_read(bio, buffer, sizeof(buffer));\n@@ -632,7 +632,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n 	BIO_free(bio);\n 	tls_rec_set_not_before(tls, buffer);\n \n-	// Read the NotAfter timestamp.\n+	/* Read the NotAfter timestamp. */\n 	bio = BIO_new(BIO_s_mem());\n 	ASN1_TIME_print(bio, X509_get_notAfter(cert));\n 	length = BIO_read(bio, buffer, sizeof(buffer));\n@@ -670,7 +670,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)\n 	for (i = 0; i < sk_X509_num(chain); i++) {\n 		cert_rec = tls_cert_create_rec();\n \n-		// Subject.\n+		/* Subject. */\n 		name = X509_get_subject_name(sk_X509_value(chain, i));\n \n 		for (j = 0; j < X509_NAME_entry_count(name); j++) {\n@@ -689,7 +689,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)\n 			tls_cert_rec_append_subject_entry(cert_rec, tls_cert_entry_rec);\n 		}\n \n-		// Issuer.\n+		/* Issuer. */\n 		name = X509_get_issuer_name(sk_X509_value(chain, i));\n \n 		for (j = 0; j < X509_NAME_entry_count(name); j++) {\n@@ -718,10 +718,10 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n 	g_return_if_fail(ssl != NULL);\n \n #ifdef SSL_get_server_tmp_key\n-	// Show ephemeral key information.\n+	/* Show ephemeral key information. */\n 	EVP_PKEY *ephemeral_key = NULL;\n \n-	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598\n+	/* OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 */\n #ifndef OPENSSL_NO_EC\n 	EC_KEY *ec_key = NULL;\n #endif\n@@ -759,7 +759,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n \n 		EVP_PKEY_free(ephemeral_key);\n 	}\n-#endif // SSL_get_server_tmp_key.\n+#endif /* SSL_get_server_tmp_key. */\n }\n \n GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server)\n@@ -866,7 +866,7 @@ int irssi_ssl_handshake(GIOChannel *handle)\n 	set_peer_cert_chain_info(tls, chan->ssl);\n 	set_server_temporary_key_info(tls, chan->ssl);\n \n-	// Emit the TLS rec.\n+	/* Emit the TLS rec. */\n 	signal_emit(\"tls handshake finished\", 2, chan->server, tls);\n \n 	ret = 1;\n@@ -893,7 +893,7 @@ int irssi_ssl_handshake(GIOChannel *handle)\n 		ret = irssi_ssl_verify(chan->ssl, chan->ctx, chan->server->connrec->address, chan->port, cert, chan->server, tls);\n \n 		if (! ret) {\n-			// irssi_ssl_verify emits a warning itself.\n+			/* irssi_ssl_verify emits a warning itself. */\n 			goto done;\n 		}\n 	}\n','true','false','not openssl_no_ec'),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','irssi.c','33','2','1','1','MODIFY','@@ -21,7 +21,7 @@\n #include \"module.h\"\n #include \"modules-load.h\"\n #include \"levels.h\"\n-#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text\n+#include \"../fe-text/module-formats.h\" /* need to explicitly grab from fe-text */\n #include \"themes.h\"\n #include \"core.h\"\n #include \"fe-common-core.h\"\n','true','false','none'),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','statusbar-items.c','391','99','2','2','MODIFY','@@ -369,8 +369,8 @@ static void item_lag(SBAR_ITEM_REC *item, int get_size_only)\n 	last_lag_unknown = lag_unknown;\n \n 	if (lag_unknown) {\n-		// \"??)\" in C becomes \']\'\n-		// See: https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C\n+		/* \"??)\" in C becomes \']\'\n+		   See: https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C */\n 		g_snprintf(str, sizeof(str), \"%d (?\"\"?)\", lag / 100);\n 	} else {\n 		if (lag % 100 == 0)\n','true','false','none'),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','sasl.c','199','35','3','3','MODIFY','@@ -30,16 +30,16 @@\n  * Based on IRCv3 SASL Extension Specification:\n  * http://ircv3.net/specs/extensions/sasl-3.1.html\n  */\n-#define AUTHENTICATE_CHUNK_SIZE 400 // bytes\n+#define AUTHENTICATE_CHUNK_SIZE 400 /* bytes */\n \n /*\n  * Maximum size to allow the buffer to grow to before the next fragment comes in. Note that\n  * due to the way fragmentation works, the maximum message size will actually be:\n  * floor(AUTHENTICATE_MAX_SIZE / AUTHENTICATE_CHUNK_SIZE) + AUTHENTICATE_CHUNK_SIZE - 1\n  */\n-#define AUTHENTICATE_MAX_SIZE 8192 // bytes\n+#define AUTHENTICATE_MAX_SIZE 8192 /* bytes */\n \n-#define SASL_TIMEOUT (20 * 1000) // ms\n+#define SASL_TIMEOUT (20 * 1000) /* ms */\n \n static gboolean sasl_timeout(IRC_SERVER_REC *server)\n {\n','true','false','none'),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','network-openssl.c','679','147','9','9','MODIFY','@@ -583,9 +583,6 @@ static void set_cipher_info(TLS_REC *tls, SSL *ssl)\n \n static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_fingerprint, size_t cert_fingerprint_size, unsigned char *public_key_fingerprint, size_t public_key_fingerprint_size)\n {\n-	g_return_if_fail(tls != NULL);\n-	g_return_if_fail(cert != NULL);\n-\n 	EVP_PKEY *pubkey = NULL;\n 	char *cert_fingerprint_hex = NULL;\n 	char *public_key_fingerprint_hex = NULL;\n@@ -594,6 +591,9 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n 	char buffer[128];\n 	size_t length;\n \n+	g_return_if_fail(tls != NULL);\n+	g_return_if_fail(cert != NULL);\n+\n 	pubkey = X509_get_pubkey(cert);\n \n 	cert_fingerprint_hex = binary_to_hex(cert_fingerprint, cert_fingerprint_size);\n@@ -647,9 +647,6 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger\n \n static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)\n {\n-	g_return_if_fail(tls != NULL);\n-	g_return_if_fail(ssl != NULL);\n-\n 	int nid;\n 	char *key = NULL;\n 	char *value = NULL;\n@@ -662,6 +659,9 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)\n 	TLS_CERT_ENTRY_REC *tls_cert_entry_rec = NULL;\n 	ASN1_STRING *data = NULL;\n \n+	g_return_if_fail(tls != NULL);\n+	g_return_if_fail(ssl != NULL);\n+\n 	chain = SSL_get_peer_cert_chain(ssl);\n \n 	if (chain == NULL)\n@@ -714,9 +714,6 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)\n \n static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n {\n-	g_return_if_fail(tls != NULL);\n-	g_return_if_fail(ssl != NULL);\n-\n #ifdef SSL_get_server_tmp_key\n 	/* Show ephemeral key information. */\n 	EVP_PKEY *ephemeral_key = NULL;\n@@ -729,6 +726,9 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)\n 	char *cname = NULL;\n 	int nid;\n \n+	g_return_if_fail(tls != NULL);\n+	g_return_if_fail(ssl != NULL);\n+\n 	if (SSL_get_server_tmp_key(ssl, &ephemeral_key)) {\n 		switch (EVP_PKEY_id(ephemeral_key)) {\n 			case EVP_PKEY_DH:\n','false','false','ssl_get_server_tmp_key'),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','fe-windows.c','623','184','3','1','MODIFY','@@ -563,8 +563,10 @@ GSList *windows_get_sorted(void)\n 	begin = windows_seq_begin();\n \n 	while (iter != begin) {\n+		WINDOW_REC *rec;\n+\n 		iter = g_sequence_iter_prev(iter);\n-		WINDOW_REC *rec = g_sequence_get(iter);\n+		rec = g_sequence_get(iter);\n \n 		sorted = g_slist_prepend(sorted, rec);\n 	}\n','false','false','none'),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','Expando.xs','147','21','2','1','MODIFY','@@ -74,6 +74,7 @@ static char *perl_expando_event(PerlExpando *rec, SERVER_REC *server,\n \n 	ret = NULL;\n 	if (SvTRUE(ERRSV)) {\n+		char *error;\n 		PERL_SCRIPT_REC *script = rec->script;\n \n 		(void) POPs;\n@@ -85,7 +86,7 @@ static char *perl_expando_event(PerlExpando *rec, SERVER_REC *server,\n 			script_unregister_expandos(script);\n 		/* rec has been freed now */\n \n-		char *error = g_strdup(SvPV_nolen(ERRSV));\n+		error = g_strdup(SvPV_nolen(ERRSV));\n 		signal_emit(\"script error\", 2, script, error);\n 		g_free(error);\n 	} else if (retcount > 0) {\n','false','false','none'),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','Statusbar.xs','136','17','2','2','MODIFY','@@ -67,7 +67,7 @@ static void perl_statusbar_event(char *function, SBAR_ITEM_REC *item,\n \n 	if (SvTRUE(ERRSV)) {\n                 PERL_SCRIPT_REC *script;\n-                char *package;\n+                char *package, *error;\n \n                 package = perl_function_get_package(function);\n                 script = perl_script_find_package(package);\n@@ -78,7 +78,7 @@ static void perl_statusbar_event(char *function, SBAR_ITEM_REC *item,\n 			script_unregister_statusbars(script);\n 		}\n \n-		char *error = g_strdup(SvPV_nolen(ERRSV));\n+		error = g_strdup(SvPV_nolen(ERRSV));\n 		signal_emit(\"script error\", 2, script, error);\n 		g_free(error);\n 	} else {\n','false','false','none'),('irssi','1.0.5','b0637ad6ea8784d3b2be829ca40f9dddf0c049fc','Will Storey','update null comparison style and be c89 compatible','irc.c','317','74','5','3','MODIFY','@@ -287,11 +287,13 @@ char *event_get_params(const char *data, int count, ...)\n /* Given a string containing <params>, strip any colon prefixing <trailing>. */\n static void strip_params_colon(char *const params)\n {\n-	if (!params) {\n+	char *s;\n+\n+	if (params == NULL) {\n 		return;\n 	}\n \n-	char *s = params;\n+	s = params;\n 	while (*s != \'\\0\') {\n 		if (*s == \':\') {\n 			memmove(s, s+1, strlen(s+1)+1);\n@@ -299,7 +301,7 @@ static void strip_params_colon(char *const params)\n 		}\n \n 		s = strchr(s, \' \');\n-		if (!s) {\n+		if (s == NULL) {\n 			return;\n 		}\n \n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','.gitignore','54','0','3','0','MODIFY','@@ -49,6 +49,9 @@ src/perl/*/Makefile.old\n src/fe-fuzz/crash-*\n src/fe-fuzz/oom-*\n \n+tests/irc/core/test-irc\n+tests/irc/core/test-irc.trs\n+\n *.a\n *.bs\n *.la\n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','.travis.yml','50','0','3','1','MODIFY','@@ -49,5 +49,7 @@ before_script:\n     - echo ^quit >> irssi-test/startup\n     - irssi-build/bin/irssi --home irssi-test\n     - cat irc.log.*\n+    - cd $TRAVIS_BUILD_DIR\n \n-script: true\n+script:\n+    - make check\n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','Makefile.am','22','0','1','1','MODIFY','@@ -16,7 +16,7 @@ irssi-version.h:\n 	VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) | \\\n 		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) >$@\n \n-SUBDIRS = src docs scripts themes utils\n+SUBDIRS = src tests docs scripts themes utils\n \n confdir = $(sysconfdir)\n conf_DATA = irssi.conf\n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','configure.ac','703','4','3','0','MODIFY','@@ -658,6 +658,9 @@ src/perl/ui/Makefile.PL\n src/perl/textui/Makefile.PL\n scripts/Makefile\n scripts/examples/Makefile\n+tests/Makefile\n+tests/irc/Makefile\n+tests/irc/core/Makefile\n docs/Makefile\n docs/help/Makefile\n docs/help/in/Makefile\n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@\n+SUBDIRS = irc\n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@\n+SUBDIRS = core\n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','Makefile.am','31','0','36','0','ADD','@@ -0,0 +1,36 @@\n+AM_CPPFLAGS = \\\n+	-I$(top_srcdir)/src \\\n+	-I$(top_srcdir)/src/core \\\n+	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\\n+	$(GLIB_CFLAGS)\n+\n+TESTS = test-irc\n+check_PROGRAMS = test-irc\n+\n+test_irc_CPPFLAGS = \\\n+	-I$(top_srcdir)/src/irc/core \\\n+	$(AM_CPPFLAGS)\n+\n+test_irc_DEPENDENCIES = \\\n+	../../../src/core/libcore.a \\\n+	../../../src/lib-config/libirssi_config.a\n+\n+test_irc_LDADD = \\\n+	../../../src/core/libcore.a \\\n+	../../../src/lib-config/libirssi_config.a \\\n+	@GLIB_LIBS@ \\\n+	@OPENSSL_LIBS@\n+\n+test_irc_SOURCES = \\\n+	test-irc.c \\\n+	../../../src/irc/core/irc-cap.c \\\n+	../../../src/irc/core/irc-nicklist.c \\\n+	../../../src/irc/core/irc-queries.c \\\n+	../../../src/irc/core/irc-servers-reconnect.c \\\n+	../../../src/irc/core/irc-servers-setup.c \\\n+	../../../src/irc/core/irc-servers.c \\\n+	../../../src/irc/core/irc.c \\\n+	../../../src/irc/core/mode-lists.c \\\n+	../../../src/irc/core/modes.c \\\n+	../../../src/irc/core/servers-idle.c \\\n+	../../../src/irc/core/servers-redirect.c\n','false','false','none'),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','add a test program to test mode parsing\n\nthis uses glib\'s testing framework. it is to test the changes to the\nmode parsing for #603.','test-irc.c','189','5','230','0','ADD','@@ -0,0 +1,230 @@\n+/*\n+ test-irc.c : irssi\n+\n+    Copyright (C) 2017 Will Storey\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+*/\n+\n+#include <glib.h>\n+#include <irc.h>\n+#include <string.h>\n+\n+static void test_event_get_param(void);\n+static void test_event_get_params(void);\n+\n+int main(int argc, char **argv)\n+{\n+	g_test_init(&argc, &argv, NULL);\n+\n+	g_test_add_func(\"/test/event_get_param\", test_event_get_param);\n+	g_test_add_func(\"/test/event_get_params\", test_event_get_params);\n+\n+	return g_test_run();\n+}\n+\n+static void test_event_get_param(void)\n+{\n+	struct test_case {\n+		char const *const description;\n+		char const *const input;\n+		char const *const input_after;\n+		char const *const output;\n+	};\n+\n+	struct test_case const tests[] = {\n+		{\n+			.description = \"Zero parameters\",\n+			.input       = \"\",\n+			.input_after = \"\",\n+			.output      = \"\",\n+		},\n+		{\n+			.description = \"One parameter\",\n+			.input       = \"#test\",\n+			.input_after = \"\",\n+			.output      = \"#test\",\n+		},\n+		{\n+			.description = \"One parameter, trailing space\",\n+			.input       = \"#test \",\n+			.input_after = \"\",\n+			.output      = \"#test\",\n+		},\n+		{\n+			.description = \"One parameter, more trailing space\",\n+			.input       = \"#test  \",\n+			.input_after = \" \",\n+			.output      = \"#test\",\n+		},\n+		{\n+			.description = \"Two parameters\",\n+			.input       = \"#test +o\",\n+			.input_after = \"+o\",\n+			.output      = \"#test\",\n+		},\n+		{\n+			.description = \"Two parameters continued\",\n+			.input       = \"+o\",\n+			.input_after = \"\",\n+			.output      = \"+o\",\n+		},\n+		{\n+			.description = \"Two parameters with trailing space\",\n+			.input       = \"#test +o \",\n+			.input_after = \"+o \",\n+			.output      = \"#test\",\n+		},\n+		{\n+			.description = \"Two parameters with trailing space continued\",\n+			.input       = \"+o \",\n+			.input_after = \"\",\n+			.output      = \"+o\",\n+		},\n+		{\n+			.description = \"Two parameters with inline and trailing space\",\n+			.input       = \"#test  +o \",\n+			.input_after = \" +o \",\n+			.output      = \"#test\",\n+		},\n+		/* TODO: It seems not ideal that the caller has to deal with inline space.\n+		 */\n+		{\n+			.description = \"Two parameters with inline and trailing space continued\",\n+			.input       = \" +o \",\n+			.input_after = \"+o \",\n+			.output      = \"\",\n+		},\n+	};\n+\n+	char *buf = g_malloc0(1024);\n+\n+	int i = 0;\n+	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {\n+		struct test_case const test = tests[i];\n+\n+		memcpy(buf, test.input, strlen(test.input)+1);\n+		char *input = buf;\n+\n+		char *const output = event_get_param(&input);\n+\n+		g_assert_cmpstr(input, ==, test.input_after);\n+		g_assert_cmpstr(output, ==, test.output);\n+	}\n+\n+	g_free(buf);\n+}\n+\n+static void test_event_get_params(void)\n+{\n+	struct test_case {\n+		char const *const description;\n+		char const *const input;\n+		char const *const output0;\n+		char const *const output1;\n+	};\n+\n+	struct test_case const tests[] = {\n+		{\n+			.description = \"Only a channel\",\n+			.input       = \"#test\",\n+			.output0     = \"#test\",\n+			.output1     = \"\",\n+		},\n+		{\n+			.description = \"Only a channel with trailing space\",\n+			.input       = \"#test \",\n+			.output0     = \"#test\",\n+			.output1     = \"\",\n+		},\n+		{\n+			.description = \"No :<trailing>, channel mode with one parameter after channel name\",\n+			.input       = \"#test +i\",\n+			.output0     = \"#test\",\n+			.output1     = \"+i\",\n+		},\n+		{\n+			.description = \"No :<trailing>, channel mode with two parameters after channel name\",\n+			.input       = \"#test +o tester\",\n+			.output0     = \"#test\",\n+			.output1     = \"+o tester\",\n+		},\n+		{\n+			.description = \"No :<trailing>, channel mode with three parameters afer channel name\",\n+			.input       = \"#test +ov tester tester2\",\n+			.output0     = \"#test\",\n+			.output1     = \"+ov tester tester2\",\n+		},\n+		{\n+			.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\",\n+			.input       = \"#test  +ov  tester  tester2 \",\n+			.output0     = \"#test\",\n+			.output1     = \" +ov  tester  tester2 \",\n+		},\n+		{\n+			.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\",\n+			.input       = \"#test :+i\",\n+			.output0     = \"#test\",\n+			.output1     = \"+i\",\n+		},\n+		{\n+			.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\",\n+			.input       = \"#test :+o tester\",\n+			.output0     = \"#test\",\n+			.output1     = \"+o tester\",\n+		},\n+		{\n+			.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\",\n+			.input       = \"#test :+ov tester tester2\",\n+			.output0     = \"#test\",\n+			.output1     = \"+ov tester tester2\",\n+		},\n+		{\n+			.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\",\n+			.input       = \"#test +o :tester\",\n+			.output0     = \"#test\",\n+			.output1     = \"+o tester\",\n+		},\n+		{\n+			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\",\n+			.input       = \"#test +ov tester :tester2\",\n+			.output0     = \"#test\",\n+			.output1     = \"+ov tester tester2\",\n+		},\n+		{\n+			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\",\n+			.input       = \"#test +ov tester :tester2 hi:there\",\n+			.output0     = \"#test\",\n+			.output1     = \"+ov tester tester2 hi:there\",\n+		},\n+	};\n+\n+	int i = 0;\n+	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {\n+		struct test_case const test = tests[i];\n+\n+		char *output0 = NULL;\n+		char *output1 = NULL;\n+		char *const params = event_get_params(test.input, 2 | PARAM_FLAG_GETREST,\n+				&output0, &output1);\n+\n+		/* params happens to always point at the first output */\n+		g_assert_cmpstr(params, ==, test.output0);\n+		g_assert_cmpstr(output0, ==, test.output0);\n+		g_assert_cmpstr(output1, ==, test.output1);\n+\n+		g_free(params);\n+	}\n+}\n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','configure.ac','704','4','2','0','MODIFY','@@ -295,6 +295,8 @@ fi\n \n LIBS=\"$LIBS $GLIB_LIBS\"\n \n+GLIB_TESTS\n+\n dnl **\n dnl ** OpenSSL checks\n dnl **\n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','glibtests.m4','27','0','28','0','ADD','@@ -0,0 +1,28 @@\n+dnl GLIB_TESTS\n+dnl\n+\n+AC_DEFUN([GLIB_TESTS],\n+[\n+  AC_ARG_ENABLE(installed-tests,\n+                AS_HELP_STRING([--enable-installed-tests],\n+                               [Enable installation of some test cases]),\n+                [case ${enableval} in\n+                  yes) ENABLE_INSTALLED_TESTS=\"1\"  ;;\n+                  no)  ENABLE_INSTALLED_TESTS=\"\" ;;\n+                  *) AC_MSG_ERROR([bad value ${enableval} for --enable-installed-tests]) ;;\n+                 esac])\n+  AM_CONDITIONAL([ENABLE_INSTALLED_TESTS], test \"$ENABLE_INSTALLED_TESTS\" = \"1\")\n+  AC_ARG_ENABLE(always-build-tests,\n+                AS_HELP_STRING([--enable-always-build-tests],\n+                               [Enable always building tests during \'make all\']),\n+                [case ${enableval} in\n+                  yes) ENABLE_ALWAYS_BUILD_TESTS=\"1\"  ;;\n+                  no)  ENABLE_ALWAYS_BUILD_TESTS=\"\" ;;\n+                  *) AC_MSG_ERROR([bad value ${enableval} for --enable-always-build-tests]) ;;\n+                 esac])\n+  AM_CONDITIONAL([ENABLE_ALWAYS_BUILD_TESTS], test \"$ENABLE_ALWAYS_BUILD_TESTS\" = \"1\")\n+  if test \"$ENABLE_INSTALLED_TESTS\" = \"1\"; then\n+    AC_SUBST(installed_test_metadir, [${datadir}/installed-tests/]AC_PACKAGE_NAME)\n+    AC_SUBST(installed_testdir, [${libexecdir}/installed-tests/]AC_PACKAGE_NAME)\n+  fi\n+])\n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','Makefile.am','31','0','3','2','MODIFY','@@ -1,11 +1,12 @@\n+include $(top_srcdir)/utils/glib-tap.mk\n+\n AM_CPPFLAGS = \\\n 	-I$(top_srcdir)/src \\\n 	-I$(top_srcdir)/src/core \\\n 	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\\n 	$(GLIB_CFLAGS)\n \n-TESTS = test-irc\n-check_PROGRAMS = test-irc\n+test_programs = test-irc\n \n test_irc_CPPFLAGS = \\\n 	-I$(top_srcdir)/src/irc/core \\\n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','test-irc.c','190','5','1','0','MODIFY','@@ -32,6 +32,7 @@ int main(int argc, char **argv)\n 	g_test_add_func(\"/test/event_get_param\", test_event_get_param);\n 	g_test_add_func(\"/test/event_get_params\", test_event_get_params);\n \n+	g_test_set_nonfatal_assertions();\n 	return g_test_run();\n }\n \n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','Makefile.am','6','0','3','1','MODIFY','@@ -1,4 +1,6 @@\n EXTRA_DIST = \\\n 	file2header.sh \\\n 	irssi-version.sh \\\n-	syntax.pl\n+	syntax.pl \\\n+	tap-driver.sh \\\n+	tap-test\n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','glib-tap.mk','86','0','134','0','ADD','@@ -0,0 +1,134 @@\n+# GLIB - Library of useful C routines\n+\n+TESTS_ENVIRONMENT= \\\n+	G_TEST_SRCDIR=\"$(abs_srcdir)\" 		\\\n+	G_TEST_BUILDDIR=\"$(abs_builddir)\" 	\\\n+	G_DEBUG=gc-friendly 			\\\n+	MALLOC_CHECK_=2 			\\\n+	MALLOC_PERTURB_=$$(($${RANDOM:-256} % 256))\n+LOG_DRIVER = env AM_TAP_AWK=\'$(AWK)\' $(SHELL) $(top_srcdir)/utils/tap-driver.sh\n+LOG_COMPILER = $(top_srcdir)/utils/tap-test\n+\n+NULL =\n+\n+# initialize variables for unconditional += appending\n+BUILT_SOURCES =\n+BUILT_EXTRA_DIST =\n+CLEANFILES = *.log *.trs\n+DISTCLEANFILES =\n+MAINTAINERCLEANFILES =\n+EXTRA_DIST =\n+TESTS =\n+\n+installed_test_LTLIBRARIES =\n+installed_test_PROGRAMS =\n+installed_test_SCRIPTS =\n+nobase_installed_test_DATA =\n+\n+noinst_LTLIBRARIES =\n+noinst_PROGRAMS =\n+noinst_SCRIPTS =\n+noinst_DATA =\n+\n+check_LTLIBRARIES =\n+check_PROGRAMS =\n+check_SCRIPTS =\n+check_DATA =\n+\n+# We support a fairly large range of possible variables.  It is expected that all types of files in a test suite\n+# will belong in exactly one of the following variables.\n+#\n+# First, we support the usual automake suffixes, but in lowercase, with the customary meaning:\n+#\n+#   test_programs, test_scripts, test_data, test_ltlibraries\n+#\n+# The above are used to list files that are involved in both uninstalled and installed testing.  The\n+# test_programs and test_scripts are taken to be actual testcases and will be run as part of the test suite.\n+# Note that _data is always used with the nobase_ automake variable name to ensure that installed test data is\n+# installed in the same way as it appears in the package layout.\n+#\n+# In order to mark a particular file as being only for one type of testing, use \'installed\' or \'uninstalled\',\n+# like so:\n+#\n+#   installed_test_programs, uninstalled_test_programs\n+#   installed_test_scripts, uninstalled_test_scripts\n+#   installed_test_data, uninstalled_test_data\n+#   installed_test_ltlibraries, uninstalled_test_ltlibraries\n+#\n+# Additionally, we support \'extra\' infixes for programs and scripts.  This is used for support programs/scripts\n+# that should not themselves be run as testcases (but exist to be used from other testcases):\n+#\n+#   test_extra_programs, installed_test_extra_programs, uninstalled_test_extra_programs\n+#   test_extra_scripts, installed_test_extra_scripts, uninstalled_test_extra_scripts\n+#\n+# Additionally, for _scripts and _data, we support the customary dist_ prefix so that the named script or data\n+# file automatically end up in the tarball.\n+#\n+#   dist_test_scripts, dist_test_data, dist_test_extra_scripts\n+#   dist_installed_test_scripts, dist_installed_test_data, dist_installed_test_extra_scripts\n+#   dist_uninstalled_test_scripts, dist_uninstalled_test_data, dist_uninstalled_test_extra_scripts\n+#\n+# Note that no file is automatically disted unless it appears in one of the dist_ variables.  This follows the\n+# standard automake convention of not disting programs scripts or data by default.\n+#\n+# test_programs, test_scripts, uninstalled_test_programs and uninstalled_test_scripts (as well as their disted\n+# variants) will be run as part of the in-tree \'make check\'.  These are all assumed to be runnable under\n+# gtester.  That\'s a bit strange for scripts, but it\'s possible.\n+\n+TESTS += $(test_programs) $(test_scripts) $(uninstalled_test_programs) $(uninstalled_test_scripts) \\\n+         $(dist_test_scripts) $(dist_uninstalled_test_scripts)\n+\n+# Note: build even the installed-only targets during \'make check\' to ensure that they still work.\n+# We need to do a bit of trickery here and manage disting via EXTRA_DIST instead of using dist_ prefixes to\n+# prevent automake from mistreating gmake functions like $(wildcard ...) and $(addprefix ...) as if they were\n+# filenames, including removing duplicate instances of the opening part before the space, eg. \'$(addprefix\'.\n+all_test_programs     = $(test_programs) $(uninstalled_test_programs) $(installed_test_programs) \\\n+                        $(test_extra_programs) $(uninstalled_test_extra_programs) $(installed_test_extra_programs)\n+all_test_scripts      = $(test_scripts) $(uninstalled_test_scripts) $(installed_test_scripts) \\\n+                        $(test_extra_scripts) $(uninstalled_test_extra_scripts) $(installed_test_extra_scripts)\n+all_dist_test_scripts = $(dist_test_scripts) $(dist_uninstalled_test_scripts) $(dist_installed_test_scripts) \\\n+                        $(dist_test_extra_scripts) $(dist_uninstalled_test_extra_scripts) $(dist_installed_test_extra_scripts)\n+all_test_scripts     += $(all_dist_test_scripts)\n+EXTRA_DIST           += $(all_dist_test_scripts)\n+all_test_data         = $(test_data) $(uninstalled_test_data) $(installed_test_data)\n+all_dist_test_data    = $(dist_test_data) $(dist_uninstalled_test_data) $(dist_installed_test_data)\n+all_test_data        += $(all_dist_test_data)\n+EXTRA_DIST           += $(all_dist_test_data)\n+all_test_ltlibs       = $(test_ltlibraries) $(uninstalled_test_ltlibraries) $(installed_test_ltlibraries)\n+\n+if ENABLE_ALWAYS_BUILD_TESTS\n+noinst_LTLIBRARIES += $(all_test_ltlibs)\n+noinst_PROGRAMS += $(all_test_programs)\n+noinst_SCRIPTS += $(all_test_scripts)\n+noinst_DATA += $(all_test_data)\n+else\n+check_LTLIBRARIES += $(all_test_ltlibs)\n+check_PROGRAMS += $(all_test_programs)\n+check_SCRIPTS += $(all_test_scripts)\n+check_DATA += $(all_test_data)\n+endif\n+\n+if ENABLE_INSTALLED_TESTS\n+installed_test_PROGRAMS += $(test_programs) $(installed_test_programs) \\\n+                          $(test_extra_programs) $(installed_test_extra_programs)\n+installed_test_SCRIPTS += $(test_scripts) $(installed_test_scripts) \\\n+                          $(test_extra_scripts) $(test_installed_extra_scripts)\n+installed_test_SCRIPTS += $(dist_test_scripts) $(dist_test_extra_scripts) \\\n+                          $(dist_installed_test_scripts) $(dist_installed_test_extra_scripts)\n+nobase_installed_test_DATA += $(test_data) $(installed_test_data)\n+nobase_installed_test_DATA += $(dist_test_data) $(dist_installed_test_data)\n+installed_test_LTLIBRARIES += $(test_ltlibraries) $(installed_test_ltlibraries)\n+installed_testcases = $(test_programs) $(installed_test_programs) \\\n+                      $(test_scripts) $(installed_test_scripts) \\\n+                      $(dist_test_scripts) $(dist_installed_test_scripts)\n+\n+installed_test_meta_DATA = $(installed_testcases:=.test)\n+\n+%.test: %$(EXEEXT) Makefile\n+	$(AM_V_GEN) (echo \'[Test]\' > $@.tmp; \\\n+	echo \'Type=session\' >> $@.tmp; \\\n+	echo \'Exec=$(installed_testdir)/$<\' >> $@.tmp; \\\n+	mv $@.tmp $@)\n+\n+CLEANFILES += $(installed_test_meta_DATA)\n+endif\n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','tap-driver.sh','452','2','652','0','ADD','@@ -0,0 +1,652 @@\n+#! /bin/sh\n+# Copyright (C) 2011-2013 Free Software Foundation, Inc.\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+# This file is maintained in Automake, please report\n+# bugs to <bug-automake@gnu.org> or send patches to\n+# <automake-patches@gnu.org>.\n+\n+scriptversion=2011-12-27.17; # UTC\n+\n+# Make unconditional expansion of undefined variables an error.  This\n+# helps a lot in preventing typo-related bugs.\n+set -u\n+\n+me=tap-driver.sh\n+\n+fatal ()\n+{\n+  echo \"$me: fatal: $*\" >&2\n+  exit 1\n+}\n+\n+usage_error ()\n+{\n+  echo \"$me: $*\" >&2\n+  print_usage >&2\n+  exit 2\n+}\n+\n+print_usage ()\n+{\n+  cat <<END\n+Usage:\n+  tap-driver.sh --test-name=NAME --log-file=PATH --trs-file=PATH\n+                [--expect-failure={yes|no}] [--color-tests={yes|no}]\n+                [--enable-hard-errors={yes|no}] [--ignore-exit]\n+                [--diagnostic-string=STRING] [--merge|--no-merge]\n+                [--comments|--no-comments] [--] TEST-COMMAND\n+The \\`--test-name\', \\`--log-file\' and \\`--trs-file\' options are mandatory.\n+END\n+}\n+\n+# TODO: better error handling in option parsing (in particular, ensure\n+# TODO: $log_file, $trs_file and $test_name are defined).\n+test_name= # Used for reporting.\n+log_file=  # Where to save the result and output of the test script.\n+trs_file=  # Where to save the metadata of the test run.\n+expect_failure=0\n+color_tests=0\n+merge=0\n+ignore_exit=0\n+comments=0\n+diag_string=\'#\'\n+while test $# -gt 0; do\n+  case $1 in\n+  --help) print_usage; exit $?;;\n+  --version) echo \"$me $scriptversion\"; exit $?;;\n+  --test-name) test_name=$2; shift;;\n+  --log-file) log_file=$2; shift;;\n+  --trs-file) trs_file=$2; shift;;\n+  --color-tests) color_tests=$2; shift;;\n+  --expect-failure) expect_failure=$2; shift;;\n+  --enable-hard-errors) shift;; # No-op.\n+  --merge) merge=1;;\n+  --no-merge) merge=0;;\n+  --ignore-exit) ignore_exit=1;;\n+  --comments) comments=1;;\n+  --no-comments) comments=0;;\n+  --diagnostic-string) diag_string=$2; shift;;\n+  --) shift; break;;\n+  -*) usage_error \"invalid option: \'$1\'\";;\n+  esac\n+  shift\n+done\n+\n+test $# -gt 0 || usage_error \"missing test command\"\n+\n+case $expect_failure in\n+  yes) expect_failure=1;;\n+    *) expect_failure=0;;\n+esac\n+\n+if test $color_tests = yes; then\n+  init_colors=\'\n+    color_map[\"red\"]=\"[0;31m\" # Red.\n+    color_map[\"grn\"]=\"[0;32m\" # Green.\n+    color_map[\"lgn\"]=\"[1;32m\" # Light green.\n+    color_map[\"blu\"]=\"[1;34m\" # Blue.\n+    color_map[\"mgn\"]=\"[0;35m\" # Magenta.\n+    color_map[\"std\"]=\"[m\"     # No color.\n+    color_for_result[\"ERROR\"] = \"mgn\"\n+    color_for_result[\"PASS\"]  = \"grn\"\n+    color_for_result[\"XPASS\"] = \"red\"\n+    color_for_result[\"FAIL\"]  = \"red\"\n+    color_for_result[\"XFAIL\"] = \"lgn\"\n+    color_for_result[\"SKIP\"]  = \"blu\"\'\n+else\n+  init_colors=\'\'\n+fi\n+\n+# :; is there to work around a bug in bash 3.2 (and earlier) which\n+# does not always set \'$?\' properly on redirection failure.\n+# See the Autoconf manual for more details.\n+:;{\n+  (\n+    # Ignore common signals (in this subshell only!), to avoid potential\n+    # problems with Korn shells.  Some Korn shells are known to propagate\n+    # to themselves signals that have killed a child process they were\n+    # waiting for; this is done at least for SIGINT (and usually only for\n+    # it, in truth).  Without the `trap\' below, such a behaviour could\n+    # cause a premature exit in the current subshell, e.g., in case the\n+    # test command it runs gets terminated by a SIGINT.  Thus, the awk\n+    # script we are piping into would never seen the exit status it\n+    # expects on its last input line (which is displayed below by the\n+    # last `echo $?\' statement), and would thus die reporting an internal\n+    # error.\n+    # For more information, see the Autoconf manual and the threads:\n+    # <http://lists.gnu.org/archive/html/bug-autoconf/2011-09/msg00004.html>\n+    # <http://mail.opensolaris.org/pipermail/ksh93-integration-discuss/2009-February/004121.html>\n+    trap : 1 3 2 13 15\n+    if test $merge -gt 0; then\n+      exec 2>&1\n+    else\n+      exec 2>&3\n+    fi\n+    \"$@\"\n+    echo $?\n+  ) | LC_ALL=C ${AM_TAP_AWK-awk} \\\n+        -v me=\"$me\" \\\n+        -v test_script_name=\"$test_name\" \\\n+        -v log_file=\"$log_file\" \\\n+        -v trs_file=\"$trs_file\" \\\n+        -v expect_failure=\"$expect_failure\" \\\n+        -v merge=\"$merge\" \\\n+        -v ignore_exit=\"$ignore_exit\" \\\n+        -v comments=\"$comments\" \\\n+        -v diag_string=\"$diag_string\" \\\n+\'\n+# FIXME: the usages of \"cat >&3\" below could be optimized when using\n+# FIXME: GNU awk, and/on on systems that supports /dev/fd/.\n+\n+# Implementation note: in what follows, `result_obj` will be an\n+# associative array that (partly) simulates a TAP result object\n+# from the `TAP::Parser` perl module.\n+\n+## ----------- ##\n+##  FUNCTIONS  ##\n+## ----------- ##\n+\n+function fatal(msg)\n+{\n+  print me \": \" msg | \"cat >&2\"\n+  exit 1\n+}\n+\n+function abort(where)\n+{\n+  fatal(\"internal error \" where)\n+}\n+\n+# Convert a boolean to a \"yes\"/\"no\" string.\n+function yn(bool)\n+{\n+  return bool ? \"yes\" : \"no\";\n+}\n+\n+function add_test_result(result)\n+{\n+  if (!test_results_index)\n+    test_results_index = 0\n+  test_results_list[test_results_index] = result\n+  test_results_index += 1\n+  test_results_seen[result] = 1;\n+}\n+\n+# Whether the test script should be re-run by \"make recheck\".\n+function must_recheck()\n+{\n+  for (k in test_results_seen)\n+    if (k != \"XFAIL\" && k != \"PASS\" && k != \"SKIP\")\n+      return 1\n+  return 0\n+}\n+\n+# Whether the content of the log file associated to this test should\n+# be copied into the \"global\" test-suite.log.\n+function copy_in_global_log()\n+{\n+  for (k in test_results_seen)\n+    if (k != \"PASS\")\n+      return 1\n+  return 0\n+}\n+\n+# FIXME: this can certainly be improved ...\n+function get_global_test_result()\n+{\n+    if (\"ERROR\" in test_results_seen)\n+      return \"ERROR\"\n+    if (\"FAIL\" in test_results_seen || \"XPASS\" in test_results_seen)\n+      return \"FAIL\"\n+    all_skipped = 1\n+    for (k in test_results_seen)\n+      if (k != \"SKIP\")\n+        all_skipped = 0\n+    if (all_skipped)\n+      return \"SKIP\"\n+    return \"PASS\";\n+}\n+\n+function stringify_result_obj(result_obj)\n+{\n+  if (result_obj[\"is_unplanned\"] || result_obj[\"number\"] != testno)\n+    return \"ERROR\"\n+\n+  if (plan_seen == LATE_PLAN)\n+    return \"ERROR\"\n+\n+  if (result_obj[\"directive\"] == \"TODO\")\n+    return result_obj[\"is_ok\"] ? \"XPASS\" : \"XFAIL\"\n+\n+  if (result_obj[\"directive\"] == \"SKIP\")\n+    return result_obj[\"is_ok\"] ? \"SKIP\" : COOKED_FAIL;\n+\n+  if (length(result_obj[\"directive\"]))\n+      abort(\"in function stringify_result_obj()\")\n+\n+  return result_obj[\"is_ok\"] ? COOKED_PASS : COOKED_FAIL\n+}\n+\n+function decorate_result(result)\n+{\n+  color_name = color_for_result[result]\n+  if (color_name)\n+    return color_map[color_name] \"\" result \"\" color_map[\"std\"]\n+  # If we are not using colorized output, or if we do not know how\n+  # to colorize the given result, we should return it unchanged.\n+  return result\n+}\n+\n+function report(result, details)\n+{\n+  if (result ~ /^(X?(PASS|FAIL)|SKIP|ERROR)/)\n+    {\n+      msg = \": \" test_script_name\n+      add_test_result(result)\n+    }\n+  else if (result == \"#\")\n+    {\n+      msg = \" \" test_script_name \":\"\n+    }\n+  else\n+    {\n+      abort(\"in function report()\")\n+    }\n+  if (length(details))\n+    msg = msg \" \" details\n+  # Output on console might be colorized.\n+  print decorate_result(result) msg\n+  # Log the result in the log file too, to help debugging (this is\n+  # especially true when said result is a TAP error or \"Bail out!\").\n+  print result msg | \"cat >&3\";\n+}\n+\n+function testsuite_error(error_message)\n+{\n+  report(\"ERROR\", \"- \" error_message)\n+}\n+\n+function handle_tap_result()\n+{\n+  details = result_obj[\"number\"];\n+  if (length(result_obj[\"description\"]))\n+    details = details \" \" result_obj[\"description\"]\n+\n+  if (plan_seen == LATE_PLAN)\n+    {\n+      details = details \" # AFTER LATE PLAN\";\n+    }\n+  else if (result_obj[\"is_unplanned\"])\n+    {\n+       details = details \" # UNPLANNED\";\n+    }\n+  else if (result_obj[\"number\"] != testno)\n+    {\n+       details = sprintf(\"%s # OUT-OF-ORDER (expecting %d)\",\n+                         details, testno);\n+    }\n+  else if (result_obj[\"directive\"])\n+    {\n+      details = details \" # \" result_obj[\"directive\"];\n+      if (length(result_obj[\"explanation\"]))\n+        details = details \" \" result_obj[\"explanation\"]\n+    }\n+\n+  report(stringify_result_obj(result_obj), details)\n+}\n+\n+# `skip_reason` should be empty whenever planned > 0.\n+function handle_tap_plan(planned, skip_reason)\n+{\n+  planned += 0 # Avoid getting confused if, say, `planned` is \"00\"\n+  if (length(skip_reason) && planned > 0)\n+    abort(\"in function handle_tap_plan()\")\n+  if (plan_seen)\n+    {\n+      # Error, only one plan per stream is acceptable.\n+      testsuite_error(\"multiple test plans\")\n+      return;\n+    }\n+  planned_tests = planned\n+  # The TAP plan can come before or after *all* the TAP results; we speak\n+  # respectively of an \"early\" or a \"late\" plan.  If we see the plan line\n+  # after at least one TAP result has been seen, assume we have a late\n+  # plan; in this case, any further test result seen after the plan will\n+  # be flagged as an error.\n+  plan_seen = (testno >= 1 ? LATE_PLAN : EARLY_PLAN)\n+  # If testno > 0, we have an error (\"too many tests run\") that will be\n+  # automatically dealt with later, so do not worry about it here.  If\n+  # $plan_seen is true, we have an error due to a repeated plan, and that\n+  # has already been dealt with above.  Otherwise, we have a valid \"plan\n+  # with SKIP\" specification, and should report it as a particular kind\n+  # of SKIP result.\n+  if (planned == 0 && testno == 0)\n+    {\n+      if (length(skip_reason))\n+        skip_reason = \"- \"  skip_reason;\n+      report(\"SKIP\", skip_reason);\n+    }\n+}\n+\n+function extract_tap_comment(line)\n+{\n+  if (index(line, diag_string) == 1)\n+    {\n+      # Strip leading `diag_string` from `line`.\n+      line = substr(line, length(diag_string) + 1)\n+      # And strip any leading and trailing whitespace left.\n+      sub(\"^[ \\t]*\", \"\", line)\n+      sub(\"[ \\t]*$\", \"\", line)\n+      # Return what is left (if any).\n+      return line;\n+    }\n+  return \"\";\n+}\n+\n+# When this function is called, we know that line is a TAP result line,\n+# so that it matches the (perl) RE \"^(not )?ok\\b\".\n+function setup_result_obj(line)\n+{\n+  # Get the result, and remove it from the line.\n+  result_obj[\"is_ok\"] = (substr(line, 1, 2) == \"ok\" ? 1 : 0)\n+  sub(\"^(not )?ok[ \\t]*\", \"\", line)\n+\n+  # If the result has an explicit number, get it and strip it; otherwise,\n+  # automatically assing the next progresive number to it.\n+  if (line ~ /^[0-9]+$/ || line ~ /^[0-9]+[^a-zA-Z0-9_]/)\n+    {\n+      match(line, \"^[0-9]+\")\n+      # The final `+ 0` is to normalize numbers with leading zeros.\n+      result_obj[\"number\"] = substr(line, 1, RLENGTH) + 0\n+      line = substr(line, RLENGTH + 1)\n+    }\n+  else\n+    {\n+      result_obj[\"number\"] = testno\n+    }\n+\n+  if (plan_seen == LATE_PLAN)\n+    # No further test results are acceptable after a \"late\" TAP plan\n+    # has been seen.\n+    result_obj[\"is_unplanned\"] = 1\n+  else if (plan_seen && testno > planned_tests)\n+    result_obj[\"is_unplanned\"] = 1\n+  else\n+    result_obj[\"is_unplanned\"] = 0\n+\n+  # Strip trailing and leading whitespace.\n+  sub(\"^[ \\t]*\", \"\", line)\n+  sub(\"[ \\t]*$\", \"\", line)\n+\n+  # This will have to be corrected if we have a \"TODO\"/\"SKIP\" directive.\n+  result_obj[\"description\"] = line\n+  result_obj[\"directive\"] = \"\"\n+  result_obj[\"explanation\"] = \"\"\n+\n+  if (index(line, \"#\") == 0)\n+    return # No possible directive, nothing more to do.\n+\n+  # Directives are case-insensitive.\n+  rx = \"[ \\t]*#[ \\t]*([tT][oO][dD][oO]|[sS][kK][iI][pP])[ \\t]*\"\n+\n+  # See whether we have the directive, and if yes, where.\n+  pos = match(line, rx \"$\")\n+  if (!pos)\n+    pos = match(line, rx \"[^a-zA-Z0-9_]\")\n+\n+  # If there was no TAP directive, we have nothing more to do.\n+  if (!pos)\n+    return\n+\n+  # Let`s now see if the TAP directive has been escaped.  For example:\n+  #  escaped:     ok \\# SKIP\n+  #  not escaped: ok \\\\# SKIP\n+  #  escaped:     ok \\\\\\\\\\# SKIP\n+  #  not escaped: ok \\ # SKIP\n+  if (substr(line, pos, 1) == \"#\")\n+    {\n+      bslash_count = 0\n+      for (i = pos; i > 1 && substr(line, i - 1, 1) == \"\\\\\"; i--)\n+        bslash_count += 1\n+      if (bslash_count % 2)\n+        return # Directive was escaped.\n+    }\n+\n+  # Strip the directive and its explanation (if any) from the test\n+  # description.\n+  result_obj[\"description\"] = substr(line, 1, pos - 1)\n+  # Now remove the test description from the line, that has been dealt\n+  # with already.\n+  line = substr(line, pos)\n+  # Strip the directive, and save its value (normalized to upper case).\n+  sub(\"^[ \\t]*#[ \\t]*\", \"\", line)\n+  result_obj[\"directive\"] = toupper(substr(line, 1, 4))\n+  line = substr(line, 5)\n+  # Now get the explanation for the directive (if any), with leading\n+  # and trailing whitespace removed.\n+  sub(\"^[ \\t]*\", \"\", line)\n+  sub(\"[ \\t]*$\", \"\", line)\n+  result_obj[\"explanation\"] = line\n+}\n+\n+function get_test_exit_message(status)\n+{\n+  if (status == 0)\n+    return \"\"\n+  if (status !~ /^[1-9][0-9]*$/)\n+    abort(\"getting exit status\")\n+  if (status < 127)\n+    exit_details = \"\"\n+  else if (status == 127)\n+    exit_details = \" (command not found?)\"\n+  else if (status >= 128 && status <= 255)\n+    exit_details = sprintf(\" (terminated by signal %d?)\", status - 128)\n+  else if (status > 256 && status <= 384)\n+    # We used to report an \"abnormal termination\" here, but some Korn\n+    # shells, when a child process die due to signal number n, can leave\n+    # in $? an exit status of 256+n instead of the more standard 128+n.\n+    # Apparently, both behaviours are allowed by POSIX (2008), so be\n+    # prepared to handle them both.  See also Austing Group report ID\n+    # 0000051 <http://www.austingroupbugs.net/view.php?id=51>\n+    exit_details = sprintf(\" (terminated by signal %d?)\", status - 256)\n+  else\n+    # Never seen in practice.\n+    exit_details = \" (abnormal termination)\"\n+  return sprintf(\"exited with status %d%s\", status, exit_details)\n+}\n+\n+function write_test_results()\n+{\n+  print \":global-test-result: \" get_global_test_result() > trs_file\n+  print \":recheck: \"  yn(must_recheck()) > trs_file\n+  print \":copy-in-global-log: \" yn(copy_in_global_log()) > trs_file\n+  for (i = 0; i < test_results_index; i += 1)\n+    print \":test-result: \" test_results_list[i] > trs_file\n+  close(trs_file);\n+}\n+\n+BEGIN {\n+\n+## ------- ##\n+##  SETUP  ##\n+## ------- ##\n+\n+\'\"$init_colors\"\'\n+\n+# Properly initialized once the TAP plan is seen.\n+planned_tests = 0\n+\n+COOKED_PASS = expect_failure ? \"XPASS\": \"PASS\";\n+COOKED_FAIL = expect_failure ? \"XFAIL\": \"FAIL\";\n+\n+# Enumeration-like constants to remember which kind of plan (if any)\n+# has been seen.  It is important that NO_PLAN evaluates \"false\" as\n+# a boolean.\n+NO_PLAN = 0\n+EARLY_PLAN = 1\n+LATE_PLAN = 2\n+\n+testno = 0     # Number of test results seen so far.\n+bailed_out = 0 # Whether a \"Bail out!\" directive has been seen.\n+\n+# Whether the TAP plan has been seen or not, and if yes, which kind\n+# it is (\"early\" is seen before any test result, \"late\" otherwise).\n+plan_seen = NO_PLAN\n+\n+## --------- ##\n+##  PARSING  ##\n+## --------- ##\n+\n+is_first_read = 1\n+\n+while (1)\n+  {\n+    # Involutions required so that we are able to read the exit status\n+    # from the last input line.\n+    st = getline\n+    if (st < 0) # I/O error.\n+      fatal(\"I/O error while reading from input stream\")\n+    else if (st == 0) # End-of-input\n+      {\n+        if (is_first_read)\n+          abort(\"in input loop: only one input line\")\n+        break\n+      }\n+    if (is_first_read)\n+      {\n+        is_first_read = 0\n+        nextline = $0\n+        continue\n+      }\n+    else\n+      {\n+        curline = nextline\n+        nextline = $0\n+        $0 = curline\n+      }\n+    # Copy any input line verbatim into the log file.\n+    print | \"cat >&3\"\n+    # Parsing of TAP input should stop after a \"Bail out!\" directive.\n+    if (bailed_out)\n+      continue\n+\n+    # TAP test result.\n+    if ($0 ~ /^(not )?ok$/ || $0 ~ /^(not )?ok[^a-zA-Z0-9_]/)\n+      {\n+        testno += 1\n+        setup_result_obj($0)\n+        handle_tap_result()\n+      }\n+    # TAP plan (normal or \"SKIP\" without explanation).\n+    else if ($0 ~ /^1\\.\\.[0-9]+[ \\t]*$/)\n+      {\n+        # The next two lines will put the number of planned tests in $0.\n+        sub(\"^1\\\\.\\\\.\", \"\")\n+        sub(\"[^0-9]*$\", \"\")\n+        handle_tap_plan($0, \"\")\n+        continue\n+      }\n+    # TAP \"SKIP\" plan, with an explanation.\n+    else if ($0 ~ /^1\\.\\.0+[ \\t]*#/)\n+      {\n+        # The next lines will put the skip explanation in $0, stripping\n+        # any leading and trailing whitespace.  This is a little more\n+        # tricky in truth, since we want to also strip a potential leading\n+        # \"SKIP\" string from the message.\n+        sub(\"^[^#]*#[ \\t]*(SKIP[: \\t][ \\t]*)?\", \"\")\n+        sub(\"[ \\t]*$\", \"\");\n+        handle_tap_plan(0, $0)\n+      }\n+    # \"Bail out!\" magic.\n+    # Older versions of prove and TAP::Harness (e.g., 3.17) did not\n+    # recognize a \"Bail out!\" directive when preceded by leading\n+    # whitespace, but more modern versions (e.g., 3.23) do.  So we\n+    # emulate the latter, \"more modern\" behaviour.\n+    else if ($0 ~ /^[ \\t]*Bail out!/)\n+      {\n+        bailed_out = 1\n+        # Get the bailout message (if any), with leading and trailing\n+        # whitespace stripped.  The message remains stored in `$0`.\n+        sub(\"^[ \\t]*Bail out![ \\t]*\", \"\");\n+        sub(\"[ \\t]*$\", \"\");\n+        # Format the error message for the\n+        bailout_message = \"Bail out!\"\n+        if (length($0))\n+          bailout_message = bailout_message \" \" $0\n+        testsuite_error(bailout_message)\n+      }\n+    # Maybe we have too look for dianogtic comments too.\n+    else if (comments != 0)\n+      {\n+        comment = extract_tap_comment($0);\n+        if (length(comment))\n+          report(\"#\", comment);\n+      }\n+  }\n+\n+## -------- ##\n+##  FINISH  ##\n+## -------- ##\n+\n+# A \"Bail out!\" directive should cause us to ignore any following TAP\n+# error, as well as a non-zero exit status from the TAP producer.\n+if (!bailed_out)\n+  {\n+    if (!plan_seen)\n+      {\n+        testsuite_error(\"missing test plan\")\n+      }\n+    else if (planned_tests != testno)\n+      {\n+        bad_amount = testno > planned_tests ? \"many\" : \"few\"\n+        testsuite_error(sprintf(\"too %s tests run (expected %d, got %d)\",\n+                                bad_amount, planned_tests, testno))\n+      }\n+    if (!ignore_exit)\n+      {\n+        # Fetch exit status from the last line.\n+        exit_message = get_test_exit_message(nextline)\n+        if (exit_message)\n+          testsuite_error(exit_message)\n+      }\n+  }\n+\n+write_test_results()\n+\n+exit 0\n+\n+} # End of \"BEGIN\" block.\n+\'\n+\n+# TODO: document that we consume the file descriptor 3 :-(\n+} 3>\"$log_file\"\n+\n+test $? -eq 0 || fatal \"I/O or internal error\"\n+\n+# Local Variables:\n+# mode: shell-script\n+# sh-indentation: 2\n+# eval: (add-hook \'write-file-hooks \'time-stamp)\n+# time-stamp-start: \"scriptversion=\"\n+# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n+# time-stamp-time-zone: \"UTC\"\n+# time-stamp-end: \"; # UTC\"\n+# End:\n','false','false','none'),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing tap utilities','tap-test','2','0','5','0','ADD','@@ -0,0 +1,5 @@\n+#! /bin/sh\n+\n+# run a GTest in tap mode. The test binary is passed as $1\n+\n+$1 -k --tap\n','false','false','none'),('irssi','1.0.5','43d06369bf8e5c5e470dc2b00656ddcdb9ee0480','ailin-nemui','move fixtures to outer scope','Makefile.am','22','0','4','12','MODIFY','@@ -1,5 +1,7 @@\n include $(top_srcdir)/utils/glib-tap.mk\n \n+PACKAGE_STRING=irc/core\n+\n AM_CPPFLAGS = \\\n 	-I$(top_srcdir)/src \\\n 	-I$(top_srcdir)/src/core \\\n@@ -17,21 +19,11 @@ test_irc_DEPENDENCIES = \\\n 	../../../src/lib-config/libirssi_config.a\n \n test_irc_LDADD = \\\n+	../../../src/irc/core/libirc_core.a \\\n 	../../../src/core/libcore.a \\\n 	../../../src/lib-config/libirssi_config.a \\\n 	@GLIB_LIBS@ \\\n 	@OPENSSL_LIBS@\n \n test_irc_SOURCES = \\\n-	test-irc.c \\\n-	../../../src/irc/core/irc-cap.c \\\n-	../../../src/irc/core/irc-nicklist.c \\\n-	../../../src/irc/core/irc-queries.c \\\n-	../../../src/irc/core/irc-servers-reconnect.c \\\n-	../../../src/irc/core/irc-servers-setup.c \\\n-	../../../src/irc/core/irc-servers.c \\\n-	../../../src/irc/core/irc.c \\\n-	../../../src/irc/core/mode-lists.c \\\n-	../../../src/irc/core/modes.c \\\n-	../../../src/irc/core/servers-idle.c \\\n-	../../../src/irc/core/servers-redirect.c\n+	test-irc.c\n','false','false','none'),('irssi','1.0.5','43d06369bf8e5c5e470dc2b00656ddcdb9ee0480','ailin-nemui','move fixtures to outer scope','test-irc.c','191','5','190','190','MODIFY','@@ -22,210 +22,210 @@\n #include <irc.h>\n #include <string.h>\n \n-static void test_event_get_param(void);\n-static void test_event_get_params(void);\n+typedef struct {\n+	char const *const description;\n+	char const *const input;\n+	char const *const input_after;\n+	char const *const output;\n+} event_get_param_test_case;\n+\n+event_get_param_test_case const event_get_param_fixtures[] = {\n+	{\n+		.description = \"Zero parameters\",\n+		.input       = \"\",\n+		.input_after = \"\",\n+		.output      = \"\",\n+	},\n+	{\n+		.description = \"One parameter\",\n+		.input       = \"#test\",\n+		.input_after = \"\",\n+		.output      = \"#test\",\n+	},\n+	{\n+		.description = \"One parameter, trailing space\",\n+		.input       = \"#test \",\n+		.input_after = \"\",\n+		.output      = \"#test\",\n+	},\n+	{\n+		.description = \"One parameter, more trailing space\",\n+		.input       = \"#test  \",\n+		.input_after = \" \",\n+		.output      = \"#test\",\n+	},\n+	{\n+		.description = \"Two parameters\",\n+		.input       = \"#test +o\",\n+		.input_after = \"+o\",\n+		.output      = \"#test\",\n+	},\n+	{\n+		.description = \"Two parameters continued\",\n+		.input       = \"+o\",\n+		.input_after = \"\",\n+		.output      = \"+o\",\n+	},\n+	{\n+		.description = \"Two parameters with trailing space\",\n+		.input       = \"#test +o \",\n+		.input_after = \"+o \",\n+		.output      = \"#test\",\n+	},\n+	{\n+		.description = \"Two parameters with trailing space continued\",\n+		.input       = \"+o \",\n+		.input_after = \"\",\n+		.output      = \"+o\",\n+	},\n+	{\n+		.description = \"Two parameters with inline and trailing space\",\n+		.input       = \"#test  +o \",\n+		.input_after = \" +o \",\n+		.output      = \"#test\",\n+	},\n+	/* TODO: It seems not ideal that the caller has to deal with inline space.\n+	 */\n+	{\n+		.description = \"Two parameters with inline and trailing space continued\",\n+		.input       = \" +o \",\n+		.input_after = \"+o \",\n+		.output      = \"\",\n+	},\n+};\n+\n+static void test_event_get_param(const event_get_param_test_case *test);\n+\n+typedef struct {\n+	char const *const description;\n+	char const *const input;\n+	char const *const output0;\n+	char const *const output1;\n+} event_get_params_test_case;\n+\n+event_get_params_test_case const event_get_params_fixtures[] = {\n+	{\n+		.description = \"Only a channel\",\n+		.input       = \"#test\",\n+		.output0     = \"#test\",\n+		.output1     = \"\",\n+	},\n+	{\n+		.description = \"Only a channel with trailing space\",\n+		.input       = \"#test \",\n+		.output0     = \"#test\",\n+		.output1     = \"\",\n+	},\n+	{\n+		.description = \"No :<trailing>, channel mode with one parameter after channel name\",\n+		.input       = \"#test +i\",\n+		.output0     = \"#test\",\n+		.output1     = \"+i\",\n+	},\n+	{\n+		.description = \"No :<trailing>, channel mode with two parameters after channel name\",\n+		.input       = \"#test +o tester\",\n+		.output0     = \"#test\",\n+		.output1     = \"+o tester\",\n+	},\n+	{\n+		.description = \"No :<trailing>, channel mode with three parameters afer channel name\",\n+		.input       = \"#test +ov tester tester2\",\n+		.output0     = \"#test\",\n+		.output1     = \"+ov tester tester2\",\n+	},\n+	{\n+		.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\",\n+		.input       = \"#test  +ov  tester  tester2 \",\n+		.output0     = \"#test\",\n+		.output1     = \" +ov  tester  tester2 \",\n+	},\n+	{\n+		.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\",\n+		.input       = \"#test :+i\",\n+		.output0     = \"#test\",\n+		.output1     = \"+i\",\n+	},\n+	{\n+		.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\",\n+		.input       = \"#test :+o tester\",\n+		.output0     = \"#test\",\n+		.output1     = \"+o tester\",\n+	},\n+	{\n+		.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\",\n+		.input       = \"#test :+ov tester tester2\",\n+		.output0     = \"#test\",\n+		.output1     = \"+ov tester tester2\",\n+	},\n+	{\n+		.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\",\n+		.input       = \"#test +o :tester\",\n+		.output0     = \"#test\",\n+		.output1     = \"+o tester\",\n+	},\n+	{\n+		.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\",\n+		.input       = \"#test +ov tester :tester2\",\n+		.output0     = \"#test\",\n+		.output1     = \"+ov tester tester2\",\n+	},\n+	{\n+		.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\",\n+		.input       = \"#test +ov tester :tester2 hi:there\",\n+		.output0     = \"#test\",\n+		.output1     = \"+ov tester tester2 hi:there\",\n+	},\n+};\n+\n+static void test_event_get_params(const event_get_params_test_case *test);\n \n int main(int argc, char **argv)\n {\n+	int i;\n+\n 	g_test_init(&argc, &argv, NULL);\n \n-	g_test_add_func(\"/test/event_get_param\", test_event_get_param);\n-	g_test_add_func(\"/test/event_get_params\", test_event_get_params);\n+	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) {\n+		char *name = g_strdup_printf(\"/test/event_get_params/%d\", i);\n+		g_test_add_data_func(name, &event_get_params_fixtures[i], (GTestDataFunc)test_event_get_params);\n+		g_free(name);\n+	}\n+	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) {\n+		char *name = g_strdup_printf(\"/test/event_get_param/%d\", i);\n+		g_test_add_data_func(name, &event_get_param_fixtures[i], (GTestDataFunc)test_event_get_param);\n+		g_free(name);\n+	}\n \n 	g_test_set_nonfatal_assertions();\n 	return g_test_run();\n }\n \n-static void test_event_get_param(void)\n+static void test_event_get_param(const event_get_param_test_case *test)\n {\n-	struct test_case {\n-		char const *const description;\n-		char const *const input;\n-		char const *const input_after;\n-		char const *const output;\n-	};\n-\n-	struct test_case const tests[] = {\n-		{\n-			.description = \"Zero parameters\",\n-			.input       = \"\",\n-			.input_after = \"\",\n-			.output      = \"\",\n-		},\n-		{\n-			.description = \"One parameter\",\n-			.input       = \"#test\",\n-			.input_after = \"\",\n-			.output      = \"#test\",\n-		},\n-		{\n-			.description = \"One parameter, trailing space\",\n-			.input       = \"#test \",\n-			.input_after = \"\",\n-			.output      = \"#test\",\n-		},\n-		{\n-			.description = \"One parameter, more trailing space\",\n-			.input       = \"#test  \",\n-			.input_after = \" \",\n-			.output      = \"#test\",\n-		},\n-		{\n-			.description = \"Two parameters\",\n-			.input       = \"#test +o\",\n-			.input_after = \"+o\",\n-			.output      = \"#test\",\n-		},\n-		{\n-			.description = \"Two parameters continued\",\n-			.input       = \"+o\",\n-			.input_after = \"\",\n-			.output      = \"+o\",\n-		},\n-		{\n-			.description = \"Two parameters with trailing space\",\n-			.input       = \"#test +o \",\n-			.input_after = \"+o \",\n-			.output      = \"#test\",\n-		},\n-		{\n-			.description = \"Two parameters with trailing space continued\",\n-			.input       = \"+o \",\n-			.input_after = \"\",\n-			.output      = \"+o\",\n-		},\n-		{\n-			.description = \"Two parameters with inline and trailing space\",\n-			.input       = \"#test  +o \",\n-			.input_after = \" +o \",\n-			.output      = \"#test\",\n-		},\n-		/* TODO: It seems not ideal that the caller has to deal with inline space.\n-		 */\n-		{\n-			.description = \"Two parameters with inline and trailing space continued\",\n-			.input       = \" +o \",\n-			.input_after = \"+o \",\n-			.output      = \"\",\n-		},\n-	};\n-\n-	char *buf = g_malloc0(1024);\n-\n-	int i = 0;\n-	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {\n-		struct test_case const test = tests[i];\n-\n-		memcpy(buf, test.input, strlen(test.input)+1);\n-		char *input = buf;\n-\n-		char *const output = event_get_param(&input);\n-\n-		g_assert_cmpstr(input, ==, test.input_after);\n-		g_assert_cmpstr(output, ==, test.output);\n-	}\n+	char *buf, *input, *output;\n+\n+	input = buf = g_strdup(test->input);\n+	output = event_get_param(&input);\n+\n+	g_assert_cmpstr(input, ==, test->input_after);\n+	g_assert_cmpstr(output, ==, test->output);\n \n 	g_free(buf);\n }\n \n-static void test_event_get_params(void)\n+static void test_event_get_params(const event_get_params_test_case *test)\n {\n-	struct test_case {\n-		char const *const description;\n-		char const *const input;\n-		char const *const output0;\n-		char const *const output1;\n-	};\n-\n-	struct test_case const tests[] = {\n-		{\n-			.description = \"Only a channel\",\n-			.input       = \"#test\",\n-			.output0     = \"#test\",\n-			.output1     = \"\",\n-		},\n-		{\n-			.description = \"Only a channel with trailing space\",\n-			.input       = \"#test \",\n-			.output0     = \"#test\",\n-			.output1     = \"\",\n-		},\n-		{\n-			.description = \"No :<trailing>, channel mode with one parameter after channel name\",\n-			.input       = \"#test +i\",\n-			.output0     = \"#test\",\n-			.output1     = \"+i\",\n-		},\n-		{\n-			.description = \"No :<trailing>, channel mode with two parameters after channel name\",\n-			.input       = \"#test +o tester\",\n-			.output0     = \"#test\",\n-			.output1     = \"+o tester\",\n-		},\n-		{\n-			.description = \"No :<trailing>, channel mode with three parameters afer channel name\",\n-			.input       = \"#test +ov tester tester2\",\n-			.output0     = \"#test\",\n-			.output1     = \"+ov tester tester2\",\n-		},\n-		{\n-			.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\",\n-			.input       = \"#test  +ov  tester  tester2 \",\n-			.output0     = \"#test\",\n-			.output1     = \" +ov  tester  tester2 \",\n-		},\n-		{\n-			.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\",\n-			.input       = \"#test :+i\",\n-			.output0     = \"#test\",\n-			.output1     = \"+i\",\n-		},\n-		{\n-			.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\",\n-			.input       = \"#test :+o tester\",\n-			.output0     = \"#test\",\n-			.output1     = \"+o tester\",\n-		},\n-		{\n-			.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\",\n-			.input       = \"#test :+ov tester tester2\",\n-			.output0     = \"#test\",\n-			.output1     = \"+ov tester tester2\",\n-		},\n-		{\n-			.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\",\n-			.input       = \"#test +o :tester\",\n-			.output0     = \"#test\",\n-			.output1     = \"+o tester\",\n-		},\n-		{\n-			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\",\n-			.input       = \"#test +ov tester :tester2\",\n-			.output0     = \"#test\",\n-			.output1     = \"+ov tester tester2\",\n-		},\n-		{\n-			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\",\n-			.input       = \"#test +ov tester :tester2 hi:there\",\n-			.output0     = \"#test\",\n-			.output1     = \"+ov tester tester2 hi:there\",\n-		},\n-	};\n-\n-	int i = 0;\n-	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {\n-		struct test_case const test = tests[i];\n-\n-		char *output0 = NULL;\n-		char *output1 = NULL;\n-		char *const params = event_get_params(test.input, 2 | PARAM_FLAG_GETREST,\n-				&output0, &output1);\n-\n-		/* params happens to always point at the first output */\n-		g_assert_cmpstr(params, ==, test.output0);\n-		g_assert_cmpstr(output0, ==, test.output0);\n-		g_assert_cmpstr(output1, ==, test.output1);\n-\n-		g_free(params);\n-	}\n+	char *output0, *output1, *params;\n+	output0 = NULL;\n+	output1 = NULL;\n+	params = event_get_params(test->input, 2 | PARAM_FLAG_GETREST,\n+			&output0, &output1);\n+\n+	/* params happens to always point at the first output */\n+	g_assert_cmpstr(params, ==, test->output0);\n+	g_assert_cmpstr(output0, ==, test->output0);\n+	g_assert_cmpstr(output1, ==, test->output1);\n+\n+	g_free(params);\n }\n','false','false','none'),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','configure.ac','706','4','2','0','MODIFY','@@ -661,6 +661,8 @@ src/perl/textui/Makefile.PL\n scripts/Makefile\n scripts/examples/Makefile\n tests/Makefile\n+tests/fe-common/Makefile\n+tests/fe-common/core/Makefile\n tests/irc/Makefile\n tests/irc/core/Makefile\n docs/Makefile\n','false','false','none'),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','1','0','1','1','MODIFY','@@ -1 +1 @@\n-SUBDIRS = irc\n+SUBDIRS = fe-common irc\n','false','false','none'),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@\n+SUBDIRS = core\n','false','false','none'),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','21','0','28','0','ADD','@@ -0,0 +1,28 @@\n+include $(top_srcdir)/utils/glib-tap.mk\n+\n+PACKAGE_STRING=fe-common/core\n+\n+AM_CPPFLAGS = \\\n+	-I$(top_srcdir)/src \\\n+	-I$(top_srcdir)/src/core \\\n+	$(GLIB_CFLAGS)\n+\n+test_programs = test-formats\n+\n+test_formats_CPPFLAGS = \\\n+	-I$(top_srcdir)/src/fe-common/core \\\n+	$(AM_CPPFLAGS)\n+\n+test_formats_DEPENDENCIES = \\\n+	../../../src/core/libcore.a \\\n+	../../../src/lib-config/libirssi_config.a\n+\n+test_formats_LDADD = \\\n+	../../../src/fe-common/core/libfe_common_core.a \\\n+	../../../src/core/libcore.a \\\n+	../../../src/lib-config/libirssi_config.a \\\n+	@GLIB_LIBS@ \\\n+	@OPENSSL_LIBS@\n+\n+test_formats_SOURCES = \\\n+	test-formats.c\n','false','false','none'),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','test-formats.c','37','4','50','0','ADD','@@ -0,0 +1,50 @@\n+#include \"common.h\"\n+#include \"formats.h\"\n+\n+#define MAX_LENGTH 5\n+\n+typedef struct {\n+	char const *const description;\n+	char const *const input;\n+	int const result[ MAX_LENGTH ];\n+} format_real_length_test_case;\n+\n+static void test_format_real_length(const format_real_length_test_case *test);\n+\n+format_real_length_test_case const format_real_length_fixtures[] = {\n+	{\n+		.description = \"\",\n+		.input = \"%4%w \",\n+		.result = { 0, 5, 5, -1 },\n+	},\n+};\n+\n+int main(int argc, char **argv)\n+{\n+	int i;\n+\n+	g_test_init(&argc, &argv, NULL);\n+\n+	for (i = 0; i < G_N_ELEMENTS(format_real_length_fixtures); i++) {\n+		char *name = g_strdup_printf(\"/test/format_real_length/%d\", i);\n+		g_test_add_data_func(name, &format_real_length_fixtures[i], (GTestDataFunc)test_format_real_length);\n+		g_free(name);\n+	}\n+\n+	g_test_set_nonfatal_assertions();\n+	return g_test_run();\n+}\n+\n+static void test_format_real_length(const format_real_length_test_case *test)\n+{\n+	int j, len;\n+\n+	g_test_message(\"Testing format %s\", test->input);\n+\n+	for (j = 0; test->result[j] != -1; j++) {\n+		len = format_real_length(test->input, j);\n+		g_assert_cmpint(len, ==, test->result[j]);\n+	}\n+\n+	return;\n+}\n','false','false','none'),('irssi','1.0.5','d6458304d7dba0644fb4b682e09baf0acebdbb97','ailin-nemui','mess with travis','.travis.yml','58','0','16','7','MODIFY','@@ -12,8 +12,13 @@ perl:\n     # - \"5.18-shrplib\"\n     - \"system-perl\"\n env:\n-    - CC=clang\n-    - CC=gcc\n+    - CC=clang UNITTESTS=false\n+    - CC=gcc   UNITTESTS=false\n+    - CC=clang UNITTESTS=true\n+matrix:\n+    exclude:\n+        - env: CC=clang UNITTESTS=true\n+          perl: \"system-perl\"\n \n addons:\n     apt:\n@@ -31,11 +36,12 @@ before_install:\n \n install:\n     - ./configure --with-proxy --with-bot --with-perl=module --prefix=$HOME/irssi-build\n+      $( $UNITTESTS && echo --enable-always-build-tests )\n     - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"\n     - make install\n \n before_script:\n-    - cd\n+    - pushd ~\n     - mkdir irssi-test\n     - echo echo automated irssi launch test > irssi-test/startup;\n       echo ^set settings_autosave off >> irssi-test/startup;\n@@ -47,9 +53,12 @@ before_script:\n     - echo load perl >> irssi-test/startup\n     - echo load proxy >> irssi-test/startup\n     - echo ^quit >> irssi-test/startup\n-    - irssi-build/bin/irssi --home irssi-test\n-    - cat irc.log.*\n-    - cd $TRAVIS_BUILD_DIR\n \n script:\n-    - make check\n+    - irssi-build/bin/irssi --home irssi-test\n+    - popd\n+    - if $UNITTESTS; then make -C tests -sk check; fi\n+\n+after_script:\n+    - cat ~/irc.log.*;\n+      find -name test-suite.log -exec cat {} +\n','false','false','none'),('irssi','1.0.5','eb9e2ed6fdacc3fa262b4907de51dea3f12be5fe','ailin-nemui','update test-irc.c\n\nfix wrong array (missing an s)','test-irc.c','191','5','1','1','MODIFY','@@ -186,7 +186,7 @@ int main(int argc, char **argv)\n \n 	g_test_init(&argc, &argv, NULL);\n \n-	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) {\n+	for (i = 0; i < G_N_ELEMENTS(event_get_params_fixtures); i++) {\n 		char *name = g_strdup_printf(\"/test/event_get_params/%d\", i);\n 		g_test_add_data_func(name, &event_get_params_fixtures[i], (GTestDataFunc)test_event_get_params);\n 		g_free(name);\n','false','false','none'),('irssi','1.0.5','8b34871ea67c420b045ead9e317b67a247c02aae','ailin-nemui','make travis pass despite failures','.travis.yml','60','0','2','0','MODIFY','@@ -19,6 +19,8 @@ matrix:\n     exclude:\n         - env: CC=clang UNITTESTS=true\n           perl: \"system-perl\"\n+    allow_failures:\n+        - env: CC=clang UNITTESTS=true\n \n addons:\n     apt:\n','false','false','none'),('irssi','1.0.5','58557d18c49c11cd4a4de44c5a9e7c00f2d8f880','ailin-nemui','add separator in travis.yml','.travis.yml','60','0','2','2','MODIFY','@@ -62,5 +62,5 @@ script:\n     - if $UNITTESTS; then make -C tests -sk check; fi\n \n after_script:\n-    - cat ~/irc.log.*;\n-      find -name test-suite.log -exec cat {} +\n+    - cat ~/irc.log.*\n+    - find -name test-suite.log -exec cat {} +\n','false','false','none'),('irssi','1.0.5','ef07b3c60c80a828f529a2075246185d7d0b5b25','Joseph Bisch','remove redundant if case','event-get-params.c','57','10','0','2','MODIFY','@@ -74,8 +74,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n 		params = event_get_params(copy, 2, &output0, &output1);\n 	} else if (count % 8 == 6) {\n 		params = event_get_params(copy, 3, &output0, &output1, &output2);\n-	} else if (count % 8 == 7) {\n-		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);\n 	} else {\n 		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);\n 	}\n','false','false','none'),('irssi','1.0.5','15705432e1fb88d9f784cb3fc12c89f8f9164043','Joseph Bisch','remove outdated comment','event-get-params.c','57','10','0','1','MODIFY','@@ -52,7 +52,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n 		return 0;\n 	}\n 	uint8_t count = *data;\n-	/* malloc(size) instead of size+1, because we already used one byte of data */\n 	gchar *copy = g_strndup((const gchar *)data+1, size-1);\n \n 	char *output0;\n','false','false','none'),('irssi','1.0.5','54d453623d879ea83d0818a80bd14151192953ec','ailin-nemui','do not record topic change time when sender is blank','channel-events.c','275','68','7','1','MODIFY','@@ -138,7 +138,13 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,\n 	g_free_not_null(chanrec->topic_by);\n 	chanrec->topic_by = g_strdup(setby);\n \n-	chanrec->topic_time = settime;\n+	if (chanrec->topic_by == NULL) {\n+		/* ensure invariant topic_time > 0 <=> topic_by != NULL.\n+		   this could be triggered by a topic command without sender */\n+		chanrec->topic_time = 0;\n+	} else {\n+		chanrec->topic_time = settime;\n+	}\n \n 	signal_emit(\"channel topic changed\", 1, chanrec);\n }\n','false','false','none'),('irssi','1.0.5','7a83c63701b7395ee6cc606905314318eef77971','ailin-nemui','check if \\\\c is complete in eval','misc.c','781','258','5','2','MODIFY','@@ -703,8 +703,11 @@ int expand_escape(const char **data)\n 		*data += 2;\n 		return strtol(digit, NULL, 16);\n 	case \'c\':\n-                /* control character (\\cA = ^A) */\n-                (*data)++;\n+		/* check for end of string */\n+		if ((*data)[1] == \'\\0\')\n+			return 0;\n+		/* control character (\\cA = ^A) */\n+		(*data)++;\n 		return i_toupper(**data) - 64;\n 	case \'0\': case \'1\': case \'2\': case \'3\':\n 	case \'4\': case \'5\': case \'6\': case \'7\':\n','false','false','none'),('irssi','1.0.5','2361d4b1e5d38701f35146219ceddd318ac4e645','ailin-nemui','rewrite completion code and check for direct match of separator','completion.c','658','185','12','6','MODIFY','@@ -187,12 +187,18 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i\n 			char *old;\n \n 			old = linestart;\n-			linestart = *linestart == \'\\0\' ?\n-				g_strdup(word) :\n-				g_strdup_printf(\"%s%c%s\",\n-						/* do not accidentally duplicate the word separator */\n-						line == wordstart - 1 ? \"\" : linestart,\n-						old_wordstart[-1], word);\n+			/* we want to move word into linestart */\n+			if (*linestart == \'\\0\') {\n+				linestart = g_strdup(word);\n+			} else {\n+				GString *str = g_string_new(linestart);\n+				if (old_wordstart[-1] != str->str[str->len - 1]) {\n+					/* do not accidentally duplicate the word separator */\n+					g_string_append_c(str, old_wordstart[-1]);\n+				}\n+				g_string_append(str, word);\n+				linestart = g_string_free(str, FALSE);\n+			}\n 			g_free(old);\n \n 			g_free(word);\n','false','false','none'),('irssi','1.0.5','cc17837a9b326ec9100a35981348fa0f5d6316fa','ailin-nemui','disable variable arguments code','special-vars.c','541','162','4','0','MODIFY','@@ -384,6 +384,7 @@ char *parse_special(char **cmd, SERVER_REC *server, void *item,\n 	}\n \n 	nest_free = FALSE; nest_value = NULL;\n+#if 0 /* this code is disabled due to security issues until it is fixed */\n 	if (**cmd == \'(\' && (*cmd)[1] != \'\\0\') {\n 		/* subvariable */\n 		int toplevel = nested_orig_cmd == NULL;\n@@ -412,6 +413,9 @@ char *parse_special(char **cmd, SERVER_REC *server, void *item,\n \n                 if (toplevel) nested_orig_cmd = NULL;\n 	}\n+#else\n+	if (nested_orig_cmd) nested_orig_cmd = NULL;\n+#endif\n \n 	if (**cmd != \'{\')\n 		brackets = FALSE;\n','false','false','none'),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','configure.ac','707','4','1','0','MODIFY','@@ -665,6 +665,7 @@ tests/fe-common/Makefile\n tests/fe-common/core/Makefile\n tests/irc/Makefile\n tests/irc/core/Makefile\n+tests/irc/flood/Makefile\n docs/Makefile\n docs/help/Makefile\n docs/help/in/Makefile\n','false','false','none'),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','Makefile.am','3','0','3','1','MODIFY','@@ -1 +1,3 @@\n-SUBDIRS = core\n+SUBDIRS = \\\n+	core \\\n+	flood\n','false','false','none'),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','Makefile.am','25','0','32','0','ADD','@@ -0,0 +1,32 @@\n+include $(top_srcdir)/utils/glib-tap.mk\n+\n+PACKAGE_STRING=irc/flood\n+\n+AM_CPPFLAGS = \\\n+	-I$(top_srcdir)/src \\\n+	-I$(top_srcdir)/src/core \\\n+	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\\n+	$(GLIB_CFLAGS)\n+\n+test_programs = \\\n+	test-796\n+\n+test_796_CPPFLAGS = \\\n+	-I$(top_srcdir)/src/irc/core \\\n+	-I$(top_srcdir)/src/irc/flood \\\n+	$(AM_CPPFLAGS)\n+\n+test_796_DEPENDENCIES = \\\n+	../../../src/core/libcore.a \\\n+	../../../src/lib-config/libirssi_config.a\n+\n+test_796_LDADD = \\\n+	../../../src/irc/flood/libirc_flood.a \\\n+	../../../src/irc/core/libirc_core.a \\\n+	../../../src/core/libcore.a \\\n+	../../../src/lib-config/libirssi_config.a \\\n+	@GLIB_LIBS@ \\\n+	@OPENSSL_LIBS@\n+\n+test_796_SOURCES = \\\n+	test-796.c\n','false','false','none'),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','test-796.c','7','1','29','0','ADD','@@ -0,0 +1,29 @@\n+/*\n+ test-796.c : irssi\n+\n+    Copyright (C) 2017 The Irssi project.\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+*/\n+\n+#include \"common.h\"\n+\n+int main(int argc, char **argv)\n+{\n+	g_test_init(&argc, &argv, NULL);\n+\n+	g_test_set_nonfatal_assertions();\n+	return g_test_run();\n+}\n','false','false','none'),('irssi','1.0.5','c7cd49f8d7e83302c0f21f4449cddac528d28eea','ailin-nemui','first bug case, exposes broken server object in chat-completion','Makefile.am','33','0','8','0','MODIFY','@@ -12,6 +12,7 @@ test_programs = \\\n 	test-796\n \n test_796_CPPFLAGS = \\\n+	-I$(top_srcdir)/src/fe-common/core \\\n 	-I$(top_srcdir)/src/irc/core \\\n 	-I$(top_srcdir)/src/irc/flood \\\n 	$(AM_CPPFLAGS)\n@@ -21,8 +22,15 @@ test_796_DEPENDENCIES = \\\n 	../../../src/lib-config/libirssi_config.a\n \n test_796_LDADD = \\\n+	../../../src/irc/libirc.a \\\n+	../../../src/fe-common/irc/libfe_common_irc.a \\\n+	../../../src/fe-common/irc/dcc/libfe_irc_dcc.a \\\n+	../../../src/fe-common/irc/notifylist/libfe_irc_notifylist.a \\\n+	../../../src/irc/dcc/libirc_dcc.a \\\n+	../../../src/irc/notifylist/libirc_notifylist.a \\\n 	../../../src/irc/flood/libirc_flood.a \\\n 	../../../src/irc/core/libirc_core.a \\\n+	../../../src/fe-common/core/libfe_common_core.a \\\n 	../../../src/core/libcore.a \\\n 	../../../src/lib-config/libirssi_config.a \\\n 	@GLIB_LIBS@ \\\n','true','false','none'),('irssi','1.0.5','c7cd49f8d7e83302c0f21f4449cddac528d28eea','ailin-nemui','first bug case, exposes broken server object in chat-completion','test-796.c','92','8','122','0','MODIFY','@@ -19,11 +19,133 @@\n */\n \n #include \"common.h\"\n+#include \"args.h\"\n+#include \"core.h\"\n+#include \"misc.h\"\n+#include \"servers-setup.h\"\n+\n+#include \"formats.h\"\n+#include \"fe-common-core.h\"\n+\n+#include \"irc.h\"\n+#include \"irc-servers.h\"\n+#include \"irc-channels.h\"\n+\n+/* irc.c */\n+void irc_init(void);\n+void irc_deinit(void) ;\n+\n+/* irc-session.c */\n+void irc_session_init(void);\n+void irc_session_deinit(void);\n+\n+/* fe-common-irc.c */\n+void fe_common_irc_init(void);\n+void fe_common_irc_deinit(void);\n+\n+typedef struct {\n+} ServerDestroyFloodData;\n+\n+#define MODULE_NAME \"tests\"\n+\n+static void cmd_echo(const char *data, void *server, WI_ITEM_REC *item)\n+{\n+	g_test_message(\"echo: [server=%p,item=%p] %s\", server, item, data);\n+}\n+\n+static void sig_public(SERVER_REC *server, const char *msg, const char *nick, const char *address, const char *target)\n+{\n+	signal_emit(\"send command\", 3, \"/eval echo $tag\", server, NULL);\n+}\n+\n+static void print_disconnect(SERVER_REC *server)\n+{\n+	g_test_message(\"server %p was disconnected\", server);\n+}\n+\n+static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const void *data)\n+{\n+	args_execute(0, NULL);\n+	core_init();\n+	irc_init();\n+	fe_common_core_init();\n+	fe_common_irc_init();\n+	signal_emit(\"irssi init finished\", 0);\n+	command_bind(\"echo\", NULL, (SIGNAL_FUNC) cmd_echo);\n+	signal_add(\"message public\", (SIGNAL_FUNC) sig_public);\n+	signal_add_first(\"server disconnected\", (SIGNAL_FUNC) print_disconnect);\n+}\n+\n+static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, const void *data)\n+{\n+	signal_remove(\"server disconnected\", (SIGNAL_FUNC) print_disconnect);\n+	signal_remove(\"message public\", (SIGNAL_FUNC) sig_public);\n+	command_unbind(\"echo\", (SIGNAL_FUNC) cmd_echo);\n+	fe_common_irc_deinit();\n+	fe_common_core_deinit();\n+	irc_deinit();\n+	core_deinit();\n+}\n+\n+static void irc_server_init_bare_minimum(IRC_SERVER_REC *server)\n+{\n+	server->isupport = g_hash_table_new((GHashFunc) g_istr_hash,\n+                                            (GCompareFunc) g_istr_equal);\n+\n+        /* set the standards */\n+        g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\"));\n+        g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\"));\n+}\n+\n+static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const void *data)\n+{\n+	SERVER_REC *server; /* = g_new0(IRC_SERVER_REC, 1); */\n+        CHAT_PROTOCOL_REC *proto;\n+	SERVER_CONNECT_REC *conn;\n+\n+	g_test_bug(\"796\");\n+\n+	proto = chat_protocol_find(\"IRC\");\n+	conn = server_create_conn(proto->id, \"localhost\", 0, \"\", \"\", \"user\");\n+	server = proto->server_init_connect(conn);\n+	server->session_reconnect = TRUE;\n+	server->tag = g_strdup(\"testserver\");\n+\n+	g_test_message(\"created server: %p\", server);\n+\n+	/* we skip some initialisations that would try to send data */\n+	/* irc_servers_deinit(); */\n+	irc_session_deinit();\n+	irc_irc_deinit();\n+\n+	signal_emit(\"server connected\", 1, server);\n+\n+	/* make up for the skipped session init */\n+	irc_server_init_bare_minimum(IRC_SERVER(server));\n+\n+	irc_irc_init();\n+	irc_session_init();\n+	/* irc_servers_init(); */\n+\n+	/* simulate failing irc_server_send_data() */\n+	server->connection_lost = TRUE;\n+\n+	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\");\n+}\n \n int main(int argc, char **argv)\n {\n 	g_test_init(&argc, &argv, NULL);\n+	g_test_bug_base(\"https://github.com/irssi/irssi/issues/\");\n+\n+	g_test_add(\"/test/server_destroy_flood\", ServerDestroyFloodData, NULL,\n+		   server_destroy_flood_set_up, test_server_destroy_flood,\n+		   server_destroy_flood_tear_down);\n \n 	g_test_set_nonfatal_assertions();\n+\n+	core_preinit(*argv);\n+	irssi_gui = IRSSI_GUI_NONE;\n+\n 	return g_test_run();\n }\n','true','false','none'),('irssi','1.0.5','3b7b868bb11faf74c872ecf606c4eef189e31725','ailin-nemui','finish test case','test-796.c','94','8','13','1','MODIFY','@@ -110,6 +110,7 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi\n 	server = proto->server_init_connect(conn);\n 	server->session_reconnect = TRUE;\n 	server->tag = g_strdup(\"testserver\");\n+	server_ref(server);\n \n 	g_test_message(\"created server: %p\", server);\n \n@@ -118,7 +119,8 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi\n 	irc_session_deinit();\n 	irc_irc_deinit();\n \n-	signal_emit(\"server connected\", 1, server);\n+\n+	server_connect_finished(server);\n \n 	/* make up for the skipped session init */\n 	irc_server_init_bare_minimum(IRC_SERVER(server));\n@@ -130,6 +132,16 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi\n 	/* simulate failing irc_server_send_data() */\n 	server->connection_lost = TRUE;\n \n+	/*\n+	chat_completion_deinit();\n+	fe_messages_deinit();\n+	irc_notifylist_deinit();\n+	*/\n+\n+	/* for the purpose of this exercise, we are ignoring the\n+	   errors of g_hash_table_lookup failure */\n+	g_log_set_always_fatal(G_LOG_FATAL_MASK);\n+\n 	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\");\n }\n \n','false','false','none'),('irssi','1.0.5','bffced54981c191f5bac4f9611e4691fe442e58c','ailin-nemui','update test-796.c\n\nodd space','test-796.c','94','8','1','1','MODIFY','@@ -33,7 +33,7 @@\n \n /* irc.c */\n void irc_init(void);\n-void irc_deinit(void) ;\n+void irc_deinit(void);\n \n /* irc-session.c */\n void irc_session_init(void);\n','false','false','none'),('irssi','1.0.5','6b0e14099655bf4d94a19dff252cce89b2858c93','ailin-nemui','show destroyed event','test-796.c','103','9','21','10','MODIFY','@@ -63,6 +63,11 @@ static void print_disconnect(SERVER_REC *server)\n 	g_test_message(\"server %p was disconnected\", server);\n }\n \n+static void print_destroyed(SERVER_REC *server)\n+{\n+	g_test_message(\"server %p was destroyed\", server);\n+}\n+\n static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const void *data)\n {\n 	args_execute(0, NULL);\n@@ -73,12 +78,14 @@ static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const v\n 	signal_emit(\"irssi init finished\", 0);\n 	command_bind(\"echo\", NULL, (SIGNAL_FUNC) cmd_echo);\n 	signal_add(\"message public\", (SIGNAL_FUNC) sig_public);\n+	signal_add(\"server destroyed\", (SIGNAL_FUNC) print_destroyed);\n 	signal_add_first(\"server disconnected\", (SIGNAL_FUNC) print_disconnect);\n }\n \n static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, const void *data)\n {\n 	signal_remove(\"server disconnected\", (SIGNAL_FUNC) print_disconnect);\n+	signal_remove(\"server destroyed\", (SIGNAL_FUNC) print_destroyed);\n 	signal_remove(\"message public\", (SIGNAL_FUNC) sig_public);\n 	command_unbind(\"echo\", (SIGNAL_FUNC) cmd_echo);\n 	fe_common_irc_deinit();\n@@ -90,27 +97,31 @@ static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, cons\n static void irc_server_init_bare_minimum(IRC_SERVER_REC *server)\n {\n 	server->isupport = g_hash_table_new((GHashFunc) g_istr_hash,\n-                                            (GCompareFunc) g_istr_equal);\n+					    (GCompareFunc) g_istr_equal);\n \n-        /* set the standards */\n-        g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\"));\n-        g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\"));\n+	/* set the standards */\n+	g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\"));\n+	g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\"));\n }\n \n static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const void *data)\n {\n 	SERVER_REC *server; /* = g_new0(IRC_SERVER_REC, 1); */\n-        CHAT_PROTOCOL_REC *proto;\n+	CHAT_PROTOCOL_REC *proto;\n 	SERVER_CONNECT_REC *conn;\n+	GLogLevelFlags loglev;\n \n 	g_test_bug(\"796\");\n \n+	/* for the purpose of this exercise, we are ignoring the\n+	   errors of g_hash_table_lookup failure */\n+	loglev = g_log_set_always_fatal(G_LOG_FATAL_MASK);\n+\n 	proto = chat_protocol_find(\"IRC\");\n 	conn = server_create_conn(proto->id, \"localhost\", 0, \"\", \"\", \"user\");\n 	server = proto->server_init_connect(conn);\n 	server->session_reconnect = TRUE;\n 	server->tag = g_strdup(\"testserver\");\n-	server_ref(server);\n \n 	g_test_message(\"created server: %p\", server);\n \n@@ -138,11 +149,11 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi\n 	irc_notifylist_deinit();\n 	*/\n \n-	/* for the purpose of this exercise, we are ignoring the\n-	   errors of g_hash_table_lookup failure */\n-	g_log_set_always_fatal(G_LOG_FATAL_MASK);\n-\n+	server_ref(server);\n 	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\");\n+	server_unref(server);\n+\n+	g_log_set_always_fatal(loglev);\n }\n \n int main(int argc, char **argv)\n','false','false','none'),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','postpone server cleanup until after unref\n\nadd a new signal, server destroyed, that is supposed to run the clean up\ntasks of server disconnected. this is so that some structures will stay\naround longer.','servers.c','544','132','1','0','MODIFY','@@ -524,6 +524,7 @@ int server_unref(SERVER_REC *server)\n 		return TRUE;\n 	}\n \n+	signal_emit(\"server destroyed\", 1, server);\n         MODULE_DATA_DEINIT(server);\n 	server_connect_unref(server->connrec);\n 	if (server->rawlog != NULL) rawlog_destroy(server->rawlog);\n','false','true','none'),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','postpone server cleanup until after unref\n\nadd a new signal, server destroyed, that is supposed to run the clean up\ntasks of server disconnected. this is so that some structures will stay\naround longer.','fe-common-core.c','377','54','3','3','MODIFY','@@ -104,7 +104,7 @@ static void sig_connected(SERVER_REC *server)\n 	MODULE_DATA_SET(server, g_new0(MODULE_SERVER_REC, 1));\n }\n \n-static void sig_disconnected(SERVER_REC *server)\n+static void sig_destroyed(SERVER_REC *server)\n {\n 	void *data = MODULE_DATA(server);\n 	g_free(data);\n@@ -203,7 +203,7 @@ void fe_common_core_init(void)\n 	settings_check();\n \n         signal_add_first(\"server connected\", (SIGNAL_FUNC) sig_connected);\n-        signal_add_last(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected);\n+        signal_add_last(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);\n         signal_add_first(\"channel created\", (SIGNAL_FUNC) sig_channel_created);\n         signal_add_last(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);\n \n@@ -249,7 +249,7 @@ void fe_common_core_deinit(void)\n \n         signal_remove(\"setup changed\", (SIGNAL_FUNC) sig_setup_changed);\n         signal_remove(\"server connected\", (SIGNAL_FUNC) sig_connected);\n-        signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected);\n+        signal_remove(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);\n         signal_remove(\"channel created\", (SIGNAL_FUNC) sig_channel_created);\n         signal_remove(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);\n }\n','false','false','none'),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','postpone server cleanup until after unref\n\nadd a new signal, server destroyed, that is supposed to run the clean up\ntasks of server disconnected. this is so that some structures will stay\naround longer.','irc-servers.c','780','195','3','3','MODIFY','@@ -425,7 +425,7 @@ static void isupport_destroy_hash(void *key, void *value)\n 	g_free(value);\n }\n \n-static void sig_disconnected(IRC_SERVER_REC *server)\n+static void sig_destroyed(IRC_SERVER_REC *server)\n {\n 	GSList *tmp;\n \n@@ -1031,7 +1031,7 @@ void irc_servers_init(void)\n 	cmd_tag = -1;\n \n 	signal_add_first(\"server connected\", (SIGNAL_FUNC) sig_connected);\n-	signal_add_last(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected);\n+	signal_add_last(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);\n 	signal_add_last(\"server quit\", (SIGNAL_FUNC) sig_server_quit);\n 	signal_add(\"event 001\", (SIGNAL_FUNC) event_connected);\n 	signal_add(\"event 004\", (SIGNAL_FUNC) event_server_info);\n@@ -1058,7 +1058,7 @@ void irc_servers_deinit(void)\n 		g_source_remove(cmd_tag);\n \n 	signal_remove(\"server connected\", (SIGNAL_FUNC) sig_connected);\n-	signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected);\n+	signal_remove(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);\n         signal_remove(\"server quit\", (SIGNAL_FUNC) sig_server_quit);\n 	signal_remove(\"event 001\", (SIGNAL_FUNC) event_connected);\n 	signal_remove(\"event 004\", (SIGNAL_FUNC) event_server_info);\n','false','false','none'),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','postpone server cleanup until after unref\n\nadd a new signal, server destroyed, that is supposed to run the clean up\ntasks of server disconnected. this is so that some structures will stay\naround longer.','flood.c','253','52','2','2','MODIFY','@@ -324,7 +324,7 @@ void irc_flood_init(void)\n 	read_settings();\n 	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings);\n 	signal_add_first(\"server connected\", (SIGNAL_FUNC) flood_init_server);\n-	signal_add(\"server disconnected\", (SIGNAL_FUNC) flood_deinit_server);\n+	signal_add(\"server destroyed\", (SIGNAL_FUNC) flood_deinit_server);\n \n 	autoignore_init();\n 	settings_check();\n@@ -344,5 +344,5 @@ void irc_flood_deinit(void)\n \n 	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);\n 	signal_remove(\"server connected\", (SIGNAL_FUNC) flood_init_server);\n-	signal_remove(\"server disconnected\", (SIGNAL_FUNC) flood_deinit_server);\n+	signal_remove(\"server destroyed\", (SIGNAL_FUNC) flood_deinit_server);\n }\n','false','false','none'),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','postpone server cleanup until after unref\n\nadd a new signal, server destroyed, that is supposed to run the clean up\ntasks of server disconnected. this is so that some structures will stay\naround longer.','notifylist.c','258','67','2','2','MODIFY','@@ -331,7 +331,7 @@ void irc_notifylist_init(void)\n 	notifylist_ison_init();\n 	notifylist_whois_init();\n 	signal_add(\"server connected\", (SIGNAL_FUNC) notifylist_init_server);\n-	signal_add(\"server disconnected\", (SIGNAL_FUNC) notifylist_deinit_server);\n+	signal_add(\"server destroyed\", (SIGNAL_FUNC) notifylist_deinit_server);\n 	signal_add(\"event quit\", (SIGNAL_FUNC) event_quit);\n 	signal_add(\"event privmsg\", (SIGNAL_FUNC) event_privmsg);\n 	signal_add(\"event join\", (SIGNAL_FUNC) event_join);\n@@ -349,7 +349,7 @@ void irc_notifylist_deinit(void)\n 	notifylist_whois_deinit();\n \n 	signal_remove(\"server connected\", (SIGNAL_FUNC) notifylist_init_server);\n-	signal_remove(\"server disconnected\", (SIGNAL_FUNC) notifylist_deinit_server);\n+	signal_remove(\"server destroyed\", (SIGNAL_FUNC) notifylist_deinit_server);\n 	signal_remove(\"event quit\", (SIGNAL_FUNC) event_quit);\n 	signal_remove(\"event privmsg\", (SIGNAL_FUNC) event_privmsg);\n 	signal_remove(\"event join\", (SIGNAL_FUNC) event_join);\n','false','false','none'),('irssi','1.0.6','c8012b2e574c6e1e25cf20ed31182323a492a98e','Ailin Nemui','merge tag \'1.0.6\' into integrate/1.0.6','NEWS','2934','0','13','1','MODIFY','@@ -1,4 +1,16 @@\n-v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>\n+v1.1-head 2018-xx-xx  The Irssi team <staff@irssi.org>\n+\n+v1.0.6 2018-01-07 The Irssi team <staff@irssi.org>\n+	- Fix invalid memory access when reading hilight configuration\n+          (#787, #788).\n+	- Fix null pointer dereference when the channel topic is set\n+          without specifying a sender (GL#20, GL!25).\n+	- Fix return of random memory when using incomplete escape\n+          codes (GL#21, GL!26).\n+	- Fix heap buffer overflow when completing certain strings\n+          (GL#19, GL!27).\n+	- Fix return of random memory when using an incomplete\n+          variable argument (GL#18, GL!28).\n \n v1.0.5 2017-10-23  The Irssi team <staff@irssi.org>\n 	- Fix missing -sasl_method \'\' in /NETWORK (#718, #719).\n','false','false','none'),('irssi','1.0.6','3c7185c5ad61de24f9d1bc39240c8145665fba44','ailin-nemui','update irc-nicklist.c\n\nmove altnick check before the nick correction code','irc-nicklist.c','386','92','6','3','MODIFY','@@ -345,6 +345,7 @@ static void event_nick_in_use(IRC_SERVER_REC *server, const char *data)\n {\n 	char *str, *cmd, *params, *nick;\n 	int n;\n+	gboolean try_alternate_nick;\n \n 	g_return_if_fail(data != NULL);\n \n@@ -352,6 +353,10 @@ static void event_nick_in_use(IRC_SERVER_REC *server, const char *data)\n 		/* Already connected, no need to handle this anymore. */\n 		return;\n 	}\n+	\n+	try_alternate_nick = g_ascii_strcasecmp(server->nick, server->connrec->nick) == 0 &&\n+	    server->connrec->alternate_nick != NULL &&\n+	    g_ascii_strcasecmp(server->connrec->alternate_nick, server->nick) != 0;\n \n 	params = event_get_params(data, 2, NULL, &nick);\n 	if (g_ascii_strcasecmp(server->nick, nick) != 0) {\n@@ -362,9 +367,7 @@ static void event_nick_in_use(IRC_SERVER_REC *server, const char *data)\n 	g_free(params);\n \n 	/* nick already in use - need to change it .. */\n-	if (g_ascii_strcasecmp(server->nick, server->connrec->nick) == 0 &&\n-	    server->connrec->alternate_nick != NULL &&\n-	    g_ascii_strcasecmp(server->connrec->alternate_nick, server->nick) != 0) {\n+	if (try_alternate_nick) {\n 		/* first try, so try the alternative nick.. */\n 		g_free(server->nick);\n 		server->nick = g_strdup(server->connrec->alternate_nick);\n','false','false','none'),('irssi','1.0.6','eb18904840cc7d4a6830bf0711f4682af50f1abc','ailin-nemui','fix crash in notifylist','servers.c','545','133','6','1','MODIFY','@@ -524,7 +524,12 @@ int server_unref(SERVER_REC *server)\n 		return TRUE;\n 	}\n \n-	signal_emit(\"server destroyed\", 1, server);\n+	/* since module initialisation uses server connected, only let\n+	   them know that the object got destroyed if the server was\n+	   disconnected */\n+	if (server->disconnected)\n+		signal_emit(\"server destroyed\", 1, server);\n+\n         MODULE_DATA_DEINIT(server);\n 	server_connect_unref(server->connrec);\n 	if (server->rawlog != NULL) rawlog_destroy(server->rawlog);\n','true','true','none'),('irssi','1.0.6','b111f038ddb7b5079f9901dd282fd4733390b1ba','ailin-nemui','fix /exec -o for blank lines\n\nsince it is not allowed to send nothing, instead of spamming the status window\nwith error, send \" \" instead\n\nfixes fs#902','fe-exec.c','498','119','1','1','MODIFY','@@ -613,7 +613,7 @@ static void sig_exec_input(PROCESS_REC *rec, const char *text)\n \n 		str = g_strconcat(rec->target_nick ? \"-nick \" :\n 				  rec->target_channel ? \"-channel \" : \"\",\n-				  rec->target, \" \", text, NULL);\n+				  rec->target, \" \", *text == \'\\0\' ? \" \" : text, NULL);\n 		signal_emit(rec->notice ? \"command notice\" : \"command msg\",\n 			    3, str, server, item);\n                 g_free(str);\n','true','false','none'),('irssi','1.0.6','6e6a96d8c1eb8a51404d34809382e54eea46a9f7','ailin-nemui','fix uaf in signal path','servers.c','546','133','23','18','MODIFY','@@ -460,8 +460,6 @@ static int server_remove_channels(SERVER_REC *server)\n \n void server_disconnect(SERVER_REC *server)\n {\n-	int chans;\n-\n 	g_return_if_fail(IS_SERVER(server));\n \n 	if (server->disconnected)\n@@ -480,21 +478,9 @@ void server_disconnect(SERVER_REC *server)\n 	server->disconnected = TRUE;\n 	signal_emit(\"server disconnected\", 1, server);\n \n-	/* close all channels */\n-	chans = server_remove_channels(server);\n-\n-	if (server->handle != NULL) {\n-		if (!chans || server->connection_lost)\n-			net_sendbuffer_destroy(server->handle, TRUE);\n-		else {\n-			/* we were on some channels, try to let the server\n-			   disconnect so that our quit message is guaranteed\n-			   to get displayed */\n-			net_disconnect_later(net_sendbuffer_handle(server->handle));\n-			net_sendbuffer_destroy(server->handle, FALSE);\n-		}\n-		server->handle = NULL;\n-	}\n+	/* we used to destroy the handle here but it may be still in\n+	   use during signal processing, so destroy it on unref\n+	   instead */\n \n 	if (server->readtag > 0) {\n 		g_source_remove(server->readtag);\n@@ -513,6 +499,8 @@ void server_ref(SERVER_REC *server)\n \n int server_unref(SERVER_REC *server)\n {\n+	int chans;\n+\n 	g_return_val_if_fail(IS_SERVER(server), FALSE);\n \n 	if (--server->refcount > 0)\n@@ -524,11 +512,28 @@ int server_unref(SERVER_REC *server)\n 		return TRUE;\n 	}\n \n+	/* close all channels */\n+	chans = server_remove_channels(server);\n+\n 	/* since module initialisation uses server connected, only let\n 	   them know that the object got destroyed if the server was\n 	   disconnected */\n-	if (server->disconnected)\n+	if (server->disconnected) {\n 		signal_emit(\"server destroyed\", 1, server);\n+	}\n+\n+	if (server->handle != NULL) {\n+		if (!chans || server->connection_lost)\n+			net_sendbuffer_destroy(server->handle, TRUE);\n+		else {\n+			/* we were on some channels, try to let the server\n+			   disconnect so that our quit message is guaranteed\n+			   to get displayed */\n+			net_disconnect_later(net_sendbuffer_handle(server->handle));\n+			net_sendbuffer_destroy(server->handle, FALSE);\n+		}\n+		server->handle = NULL;\n+	}\n \n         MODULE_DATA_DEINIT(server);\n 	server_connect_unref(server->connrec);\n','true','false','none'),('irssi','1.0.6','451019d05dfabbac2463f0d835c5113ac140c5c4','ailin-nemui','make format_real_length left-collecting','formats.c','1131','353','15','12','MODIFY','@@ -480,27 +480,30 @@ int format_real_length(const char *str, int len)\n \n 	start = str;\n 	tmp = g_string_new(NULL);\n-	while (*str != \'\\0\' && len > 0) {\n+	while (*str != \'\\0\') {\n+		oldstr = str;\n 		if (*str == \'%\' && str[1] != \'\\0\') {\n 			str++;\n 			if (*str != \'%\') {\n 			     adv = format_expand_styles(tmp, &str, NULL);\n-			     str += adv;\n-			     if (adv)\n-				continue;\n-			}\n-\n-			/* %% or unknown %code, written as-is */\n-			if (*str != \'%\') {\n-				if (--len == 0)\n-					break;\n+			     if (adv) {\n+				     str += adv;\n+				     continue;\n+			     }\n+			     /* discount for unknown % */\n+			     if (--len < 0) {\n+				     str = oldstr;\n+				     break;\n+			     }\n+			     oldstr = str;\n 			}\n 		}\n \n-		oldstr = str;\n 		len -= string_advance(&str, utf8);\n-		if (len < 0)\n+		if (len < 0) {\n 			str = oldstr;\n+			break;\n+		}\n 	}\n \n 	g_string_free(tmp, TRUE);\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','window.in','71','0','13','2','MODIFY','@@ -35,10 +35,19 @@\n     SHRINK:       %|Decrease the size of the active split window by the specified number of lines.\n     SIZE:         %|Set the current split window size to the specified numer of lines.\n     BALANCE:      %|Balance the heights of all split windows.\n+    RGROW:        %|Increase the width of the active split window by the specified number of columns.\n+    RSHRINK:      %|Decrease the wodth of the active split window by the specified number of columns.\n+    RSIZE:        %|Set the current split window width to the specified numer of columns.\n+    RBALANCE:     %|Balance the widths of all split windows in this line.\n     HIDE:         %|Hides the current split window, or the split window specified by number or item name.\n     SHOW:         %|Show the window specified by number or item name as a new split windows. It is made sticky when autostick_split_windows is turned on.\n-    UP:           %|Set the split window above the current one active. At the top, wraps to the bottom.\n-    DOWN:         %|Set the split window below the current one active. At the bottom, wraps to the top.\n+    RSHOW:        %|Show the window specified by number or item name as a new windows split to the right of the current window. It is made sticky when autostick_split_windows is turned on.\n+    UP:           %|Set the split window left or above the current one active. At the top, wraps to the bottom.\n+    DOWN:         %|Set the split window right or below the current one active. At the bottom, wraps to the top.\n+    DUP:          %|Set the split window above the current one active. At the top, wraps to the bottom.\n+    DDOWN:        %|Set the split window below the current one active. At the bottom, wraps to the top.\n+    DLEFT:        %|Set the split window left to the current one active. At the left, wraps to the right.\n+    DRIGHT:       %|Set the split window right to the current one active. At the right, wraps to the left.\n     LEFT:         %|Go to the previous window numerically that is part of the current sticky group (or not part of any sticky group).\n     RIGHT:        %|Go to the next window numerically that is part of the current sticky group (or not part of any sticky group).\n     STICK:        %|Make the currently active window sticky, or stick the window specified by number to the currently visible split window. Or turn off stickyness of the currently active window or the window specified by number.\n@@ -46,6 +55,8 @@\n     MOVE RIGHT:   %|Move the window to the numerically next location inside the current sticky group.\n     MOVE UP:      %|Move the current window to the sticky group of the split window above. If no sticky group remains, the split window collapses.\n     MOVE DOWN:    %|Move the current window to the sticky group of the split window below. If no sticky group remains, the split window collapses.\n+    MOVE DLEFT:   %|Move the current window to the sticky group of the split window to the left. If no sticky group remains, the split window collapses.\n+    MOVE DRIGHT:  %|Move the current window to the sticky group of the split window to the right. If no sticky group remains, the split window collapses.\n \n    %|Add the required arguments for the given command. Without arguments, the details (size, immortality, levels, server, name and sticky group) of the currently active window are displayed. If used with a number as argument, same as WINDOW REFNUM.\n \n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','fe-windows.h','77','0','8','0','MODIFY','@@ -11,6 +11,14 @@ enum {\n         DATA_LEVEL_HILIGHT\n };\n \n+enum {\n+	MAIN_WINDOW_TYPE_NONE = -1,\n+	MAIN_WINDOW_TYPE_DEFAULT = 0,\n+	MAIN_WINDOW_TYPE_HIDDEN = 1,\n+	MAIN_WINDOW_TYPE_SPLIT = 2,\n+	MAIN_WINDOW_TYPE_RSPLIT = 3\n+};\n+\n typedef struct {\n 	char *servertag;\n         char *name;\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','window-commands.c','712','179','4','3','MODIFY','@@ -169,7 +169,7 @@ static void cmd_window(const char *data, void *server, WI_ITEM_REC *item)\n 		command_runsub(\"window\", data, server, item);\n }\n \n-/* SYNTAX: WINDOW NEW [HIDDEN|SPLIT] */\n+/* SYNTAX: WINDOW NEW [HIDDEN|SPLIT|RSPLIT] */\n static void cmd_window_new(const char *data, void *server, WI_ITEM_REC *item)\n {\n 	WINDOW_REC *window;\n@@ -177,8 +177,9 @@ static void cmd_window_new(const char *data, void *server, WI_ITEM_REC *item)\n \n 	g_return_if_fail(data != NULL);\n \n-	type = (g_ascii_strncasecmp(data, \"hid\", 3) == 0 || g_ascii_strcasecmp(data, \"tab\") == 0) ? 1 :\n-		(g_ascii_strcasecmp(data, \"split\") == 0 ? 2 : 0);\n+	type = (g_ascii_strncasecmp(data, \"hid\", 3) == 0 || g_ascii_strcasecmp(data, \"tab\") == 0) ? MAIN_WINDOW_TYPE_HIDDEN :\n+		g_ascii_strcasecmp(data, \"split\") == 0 ? MAIN_WINDOW_TYPE_SPLIT :\n+		g_ascii_strncasecmp(data, \"rs\", 2) == 0 ? MAIN_WINDOW_TYPE_RSPLIT : MAIN_WINDOW_TYPE_DEFAULT;\n 	signal_emit(\"gui window create override\", 1, GINT_TO_POINTER(type));\n \n 	window = window_create(NULL, FALSE);\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','window-items.c','244','73','1','1','MODIFY','@@ -314,7 +314,7 @@ void window_item_create(WI_ITEM_REC *item, int automatic)\n 		/* create new window to use */\n 		if (settings_get_bool(\"autocreate_split_windows\")) {\n 			signal_emit(\"gui window create override\", 1,\n-				    GINT_TO_POINTER(0));\n+				    GINT_TO_POINTER(MAIN_WINDOW_TYPE_SPLIT));\n 		}\n 		window = window_create(item, automatic);\n 	} else {\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','gui-printtext.c','267','57','41','2','MODIFY','@@ -24,6 +24,7 @@\n \n #include \"formats.h\"\n #include \"printtext.h\"\n+#include \"themes.h\"\n \n #include \"term.h\"\n #include \"gui-printtext.h\"\n@@ -138,6 +139,39 @@ void gui_printtext_after(TEXT_DEST_REC *dest, LINE_REC *prev, const char *str)\n 	gui_printtext_after_time(dest, prev, str, 0);\n }\n \n+void gui_printtext_window_border(int x, int y)\n+{\n+	char *v0, *v1;\n+	int len;\n+	if (current_theme != NULL) {\n+		v1 = theme_format_expand(current_theme, \"{window_border} \");\n+		len = format_real_length(v1, 1);\n+		v1[len] = \'\\0\';\n+	}\n+	else {\n+		v1 = g_strdup(\" \");\n+	}\n+\n+	if (*v1 == \'\\0\') {\n+		g_free(v1);\n+		v1 = g_strdup(\" \");\n+	}\n+\n+	if (clrtoeol_info->color != NULL) {\n+		char *color = g_strdup(clrtoeol_info->color);\n+		len = format_real_length(color, 0);\n+		color[len] = \'\\0\';\n+		v0 = g_strconcat(color, v1, NULL);\n+		g_free(color);\n+		g_free(v1);\n+	} else {\n+		v0 = v1;\n+	}\n+\n+	gui_printtext(x, y, v0);\n+	g_free(v0);\n+}\n+\n static void remove_old_lines(TEXT_BUFFER_VIEW_REC *view)\n {\n 	LINE_REC *line;\n@@ -236,8 +270,13 @@ static void sig_gui_print_text(WINDOW_REC *window, void *fgcolor,\n 		term_set_color2(root_window, attr, fg, bg);\n \n 		term_move(root_window, next_xpos, next_ypos);\n-		if (flags & GUI_PRINT_FLAG_CLRTOEOL)\n-			term_clrtoeol(root_window);\n+		if (flags & GUI_PRINT_FLAG_CLRTOEOL) {\n+			if (clrtoeol_info->window != NULL) {\n+				term_window_clrtoeol_abs(clrtoeol_info->window, next_ypos);\n+			} else {\n+				term_clrtoeol(root_window);\n+			}\n+		}\n 		next_xpos += term_addstr(root_window, str);\n 		return;\n 	}\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','gui-printtext.h','15','0','1','0','MODIFY','@@ -20,5 +20,6 @@ void gui_printtext(int xpos, int ypos, const char *str);\n void gui_printtext_internal(int xpos, int ypos, const char *str);\n void gui_printtext_after(TEXT_DEST_REC *dest, LINE_REC *prev, const char *str);\n void gui_printtext_after_time(TEXT_DEST_REC *dest, LINE_REC *prev, const char *str, time_t time);\n+void gui_printtext_window_border(int xpos, int ypos);\n \n #endif\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','gui-windows.c','220','52','8','6','MODIFY','@@ -73,17 +73,18 @@ static void gui_window_created(WINDOW_REC *window, void *automatic)\n \n 	g_return_if_fail(window != NULL);\n \n-	new_parent = window_create_override == 0 ||\n-		window_create_override == 2 ||\n+	new_parent = window_create_override == MAIN_WINDOW_TYPE_DEFAULT ||\n+		window_create_override == MAIN_WINDOW_TYPE_SPLIT ||\n+		window_create_override == MAIN_WINDOW_TYPE_RSPLIT ||\n 		active_win == NULL || WINDOW_GUI(active_win) == NULL;\n-	parent = !new_parent ? WINDOW_MAIN(active_win) : mainwindow_create();\n+	parent = !new_parent ? WINDOW_MAIN(active_win) : mainwindow_create(window_create_override == MAIN_WINDOW_TYPE_RSPLIT);\n 	if (parent == NULL) {\n 		/* not enough space for new window, but we really can\'t\n 		   abort creation of the window anymore, so create hidden\n 		   window instead. */\n 		parent = WINDOW_MAIN(active_win);\n 	}\n-	window_create_override = -1;\n+	window_create_override = MAIN_WINDOW_TYPE_NONE;\n \n 	if (parent->active == NULL) parent->active = window;\n 	window->gui_data = gui_window_init(window, parent);\n@@ -281,13 +282,14 @@ static void read_settings(void)\n \n void gui_windows_init(void)\n {\n-        settings_add_bool(\"lookandfeel\", \"autostick_split_windows\", TRUE);\n+	settings_add_bool(\"lookandfeel\", \"autostick_split_windows\", FALSE);\n+	settings_add_bool(\"lookandfeel\", \"autounstick_windows\", TRUE);\n 	settings_add_int(\"lookandfeel\", \"indent\", 10);\n 	settings_add_bool(\"lookandfeel\", \"indent_always\", FALSE);\n 	settings_add_bool(\"lookandfeel\", \"break_wide\", FALSE);\n 	settings_add_bool(\"lookandfeel\", \"scroll\", TRUE);\n \n-	window_create_override = -1;\n+	window_create_override = MAIN_WINDOW_TYPE_NONE;\n \n 	read_settings();\n 	signal_add(\"gui window create override\", (SIGNAL_FUNC) sig_window_create_override);\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','mainwindows-layout.c','233','57','122','37','MODIFY','@@ -48,9 +48,9 @@ static void sig_layout_window_save(WINDOW_REC *window, CONFIG_NODE *node)\n static void sig_layout_window_restore(WINDOW_REC *window, CONFIG_NODE *node)\n {\n 	WINDOW_REC *parent;\n-        GUI_WINDOW_REC *gui;\n+	GUI_WINDOW_REC *gui;\n \n-        gui = WINDOW_GUI(window);\n+	gui = WINDOW_GUI(window);\n \n 	parent = window_find_refnum(config_node_get_int(node, \"parent\", -1));\n 	if (parent != NULL)\n@@ -61,7 +61,7 @@ static void sig_layout_window_restore(WINDOW_REC *window, CONFIG_NODE *node)\n 	if (config_node_get_str(node, \"scroll\", NULL) != NULL) {\n 		gui->use_scroll = TRUE;\n 		gui->scroll = config_node_get_bool(node, \"scroll\", TRUE);\n-                textbuffer_view_set_scroll(gui->view, gui->scroll);\n+		textbuffer_view_set_scroll(gui->view, gui->scroll);\n 	}\n }\n \n@@ -74,6 +74,8 @@ static void main_window_save(MAIN_WINDOW_REC *window, CONFIG_NODE *node)\n \n 	iconfig_node_set_int(node, \"first_line\", window->first_line);\n 	iconfig_node_set_int(node, \"lines\", window->height);\n+	iconfig_node_set_int(node, \"first_column\", window->first_column);\n+	iconfig_node_set_int(node, \"columns\", window->width);\n }\n \n static void sig_layout_save(void)\n@@ -88,8 +90,16 @@ static void sig_layout_save(void)\n \n static int window_node_cmp(CONFIG_NODE *n1, CONFIG_NODE *n2)\n {\n-	return config_node_get_int(n1, \"first_line\", 0) >\n-		config_node_get_int(n2, \"first_line\", 0) ? -1 : 1;\n+	return (config_node_get_int(n1, \"first_line\", 0) ==\n+		config_node_get_int(n2, \"first_line\", 0)\n+		&&\n+		config_node_get_int(n1, \"first_column\", 0) >\n+		config_node_get_int(n2, \"first_column\", 0)\n+	       ) ||\n+		config_node_get_int(n1, \"first_line\", 0) >\n+		config_node_get_int(n2, \"first_line\", 0)\n+		? -1\n+		: 1;\n }\n \n /* Returns list of mainwindow nodes sorted by first_line\n@@ -108,14 +118,45 @@ static GSList *get_sorted_windows_config(CONFIG_NODE *node)\n         return output;\n }\n \n+static GSList *get_windows_config_filter_line(GSList *in)\n+{\n+	GSList *tmp, *output;\n+\n+	output = NULL;\n+	for (tmp = in; tmp != NULL; tmp = tmp->next) {\n+		CONFIG_NODE *node = tmp->data;\n+		if (config_node_get_int(node, \"first_column\", 0) == 0)\n+			output = g_slist_append(output, node);\n+	}\n+\n+	return output;\n+}\n+\n+static GSList *get_windows_config_filter_column(GSList *in, int first_line, int last_line)\n+{\n+	GSList *tmp, *output;\n+\n+	output = NULL;\n+	for (tmp = in; tmp != NULL; tmp = tmp->next) {\n+		int l1, l2;\n+		CONFIG_NODE *node = tmp->data;\n+		l1 = config_node_get_int(node, \"first_line\", -1);\n+		l2 = l1 + config_node_get_int(node, \"lines\", 0) - 1;\n+		if (l1 >= first_line && l2 <= last_line)\n+			output = g_slist_prepend(output, node);\n+	}\n+\n+	return output;\n+}\n+\n static void sig_layout_restore(void)\n {\n-        MAIN_WINDOW_REC *lower_window;\n-        WINDOW_REC *window;\n+	MAIN_WINDOW_REC *lower_window;\n+	WINDOW_REC *window, *first;\n 	CONFIG_NODE *node;\n-	GSList *tmp, *sorted_config;\n-        int avail_height, height, *heights;\n-	int i, lower_size, windows_count, diff;\n+	GSList *tmp, *sorted_config, *lines_config;\n+	int avail_height, height, *heights, *widths, max_wins_line;\n+	int i, lower_size, lines_count, columns_count, diff;\n \n 	node = iconfig_node_traverse(\"mainwindows\", FALSE);\n 	if (node == NULL) return;\n@@ -123,51 +164,56 @@ static void sig_layout_restore(void)\n 	sorted_config = get_sorted_windows_config(node);\n 	if (sorted_config == NULL) return;\n \n-        windows_count = g_slist_length(sorted_config);\n+	lines_config = get_windows_config_filter_line(sorted_config);\n+	lines_count = g_slist_length(lines_config);\n \n-        /* calculate the saved terminal height */\n+	/* calculate the saved terminal height */\n 	avail_height = term_height -\n 		screen_reserved_top - screen_reserved_bottom;\n 	height = 0;\n-        heights = g_new0(int, windows_count);\n-	for (i = 0, tmp = sorted_config; tmp != NULL; tmp = tmp->next, i++) {\n+	heights = g_new0(int, lines_count);\n+	for (i = 0, tmp = lines_config; tmp != NULL; tmp = tmp->next, i++) {\n 		CONFIG_NODE *node = tmp->data;\n \n-                heights[i] = config_node_get_int(node, \"lines\", 0);\n+		heights[i] = config_node_get_int(node, \"lines\", 0);\n 		height += heights[i];\n 	}\n \n+	max_wins_line = (term_width + 1) / (NEW_WINDOW_WIDTH + 1);\n+	if (max_wins_line < 1)\n+		max_wins_line = 1;\n+\n 	if (avail_height <= (WINDOW_MIN_SIZE*2)+1) {\n 		/* we can fit only one window to screen -\n 		   give it all the height we can */\n-		windows_count = 1;\n-                heights[0] = avail_height;\n+		lines_count = 1;\n+		heights[0] = avail_height;\n 	} else if (height != avail_height) {\n 		/* Terminal\'s height is different from the saved one.\n 		   Resize the windows so they fit to screen. */\n 		while (height > avail_height &&\n-		       windows_count*(WINDOW_MIN_SIZE+1) > avail_height) {\n+		       lines_count*(WINDOW_MIN_SIZE+1) > avail_height) {\n 			/* all windows can\'t fit into screen,\n 			   remove the lowest ones */\n-                        windows_count--;\n+			lines_count--;\n 		}\n \n-                /* try to keep the windows\' size about the same in percents */\n-		for (i = 0; i < windows_count; i++) {\n+		/* try to keep the windows\' size about the same in percents */\n+		for (i = 0; i < lines_count; i++) {\n 			int size = avail_height*heights[i]/height;\n 			if (size < WINDOW_MIN_SIZE+1)\n-                                size = WINDOW_MIN_SIZE+1;\n+				size = WINDOW_MIN_SIZE+1;\n 			heights[i] = size;\n 		}\n \n 		/* give/remove the last bits */\n-                height = 0;\n-		for (i = 0; i < windows_count; i++)\n-                        height += heights[i];\n+		height = 0;\n+		for (i = 0; i < lines_count; i++)\n+			height += heights[i];\n \n 		diff = height < avail_height ? 1 : -1;\n 		for (i = 0; height != avail_height; i++) {\n-			if (i == windows_count)\n+			if (i == lines_count)\n 				i = 0;\n \n 			if (heights[i] > WINDOW_MIN_SIZE+1) {\n@@ -178,25 +224,59 @@ static void sig_layout_restore(void)\n 	}\n \n 	/* create all the visible windows with correct size */\n-	lower_window = NULL; lower_size = 0;\n-	for (i = 0, tmp = sorted_config; i < windows_count; tmp = tmp->next, i++) {\n+	lower_window = NULL; lower_size = 0; first = NULL;\n+	for (i = 0, tmp = lines_config; i < lines_count; tmp = tmp->next, i++) {\n+		GSList *tmp2, *columns_config, *line;\n+		int j, l1, l2;\n 		CONFIG_NODE *node = tmp->data;\n 		if (node->key == NULL) continue;\n \n-		/* create a new window + mainwindow */\n-		signal_emit(\"gui window create override\", 1,\n-			    GINT_TO_POINTER(0));\n+		l1 = config_node_get_int(node, \"first_line\", -1);\n+		l2 = l1 + config_node_get_int(node, \"lines\", 0) - 1;\n+		columns_config = get_windows_config_filter_column(sorted_config, l1, l2);\n+\n+		window = NULL; columns_count = 0;\n+		widths = g_new0(int, max_wins_line);\n+		for (j = 0, tmp2 = columns_config; j < max_wins_line && tmp2 != NULL; tmp2 = tmp2->next, j++) {\n+			int width;\n+			WINDOW_REC *new_win;\n+			CONFIG_NODE *node2 = tmp2->data;\n+			if (node2->key == NULL) continue;\n+\n+			/* create a new window + mainwindow */\n+			signal_emit(\"gui window create override\", 1,\n+				    GINT_TO_POINTER(window == NULL ? MAIN_WINDOW_TYPE_SPLIT : MAIN_WINDOW_TYPE_RSPLIT));\n+\n+			new_win = window_create(NULL, TRUE);\n \n-		window = window_create(NULL, TRUE);\n-                window_set_refnum(window, atoi(node->key));\n+			window_set_refnum(new_win, atoi(node2->key));\n+			width = config_node_get_int(node2, \"columns\", NEW_WINDOW_WIDTH);\n+			widths[j] = width;\n+			columns_count += width + (window == NULL ? 0 : 1);\n+\n+			if (window == NULL)\n+				window = new_win;\n+			if (first == NULL)\n+				first = new_win;\n+\n+			window_set_active(new_win);\n+			active_mainwin = WINDOW_MAIN(new_win);\n+		}\n+		if (window == NULL)\n+			continue;\n+		line = g_slist_reverse(mainwindows_get_line(WINDOW_MAIN(window)));\n+		for (j = g_slist_length(line), tmp2 = line; tmp2 != NULL; tmp2 = tmp2->next, j--) {\n+			int width = MAX(NEW_WINDOW_WIDTH, widths[j-1] * term_width / columns_count);\n+			MAIN_WINDOW_REC *rec = tmp2->data;\n+			mainwindow_set_rsize(rec, width);\n+		}\n+		g_slist_free(line);\n+		g_free(widths);\n \n 		if (lower_size > 0)\n 			mainwindow_set_size(lower_window, lower_size, FALSE);\n \n-		window_set_active(window);\n-                active_mainwin = WINDOW_MAIN(window);\n-\n-                lower_window = WINDOW_MAIN(window);\n+		lower_window = WINDOW_MAIN(window);\n 		lower_size = heights[i];\n 		if (lower_size < WINDOW_MIN_SIZE+1)\n 			lower_size = WINDOW_MIN_SIZE+1;\n@@ -206,6 +286,11 @@ static void sig_layout_restore(void)\n \n 	if (lower_size > 0)\n 		mainwindow_set_size(lower_window, lower_size, FALSE);\n+\n+	if (first != NULL) {\n+		window_set_active(first);\n+		active_mainwin = WINDOW_MAIN(first);\n+	}\n }\n \n static void sig_layout_reset(void)\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','mainwindows.c','1461','353','959','187','MODIFY','@@ -34,24 +34,27 @@\n \n GSList *mainwindows;\n MAIN_WINDOW_REC *active_mainwin;\n+MAIN_WINDOW_BORDER_REC *clrtoeol_info;\n \n int screen_reserved_top, screen_reserved_bottom;\n-static int old_screen_width, old_screen_height;\n+int screen_reserved_left, screen_reserved_right;\n+static int screen_width, screen_height;\n \n #define mainwindow_create_screen(window) \\\n-	term_window_create(0, \\\n+	term_window_create((window)->first_column + (window)->statusbar_columns_left, \\\n 			   (window)->first_line + (window)->statusbar_lines_top, \\\n-			   (window)->width, \\\n+			   (window)->width - (window)->statusbar_columns, \\\n 			   (window)->height - (window)->statusbar_lines)\n \n #define mainwindow_set_screen_size(window) \\\n-	term_window_move((window)->screen_win, 0, \\\n+	term_window_move((window)->screen_win, \\\n+			 (window)->first_column + (window)->statusbar_columns_left, \\\n 			 (window)->first_line + (window)->statusbar_lines_top, \\\n-			 (window)->width, \\\n+			 (window)->width - (window)->statusbar_columns, \\\n 			 (window)->height - (window)->statusbar_lines);\n \n \n-static MAIN_WINDOW_REC *find_window_with_room(void)\n+static MAIN_WINDOW_REC *find_window_with_room()\n {\n 	MAIN_WINDOW_REC *biggest_rec;\n 	GSList *tmp;\n@@ -71,14 +74,34 @@ static MAIN_WINDOW_REC *find_window_with_room(void)\n 	return biggest_rec;\n }\n \n+static MAIN_WINDOW_REC *find_window_with_room_right(void)\n+{\n+	MAIN_WINDOW_REC *biggest_rec;\n+	GSList *tmp;\n+	int space, biggest;\n+\n+	biggest = 0; biggest_rec = NULL;\n+	for (tmp = mainwindows; tmp != NULL; tmp = tmp->next) {\n+		MAIN_WINDOW_REC *rec = tmp->data;\n+\n+		space = MAIN_WINDOW_TEXT_WIDTH(rec);\n+		if (space >= 2 * NEW_WINDOW_WIDTH && space > biggest) {\n+			biggest = space;\n+			biggest_rec = rec;\n+		}\n+	}\n+\n+	return biggest_rec;\n+}\n+\n #define window_size_equals(window, mainwin) \\\n-	((window)->width == (mainwin)->width && \\\n+	((window)->width == MAIN_WINDOW_TEXT_WIDTH(mainwin) && \\\n 	 (window)->height == MAIN_WINDOW_TEXT_HEIGHT(mainwin))\n \n static void mainwindow_resize_windows(MAIN_WINDOW_REC *window)\n {\n 	GSList *tmp;\n-        int resized;\n+	int resized;\n \n 	mainwindow_set_screen_size(window);\n \n@@ -89,24 +112,31 @@ static void mainwindow_resize_windows(MAIN_WINDOW_REC *window)\n 		if (rec->gui_data != NULL &&\n 		    WINDOW_GUI(rec)->parent == window &&\n 		    !window_size_equals(rec, window)) {\n-                        resized = TRUE;\n-			gui_window_resize(rec, window->width,\n+			resized = TRUE;\n+			gui_window_resize(rec, MAIN_WINDOW_TEXT_WIDTH(window),\n 					  MAIN_WINDOW_TEXT_HEIGHT(window));\n 		}\n 	}\n \n-        if (resized)\n+	if (resized)\n 		signal_emit(\"mainwindow resized\", 1, window);\n }\n \n static void mainwindow_resize(MAIN_WINDOW_REC *window, int xdiff, int ydiff)\n {\n+	int height, width;\n 	if (quitting || (xdiff == 0 && ydiff == 0))\n-                return;\n+		return;\n \n-        window->width += xdiff;\n+	height = window->height + ydiff;\n+	width = window->width + xdiff;\n+	window->width = window->last_column-window->first_column+1;\n 	window->height = window->last_line-window->first_line+1;\n-        window->size_dirty = TRUE;\n+	if (height != window->height || width != window->width) {\n+		g_warning(\"Resizing window %p W:%d expected:%d H:%d expected:%d\",\n+			  window, window->width, width, window->height, height);\n+	}\n+	window->size_dirty = TRUE;\n }\n \n static GSList *get_sticky_windows_sorted(MAIN_WINDOW_REC *mainwin)\n@@ -178,14 +208,13 @@ void mainwindows_recreate(void)\n 	}\n }\n \n-MAIN_WINDOW_REC *mainwindow_create(void)\n+MAIN_WINDOW_REC *mainwindow_create(int right)\n {\n 	MAIN_WINDOW_REC *rec, *parent;\n 	int space;\n \n 	rec = g_new0(MAIN_WINDOW_REC, 1);\n 	rec->dirty = TRUE;\n-	rec->width = term_width;\n \n 	if (mainwindows == NULL) {\n 		active_mainwin = rec;\n@@ -193,21 +222,53 @@ MAIN_WINDOW_REC *mainwindow_create(void)\n 		rec->first_line = screen_reserved_top;\n 		rec->last_line = term_height-1 - screen_reserved_bottom;\n 		rec->height = rec->last_line-rec->first_line+1;\n+		rec->first_column = screen_reserved_left;\n+		rec->last_column = screen_width-1 - screen_reserved_right;\n+		rec->width = rec->last_column-rec->first_column+1;\n 	} else {\n 		parent = WINDOW_MAIN(active_win);\n-		if (MAIN_WINDOW_TEXT_HEIGHT(parent) <\n-		    WINDOW_MIN_SIZE+NEW_WINDOW_SIZE)\n-			parent = find_window_with_room();\n-		if (parent == NULL)\n-			return NULL; /* not enough space */\n-\n-		space = parent->height / 2;\n-		rec->first_line = parent->first_line;\n-		rec->last_line = rec->first_line + space;\n-		rec->height = rec->last_line-rec->first_line+1;\n \n-		parent->first_line += space+1;\n-		mainwindow_resize(parent, 0, -space-1);\n+		if (!right) {\n+			GSList *tmp, *line;\n+			if (MAIN_WINDOW_TEXT_HEIGHT(parent) <\n+			    WINDOW_MIN_SIZE+NEW_WINDOW_SIZE)\n+				parent = find_window_with_room();\n+			if (parent == NULL)\n+				return NULL; /* not enough space */\n+\n+			space = parent->height / 2;\n+			rec->first_line = parent->first_line;\n+			rec->last_line = rec->first_line + space;\n+			rec->height = rec->last_line-rec->first_line+1;\n+			rec->first_column = screen_reserved_left;\n+			rec->last_column = screen_width-1 - screen_reserved_right;\n+			rec->width = rec->last_column-rec->first_column+1;\n+\n+			line = mainwindows_get_line(parent);\n+			for (tmp = line; tmp != NULL; tmp = tmp->next) {\n+				MAIN_WINDOW_REC *rec = tmp->data;\n+				rec->first_line += space+1;\n+				mainwindow_resize(rec, 0, -space-1);\n+			}\n+			g_slist_free(line);\n+		} else {\n+			if (MAIN_WINDOW_TEXT_WIDTH(parent) <\n+			    2* NEW_WINDOW_WIDTH)\n+				parent = find_window_with_room_right();\n+			if (parent == NULL)\n+				return NULL; /* not enough space */\n+\n+			space = parent->width / 2;\n+			rec->first_line = parent->first_line;\n+			rec->last_line = parent->last_line;\n+			rec->height = parent->height;\n+			rec->first_column = parent->last_column - space + 1;\n+			rec->last_column = parent->last_column;\n+			rec->width = rec->last_column-rec->first_column+1;\n+\n+			parent->last_column -= space+1;\n+			mainwindow_resize(parent, -space-1, 0);\n+		}\n 	}\n \n 	rec->screen_win = mainwindow_create_screen(rec);\n@@ -218,16 +279,22 @@ MAIN_WINDOW_REC *mainwindow_create(void)\n 	return rec;\n }\n \n-static MAIN_WINDOW_REC *mainwindows_find_lower(int line)\n+static MAIN_WINDOW_REC *mainwindows_find_lower(MAIN_WINDOW_REC *window)\n {\n+	int last_line;\n 	MAIN_WINDOW_REC *best;\n 	GSList *tmp;\n \n+	if (window != NULL)\n+		last_line = window->last_line;\n+	else\n+		last_line = -1;\n+\n 	best = NULL;\n 	for (tmp = mainwindows; tmp != NULL; tmp = tmp->next) {\n 		MAIN_WINDOW_REC *rec = tmp->data;\n \n-		if (rec->first_line > line &&\n+		if (rec->first_line > last_line &&\n 		    (best == NULL || rec->first_line < best->first_line))\n 			best = rec;\n 	}\n@@ -235,16 +302,64 @@ static MAIN_WINDOW_REC *mainwindows_find_lower(int line)\n 	return best;\n }\n \n-static MAIN_WINDOW_REC *mainwindows_find_upper(int line)\n+static MAIN_WINDOW_REC *mainwindows_find_right(MAIN_WINDOW_REC *window, int find_first)\n+{\n+	int first_line, last_line, last_column;\n+	MAIN_WINDOW_REC *best;\n+	GSList *tmp;\n+\n+	if (window != NULL) {\n+		first_line = window->first_line;\n+		last_line = window->last_line;\n+		last_column = window->last_column;\n+	} else {\n+		first_line = last_line = last_column = -1;\n+	}\n+\n+	if (find_first)\n+		last_column = -1;\n+\n+	best = NULL;\n+	for (tmp = mainwindows; tmp != NULL; tmp = tmp->next) {\n+		MAIN_WINDOW_REC *rec = tmp->data;\n+\n+		if (rec->first_line >= first_line &&\n+		    rec->last_line <= last_line &&\n+		    rec->first_column > last_column &&\n+		    (best == NULL || rec->first_column < best->first_column))\n+			best = rec;\n+	}\n+\n+	return best;\n+}\n+\n+static MAIN_WINDOW_REC *mainwindows_find_lower_right(MAIN_WINDOW_REC *window)\n+{\n+	MAIN_WINDOW_REC *best;\n+\n+	best = mainwindows_find_right(window, FALSE);\n+	if (best == NULL)\n+		best = mainwindows_find_lower(window);\n+\n+	return best;\n+}\n+\n+static MAIN_WINDOW_REC *mainwindows_find_upper(MAIN_WINDOW_REC *window)\n {\n+	int first_line;\n 	MAIN_WINDOW_REC *best;\n 	GSList *tmp;\n \n+	if (window != NULL)\n+		first_line = window->first_line;\n+	else\n+		first_line = screen_height;\n+\n 	best = NULL;\n 	for (tmp = mainwindows; tmp != NULL; tmp = tmp->next) {\n 		MAIN_WINDOW_REC *rec = tmp->data;\n \n-		if (rec->last_line < line &&\n+		if (rec->last_line < first_line &&\n 		    (best == NULL || rec->last_line > best->last_line))\n 			best = rec;\n 	}\n@@ -252,27 +367,142 @@ static MAIN_WINDOW_REC *mainwindows_find_upper(int line)\n 	return best;\n }\n \n-static void mainwindows_add_space(int first_line, int last_line)\n+static MAIN_WINDOW_REC *mainwindows_find_left(MAIN_WINDOW_REC *window, int find_last)\n+{\n+	int first_line, last_line, first_column;\n+	MAIN_WINDOW_REC *best;\n+	GSList *tmp;\n+\n+	if (window != NULL) {\n+		first_line = window->first_line;\n+		last_line = window->last_line;\n+		first_column = window->first_column;\n+	} else {\n+		first_line = last_line = screen_height;\n+		first_column = screen_width;\n+	}\n+\n+	if (find_last)\n+		first_column = screen_width;\n+\n+	best = NULL;\n+	for (tmp = mainwindows; tmp != NULL; tmp = tmp->next) {\n+		MAIN_WINDOW_REC *rec = tmp->data;\n+\n+		if (rec->first_line >= first_line &&\n+		    rec->last_line <= last_line &&\n+		    rec->last_column < first_column &&\n+		    (best == NULL || rec->last_column > best->last_column))\n+			best = rec;\n+	}\n+\n+	return best;\n+}\n+\n+static MAIN_WINDOW_REC *mainwindows_find_upper_left(MAIN_WINDOW_REC *window)\n+{\n+	MAIN_WINDOW_REC *best;\n+\n+	best = mainwindows_find_left(window, FALSE);\n+	if (best == NULL)\n+		best = mainwindows_find_upper(window);\n+\n+	return best;\n+}\n+\n+static MAIN_WINDOW_REC *mainwindows_find_left_upper(MAIN_WINDOW_REC *window)\n+{\n+	MAIN_WINDOW_REC *best;\n+\n+	best = mainwindows_find_left(window, FALSE);\n+	if (best == NULL)\n+		best = mainwindows_find_left(mainwindows_find_upper(window), TRUE);\n+\n+	return best;\n+}\n+\n+GSList *mainwindows_get_line(MAIN_WINDOW_REC *rec)\n+{\n+	MAIN_WINDOW_REC *win;\n+	GSList *list;\n+\n+	list = NULL;\n+\n+	for (win = mainwindows_find_left(rec, FALSE);\n+	     win != NULL;\n+	     win = mainwindows_find_left(win, FALSE)) {\n+		list = g_slist_append(list, win);\n+	}\n+\n+	if (rec != NULL)\n+		list = g_slist_append(list, rec);\n+\n+	for (win = mainwindows_find_right(rec, FALSE);\n+	     win != NULL;\n+	     win = mainwindows_find_right(win, FALSE)) {\n+		list = g_slist_append(list, win);\n+	}\n+\n+	return list;\n+}\n+\n+/* add back the space which was occupied by destroyed mainwindow first_line .. last_line */\n+static void mainwindows_add_space(MAIN_WINDOW_REC *destroy_win)\n {\n 	MAIN_WINDOW_REC *rec;\n-	int size;\n+	int size, rsize;\n \n-	if (last_line < first_line)\n+	if (destroy_win->last_line < destroy_win->first_line)\n 		return;\n \n-	size = last_line-first_line+1;\n+	if (destroy_win->last_column < destroy_win->first_column)\n+		return;\n+\n+	rsize = destroy_win->last_column-destroy_win->first_column+1;\n+	rec = mainwindows_find_left(destroy_win, FALSE);\n+	if (rec != NULL) {\n+		rec->last_column = destroy_win->last_column;\n+		mainwindow_resize(rec, rsize+1, 0);\n+		return;\n+	}\n \n-	rec = mainwindows_find_lower(last_line);\n+	rec = mainwindows_find_right(destroy_win, FALSE);\n 	if (rec != NULL) {\n-		rec->first_line = first_line;\n-		mainwindow_resize(rec, 0, size);\n+		rec->first_column = destroy_win->first_column;\n+		mainwindow_resize(rec, rsize+1, 0);\n 		return;\n 	}\n \n-	rec = mainwindows_find_upper(first_line);\n+	size = destroy_win->last_line-destroy_win->first_line+1;\n+\n+	rec = mainwindows_find_lower(destroy_win);\n 	if (rec != NULL) {\n-		rec->last_line = last_line;\n-		mainwindow_resize(rec, 0, size);\n+		GSList *tmp, *list;\n+		list = mainwindows_get_line(rec);\n+\n+		for (tmp = list; tmp != NULL; tmp = tmp->next) {\n+			MAIN_WINDOW_REC *rec = tmp->data;\n+			rec->first_line = destroy_win->first_line;\n+			mainwindow_resize(rec, 0, size);\n+		}\n+\n+		g_slist_free(list);\n+		return;\n+	}\n+\n+	rec = mainwindows_find_upper(destroy_win);\n+	if (rec != NULL) {\n+		GSList *tmp, *list;\n+		list = mainwindows_get_line(rec);\n+\n+		for (tmp = list; tmp != NULL; tmp = tmp->next) {\n+			MAIN_WINDOW_REC *rec = tmp->data;\n+			rec->last_line = destroy_win->last_line;\n+			mainwindow_resize(rec, 0, size);\n+		}\n+\n+		g_slist_free(list);\n+		return;\n 	}\n }\n \n@@ -302,8 +532,7 @@ void mainwindow_destroy(MAIN_WINDOW_REC *window)\n 	if (mainwindows != NULL) {\n 		gui_windows_remove_parent(window);\n 		if (!quitting) {\n-			mainwindows_add_space(window->first_line,\n-					      window->last_line);\n+			mainwindows_add_space(window);\n 			mainwindows_redraw();\n 		}\n 	}\n@@ -313,6 +542,14 @@ void mainwindow_destroy(MAIN_WINDOW_REC *window)\n 	if (active_mainwin == window) active_mainwin = NULL;\n }\n \n+void mainwindow_destroy_half(MAIN_WINDOW_REC *window)\n+{\n+	int really_quitting = quitting;\n+	quitting = TRUE;\n+	mainwindow_destroy(window);\n+	quitting = really_quitting;\n+}\n+\n void mainwindows_redraw(void)\n {\n         GSList *tmp;\n@@ -327,12 +564,20 @@ void mainwindows_redraw(void)\n \n static int mainwindows_compare(MAIN_WINDOW_REC *w1, MAIN_WINDOW_REC *w2)\n {\n-	return w1->first_line < w2->first_line ? -1 : 1;\n+	return    w1->first_line   < w2->first_line   ? -1\n+		: w1->first_line   > w2->first_line   ?  1\n+		: w1->first_column < w2->first_column ? -1\n+		: w1->first_column > w2->first_column ?  1\n+		: 0;\n }\n \n static int mainwindows_compare_reverse(MAIN_WINDOW_REC *w1, MAIN_WINDOW_REC *w2)\n {\n-	return w1->first_line < w2->first_line ? 1 : -1;\n+	return    w1->first_line   < w2->first_line   ?  1\n+		: w1->first_line   > w2->first_line   ? -1\n+		: w1->first_column < w2->first_column ?  1\n+		: w1->first_column > w2->first_column ? -1\n+		: 0;\n }\n \n GSList *mainwindows_get_sorted(int reverse)\n@@ -348,123 +593,235 @@ GSList *mainwindows_get_sorted(int reverse)\n 	return list;\n }\n \n-static void mainwindows_resize_smaller(int xdiff, int ydiff)\n+static void mainwindows_resize_smaller(int ydiff)\n {\n-        MAIN_WINDOW_REC *rec;\n+	MAIN_WINDOW_REC *rec;\n 	GSList *sorted, *tmp;\n-        int space;\n+	int space;\n \n-	sorted = mainwindows_get_sorted(TRUE);\n+	sorted = NULL;\n+	for (rec = mainwindows_find_lower(NULL);\n+	     rec != NULL;\n+	     rec = mainwindows_find_lower(rec)) {\n+		sorted = g_slist_prepend(sorted, rec);\n+	}\n 	if (sorted == NULL)\n 		return;\n \n 	for (;;) {\n+		int skip_active = FALSE;\n 		space = 0;\n-		for (tmp = mainwindows; tmp != NULL; tmp = tmp->next) {\n+		/* for each line of windows, calculate the space that can be reduced still */\n+		for (tmp = sorted; tmp != NULL; tmp = tmp->next) {\n+			int min;\n+			GSList *line, *ltmp;\n 			rec = tmp->data;\n-			space += MAIN_WINDOW_TEXT_HEIGHT(rec)-WINDOW_MIN_SIZE;\n+			line = mainwindows_get_line(rec);\n+			min = screen_height - ydiff;\n+			for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+				int lmin;\n+				MAIN_WINDOW_REC *win = ltmp->data;\n+				if (win == active_mainwin && tmp == sorted)\n+					skip_active = TRUE;\n+\n+				lmin = MAIN_WINDOW_TEXT_HEIGHT(win)-WINDOW_MIN_SIZE;\n+				if (lmin < min)\n+					min = lmin;\n+			}\n+			g_slist_free(line);\n+			space += min;\n 		}\n \n 		if (space >= -ydiff)\n 			break;\n \n 		rec = sorted->data;\n-		if (rec == active_mainwin && sorted->next != NULL)\n+		if (skip_active && sorted->next != NULL)\n 			rec = sorted->next->data;\n 		sorted = g_slist_remove(sorted, rec);\n \n 		if (sorted != NULL) {\n 			/* terminal is too small - destroy the\n 			   uppest window and try again */\n-			mainwindow_destroy(rec);\n+			GSList *line, *ltmp;\n+			line = mainwindows_get_line(rec);\n+			for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+				MAIN_WINDOW_REC *win = ltmp->data;\n+				mainwindow_destroy(win);\n+			}\n+			g_slist_free(line);\n 		} else {\n-			/* only one window in screen.. just force the resize */\n-			rec->last_line += ydiff;\n-			mainwindow_resize(rec, xdiff, ydiff);\n-                        return;\n+			/* only one line of window in screen.. just force the resize */\n+			GSList *line, *ltmp;\n+			line = mainwindows_get_line(rec);\n+			for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+				MAIN_WINDOW_REC *win = ltmp->data;\n+				win->last_line += ydiff;\n+				mainwindow_resize(win, 0, ydiff);\n+			}\n+			g_slist_free(line);\n+			return;\n 		}\n 	}\n \n 	/* resize windows that have space */\n 	for (tmp = sorted; tmp != NULL && ydiff < 0; tmp = tmp->next) {\n-		rec = tmp->data;\n+		int min;\n+		GSList *line, *ltmp;\n \n-		space = MAIN_WINDOW_TEXT_HEIGHT(rec)-WINDOW_MIN_SIZE;\n-		if (space == 0) {\n-			mainwindow_resize(rec, xdiff, 0);\n-\n-			rec->first_line += ydiff;\n-			rec->last_line += ydiff;\n-			signal_emit(\"mainwindow moved\", 1, rec);\n-			continue;\n+		rec = tmp->data;\n+		line = mainwindows_get_line(rec);\n+		min = screen_height - ydiff;\n+		for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+			int lmin;\n+			MAIN_WINDOW_REC *win = ltmp->data;\n+			lmin = MAIN_WINDOW_TEXT_HEIGHT(win)-WINDOW_MIN_SIZE;\n+			if (lmin < min)\n+				min = lmin;\n 		}\n+		space = min;\n \n-		if (space > -ydiff) space = -ydiff;\n-		rec->last_line += ydiff;\n-		ydiff += space;\n-		rec->first_line += ydiff;\n-\n-		mainwindow_resize(rec, xdiff, -space);\n-	}\n+		if (space == 0) {\n+			/* move the line */\n+			for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+				MAIN_WINDOW_REC *win = ltmp->data;\n+				mainwindow_resize(win, 0, 0);\n+				win->size_dirty = TRUE;\n+				win->first_line += ydiff;\n+				win->last_line += ydiff;\n+				signal_emit(\"mainwindow moved\", 1, win);\n+			}\n+		} else {\n+			if (space > -ydiff) space = -ydiff;\n+			for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+				MAIN_WINDOW_REC *win = ltmp->data;\n+				win->last_line += ydiff;\n+				win->first_line += ydiff + space;\n \n-	if (xdiff != 0) {\n-		while (tmp != NULL) {\n-			mainwindow_resize(tmp->data, xdiff, 0);\n-			tmp = tmp->next;\n+				mainwindow_resize(win, 0, -space);\n+			}\n+			ydiff += space;\n 		}\n+		g_slist_free(line);\n 	}\n \n 	g_slist_free(sorted);\n }\n \n-static void mainwindows_resize_bigger(int xdiff, int ydiff)\n+static void mainwindows_rresize_line(int xdiff, MAIN_WINDOW_REC *win)\n {\n-	GSList *sorted, *tmp;\n+	int windows, i, extra_width, next_column, shrunk;\n+	int *widths;\n+	GSList *line, *tmp;\n \n-	sorted = mainwindows_get_sorted(FALSE);\n-	for (tmp = sorted; tmp != NULL; tmp = tmp->next) {\n-		MAIN_WINDOW_REC *rec = tmp->data;\n+	line = mainwindows_get_line(win);\n+	windows = g_slist_length(line);\n+	widths = g_new0(int, windows);\n \n-		if (ydiff == 0 || tmp->next != NULL) {\n-			mainwindow_resize(rec, xdiff, 0);\n-			continue;\n+	extra_width = screen_width - windows + 1;\n+	for (tmp = line, i = 0; tmp != NULL; tmp = tmp->next, i++) {\n+		MAIN_WINDOW_REC *rec = tmp->data;\n+		widths[i] = (MAIN_WINDOW_TEXT_WIDTH(rec) * (screen_width - windows + 1)) / (screen_width - xdiff - windows + 1);\n+		extra_width -= widths[i] + rec->statusbar_columns;\n+	}\n+	shrunk = FALSE;\n+	for (i = windows; extra_width < 0; i = i > 1 ? i - 1 : windows) {\n+		if (widths[i-1] > NEW_WINDOW_WIDTH || (i == 1 && !shrunk)) {\n+			widths[i-1]--;\n+			extra_width++;\n+			shrunk = i == 1;\n 		}\n-\n-		/* lowest window - give all the extra space for it */\n-		rec->last_line += ydiff;\n-		mainwindow_resize(rec, xdiff, ydiff);\n 	}\n-	g_slist_free(sorted);\n-}\n \n-static void mainwindows_resize_horiz(int xdiff)\n-{\n-	GSList *tmp;\n+	next_column = 0;\n \n-	for (tmp = mainwindows; tmp != NULL; tmp = tmp->next) {\n-		MAIN_WINDOW_REC *rec = tmp->data;\n+#define extra ( (i >= screen_width % windows && i < extra_width + (screen_width % windows)) \\\n+		|| i + windows < extra_width + (screen_width % windows) ? 1 : 0 )\n \n-		mainwindow_resize(rec, xdiff, 0);\n+	for (tmp = line, i = 0; tmp != NULL; tmp = tmp->next, i++) {\n+		MAIN_WINDOW_REC *rec = tmp->data;\n+		rec->first_column = next_column;\n+		rec->last_column = rec->first_column + widths[i] + rec->statusbar_columns + extra - 1;\n+		next_column = rec->last_column + 2;\n+		mainwindow_resize(rec, widths[i] + rec->statusbar_columns + extra - rec->width, 0);\n+		rec->size_dirty = TRUE;\n 	}\n+#undef extra\n+\n+	g_free(widths);\n+	g_slist_free(line);\n }\n \n void mainwindows_resize(int width, int height)\n {\n 	int xdiff, ydiff;\n \n-	xdiff = width-old_screen_width;\n-	ydiff = height-old_screen_height;\n-        old_screen_width = width;\n-        old_screen_height = height;\n+	xdiff = width-screen_width;\n+	ydiff = height-screen_height;\n+	screen_width = width;\n+	screen_height = height;\n+\n+	if (ydiff > 0) {\n+		/* algorithm: enlarge bottom window */\n+		MAIN_WINDOW_REC *rec;\n+		GSList *line, *tmp;\n+		line = mainwindows_get_line(mainwindows_find_upper(NULL));\n+		for (tmp = line; tmp != NULL; tmp = tmp->next) {\n+			rec = tmp->data;\n+			rec->last_line += ydiff;\n+			mainwindow_resize(rec, 0, ydiff);\n+		}\n+		g_slist_free(line);\n+	}\n+\n+	if (xdiff > 0) {\n+		/* algorithm: distribute new space on each line */\n+		MAIN_WINDOW_REC *win;\n+\n+		for (win = mainwindows_find_lower(NULL);\n+		     win != NULL;\n+		     win = mainwindows_find_lower(win)) {\n+			mainwindows_rresize_line(xdiff, win);\n+		}\n+	}\n+\n+	if (xdiff < 0) {\n+		/* algorithm: shrink each window,\n+		   destroy windows on the right if no room */\n+		MAIN_WINDOW_REC *win;\n+\n+		for (win = mainwindows_find_lower(NULL);\n+		     win != NULL;\n+		     win = mainwindows_find_lower(win)) {\n+			int max_windows, i, last_column;\n+			GSList *line, *tmp;\n+\n+			line = mainwindows_get_line(win);\n+			max_windows = (screen_width + 1) / (NEW_WINDOW_WIDTH + 1);\n+			if (max_windows < 1)\n+				max_windows = 1;\n+			last_column = screen_width - 1;\n+			for (tmp = line, i = 0; tmp != NULL; tmp = tmp->next, i++) {\n+				MAIN_WINDOW_REC *rec = tmp->data;\n+				if (i >= max_windows)\n+					mainwindow_destroy_half(rec);\n+				else\n+					last_column = rec->last_column;\n+			}\n+			win = line->data;\n+			g_slist_free(line);\n+\n+			mainwindows_rresize_line(screen_width - last_column + 1, win);\n+		}\n+	}\n \n-	if (ydiff < 0)\n-		mainwindows_resize_smaller(xdiff, ydiff);\n-	else if (ydiff > 0)\n-		mainwindows_resize_bigger(xdiff, ydiff);\n-        else if (xdiff != 0)\n-		mainwindows_resize_horiz(xdiff);\n+	if (ydiff < 0) {\n+		/* algorithm: shrink windows starting from bottom,\n+		   destroy windows starting from top if no room */\n+		mainwindows_resize_smaller(ydiff);\n+	}\n \n-        signal_emit(\"terminal resized\", 0);\n+	signal_emit(\"terminal resized\", 0);\n \n 	irssi_redraw();\n }\n@@ -474,31 +831,37 @@ int mainwindows_reserve_lines(int top, int bottom)\n 	MAIN_WINDOW_REC *window;\n 	int ret;\n \n-        ret = -1;\n+	ret = -1;\n 	if (top != 0) {\n+		GSList *list, *tmp;\n 		g_return_val_if_fail(top > 0 || screen_reserved_top > top, -1);\n \n 		ret = screen_reserved_top;\n 		screen_reserved_top += top;\n \n-		window = mainwindows_find_lower(-1);\n-		if (window != NULL) {\n+		list = mainwindows_get_line(mainwindows_find_lower(NULL));\n+		for (tmp = list; tmp != NULL; tmp = tmp->next) {\n+			window = tmp->data;\n 			window->first_line += top;\n 			mainwindow_resize(window, 0, -top);\n 		}\n+		g_slist_free(list);\n 	}\n \n 	if (bottom != 0) {\n+		GSList *list, *tmp;\n 		g_return_val_if_fail(bottom > 0 || screen_reserved_bottom > bottom, -1);\n \n 		ret = screen_reserved_bottom;\n 		screen_reserved_bottom += bottom;\n \n-		window = mainwindows_find_upper(term_height);\n-		if (window != NULL) {\n+		list = mainwindows_get_line(mainwindows_find_upper(NULL));\n+		for (tmp = list; tmp != NULL; tmp = tmp->next) {\n+			window = tmp->data;\n 			window->last_line -= bottom;\n 			mainwindow_resize(window, 0, -bottom);\n 		}\n+		g_slist_free(list);\n 	}\n \n 	return ret;\n@@ -528,47 +891,109 @@ int mainwindow_set_statusbar_lines(MAIN_WINDOW_REC *window,\n         return ret;\n }\n \n-static void mainwindows_resize_two(MAIN_WINDOW_REC *grow_win,\n-				   MAIN_WINDOW_REC *shrink_win, int count)\n+static void mainwindows_resize_two(GSList *grow_list,\n+				   GSList *shrink_list, int count)\n {\n-        irssi_set_dirty();\n+	GSList *tmp;\n+	MAIN_WINDOW_REC *win;\n \n-	mainwindow_resize(grow_win, 0, count);\n-	mainwindow_resize(shrink_win, 0, -count);\n-	grow_win->dirty = TRUE;\n-	shrink_win->dirty = TRUE;\n+	irssi_set_dirty();\n+\n+	for (tmp = shrink_list; tmp != NULL; tmp = tmp->next) {\n+		win = tmp->data;\n+		mainwindow_resize(win, 0, -count);\n+		win->dirty = TRUE;\n+	}\n+	for (tmp = grow_list; tmp != NULL; tmp = tmp->next) {\n+		win = tmp->data;\n+		mainwindow_resize(win, 0, count);\n+		win->dirty = TRUE;\n+	}\n }\n \n static int try_shrink_lower(MAIN_WINDOW_REC *window, int count)\n {\n 	MAIN_WINDOW_REC *shrink_win;\n \n-	shrink_win = mainwindows_find_lower(window->last_line);\n-	if (shrink_win != NULL &&\n-	    MAIN_WINDOW_TEXT_HEIGHT(shrink_win)-count >= WINDOW_MIN_SIZE) {\n-                window->last_line += count;\n-		shrink_win->first_line += count;\n-		mainwindows_resize_two(window, shrink_win, count);\n-                return TRUE;\n+	shrink_win = mainwindows_find_lower(window);\n+	if (shrink_win != NULL) {\n+		int ok;\n+		GSList *shrink_list, *tmp;\n+		MAIN_WINDOW_REC *win;\n+\n+		ok = TRUE;\n+		shrink_list = mainwindows_get_line(shrink_win);\n+\n+		for (tmp = shrink_list; tmp != NULL; tmp = tmp->next) {\n+			win = tmp->data;\n+			if (MAIN_WINDOW_TEXT_HEIGHT(win)-count < WINDOW_MIN_SIZE) {\n+				ok = FALSE;\n+				break;\n+			}\n+		}\n+		if (ok) {\n+			GSList *grow_list;\n+			grow_list = mainwindows_get_line(window);\n+\n+			for (tmp = shrink_list; tmp != NULL; tmp = tmp->next) {\n+				win = tmp->data;\n+				win->first_line += count;\n+			}\n+			for (tmp = grow_list; tmp != NULL; tmp = tmp->next) {\n+				win = tmp->data;\n+				win->last_line += count;\n+			}\n+\n+			mainwindows_resize_two(grow_list, shrink_list, count);\n+			g_slist_free(grow_list);\n+		}\n+\n+		g_slist_free(shrink_list);\n+		return ok;\n 	}\n \n-        return FALSE;\n+	return FALSE;\n }\n \n static int try_shrink_upper(MAIN_WINDOW_REC *window, int count)\n {\n 	MAIN_WINDOW_REC *shrink_win;\n \n-	shrink_win = mainwindows_find_upper(window->first_line);\n-	if (shrink_win != NULL &&\n-	    MAIN_WINDOW_TEXT_HEIGHT(shrink_win)-count >= WINDOW_MIN_SIZE) {\n-		window->first_line -= count;\n-		shrink_win->last_line -= count;\n-		mainwindows_resize_two(window, shrink_win, count);\n-                return TRUE;\n+	shrink_win = mainwindows_find_upper(window);\n+	if (shrink_win != NULL) {\n+		int ok;\n+		GSList *shrink_list, *tmp;\n+		MAIN_WINDOW_REC *win;\n+\n+		ok = TRUE;\n+		shrink_list = mainwindows_get_line(shrink_win);\n+\n+		for (tmp = shrink_list; tmp != NULL; tmp = tmp->next) {\n+			win = tmp->data;\n+			if (MAIN_WINDOW_TEXT_HEIGHT(win)-count < WINDOW_MIN_SIZE) {\n+				ok = FALSE;\n+				break;\n+			}\n+		}\n+		if (ok) {\n+			GSList *grow_list;\n+			grow_list = mainwindows_get_line(window);\n+			for (tmp = grow_list; tmp != NULL; tmp = tmp->next) {\n+				win = tmp->data;\n+				win->first_line -= count;\n+			}\n+			for (tmp = shrink_list; tmp != NULL; tmp = tmp->next) {\n+				win = tmp->data;\n+				win->last_line -= count;\n+			}\n+			mainwindows_resize_two(grow_list, shrink_list, count);\n+			g_slist_free(grow_list);\n+		}\n+		g_slist_free(shrink_list);\n+		return ok;\n 	}\n \n-        return FALSE;\n+	return FALSE;\n }\n \n static int mainwindow_grow(MAIN_WINDOW_REC *window, int count,\n@@ -588,28 +1013,52 @@ static int try_grow_lower(MAIN_WINDOW_REC *window, int count)\n {\n 	MAIN_WINDOW_REC *grow_win;\n \n-	grow_win = mainwindows_find_lower(window->last_line);\n+	grow_win = mainwindows_find_lower(window);\n 	if (grow_win != NULL) {\n-                window->last_line -= count;\n-		grow_win->first_line -= count;\n-		mainwindows_resize_two(grow_win, window, count);\n+		MAIN_WINDOW_REC *win;\n+		GSList *grow_list, *shrink_list, *tmp;\n+		grow_list = mainwindows_get_line(grow_win);\n+		shrink_list = mainwindows_get_line(window);\n+		for (tmp = grow_list; tmp != NULL; tmp = tmp->next) {\n+			win = tmp->data;\n+			win->first_line -= count;\n+		}\n+		for (tmp = shrink_list; tmp != NULL; tmp = tmp->next) {\n+			win = tmp->data;\n+			win->last_line -= count;\n+		}\n+		mainwindows_resize_two(grow_list, shrink_list, count);\n+		g_slist_free(shrink_list);\n+		g_slist_free(grow_list);\n 	}\n \n-        return grow_win != NULL;\n+	return grow_win != NULL;\n }\n \n static int try_grow_upper(MAIN_WINDOW_REC *window, int count)\n {\n 	MAIN_WINDOW_REC *grow_win;\n \n-	grow_win = mainwindows_find_upper(window->first_line);\n+	grow_win = mainwindows_find_upper(window);\n 	if (grow_win != NULL) {\n-		window->first_line += count;\n-		grow_win->last_line += count;\n-		mainwindows_resize_two(grow_win, window, count);\n+		MAIN_WINDOW_REC *win;\n+		GSList *grow_list, *shrink_list, *tmp;\n+		grow_list = mainwindows_get_line(grow_win);\n+		shrink_list = mainwindows_get_line(window);\n+		for (tmp = grow_list; tmp != NULL; tmp = tmp->next) {\n+			win = tmp->data;\n+			win->last_line += count;\n+		}\n+		for (tmp = shrink_list; tmp != NULL; tmp = tmp->next) {\n+			win = tmp->data;\n+			win->first_line += count;\n+		}\n+		mainwindows_resize_two(grow_list, shrink_list, count);\n+		g_slist_free(shrink_list);\n+		g_slist_free(grow_list);\n 	}\n \n-        return grow_win != NULL;\n+	return grow_win != NULL;\n }\n \n static int mainwindow_shrink(MAIN_WINDOW_REC *window, int count, int resize_lower)\n@@ -627,6 +1076,109 @@ static int mainwindow_shrink(MAIN_WINDOW_REC *window, int count, int resize_lowe\n         return TRUE;\n }\n \n+static void mainwindows_rresize_two(MAIN_WINDOW_REC *grow_win,\n+				    MAIN_WINDOW_REC *shrink_win, int count)\n+{\n+	irssi_set_dirty();\n+\n+	mainwindow_resize(grow_win, count, 0);\n+	mainwindow_resize(shrink_win, -count, 0);\n+	grow_win->dirty = TRUE;\n+	shrink_win->dirty = TRUE;\n+}\n+\n+static int try_rshrink_right(MAIN_WINDOW_REC *window, int count)\n+{\n+	MAIN_WINDOW_REC *shrink_win;\n+\n+	shrink_win = mainwindows_find_right(window, FALSE);\n+	if (shrink_win != NULL) {\n+		if (MAIN_WINDOW_TEXT_WIDTH(shrink_win)-count < NEW_WINDOW_WIDTH) {\n+			return FALSE;\n+		}\n+\n+		shrink_win->first_column += count;\n+		window->last_column += count;\n+\n+		mainwindows_rresize_two(window, shrink_win, count);\n+		return TRUE;\n+	}\n+\n+	return FALSE;\n+}\n+\n+static int try_rshrink_left(MAIN_WINDOW_REC *window, int count)\n+{\n+	MAIN_WINDOW_REC *shrink_win;\n+\n+	shrink_win = mainwindows_find_left(window, FALSE);\n+	if (shrink_win != NULL) {\n+		if (MAIN_WINDOW_TEXT_WIDTH(shrink_win)-count < NEW_WINDOW_WIDTH) {\n+			return FALSE;\n+		}\n+		window->first_column -= count;\n+		shrink_win->last_column -= count;\n+\n+		mainwindows_rresize_two(window, shrink_win, count);\n+		return TRUE;\n+	}\n+\n+	return FALSE;\n+}\n+\n+static int mainwindow_rgrow(MAIN_WINDOW_REC *window, int count)\n+{\n+	if (!try_rshrink_right(window, count)) {\n+		if (!try_rshrink_left(window, count))\n+			return FALSE;\n+	}\n+\n+	return TRUE;\n+}\n+\n+static int try_rgrow_right(MAIN_WINDOW_REC *window, int count)\n+{\n+	MAIN_WINDOW_REC *grow_win;\n+\n+	grow_win = mainwindows_find_right(window, FALSE);\n+	if (grow_win != NULL) {\n+		grow_win->first_column -= count;\n+		window->last_column -= count;\n+		mainwindows_rresize_two(grow_win, window, count);\n+		return TRUE;\n+	}\n+\n+	return FALSE;\n+}\n+\n+static int try_rgrow_left(MAIN_WINDOW_REC *window, int count)\n+{\n+	MAIN_WINDOW_REC *grow_win;\n+\n+	grow_win = mainwindows_find_left(window, FALSE);\n+	if (grow_win != NULL) {\n+		grow_win->last_column += count;\n+		window->first_column += count;\n+		mainwindows_rresize_two(grow_win, window, count);\n+		return TRUE;\n+	}\n+\n+	return FALSE;\n+}\n+\n+static int mainwindow_rshrink(MAIN_WINDOW_REC *window, int count)\n+{\n+	if (MAIN_WINDOW_TEXT_WIDTH(window)-count < NEW_WINDOW_WIDTH)\n+		return FALSE;\n+\n+	if (!try_rgrow_right(window, count)) {\n+		if (!try_rgrow_left(window, count))\n+			return FALSE;\n+	}\n+\n+	return TRUE;\n+}\n+\n /* Change the window height - the height includes the lines needed for\n    statusbars. If resize_lower is TRUE, the lower window is first tried\n    to be resized instead of upper window. */\n@@ -639,6 +1191,15 @@ void mainwindow_set_size(MAIN_WINDOW_REC *window, int height, int resize_lower)\n 		mainwindow_grow(window, height, resize_lower);\n }\n \n+void mainwindow_set_rsize(MAIN_WINDOW_REC *window, int width)\n+{\n+	width -= window->width;\n+	if (width < 0)\n+		mainwindow_rshrink(window, -width);\n+	else\n+		mainwindow_rgrow(window, width);\n+}\n+\n void mainwindows_redraw_dirty(void)\n {\n 	GSList *tmp;\n@@ -707,35 +1268,52 @@ static void cmd_window_size(const char *data)\n /* SYNTAX: WINDOW BALANCE */\n static void cmd_window_balance(void)\n {\n-	GSList *sorted, *tmp;\n+	GSList *sorted, *stmp, *line, *ltmp;\n 	int avail_size, unit_size, bigger_units;\n 	int windows, last_line, old_size;\n+	MAIN_WINDOW_REC *win;\n \n 	windows = g_slist_length(mainwindows);\n 	if (windows == 1) return;\n \n+	sorted = NULL;\n+	windows = 0;\n+	for (win = mainwindows_find_lower(NULL);\n+	     win != NULL;\n+	     win = mainwindows_find_lower(win)) {\n+		windows++;\n+		sorted = g_slist_append(sorted, win);\n+	}\n+\n 	avail_size = term_height - screen_reserved_top-screen_reserved_bottom;\n 	unit_size = avail_size/windows;\n 	bigger_units = avail_size%windows;\n \n-	sorted = mainwindows_get_sorted(FALSE);\n-        last_line = screen_reserved_top;\n-	for (tmp = sorted; tmp != NULL; tmp = tmp->next) {\n-		MAIN_WINDOW_REC *rec = tmp->data;\n+	last_line = screen_reserved_top;\n+	for (stmp = sorted; stmp != NULL; stmp = stmp->next) {\n+		win = stmp->data;\n+		line = mainwindows_get_line(win);\n \n-		old_size = rec->height;\n-		rec->first_line = last_line;\n-		rec->last_line = rec->first_line + unit_size-1;\n+		for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+			MAIN_WINDOW_REC *rec = ltmp->data;\n+			old_size = rec->height;\n+			rec->first_line = last_line;\n+			rec->last_line = rec->first_line + unit_size-1;\n \n-		if (bigger_units > 0) {\n-			rec->last_line++;\n-                        bigger_units--;\n-		}\n+			if (bigger_units > 0) {\n+				rec->last_line++;\n+			}\n \n-		rec->height = rec->last_line-rec->first_line+1;\n-		last_line = rec->last_line+1;\n+			rec->height = rec->last_line-rec->first_line+1;\n \n-		mainwindow_resize(rec, 0, rec->height-old_size);\n+			mainwindow_resize(rec, 0, rec->height-old_size);\n+		}\n+		if (line != NULL && bigger_units > 0) {\n+			bigger_units--;\n+		}\n+		last_line = win->last_line+1;\n+\n+		g_slist_free(line);\n 	}\n 	g_slist_free(sorted);\n \n@@ -769,29 +1347,30 @@ static void cmd_window_hide(const char *data)\n 		return;\n \n 	if (WINDOW_MAIN(window)->sticky_windows) {\n-		printformat_window(active_win, MSGLEVEL_CLIENTERROR,\n-				   TXT_CANT_HIDE_STICKY_WINDOWS);\n-                return;\n+		if (!settings_get_bool(\"autounstick_windows\")) {\n+			printformat_window(active_win, MSGLEVEL_CLIENTERROR,\n+					   TXT_CANT_HIDE_STICKY_WINDOWS);\n+			return;\n+		}\n 	}\n \n 	mainwindow_destroy(WINDOW_MAIN(window));\n \n 	if (active_mainwin == NULL) {\n 		active_mainwin = WINDOW_MAIN(active_win);\n-                window_set_active(active_mainwin->active);\n+		window_set_active(active_mainwin->active);\n 	}\n }\n \n-/* SYNTAX: WINDOW SHOW <number>|<name> */\n-static void cmd_window_show(const char *data)\n+static void _cmd_window_show_opt(const char *data, int right)\n {\n-        MAIN_WINDOW_REC *parent;\n+	MAIN_WINDOW_REC *parent;\n 	WINDOW_REC *window;\n \n 	if (*data == \'\\0\') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n \n 	if (is_numeric(data, \'\\0\')) {\n-                window = window_find_refnum(atoi(data));\n+		window = window_find_refnum(atoi(data));\n 		if (window == NULL) {\n 			printformat_window(active_win, MSGLEVEL_CLIENTERROR,\n 					   TXT_REFNUM_NOT_FOUND, data);\n@@ -804,30 +1383,150 @@ static void cmd_window_show(const char *data)\n 		return;\n \n 	if (WINDOW_GUI(window)->sticky) {\n-		printformat_window(active_win, MSGLEVEL_CLIENTERROR,\n-				   TXT_CANT_SHOW_STICKY_WINDOWS);\n-                return;\n+		if (!settings_get_bool(\"autounstick_windows\")) {\n+			printformat_window(active_win, MSGLEVEL_CLIENTERROR,\n+					   TXT_CANT_SHOW_STICKY_WINDOWS);\n+			return;\n+		}\n 	}\n \n-	parent = mainwindow_create();\n+	parent = mainwindow_create(right);\n 	parent->active = window;\n-        gui_window_reparent(window, parent);\n+	gui_window_reparent(window, parent);\n \n 	if (settings_get_bool(\"autostick_split_windows\"))\n-                gui_window_set_sticky(window);\n+		gui_window_set_sticky(window);\n \n 	active_mainwin = NULL;\n 	window_set_active(window);\n }\n \n+/* SYNTAX: WINDOW SHOW <number>|<name> */\n+static void cmd_window_show(const char *data)\n+{\n+	_cmd_window_show_opt(data, FALSE);\n+}\n+\n+/* SYNTAX: WINDOW RSHOW <number>|<name> */\n+static void cmd_window_rshow(const char *data)\n+{\n+	_cmd_window_show_opt(data, TRUE);\n+}\n+\n+/* SYNTAX: WINDOW RGROW [<columns>] */\n+static void cmd_window_rgrow(const char *data)\n+{\n+	int count;\n+\n+	count = *data == \'\\0\' ? 1 : atoi(data);\n+	if (!mainwindow_rgrow(WINDOW_MAIN(active_win), count)) {\n+		printformat_window(active_win, MSGLEVEL_CLIENTNOTICE,\n+				   TXT_WINDOW_TOO_SMALL);\n+	}\n+}\n+\n+/* SYNTAX: WINDOW RSHRINK [<lines>] */\n+static void cmd_window_rshrink(const char *data)\n+{\n+	int count;\n+\n+	count = *data == \'\\0\' ? 1 : atoi(data);\n+	if (!mainwindow_rshrink(WINDOW_MAIN(active_win), count)) {\n+		printformat_window(active_win, MSGLEVEL_CLIENTNOTICE,\n+				   TXT_WINDOW_TOO_SMALL);\n+	}\n+}\n+\n+/* SYNTAX: WINDOW RSIZE <columns> */\n+static void cmd_window_rsize(const char *data)\n+{\n+	char rsizestr[MAX_INT_STRLEN];\n+	int rsize;\n+\n+	if (!is_numeric(data, 0)) return;\n+	rsize = atoi(data);\n+\n+	rsize -= MAIN_WINDOW_TEXT_WIDTH(WINDOW_MAIN(active_win));\n+	if (rsize == 0) return;\n+\n+	ltoa(rsizestr, rsize < 0 ? -rsize : rsize);\n+	if (rsize < 0)\n+		cmd_window_rshrink(rsizestr);\n+	else\n+		cmd_window_rgrow(rsizestr);\n+}\n+\n+/* SYNTAX: WINDOW RBALANCE */\n+static void cmd_window_rbalance(void)\n+{\n+	GSList *line, *ltmp;\n+	int avail_width, unit_width, bigger_units;\n+	int windows, last_column, old_width;\n+	MAIN_WINDOW_REC *win;\n+\n+	line = mainwindows_get_line(WINDOW_MAIN(active_win));\n+	windows = g_slist_length(line);\n+	if (windows == 1) {\n+		g_slist_free(line);\n+		return;\n+	}\n+\n+	avail_width = term_width - screen_reserved_left-screen_reserved_right - windows + 1;\n+	unit_width = avail_width/windows;\n+	bigger_units = avail_width%windows;\n+\n+	last_column = screen_reserved_left;\n+	for (ltmp = line; ltmp != NULL; ltmp = ltmp->next) {\n+		win = ltmp->data;\n+		old_width = win->width;\n+		win->first_column = last_column;\n+		win->last_column = win->first_column + unit_width-1;\n+\n+		if (bigger_units > 0) {\n+			win->last_column++;\n+			bigger_units--;\n+		}\n+\n+		mainwindow_resize(win, win->last_column - win->first_column + 1 - old_width, 0);\n+		last_column = win->last_column+2;\n+	}\n+	g_slist_free(line);\n+\n+	mainwindows_redraw();\n+}\n+\n /* SYNTAX: WINDOW UP */\n static void cmd_window_up(void)\n {\n 	MAIN_WINDOW_REC *rec;\n \n-	rec = mainwindows_find_upper(active_mainwin->first_line);\n+	rec = mainwindows_find_left_upper(active_mainwin);\n+	if (rec == NULL)\n+		rec = mainwindows_find_left_upper(NULL);\n+	if (rec != NULL)\n+		window_set_active(rec->active);\n+}\n+\n+/* SYNTAX: WINDOW DUP */\n+static void cmd_window_dup(void)\n+{\n+	MAIN_WINDOW_REC *rec;\n+\n+	rec = mainwindows_find_upper(active_mainwin);\n 	if (rec == NULL)\n-		rec = mainwindows_find_upper(term_height);\n+		rec = mainwindows_find_upper(NULL);\n+	if (rec != NULL)\n+		window_set_active(rec->active);\n+}\n+\n+/* SYNTAX: WINDOW DLEFT */\n+static void cmd_window_dleft(void)\n+{\n+	MAIN_WINDOW_REC *rec;\n+\n+	rec = mainwindows_find_left(active_mainwin, FALSE);\n+	if (rec == NULL)\n+		rec = mainwindows_find_left(active_mainwin, TRUE);\n 	if (rec != NULL)\n 		window_set_active(rec->active);\n }\n@@ -837,9 +1536,33 @@ static void cmd_window_down(void)\n {\n 	MAIN_WINDOW_REC *rec;\n \n-	rec = mainwindows_find_lower(active_mainwin->last_line);\n+	rec = mainwindows_find_lower_right(active_mainwin);\n+	if (rec == NULL)\n+		rec = mainwindows_find_lower_right(NULL);\n+	if (rec != NULL)\n+		window_set_active(rec->active);\n+}\n+\n+/* SYNTAX: WINDOW DDOWN */\n+static void cmd_window_ddown(void)\n+{\n+	MAIN_WINDOW_REC *rec;\n+\n+	rec = mainwindows_find_lower(active_mainwin);\n+	if (rec == NULL)\n+		rec = mainwindows_find_lower(NULL);\n+	if (rec != NULL)\n+		window_set_active(rec->active);\n+}\n+\n+/* SYNTAX: WINDOW DRIGHT */\n+static void cmd_window_dright(void)\n+{\n+	MAIN_WINDOW_REC *rec;\n+\n+	rec = mainwindows_find_right(active_mainwin, FALSE);\n 	if (rec == NULL)\n-		rec = mainwindows_find_lower(-1);\n+		rec = mainwindows_find_right(active_mainwin, TRUE);\n 	if (rec != NULL)\n 		window_set_active(rec->active);\n }\n@@ -997,13 +1720,37 @@ static void cmd_window_move_right(void)\n 		window_set_refnum(active_win, refnum);\n }\n \n+/* SYNTAX: WINDOW MOVE DLEFT */\n+static void cmd_window_move_dleft(void)\n+{\n+	MAIN_WINDOW_REC *rec;\n+\n+	rec = mainwindows_find_left(active_mainwin, FALSE);\n+	if (rec == NULL)\n+		rec = mainwindows_find_left(active_mainwin, TRUE);\n+	if (rec != NULL)\n+		window_reparent(active_win, rec);\n+}\n+\n+/* SYNTAX: WINDOW MOVE DRIGHT */\n+static void cmd_window_move_dright(void)\n+{\n+	MAIN_WINDOW_REC *rec;\n+\n+	rec = mainwindows_find_right(active_mainwin, FALSE);\n+	if (rec == NULL)\n+		rec = mainwindows_find_right(active_mainwin, TRUE);\n+	if (rec != NULL)\n+		window_reparent(active_win, rec);\n+}\n+\n /* SYNTAX: WINDOW MOVE UP */\n static void cmd_window_move_up(void)\n {\n 	MAIN_WINDOW_REC *rec;\n \n-	rec = mainwindows_find_upper(active_mainwin->first_line);\n-        if (rec != NULL)\n+	rec = mainwindows_find_upper_left(active_mainwin);\n+	if (rec != NULL)\n 		window_reparent(active_win, rec);\n }\n \n@@ -1012,7 +1759,7 @@ static void cmd_window_move_down(void)\n {\n 	MAIN_WINDOW_REC *rec;\n \n-	rec = mainwindows_find_lower(active_mainwin->last_line);\n+	rec = mainwindows_find_lower_right(active_mainwin);\n 	if (rec != NULL)\n 		window_reparent(active_win, rec);\n }\n@@ -1058,12 +1805,14 @@ static void sig_window_print_info(WINDOW_REC *win)\n \n void mainwindows_init(void)\n {\n-	old_screen_width = term_width;\n-	old_screen_height = term_height;\n+	screen_width = term_width;\n+	screen_height = term_height;\n \n 	mainwindows = NULL;\n 	active_mainwin = NULL;\n+	clrtoeol_info = g_new0(MAIN_WINDOW_BORDER_REC, 1);\n 	screen_reserved_top = screen_reserved_bottom = 0;\n+	screen_reserved_left = screen_reserved_right = 0;\n \n 	command_bind(\"window grow\", NULL, (SIGNAL_FUNC) cmd_window_grow);\n 	command_bind(\"window shrink\", NULL, (SIGNAL_FUNC) cmd_window_shrink);\n@@ -1075,18 +1824,30 @@ void mainwindows_init(void)\n 	command_bind(\"window down\", NULL, (SIGNAL_FUNC) cmd_window_down);\n 	command_bind(\"window left\", NULL, (SIGNAL_FUNC) cmd_window_left);\n 	command_bind(\"window right\", NULL, (SIGNAL_FUNC) cmd_window_right);\n+	command_bind(\"window dup\", NULL, (SIGNAL_FUNC) cmd_window_dup);\n+	command_bind(\"window ddown\", NULL, (SIGNAL_FUNC) cmd_window_ddown);\n+	command_bind(\"window dleft\", NULL, (SIGNAL_FUNC) cmd_window_dleft);\n+	command_bind(\"window dright\", NULL, (SIGNAL_FUNC) cmd_window_dright);\n 	command_bind(\"window stick\", NULL, (SIGNAL_FUNC) cmd_window_stick);\n 	command_bind(\"window move left\", NULL, (SIGNAL_FUNC) cmd_window_move_left);\n 	command_bind(\"window move right\", NULL, (SIGNAL_FUNC) cmd_window_move_right);\n 	command_bind(\"window move up\", NULL, (SIGNAL_FUNC) cmd_window_move_up);\n 	command_bind(\"window move down\", NULL, (SIGNAL_FUNC) cmd_window_move_down);\n-        signal_add(\"window print info\", (SIGNAL_FUNC) sig_window_print_info);\n+	command_bind(\"window move dleft\", NULL, (SIGNAL_FUNC) cmd_window_move_dleft);\n+	command_bind(\"window move dright\", NULL, (SIGNAL_FUNC) cmd_window_move_dright);\n+	command_bind(\"window rgrow\", NULL, (SIGNAL_FUNC) cmd_window_rgrow);\n+	command_bind(\"window rshrink\", NULL, (SIGNAL_FUNC) cmd_window_rshrink);\n+	command_bind(\"window rsize\", NULL, (SIGNAL_FUNC) cmd_window_rsize);\n+	command_bind(\"window rbalance\", NULL, (SIGNAL_FUNC) cmd_window_rbalance);\n+	command_bind(\"window rshow\", NULL, (SIGNAL_FUNC) cmd_window_rshow);\n+	signal_add(\"window print info\", (SIGNAL_FUNC) sig_window_print_info);\n }\n \n void mainwindows_deinit(void)\n {\n 	while (mainwindows != NULL)\n 		mainwindow_destroy(mainwindows->data);\n+	g_free(clrtoeol_info);\n \n 	command_unbind(\"window grow\", (SIGNAL_FUNC) cmd_window_grow);\n 	command_unbind(\"window shrink\", (SIGNAL_FUNC) cmd_window_shrink);\n@@ -1098,10 +1859,21 @@ void mainwindows_deinit(void)\n 	command_unbind(\"window down\", (SIGNAL_FUNC) cmd_window_down);\n 	command_unbind(\"window left\", (SIGNAL_FUNC) cmd_window_left);\n 	command_unbind(\"window right\", (SIGNAL_FUNC) cmd_window_right);\n+	command_unbind(\"window dup\", (SIGNAL_FUNC) cmd_window_dup);\n+	command_unbind(\"window ddown\", (SIGNAL_FUNC) cmd_window_ddown);\n+	command_unbind(\"window dleft\", (SIGNAL_FUNC) cmd_window_dleft);\n+	command_unbind(\"window dright\", (SIGNAL_FUNC) cmd_window_dright);\n 	command_unbind(\"window stick\", (SIGNAL_FUNC) cmd_window_stick);\n 	command_unbind(\"window move left\", (SIGNAL_FUNC) cmd_window_move_left);\n 	command_unbind(\"window move right\", (SIGNAL_FUNC) cmd_window_move_right);\n 	command_unbind(\"window move up\", (SIGNAL_FUNC) cmd_window_move_up);\n 	command_unbind(\"window move down\", (SIGNAL_FUNC) cmd_window_move_down);\n-        signal_remove(\"window print info\", (SIGNAL_FUNC) sig_window_print_info);\n+	command_unbind(\"window move dleft\", (SIGNAL_FUNC) cmd_window_move_dleft);\n+	command_unbind(\"window move dright\", (SIGNAL_FUNC) cmd_window_move_dright);\n+	command_unbind(\"window rgrow\", (SIGNAL_FUNC) cmd_window_rgrow);\n+	command_unbind(\"window rshrink\", (SIGNAL_FUNC) cmd_window_rshrink);\n+	command_unbind(\"window rsize\", (SIGNAL_FUNC) cmd_window_rsize);\n+	command_unbind(\"window rbalance\", (SIGNAL_FUNC) cmd_window_rbalance);\n+	command_unbind(\"window rshow\", (SIGNAL_FUNC) cmd_window_rshow);\n+	signal_remove(\"window print info\", (SIGNAL_FUNC) sig_window_print_info);\n }\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','mainwindows.h','43','0','18','4','MODIFY','@@ -5,36 +5,48 @@\n #include \"term.h\"\n \n #define WINDOW_MIN_SIZE 2\n+#define NEW_WINDOW_WIDTH 10\n \n #define MAIN_WINDOW_TEXT_HEIGHT(window) \\\n         ((window)->height-(window)->statusbar_lines)\n \n+#define MAIN_WINDOW_TEXT_WIDTH(window) \\\n+        ((window)->width-(window)->statusbar_columns)\n+\n typedef struct {\n 	WINDOW_REC *active;\n \n 	TERM_WINDOW *screen_win;\n-        int sticky_windows; /* number of sticky windows */\n+	int sticky_windows; /* number of sticky windows */\n \n 	int first_line, last_line; /* first/last line used by this window (0..x) (includes statusbars) */\n+	int first_column, last_column; /* first/last column used by this window (0..x) (includes statusbars) */\n 	int width, height; /* width/height of the window (includes statusbars) */\n \n 	GSList *statusbars;\n-	int statusbar_lines_top;\n-	int statusbar_lines_bottom;\n+	int statusbar_lines_top, statusbar_lines_bottom;\n 	int statusbar_lines; /* top+bottom */\n+	int statusbar_columns_left, statusbar_columns_right;\n+	int statusbar_columns; /* left+right */\n \n 	unsigned int dirty:1; /* This window needs a redraw */\n 	unsigned int size_dirty:1; /* We\'ll need to resize the window, but haven\'t got around doing it just yet. */\n } MAIN_WINDOW_REC;\n \n+typedef struct {\n+	char *color;\n+	TERM_WINDOW *window;\n+} MAIN_WINDOW_BORDER_REC;\n+\n extern GSList *mainwindows;\n extern MAIN_WINDOW_REC *active_mainwin;\n+extern MAIN_WINDOW_BORDER_REC *clrtoeol_info;\n extern int screen_reserved_top, screen_reserved_bottom;\n \n void mainwindows_init(void);\n void mainwindows_deinit(void);\n \n-MAIN_WINDOW_REC *mainwindow_create(void);\n+MAIN_WINDOW_REC *mainwindow_create(int);\n void mainwindow_destroy(MAIN_WINDOW_REC *window);\n \n void mainwindows_redraw(void);\n@@ -45,6 +57,7 @@ void mainwindows_recreate(void);\n    to be resized instead of upper window. */\n void mainwindow_set_size(MAIN_WINDOW_REC *window, int height,\n 			 int resize_lower);\n+void mainwindow_set_rsize(MAIN_WINDOW_REC *window, int width);\n void mainwindows_resize(int width, int height);\n \n void mainwindow_change_active(MAIN_WINDOW_REC *mainwin,\n@@ -56,5 +69,6 @@ int mainwindow_set_statusbar_lines(MAIN_WINDOW_REC *window,\n void mainwindows_redraw_dirty(void);\n \n GSList *mainwindows_get_sorted(int reverse);\n+GSList *mainwindows_get_line(MAIN_WINDOW_REC *rec);\n \n #endif\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','module-formats.c','66','0','2','2','MODIFY','@@ -41,8 +41,8 @@ FORMAT_REC gui_text_formats[] =\n 	{ \"refnum_not_found\", \"Window number $0 not found\", 1, { 0 } },\n 	{ \"window_too_small\", \"Not enough room to resize this window\", 0 },\n 	{ \"cant_hide_last\", \"You can\'t hide the last window\", 0 },\n-	{ \"cant_hide_sticky_windows\", \"You can\'t hide sticky windows (use /WINDOW STICK OFF)\", 0 },\n-	{ \"cant_show_sticky_windows\", \"You can\'t show sticky windows (use /WINDOW STICK OFF)\", 0 },\n+	{ \"cant_hide_sticky_windows\", \"You can\'t hide sticky windows (use /SET autounstick_windows ON)\", 0 },\n+	{ \"cant_show_sticky_windows\", \"You can\'t show sticky windows (use /SET autounstick_windows ON)\", 0 },\n 	{ \"window_not_sticky\", \"Window is not sticky\", 0 },\n 	{ \"window_set_sticky\", \"Window set sticky\", 0 },\n 	{ \"window_unset_sticky\", \"Window is not sticky anymore\", 0 },\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','statusbar-items.c','397','101','14','5','MODIFY','@@ -418,7 +418,7 @@ static void item_input(SBAR_ITEM_REC *item, int get_size_only)\n \n 	rec = g_hash_table_lookup(input_entries, item->bar->config->name);\n 	if (rec == NULL) {\n-		rec = gui_entry_create(item->xpos, item->bar->real_ypos,\n+		rec = gui_entry_create(ITEM_WINDOW_REAL_XPOS(item), item->bar->real_ypos,\n 				       item->size, term_type == TERM_TYPE_UTF8);\n 		gui_entry_set_active(rec);\n 		g_hash_table_insert(input_entries,\n@@ -426,12 +426,21 @@ static void item_input(SBAR_ITEM_REC *item, int get_size_only)\n 	}\n \n 	if (get_size_only) {\n-		item->min_size = 2+term_width/10;\n-                item->max_size = term_width;\n-                return;\n+		int max_width;\n+		WINDOW_REC *window;\n+\n+		window = item->bar->parent_window != NULL\n+			? item->bar->parent_window->active\n+			: NULL;\n+\n+		max_width = window != NULL ? window->width : term_width;\n+\n+		item->min_size = 2+max_width/10;\n+		item->max_size = max_width;\n+		return;\n 	}\n \n-	gui_entry_move(rec, item->xpos, item->bar->real_ypos,\n+	gui_entry_move(rec, ITEM_WINDOW_REAL_XPOS(item), item->bar->real_ypos,\n 		       item->size);\n 	gui_entry_redraw(rec); /* FIXME: this is only necessary with ^L.. */\n }\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','statusbar.c','896','203','53','19','MODIFY','@@ -242,17 +242,24 @@ static void statusbar_resize_items(STATUSBAR_REC *bar, int max_width)\n \n static void statusbar_calc_item_positions(STATUSBAR_REC *bar)\n {\n-        WINDOW_REC *old_active_win;\n+	WINDOW_REC *window;\n+	WINDOW_REC *old_active_win;\n 	GSList *tmp, *right_items;\n 	int xpos, rxpos;\n+	int max_width;\n \n 	old_active_win = active_win;\n-        if (bar->parent_window != NULL)\n+	if (bar->parent_window != NULL)\n 		active_win = bar->parent_window->active;\n \n-	statusbar_resize_items(bar, term_width);\n+	window = bar->parent_window != NULL\n+		? bar->parent_window->active\n+		: NULL;\n+\n+	max_width = window != NULL ? window->width : term_width;\n+	statusbar_resize_items(bar, max_width);\n \n-        /* left-aligned items */\n+	/* left-aligned items */\n 	xpos = 0;\n 	for (tmp = bar->items; tmp != NULL; tmp = tmp->next) {\n 		SBAR_ITEM_REC *rec = tmp->data;\n@@ -260,11 +267,11 @@ static void statusbar_calc_item_positions(STATUSBAR_REC *bar)\n 		if (!rec->config->right_alignment &&\n 		    (rec->size > 0 || rec->current_size > 0)) {\n 			if (SBAR_ITEM_REDRAW_NEEDED(bar, rec, xpos)) {\n-                                /* redraw the item */\n+				/* redraw the item */\n 				rec->dirty = TRUE;\n 				if (bar->dirty_xpos == -1 ||\n 				    xpos < bar->dirty_xpos) {\n-                                        irssi_set_dirty();\n+					irssi_set_dirty();\n 					bar->dirty = TRUE;\n 					bar->dirty_xpos = xpos;\n 				}\n@@ -277,12 +284,12 @@ static void statusbar_calc_item_positions(STATUSBAR_REC *bar)\n \n 	/* right-aligned items - first copy them to a new list backwards,\n 	   easier to draw them in right order */\n-        right_items = NULL;\n+	right_items = NULL;\n 	for (tmp = bar->items; tmp != NULL; tmp = tmp->next) {\n 		SBAR_ITEM_REC *rec = tmp->data;\n \n 		if (rec->config->right_alignment) {\n-                        if (rec->size > 0)\n+			if (rec->size > 0)\n 				right_items = g_slist_prepend(right_items, rec);\n 			else if (rec->current_size > 0 &&\n 				 (bar->dirty_xpos == -1 ||\n@@ -291,12 +298,12 @@ static void statusbar_calc_item_positions(STATUSBAR_REC *bar)\n 				   to begin from the item\'s old xpos */\n 				irssi_set_dirty();\n 				bar->dirty = TRUE;\n-                                bar->dirty_xpos = rec->xpos;\n+				bar->dirty_xpos = rec->xpos;\n 			}\n 		}\n 	}\n \n-	rxpos = term_width;\n+	rxpos = max_width;\n 	for (tmp = right_items; tmp != NULL; tmp = tmp->next) {\n 		SBAR_ITEM_REC *rec = tmp->data;\n \n@@ -312,7 +319,7 @@ static void statusbar_calc_item_positions(STATUSBAR_REC *bar)\n 			rec->xpos = rxpos;\n 		}\n 	}\n-        g_slist_free(right_items);\n+	g_slist_free(right_items);\n \n 	active_win = old_active_win;\n }\n@@ -451,8 +458,13 @@ static void mainwindow_recalc_ypos(MAIN_WINDOW_REC *window, int placement)\n \n static void sig_mainwindow_resized(MAIN_WINDOW_REC *window)\n {\n-        mainwindow_recalc_ypos(window, STATUSBAR_TOP);\n-        mainwindow_recalc_ypos(window, STATUSBAR_BOTTOM);\n+	GSList *tmp;\n+	mainwindow_recalc_ypos(window, STATUSBAR_TOP);\n+	mainwindow_recalc_ypos(window, STATUSBAR_BOTTOM);\n+	for (tmp = window->statusbars; tmp != NULL; tmp = tmp->next) {\n+		STATUSBAR_REC *bar = tmp->data;\n+		statusbar_redraw(bar, TRUE);\n+	}\n }\n \n STATUSBAR_REC *statusbar_create(STATUSBAR_GROUP_REC *group,\n@@ -728,7 +740,7 @@ void statusbar_item_default_handler(SBAR_ITEM_REC *item, int get_size_only,\n 				g_string_append_c(out, \' \');\n 		}\n \n-		gui_printtext(item->xpos, item->bar->real_ypos, out->str);\n+		gui_printtext(ITEM_WINDOW_REAL_XPOS(item), item->bar->real_ypos, out->str);\n 		g_string_free(out, TRUE);\n 	}\n 	g_free(tmpstr);\n@@ -960,20 +972,42 @@ void statusbar_item_destroy(SBAR_ITEM_REC *item)\n 	g_free(item);\n }\n \n+static MAIN_WINDOW_BORDER_REC *set_border_info(STATUSBAR_REC *bar)\n+{\n+	MAIN_WINDOW_BORDER_REC *orig_border, *new_border;\n+	orig_border = clrtoeol_info;\n+	new_border = g_new0(MAIN_WINDOW_BORDER_REC, 1);\n+	new_border->window = bar->parent_window != NULL ? bar->parent_window->screen_win : NULL;\n+	new_border->color = bar->color;\n+	clrtoeol_info = new_border;\n+	return orig_border;\n+}\n+\n+static void restore_border_info(MAIN_WINDOW_BORDER_REC *border_info)\n+{\n+	MAIN_WINDOW_BORDER_REC *old_border;\n+	old_border = clrtoeol_info;\n+	clrtoeol_info = border_info;\n+	g_free(old_border);\n+}\n+\n static void statusbar_redraw_needed_items(STATUSBAR_REC *bar)\n {\n-        WINDOW_REC *old_active_win;\n+	WINDOW_REC *old_active_win;\n 	GSList *tmp;\n 	char *str;\n \n 	old_active_win = active_win;\n-        if (bar->parent_window != NULL)\n+	if (bar->parent_window != NULL)\n 		active_win = bar->parent_window->active;\n \n 	if (bar->dirty_xpos >= 0) {\n+		MAIN_WINDOW_BORDER_REC *orig_border;\n+		orig_border = set_border_info(bar);\n 		str = g_strconcat(bar->color, \"%>\", NULL);\n-		gui_printtext(bar->dirty_xpos, bar->real_ypos, str);\n+		gui_printtext(BAR_WINDOW_REAL_DIRTY_XPOS(bar), bar->real_ypos, str);\n 		g_free(str);\n+		restore_border_info(orig_border);\n 	}\n \n 	for (tmp = bar->items; tmp != NULL; tmp = tmp->next) {\n@@ -982,13 +1016,13 @@ static void statusbar_redraw_needed_items(STATUSBAR_REC *bar)\n 		if (rec->dirty ||\n 		    (bar->dirty_xpos != -1 &&\n 		     rec->xpos >= bar->dirty_xpos)) {\n-                        rec->current_size = rec->size;\n+			rec->current_size = rec->size;\n 			rec->func(rec, FALSE);\n 			rec->dirty = FALSE;\n 		}\n 	}\n \n-        active_win = old_active_win;\n+	active_win = old_active_win;\n }\n \n void statusbar_redraw_dirty(void)\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','statusbar.h','63','0','6','0','MODIFY','@@ -23,6 +23,12 @@ typedef struct SBAR_ITEM_REC SBAR_ITEM_REC;\n #define STATUSBAR_VISIBLE_ACTIVE        2\n #define STATUSBAR_VISIBLE_INACTIVE      3\n \n+#define ITEM_WINDOW_REAL_XPOS(item) ( ( (item)->bar->parent_window != NULL ? \\\n+					(item)->bar->parent_window->first_column + (item)->bar->parent_window->statusbar_columns_left : 0 ) + (item)->xpos )\n+\n+#define BAR_WINDOW_REAL_DIRTY_XPOS(bar) ( ( (bar)->parent_window != NULL ? \\\n+					    (bar)->parent_window->first_column + (bar)->parent_window->statusbar_columns_left : 0 ) + (bar)->dirty_xpos )\n+\n typedef struct {\n 	char *name;\n         GSList *config_bars;\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','term-terminfo.c','555','175','52','25','MODIFY','@@ -23,6 +23,7 @@\n #include \"term.h\"\n #include \"terminfo-core.h\"\n #include \"fe-windows.h\"\n+#include \"gui-printtext.h\"\n #include \"utf8.h\"\n \n #include <signal.h>\n@@ -284,10 +285,10 @@ void term_window_clear(TERM_WINDOW *window)\n {\n 	int y;\n \n-        terminfo_set_normal();\n-        if (window->y == 0 && window->height == term_height) {\n-        	term_clear();\n-        } else {\n+	terminfo_set_normal();\n+	if (window->y == 0 && window->height == term_height && window->width == term_width) {\n+		term_clear();\n+	} else {\n 		for (y = 0; y < window->height; y++) {\n 			term_move(window, 0, y);\n 			term_clrtoeol(window);\n@@ -452,14 +453,14 @@ void term_set_color(TERM_WINDOW *window, int col)\n void term_move(TERM_WINDOW *window, int x, int y)\n {\n 	if (x >= 0 && y >= 0) {\n-	vcmove = TRUE;\n-	vcx = x+window->x;\n-        vcy = y+window->y;\n-\n-	if (vcx >= term_width)\n-		vcx = term_width-1;\n-	if (vcy >= term_height)\n-                vcy = term_height-1;\n+		vcmove = TRUE;\n+		vcx = x+window->x;\n+		vcy = y+window->y;\n+\n+		if (vcx >= term_width)\n+			vcx = term_width-1;\n+		if (vcy >= term_height)\n+			vcy = term_height-1;\n 	}\n }\n \n@@ -552,7 +553,7 @@ int term_addstr(TERM_WINDOW *window, const char *str)\n 		while (*ptr != \'\\0\') {\n 			tmp = g_utf8_get_char_validated(ptr, -1);\n 			/* On utf8 error, treat as single byte and try to\n-			   continue interpretting rest of string as utf8 */\n+			   continue interpreting rest of string as utf8 */\n 			if (tmp == (gunichar)-1 || tmp == (gunichar)-2) {\n 				len++;\n 				ptr++;\n@@ -574,23 +575,49 @@ int term_addstr(TERM_WINDOW *window, const char *str)\n \n void term_clrtoeol(TERM_WINDOW *window)\n {\n-	/* clrtoeol() doesn\'t necessarily understand colors */\n-	if (last_fg == -1 && last_bg == -1 &&\n-	    (last_attrs & (ATTR_UNDERLINE|ATTR_REVERSE|ATTR_ITALIC)) == 0) {\n-		if (!term_lines_empty[vcy]) {\n-			if (vcmove) term_move_real();\n-			terminfo_clrtoeol();\n-			if (vcx == 0) term_lines_empty[vcy] = TRUE;\n-		}\n-	} else if (vcx < term_width) {\n-		/* we\'ll need to fill the line ourself. */\n+	if (vcx < window->x) {\n+		/* we just wrapped outside of the split, put the cursor back into the window */\n+		vcx += window->x;\n+	}\n+	if (window->x + window->width < term_width) {\n+		/* we need to fill a vertical split */\n 		if (vcmove) term_move_real();\n-		terminfo_repeat(\' \', term_width-vcx);\n+		terminfo_repeat(\' \', window->x + window->width - vcx + 1);\n 		terminfo_move(vcx, vcy);\n-                term_lines_empty[vcy] = FALSE;\n+		term_lines_empty[vcy] = FALSE;\n+	} else {\n+		/* clrtoeol() doesn\'t necessarily understand colors */\n+		if (last_fg == -1 && last_bg == -1 &&\n+		    (last_attrs & (ATTR_UNDERLINE|ATTR_REVERSE|ATTR_ITALIC)) == 0) {\n+			if (!term_lines_empty[vcy]) {\n+				if (vcmove) term_move_real();\n+				terminfo_clrtoeol();\n+				if (vcx == 0) term_lines_empty[vcy] = TRUE;\n+			}\n+		} else if (vcx < term_width) {\n+			/* we\'ll need to fill the line ourself. */\n+			if (vcmove) term_move_real();\n+			terminfo_repeat(\' \', term_width-vcx);\n+			terminfo_move(vcx, vcy);\n+			term_lines_empty[vcy] = FALSE;\n+		}\n 	}\n }\n \n+void term_window_clrtoeol(TERM_WINDOW* window, int ypos)\n+{\n+	term_clrtoeol(window);\n+	if (window->x + window->width < term_width) {\n+		gui_printtext_window_border(window->x + window->width, window->y + ypos);\n+		term_set_color(window, ATTR_RESET);\n+	}\n+}\n+\n+void term_window_clrtoeol_abs(TERM_WINDOW* window, int ypos)\n+{\n+	term_window_clrtoeol(window, ypos - window->y);\n+}\n+\n void term_move_cursor(int x, int y)\n {\n 	curs_x = x;\n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','term.h','43','0','2','0','MODIFY','@@ -85,6 +85,8 @@ void term_addch(TERM_WINDOW *window, char chr);\n void term_add_unichar(TERM_WINDOW *window, unichar chr);\n int  term_addstr(TERM_WINDOW *window, const char *str);\n void term_clrtoeol(TERM_WINDOW *window);\n+void term_window_clrtoeol(TERM_WINDOW* window, int ypos);\n+void term_window_clrtoeol_abs(TERM_WINDOW* window, int ypos_abs);\n \n void term_move_cursor(int x, int y);\n \n','false','false','none'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','textbuffer-view.c','1051','256','68','52','MODIFY','@@ -388,9 +388,9 @@ static void view_reset_cache(TEXT_BUFFER_VIEW_REC *view)\n static int view_line_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n 			  int subline, int ypos, int max)\n {\n-        INDENT_FUNC indent_func;\n+	INDENT_FUNC indent_func;\n 	LINE_CACHE_REC *cache;\n-        const unsigned char *text, *end, *text_newline;\n+	const unsigned char *text, *end, *text_newline;\n 	unsigned char *tmp;\n 	unichar chr;\n 	int xpos, color, drawcount, first, need_move, need_clrtoeol, char_width;\n@@ -399,54 +399,54 @@ static int view_line_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n #endif\n \n 	if (view->dirty) /* don\'t bother drawing anything - redraw is coming */\n-                return 0;\n+		return 0;\n \n 	cache = textbuffer_view_get_line_cache(view, line);\n 	if (subline >= cache->count)\n-                return 0;\n+		return 0;\n \n-        color = ATTR_RESET;\n-        need_move = TRUE; need_clrtoeol = FALSE;\n+	color = ATTR_RESET;\n+	need_move = TRUE; need_clrtoeol = FALSE;\n 	xpos = drawcount = 0; first = TRUE;\n 	text_newline = text =\n 		subline == 0 ? line->text : cache->lines[subline-1].start;\n 	for (;;) {\n 		if (text == text_newline) {\n-			if (need_clrtoeol && xpos < term_width) {\n+			if (need_clrtoeol && xpos < view->width + (view->width == term_width ? 0 : 1)) {\n 				term_set_color(view->window, ATTR_RESET);\n-				term_clrtoeol(view->window);\n+				term_window_clrtoeol(view->window, ypos);\n 			}\n \n 			if (first)\n 				first = FALSE;\n 			else {\n 				ypos++;\n-                                if (--max == 0)\n+				if (--max == 0)\n 					break;\n 			}\n \n 			if (subline > 0) {\n-                                /* continuing previous line - indent it */\n+				/* continuing previous line - indent it */\n 				indent_func = cache->lines[subline-1].indent_func;\n 				if (indent_func == NULL)\n 					xpos = cache->lines[subline-1].indent;\n-                                color = cache->lines[subline-1].color;\n+				color = cache->lines[subline-1].color;\n #ifdef TERM_TRUECOLOR\n-                                fg24 = cache->lines[subline-1].fg24;\n-                                bg24 = cache->lines[subline-1].bg24;\n+				fg24 = cache->lines[subline-1].fg24;\n+				bg24 = cache->lines[subline-1].bg24;\n #endif\n 			} else {\n 				indent_func = NULL;\n 			}\n \n 			if (xpos == 0 && indent_func == NULL)\n-                                need_clrtoeol = TRUE;\n+				need_clrtoeol = TRUE;\n 			else {\n 				/* line was indented - need to clear the\n-                                   indented area first */\n+				   indented area first */\n 				term_set_color(view->window, ATTR_RESET);\n 				term_move(view->window, 0, ypos);\n-				term_clrtoeol(view->window);\n+				term_window_clrtoeol(view->window, ypos);\n \n 				if (indent_func != NULL)\n 					xpos = indent_func(view, line, ypos);\n@@ -463,9 +463,17 @@ static int view_line_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n 			} else {\n 				/* get the beginning of the next subline */\n 				text_newline = cache->lines[subline].start;\n-				need_move = !cache->lines[subline].continues;\n+				if (view->width == term_width) {\n+					/* ensure that links / long words are not broken */\n+					need_move = !cache->lines[subline].continues;\n+				} else {\n+					/* we cannot use the need_move\n+					   optimisation unless the split spans\n+					   the whole width */\n+					need_move = TRUE;\n+				}\n 			}\n-                        drawcount++;\n+			drawcount++;\n 			subline++;\n 		}\n \n@@ -473,10 +481,10 @@ static int view_line_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n 			/* command */\n 			text++;\n 			if (*text == LINE_CMD_EOL)\n-                                break;\n+				break;\n \n 			if (*text == LINE_CMD_CONTINUE) {\n-                                /* jump to next block */\n+				/* jump to next block */\n 				memcpy(&tmp, text+1, sizeof(unsigned char *));\n 				text = tmp;\n 				continue;\n@@ -511,13 +519,13 @@ static int view_line_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n 		}\n \n 		xpos += char_width;\n-		if (xpos <= term_width) {\n+		if (xpos <= view->width) {\n 			if (unichar_isprint(chr)) {\n 				if (view->utf8)\n-				term_add_unichar(view->window, chr);\n+					term_add_unichar(view->window, chr);\n 				else\n-				for (; text < end; text++)\n-					term_addch(view->window, *text);\n+					for (; text < end; text++)\n+						term_addch(view->window, *text);\n 			} else {\n 				/* low-ascii */\n 				term_set_color(view->window, ATTR_RESET|ATTR_REVERSE);\n@@ -528,12 +536,12 @@ static int view_line_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n 		text = end;\n 	}\n \n-	if (need_clrtoeol && xpos < term_width) {\n+	if (need_clrtoeol && xpos < view->width + (view->width == term_width ? 0 : 1)) {\n 		term_set_color(view->window, ATTR_RESET);\n-		term_clrtoeol(view->window);\n+		term_window_clrtoeol(view->window, ypos);\n 	}\n \n-        return drawcount;\n+	return drawcount;\n }\n \n /* Recalculate view\'s bottom line information - try to keep the\n@@ -738,7 +746,7 @@ static void view_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,\n 		term_set_color(view->window, ATTR_RESET);\n 		while (lines > 0) {\n 			term_move(view->window, 0, ypos);\n-			term_clrtoeol(view->window);\n+			term_window_clrtoeol(view->window, ypos);\n 			ypos++; lines--;\n 		}\n 	}\n@@ -775,51 +783,51 @@ static int view_scroll(TEXT_BUFFER_VIEW_REC *view, LINE_REC **lines,\n 	int linecount, realcount, scroll_visible;\n \n 	if (*lines == NULL)\n-                return 0;\n+		return 0;\n \n 	/* scroll down */\n 	scroll_visible = lines == &view->startline;\n \n 	realcount = -*subline;\n 	scrollcount += *subline;\n-        *subline = 0;\n+	*subline = 0;\n 	while (scrollcount > 0) {\n 		linecount = view_get_linecount(view, *lines);\n \n 		if ((scroll_visible && *lines == view->bottom_startline) &&\n 		    (scrollcount >= view->bottom_subline)) {\n 			*subline = view->bottom_subline;\n-                        realcount += view->bottom_subline;\n-                        scrollcount = 0;\n-                        break;\n+			realcount += view->bottom_subline;\n+			scrollcount = 0;\n+			break;\n 		}\n \n-                realcount += linecount;\n+		realcount += linecount;\n 		scrollcount -= linecount;\n 		if (scrollcount < 0) {\n-                        realcount += scrollcount;\n+			realcount += scrollcount;\n 			*subline = linecount+scrollcount;\n-                        scrollcount = 0;\n-                        break;\n+			scrollcount = 0;\n+			break;\n 		}\n \n 		if ((*lines)->next == NULL)\n 			break;\n \n-                *lines = (*lines)->next;\n+		*lines = (*lines)->next;\n 	}\n \n-        /* scroll up */\n+	/* scroll up */\n 	while (scrollcount < 0 && (*lines)->prev != NULL) {\n 		*lines = (*lines)->prev;\n 		linecount = view_get_linecount(view, *lines);\n \n-                realcount -= linecount;\n+		realcount -= linecount;\n 		scrollcount += linecount;\n 		if (scrollcount > 0) {\n-                        realcount += scrollcount;\n+			realcount += scrollcount;\n 			*subline = scrollcount;\n-                        break;\n+			break;\n 		}\n 	}\n \n@@ -827,19 +835,27 @@ static int view_scroll(TEXT_BUFFER_VIEW_REC *view, LINE_REC **lines,\n 		if (realcount <= -view->height || realcount >= view->height) {\n 			/* scrolled more than screenful, redraw the\n 			   whole view */\n-                        textbuffer_view_redraw(view);\n+			textbuffer_view_redraw(view);\n 		} else {\n-			term_set_color(view->window, ATTR_RESET);\n-			term_window_scroll(view->window, realcount);\n+			if (view->width == term_width) {\n+				/* we can try to use vt100 scroll regions */\n+				term_set_color(view->window, ATTR_RESET);\n+				term_window_scroll(view->window, realcount);\n \n-			if (draw_nonclean) {\n-				if (realcount < 0)\n-                                        view_draw_top(view, -realcount, TRUE);\n-				else\n-					view_draw_bottom(view, realcount);\n-			}\n+				if (draw_nonclean) {\n+					if (realcount < 0)\n+						view_draw_top(view, -realcount, TRUE);\n+					else\n+						view_draw_bottom(view, realcount);\n+				}\n \n-			term_refresh(view->window);\n+				term_refresh(view->window);\n+			} else {\n+				/* do not bother with vt400 scroll\n+				   rectangles for now, redraw the\n+				   whole view */\n+				textbuffer_view_redraw(view);\n+			}\n 		}\n 	}\n \n','false','true','term_truecolor'),('irssi','1.0.6','4e71a1f485d9a546cb92ad94e8918a2363a88b03','ailin-nemui','sideways split support for irssi\n\nwarning:\n\n* may be buggy\n\nthis commit adds support for sideways splits into irssi. to that regard,\nthere are a number of new commands available\n\nthe \"r\" commands:\n	/window new rsplit - make a new sideways split\n	/window rshow - show an existing window to the right\n	/window rgrow/rshrink/rsize/rbalance\n	 - manipulate the size of your sideways split windows\n\nthe \"d\" commands:\n	/window dup/ddown/dleft/dright\n	 - navigate the windows directionally, as an alternative to\n	   /window up/down that you can bind to some key\n	/window move dleft/dright - the same for moving\n\nenjoy!','default.theme','241','0','1','0','MODIFY','@@ -251,6 +251,7 @@ abstracts = {\n   # default background for all statusbars. You can also give\n   # the default foreground color for statusbar items.\n   sb_background = \"%4%w\";\n+  window_border = \"%4%w\";\n \n   # default backround for \"default\" statusbar group\n   #sb_default_bg = \"%4\";\n','false','false','none'),('irssi','1.0.6','63d8e884ddb970d6a8b5c6a7a546f0283d38a055','ailin-nemui','fix some more','term-terminfo.c','559','177','6','1','MODIFY','@@ -576,8 +576,9 @@ int term_addstr(TERM_WINDOW *window, const char *str)\n void term_clrtoeol(TERM_WINDOW *window)\n {\n 	if (vcx < window->x) {\n-		/* we just wrapped outside of the split, put the cursor back into the window */\n+		/* we just wrapped outside of the split, warp the cursor back into the window */\n 		vcx += window->x;\n+		vcmove = TRUE;\n 	}\n 	if (window->x + window->width < term_width) {\n 		/* we need to fill a vertical split */\n@@ -606,6 +607,10 @@ void term_clrtoeol(TERM_WINDOW *window)\n \n void term_window_clrtoeol(TERM_WINDOW* window, int ypos)\n {\n+	if (ypos >= 0 && window->y + ypos != vcy) {\n+		/* the line is already full */\n+		return;\n+	}\n 	term_clrtoeol(window);\n 	if (window->x + window->width < term_width) {\n 		gui_printtext_window_border(window->x + window->width, window->y + ypos);\n','true','false','none'),('irssi','1.0.6','ded4e4d98df3c8df20119574c145fe1a736ee994','ailin-nemui','fix redraw','mainwindows.c','1463','354','2','0','MODIFY','@@ -1214,6 +1214,8 @@ void mainwindows_redraw_dirty(void)\n 		if (rec->dirty) {\n                         rec->dirty = FALSE;\n 			gui_window_redraw(rec->active);\n+		} else if (WINDOW_GUI(rec->active)->view->dirty) {\n+			gui_window_redraw(rec->active);\n 		}\n 	}\n }\n','true','false','none'),('irssi','1.0.6','ded4e4d98df3c8df20119574c145fe1a736ee994','ailin-nemui','fix redraw','textbuffer-view.c','1052','256','2','1','MODIFY','@@ -854,7 +854,8 @@ static int view_scroll(TEXT_BUFFER_VIEW_REC *view, LINE_REC **lines,\n 				/* do not bother with vt400 scroll\n 				   rectangles for now, redraw the\n 				   whole view */\n-				textbuffer_view_redraw(view);\n+				view->dirty = TRUE;\n+				irssi_set_dirty();\n 			}\n 		}\n 	}\n','true','false','none'),('irssi','1.0.6','4d5982f07d7f32585c00f1d6cca3fb425183140f','ailin-nemui','update fe-common-core.c','fe-common-core.c','392','62','9','6','MODIFY','@@ -475,26 +475,29 @@ gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)\n 		return FALSE;\n 	}\n \n-	int server_tag_len = dest->server_tag ? strlen(dest->server_tag) : 0;\n+	int server_tag_len = dest->server_tag != NULL ? strlen(dest->server_tag) : 0;\n 	for (tmp = array; *tmp != NULL; tmp++) {\n 		char *str = *tmp;\n 		if (*str == \'\\0\') {\n 			continue;\n 		}\n \n-		if (server_tag_len && !g_ascii_strncasecmp(str, dest->server_tag, server_tag_len) && str[server_tag_len] == \'/\') {\n+		if (server_tag_len &&\n+		    g_ascii_strncasecmp(str, dest->server_tag, server_tag_len) == 0 &&\n+		    str[server_tag_len] == \'/\') {\n 			str += server_tag_len + 1;\n 		}\n \n-		if (!g_strcmp0(str, \"\") || !g_strcmp0(str, \"::all\")) {\n+		if (g_strcmp0(str, \"\") == 0 || g_strcmp0(str, \"::all\") == 0) {\n 			return TRUE;\n-		} else if (!g_ascii_strcasecmp(str, dest->target)) {\n+		} else if (g_ascii_strcasecmp(str, dest->target) == 0) {\n 			return TRUE;\n 		} else if (item->type == query_type &&\n-			!g_strcmp0(str, (dest->target[0] == \'=\') ? \"::dccqueries\" : \"::queries\")) {\n+		           g_strcmp0(str, dest->target[0] == \'=\' ? \"::dccqueries\" :\n+			             \"::queries\") == 0) {\n 			return TRUE;\n 		} else if (item->type == channel_type &&\n-			!g_strcmp0(str, \"::channels\")) {\n+			   g_strcmp0(str, \"::channels\") == 0) {\n 			return TRUE;\n 		}\n 	}\n','false','true','none'),('irssi','1.0.6','121a4971e61176e326ee3d2f71867e87732f4519','ailin-nemui','update fe-common-core.c\n\nfix mixed decls','fe-common-core.c','394','62','6','3','MODIFY','@@ -461,16 +461,19 @@ void fe_common_core_finish_init(void)\n \n gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)\n {\n-	int channel_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"CHANNEL\");\n-	int query_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"QUERY\");\n+	WI_ITEM_REC *item;\n+	int server_tag_len, channel_type, query_type;\n 	char **tmp;\n \n+	channel_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"CHANNEL\");\n+	query_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"QUERY\");\n+\n 	g_return_val_if_fail(array != NULL, FALSE);\n 	g_return_val_if_fail(dest != NULL, FALSE);\n 	g_return_val_if_fail(dest->window != NULL, FALSE);\n 	g_return_val_if_fail(dest->target != NULL, FALSE);\n \n-	WI_ITEM_REC *item = window_item_find_window(dest->window, dest->server, dest->target);\n+	item = window_item_find_window(dest->window, dest->server, dest->target);\n 	if (item == NULL) {\n 		return FALSE;\n 	}\n','false','false','none'),('irssi','1.0.6','0aafd011c0adc58ddf43783764b96fdd74578243','dequis','add a startup warning if the term var is wrong inside tmux/screen\n\none of the most common and confusing issues we get in #irssi,\nthis should help identifying and mitigating it.','irssi.c','225','30','2','0','MODIFY','@@ -207,6 +207,8 @@ static void textui_finish_init(void)\n 		fe_settings_set_print(\"nick\");\n 	if (user_settings_changed & USER_SETTINGS_HOSTNAME)\n 		fe_settings_set_print(\"hostname\");\n+\n+	term_environment_check();\n }\n \n static void textui_deinit(void)\n','false','false','none'),('irssi','1.0.6','0aafd011c0adc58ddf43783764b96fdd74578243','dequis','add a startup warning if the term var is wrong inside tmux/screen\n\none of the most common and confusing issues we get in #irssi,\nthis should help identifying and mitigating it.','term-terminfo.c','553','177','28','0','MODIFY','@@ -733,3 +733,31 @@ void term_gets(GArray *buffer, int *line_count)\n 		}\n 	}\n }\n+\n+static const char* term_env_warning =\n+	\"The TERM environment variable is set to \'%s\' which can cause display \"\n+	\"glitches when running under %s.\\n\"\n+	\"Consider changing TERM to \'screen\' or \'screen-256color\' instead.\";\n+\n+void term_environment_check(void)\n+{\n+	const char *term, *sty, *tmux, *multiplexer;\n+\n+	term = g_getenv(\"TERM\");\n+	sty = g_getenv(\"STY\");\n+	tmux = g_getenv(\"TMUX\");\n+\n+	multiplexer = (sty && *sty) ? \"screen\" :\n+	              (tmux && *tmux) ? \"tmux\" : NULL;\n+\n+	if (!multiplexer) {\n+		return;\n+	}\n+\n+	if (term && (g_str_has_prefix(term, \"screen\") ||\n+	             g_str_has_prefix(term, \"tmux\"))) {\n+		return;\n+	}\n+\n+	g_warning(term_env_warning, term, multiplexer);\n+}\n','false','false','none'),('irssi','1.0.6','0aafd011c0adc58ddf43783764b96fdd74578243','dequis','add a startup warning if the term var is wrong inside tmux/screen\n\none of the most common and confusing issues we get in #irssi,\nthis should help identifying and mitigating it.','term.h','42','0','2','0','MODIFY','@@ -105,4 +105,6 @@ void term_gets(GArray *buffer, int *line_count);\n void term_common_init(void);\n void term_common_deinit(void);\n \n+void term_environment_check(void);\n+\n #endif\n','false','false','none'),('irssi','1.0.6','f9c8365999c5319be6970dcf27f21190b0481314','dequis','fe-common-core: fix redeclaration of server_tag_len','fe-common-core.c','394','62','1','1','MODIFY','@@ -478,7 +478,7 @@ gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)\n 		return FALSE;\n 	}\n \n-	int server_tag_len = dest->server_tag != NULL ? strlen(dest->server_tag) : 0;\n+	server_tag_len = dest->server_tag != NULL ? strlen(dest->server_tag) : 0;\n 	for (tmp = array; *tmp != NULL; tmp++) {\n 		char *str = *tmp;\n 		if (*str == \'\\0\') {\n','true','false','none'),('irssi','1.0.6','0d5e353ef1be253106ed66417b270d03b2b91ed3','ailin-nemui','reword warning message\n\ninclude multiplexer name in term recommendation','term-terminfo.c','553','177','3','3','MODIFY','@@ -735,9 +735,9 @@ void term_gets(GArray *buffer, int *line_count)\n }\n \n static const char* term_env_warning =\n-	\"The TERM environment variable is set to \'%s\' which can cause display \"\n-	\"glitches when running under %s.\\n\"\n-	\"Consider changing TERM to \'screen\' or \'screen-256color\' instead.\";\n+	\"You seem to be running Irssi inside %2$s, but the TERM environment variable\"\n+	\"is set to \'%1$s\', which can cause display glitches.\\n\"\n+	\"Consider changing TERM to \'%2$s\' or \'%2$s-256color\' instead.\";\n \n void term_environment_check(void)\n {\n','false','true','none'),('irssi','1.0.6','98836f8b7ee058c32d54562903676c4d16f83aa4','LemonBoy','parse the k/v form in cap ls\n\nthis is a prerequisite for the irc v3.2 compliance.','irc-cap.c','148','40','39','4','MODIFY','@@ -45,7 +45,7 @@ int cap_toggle (IRC_SERVER_REC *server, char *cap, int enable)\n \n 	if (enable && !gslist_find_string(server->cap_active, cap)) {\n 		/* Make sure the required cap is supported by the server */\n-		if (!gslist_find_string(server->cap_supported, cap))\n+		if (!g_hash_table_lookup_extended(server->cap_supported, cap, NULL, NULL))\n 			return FALSE;\n \n 		irc_send_cmdv(server, \"CAP REQ %s\", cap);\n@@ -96,9 +96,44 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 	caps_length = g_strv_length(caps);\n \n 	if (!g_strcmp0(evt, \"LS\")) {\n+		if (server->cap_supported) {\n+			g_hash_table_destroy(server->cap_supported);\n+		}\n+		/* Start with a fresh table */\n+		server->cap_supported = g_hash_table_new_full(g_str_hash,\n+							      g_str_equal,\n+							      g_free, g_free);\n+\n 		/* Create a list of the supported caps */\n-		for (i = 0; i < caps_length; i++)\n-			server->cap_supported = g_slist_prepend(server->cap_supported, g_strdup(caps[i]));\n+		for (i = 0; i < caps_length; i++) {\n+			const char *name = caps[i];\n+			const char *eq = strchr(name, \'=\');\n+			int fresh = TRUE;\n+\n+			if (!eq) {\n+				fresh = g_hash_table_insert(server->cap_supported,\n+							    g_strdup(name),\n+							    NULL);\n+			}\n+			/* Some values are in a KEY=VALUE form, parse them */\n+			else if (eq[1] != \'\\0\') {\n+				char *key = g_strndup(name, (int)(eq - name));\n+				char *val = g_strdup(eq + 1);\n+				fresh = g_hash_table_insert(server->cap_supported,\n+							    key, val);\n+			}\n+			/* If the string ends after the \'=\' consider the value\n+			 * as invalid */\n+			else {\n+				g_warning(\"Invalid CAP key/value pair\");\n+			}\n+\n+			/* The specification doesn\'t say anything about\n+			 * duplicated values, let\'s just warn the user */\n+			if (fresh == FALSE) {\n+				g_warning(\"Duplicate value\");\n+			}\n+		}\n \n 		/* Request the required caps, if any */\n 		if (server->cap_queue == NULL) {\n@@ -111,7 +146,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n \n 			/* Check whether the cap is supported by the server */\n 			for (tmp = server->cap_queue; tmp != NULL; tmp = tmp->next) {\n-				if (gslist_find_string(server->cap_supported, tmp->data)) {\n+				if (g_hash_table_lookup_extended(server->cap_supported, tmp->data, NULL, NULL)) {\n 					if (avail_caps > 0)\n 						g_string_append_c(cmd, \' \');\n 					g_string_append(cmd, tmp->data);\n','false','false','none'),('irssi','1.0.6','98836f8b7ee058c32d54562903676c4d16f83aa4','LemonBoy','parse the k/v form in cap ls\n\nthis is a prerequisite for the irc v3.2 compliance.','irc-servers.c','780','195','1','1','MODIFY','@@ -443,7 +443,7 @@ static void sig_disconnected(IRC_SERVER_REC *server)\n 	gslist_free_full(server->cap_active, (GDestroyNotify) g_free);\n 	server->cap_active = NULL;\n \n-	gslist_free_full(server->cap_supported, (GDestroyNotify) g_free);\n+	g_hash_table_destroy(server->cap_supported);\n 	server->cap_supported = NULL;\n \n 	gslist_free_full(server->cap_queue, (GDestroyNotify) g_free);\n','false','false','none'),('irssi','1.0.6','98836f8b7ee058c32d54562903676c4d16f83aa4','LemonBoy','parse the k/v form in cap ls\n\nthis is a prerequisite for the irc v3.2 compliance.','irc-servers.h','81','0','1','1','MODIFY','@@ -75,7 +75,7 @@ struct _IRC_SERVER_REC {\n 	int max_whois_in_cmd; /* max. number of nicks in one /WHOIS command */\n 	int max_msgs_in_cmd; /* max. number of targets in one /MSG */\n \n-	GSList *cap_supported; /* A list of caps supported by the server */\n+	GHashTable *cap_supported; /* A list of caps supported by the server */\n 	GSList *cap_active;    /* A list of caps active for this session */\n 	GSList *cap_queue;     /* A list of caps to request on connection */ \n \n','false','false','none'),('irssi','1.0.6','98836f8b7ee058c32d54562903676c4d16f83aa4','LemonBoy','parse the k/v form in cap ls\n\nthis is a prerequisite for the irc v3.2 compliance.','Irc.xs','208','18','11','4','MODIFY','@@ -12,7 +12,10 @@ static void perl_irc_connect_fill_hash(HV *hv, IRC_SERVER_CONNECT_REC *conn)\n static void perl_irc_server_fill_hash(HV *hv, IRC_SERVER_REC *server)\n {\n 	AV *av;\n+	HV *hv_;\n 	GSList *tmp;\n+	GHashTableIter iter;\n+	gpointer key_, val_;\n \n 	perl_irc_connect_fill_hash(hv, server->connrec);\n 	perl_server_fill_hash(hv, (SERVER_REC *) server);\n@@ -34,10 +37,14 @@ static void perl_irc_server_fill_hash(HV *hv, IRC_SERVER_REC *server)\n 	(void) hv_store(hv, \"cap_complete\", 12, newSViv(server->cap_complete), 0);\n 	(void) hv_store(hv, \"sasl_success\", 12, newSViv(server->sasl_success), 0);\n \n-	av = newAV();\n-	for (tmp = server->cap_supported; tmp != NULL; tmp = tmp->next)\n-		av_push(av, new_pv(tmp->data));\n-	(void) hv_store(hv, \"cap_supported\", 13, newRV_noinc((SV*)av), 0);\n+	hv_ = newHV();\n+	g_hash_table_iter_init(&iter, server->cap_supported);\n+	while (g_hash_table_iter_next(&iter, &key_, &val_)) {\n+		char *key = (char *)key_;\n+		char *val = (char *)val_;\n+		hv_store(hv_, key, strlen(key), new_pv(val), 0);\n+	}\n+	(void) hv_store(hv, \"cap_supported\", 13, newRV_noinc((SV*)hv_), 0);\n \n 	av = newAV();\n 	for (tmp = server->cap_active; tmp != NULL; tmp = tmp->next)\n','false','false','none'),('irssi','1.0.6','d21706e1cc78284d5e7b2d69ebe4873e459d0e9b','LemonBoy','factor out the parsing function\n\nthis is also needed for cap new and cap del.','irc-cap.c','159','42','36','22','MODIFY','@@ -79,6 +79,33 @@ static void cap_emit_signal (IRC_SERVER_REC *server, char *cmd, char *args)\n 	g_free(signal_name);\n }\n \n+static gboolean parse_cap_name(char *name, char **key, char **val)\n+{\n+	g_return_val_if_fail(name != NULL, FALSE);\n+	g_return_val_if_fail(name[0] != \'\\0\', FALSE);\n+\n+	const char *eq = strchr(name, \'=\');\n+	/* KEY only value */\n+	if (!eq) {\n+		*key = g_strdup(name);\n+		*val = NULL;\n+		return TRUE;\n+	}\n+	/* Some values are in a KEY=VALUE form, parse them */\n+	else if (eq[1] != \'\\0\') {\n+		*key = g_strndup(name, (int)(eq - name));\n+		*val = g_strdup(eq + 1);\n+		return TRUE;\n+	}\n+	/* If the string ends after the \'=\' consider the value\n+	 * as invalid */\n+	else {\n+		*key = NULL;\n+		*val = NULL;\n+		return FALSE;\n+	}\n+}\n+\n static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *address)\n {\n 	GSList *tmp;\n@@ -106,33 +133,20 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n \n 		/* Create a list of the supported caps */\n 		for (i = 0; i < caps_length; i++) {\n-			const char *name = caps[i];\n-			const char *eq = strchr(name, \'=\');\n-			int fresh = TRUE;\n-\n-			if (!eq) {\n-				fresh = g_hash_table_insert(server->cap_supported,\n-							    g_strdup(name),\n-							    NULL);\n-			}\n-			/* Some values are in a KEY=VALUE form, parse them */\n-			else if (eq[1] != \'\\0\') {\n-				char *key = g_strndup(name, (int)(eq - name));\n-				char *val = g_strdup(eq + 1);\n-				fresh = g_hash_table_insert(server->cap_supported,\n-							    key, val);\n+			char *key, *val;\n+\n+			if (parse_cap_name(caps[i], &key, &val)) {\n+				if (!g_hash_table_insert(server->cap_supported,\n+							 key, val)) {\n+					/* The specification doesn\'t say anything about\n+					 * duplicated values, let\'s just warn the user */\n+					g_warning(\"Duplicate value\");\n+				}\n 			}\n-			/* If the string ends after the \'=\' consider the value\n-			 * as invalid */\n 			else {\n 				g_warning(\"Invalid CAP key/value pair\");\n 			}\n \n-			/* The specification doesn\'t say anything about\n-			 * duplicated values, let\'s just warn the user */\n-			if (fresh == FALSE) {\n-				g_warning(\"Duplicate value\");\n-			}\n 		}\n \n 		/* Request the required caps, if any */\n','false','true','none'),('irssi','1.0.6','57827ca743e95a6b6ad830fab03f46efaf1d9069','LemonBoy','don\'t free the hash table if there\'s none\n\nglib doesn\'t like that and shows a harmless warning.','irc-servers.c','782','196','4','2','MODIFY','@@ -443,8 +443,10 @@ static void sig_disconnected(IRC_SERVER_REC *server)\n 	gslist_free_full(server->cap_active, (GDestroyNotify) g_free);\n 	server->cap_active = NULL;\n \n-	g_hash_table_destroy(server->cap_supported);\n-	server->cap_supported = NULL;\n+	if (server->cap_supported) {\n+	    g_hash_table_destroy(server->cap_supported);\n+	    server->cap_supported = NULL;\n+	}\n \n 	gslist_free_full(server->cap_queue, (GDestroyNotify) g_free);\n 	server->cap_queue = NULL;\n','false','false','none'),('irssi','1.0.6','8c87766132b7dbb75d8a49548ff7c97037ea983b','LemonBoy','parse multiline responses to cap ls\n\nthe parsing logic isn\'t too elegant because of the optional parameter\nused for signaling if a response has a continuation one.','irc-cap.c','176','46','52','27','MODIFY','@@ -110,13 +110,31 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n {\n 	GSList *tmp;\n 	GString *cmd;\n-	char *params, *evt, *list, **caps;\n-	int i, caps_length, disable, avail_caps;\n+	char *params, *evt, *list, *star, **caps;\n+	int i, caps_length, disable, avail_caps, multiline;\n \n-	params = event_get_params(args, 3, NULL, &evt, &list);\n+	params = event_get_params(args, 4, NULL, &evt, &star, &list);\n 	if (params == NULL)\n 		return;\n \n+	/* Multiline responses have an additional parameter and we have to do\n+	 * this stupid dance to parse them */\n+	if (evt[0] == \'L\' && !strcmp(star, \"*\")) {\n+		multiline = TRUE;\n+	}\n+	/* This branch covers the \'*\' parameter isn\'t present, adjust the\n+	 * parameter pointer to compensate for this */\n+	else if (list[0] == \'\\0\') {\n+		multiline = FALSE;\n+		list = star;\n+	}\n+	/* Malformed request, terminate the negotiation */\n+	else {\n+		cap_finish_negotiation(server);\n+		g_warn_if_reached();\n+		return;\n+	}\n+\n 	/* Strip the trailing whitespaces before splitting the string, some servers send responses with\n 	 * superfluous whitespaces that g_strsplit the interprets as tokens */\n 	caps = g_strsplit(g_strchomp(list), \" \", -1);\n@@ -149,37 +167,41 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n \n 		}\n \n-		/* Request the required caps, if any */\n-		if (server->cap_queue == NULL) {\n-			cap_finish_negotiation(server);\n-		}\n-		else {\n-			cmd = g_string_new(\"CAP REQ :\");\n+		/* A multiline response is always terminated by a normal one,\n+		 * wait until we receive that one to require any CAP */\n+		if (multiline == FALSE) {\n+			/* No CAP has been requested */\n+			if (server->cap_queue == NULL) {\n+				cap_finish_negotiation(server);\n+			}\n+			else {\n+				cmd = g_string_new(\"CAP REQ :\");\n \n-			avail_caps = 0;\n+				avail_caps = 0;\n \n-			/* Check whether the cap is supported by the server */\n-			for (tmp = server->cap_queue; tmp != NULL; tmp = tmp->next) {\n-				if (g_hash_table_lookup_extended(server->cap_supported, tmp->data, NULL, NULL)) {\n-					if (avail_caps > 0)\n-						g_string_append_c(cmd, \' \');\n-					g_string_append(cmd, tmp->data);\n+				/* Check whether the cap is supported by the server */\n+				for (tmp = server->cap_queue; tmp != NULL; tmp = tmp->next) {\n+					if (g_hash_table_lookup_extended(server->cap_supported, tmp->data, NULL, NULL)) {\n+						if (avail_caps > 0)\n+							g_string_append_c(cmd, \' \');\n+						g_string_append(cmd, tmp->data);\n \n-					avail_caps++;\n+						avail_caps++;\n+					}\n 				}\n-			}\n \n-			/* Clear the queue here */\n-			gslist_free_full(server->cap_queue, (GDestroyNotify) g_free);\n-			server->cap_queue = NULL;\n+				/* Clear the queue here */\n+				gslist_free_full(server->cap_queue, (GDestroyNotify) g_free);\n+				server->cap_queue = NULL;\n \n-			/* If the server doesn\'t support any cap we requested close the negotiation here */\n-			if (avail_caps > 0)\n-				irc_send_cmd_now(server, cmd->str);\n-			else\n-				cap_finish_negotiation(server);\n+				/* If the server doesn\'t support any cap we requested close the negotiation here */\n+				if (avail_caps > 0)\n+					irc_send_cmd_now(server, cmd->str);\n+				else\n+					cap_finish_negotiation(server);\n \n-			g_string_free(cmd, TRUE);\n+				g_string_free(cmd, TRUE);\n+			}\n 		}\n 	}\n 	else if (!g_strcmp0(evt, \"ACK\")) {\n@@ -214,6 +236,9 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		for (i = 0; i < caps_length; i++)\n 			cap_emit_signal(server, \"nak\", caps[i]);\n 	}\n+	else {\n+		g_warning(\"Unhandled CAP subcommand %s\", evt);\n+	}\n \n 	g_strfreev(caps);\n 	g_free(params);\n','false','false','none'),('irssi','1.0.6','f4d811ddf51ce03e90e0417a6c25baeb9aa48353','LemonBoy','handle cap {add,del} from cap-notify\n\nthis is the last piece of the puzzle.','irc-cap.c','203','52','34','2','MODIFY','@@ -135,6 +135,8 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		return;\n 	}\n \n+	g_warning(\"%s -> %s\", evt, list);\n+\n 	/* Strip the trailing whitespaces before splitting the string, some servers send responses with\n 	 * superfluous whitespaces that g_strsplit the interprets as tokens */\n 	caps = g_strsplit(g_strchomp(list), \" \", -1);\n@@ -158,11 +160,11 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 							 key, val)) {\n 					/* The specification doesn\'t say anything about\n 					 * duplicated values, let\'s just warn the user */\n-					g_warning(\"Duplicate value\");\n+					g_warning(\"Duplicate value %s\", key);\n 				}\n 			}\n 			else {\n-				g_warning(\"Invalid CAP key/value pair\");\n+				g_warning(\"Invalid CAP %s key/value pair\", evt);\n 			}\n \n 		}\n@@ -236,6 +238,36 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		for (i = 0; i < caps_length; i++)\n 			cap_emit_signal(server, \"nak\", caps[i]);\n 	}\n+	else if (!strcmp(evt, \"NEW\")) {\n+		for (i = 0; i < caps_length; i++) {\n+			char *key, *val;\n+\n+			if (parse_cap_name(caps[i], &key, &val)) {\n+				g_hash_table_insert(server->cap_supported,\n+						    key, val);\n+			}\n+			else {\n+				g_warning(\"Invalid CAP %s key/value pair\", evt);\n+			}\n+			cap_emit_signal(server, \"new\", key);\n+		}\n+	}\n+	else if (!strcmp(evt, \"DEL\")) {\n+		for (i = 0; i < caps_length; i++) {\n+			char *key, *val;\n+\n+			if (parse_cap_name(caps[i], &key, &val)) {\n+				g_hash_table_remove(server->cap_supported, key);\n+			}\n+			else {\n+				g_warning(\"Invalid CAP %s key/value pair\", evt);\n+			}\n+			cap_emit_signal(server, \"delete\", key);\n+			/* The server removed this CAP, remove it from the list\n+			 * of the active ones if we had requested it */\n+			server->cap_active = gslist_remove_string(server->cap_active, key);\n+		}\n+	}\n 	else {\n 		g_warning(\"Unhandled CAP subcommand %s\", evt);\n 	}\n','false','true','none'),('irssi','1.0.6','cfc8c9f8e2d982ee3ebff7afa1d1bdeb04003029','LemonBoy','properly dispose the gslist chains\n\nwe forgot to free the link and the data, oops.','misc.c','791','260','13','0','MODIFY','@@ -218,6 +218,19 @@ GSList *gslist_remove_string (GSList *list, const char *str)\n 	return list;\n }\n \n+GSList *gslist_delete_string (GSList *list, const char *str, GDestroyNotify free_func)\n+{\n+	GSList *l;\n+\n+	l = g_slist_find_custom(list, str, (GCompareFunc) g_strcmp0);\n+	if (l != NULL) {\n+		free_func(l->data);\n+		return g_slist_delete_link(list, l);\n+	}\n+\n+	return list;\n+}\n+\n /* `list\' contains pointer to structure with a char* to string. */\n char *gslistptr_to_string(GSList *list, int offset, const char *delimiter)\n {\n','false','false','none'),('irssi','1.0.6','cfc8c9f8e2d982ee3ebff7afa1d1bdeb04003029','LemonBoy','properly dispose the gslist chains\n\nwe forgot to free the link and the data, oops.','misc.h','49','0','1','0','MODIFY','@@ -22,6 +22,7 @@ GSList *gslist_find_icase_string(GSList *list, const char *key);\n GList *glist_find_string(GList *list, const char *key);\n GList *glist_find_icase_string(GList *list, const char *key);\n GSList *gslist_remove_string (GSList *list, const char *str);\n+GSList *gslist_delete_string (GSList *list, const char *str, GDestroyNotify free_func);\n \n void gslist_free_full (GSList *list, GDestroyNotify free_func);\n \n','false','false','none'),('irssi','1.0.6','cfc8c9f8e2d982ee3ebff7afa1d1bdeb04003029','LemonBoy','properly dispose the gslist chains\n\nwe forgot to free the link and the data, oops.','irc-cap.c','202','52','3','5','MODIFY','@@ -36,7 +36,7 @@ int cap_toggle (IRC_SERVER_REC *server, char *cap, int enable)\n 			return TRUE;\n 		}\n 		else if (!enable && gslist_find_string(server->cap_queue, cap)) {\n-			server->cap_queue = gslist_remove_string(server->cap_queue, cap);\n+			server->cap_queue = gslist_delete_string(server->cap_queue, cap, g_free);\n 			return TRUE;\n 		}\n \n@@ -135,8 +135,6 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		return;\n 	}\n \n-	g_warning(\"%s -> %s\", evt, list);\n-\n 	/* Strip the trailing whitespaces before splitting the string, some servers send responses with\n 	 * superfluous whitespaces that g_strsplit the interprets as tokens */\n 	caps = g_strsplit(g_strchomp(list), \" \", -1);\n@@ -214,7 +212,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			disable = (*caps[i] == \'-\');\n \n 			if (disable)\n-				server->cap_active = gslist_remove_string(server->cap_active, caps[i] + 1);\n+				server->cap_active = gslist_delete_string(server->cap_active, caps[i] + 1, g_free);\n 			else\n 				server->cap_active = g_slist_prepend(server->cap_active, g_strdup(caps[i]));\n \n@@ -265,7 +263,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			cap_emit_signal(server, \"delete\", key);\n 			/* The server removed this CAP, remove it from the list\n 			 * of the active ones if we had requested it */\n-			server->cap_active = gslist_remove_string(server->cap_active, key);\n+			server->cap_active = gslist_delete_string(server->cap_active, key, g_free);\n 		}\n 	}\n 	else {\n','false','false','none'),('irssi','1.0.6','432368bdc6b941c1ff6319748b357bd5bae1bb6e','LemonBoy','use strcmp instead of g_strcmp0\n\nthere\'s no need to use the latter.','irc-cap.c','202','52','4','4','MODIFY','@@ -140,7 +140,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 	caps = g_strsplit(g_strchomp(list), \" \", -1);\n 	caps_length = g_strv_length(caps);\n \n-	if (!g_strcmp0(evt, \"LS\")) {\n+	if (!strcmp(evt, \"LS\")) {\n 		if (server->cap_supported) {\n 			g_hash_table_destroy(server->cap_supported);\n 		}\n@@ -204,7 +204,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			}\n 		}\n 	}\n-	else if (!g_strcmp0(evt, \"ACK\")) {\n+	else if (!strcmp(evt, \"ACK\")) {\n 		int got_sasl = FALSE;\n \n 		/* Emit a signal for every ack\'d cap */\n@@ -216,7 +216,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			else\n 				server->cap_active = g_slist_prepend(server->cap_active, g_strdup(caps[i]));\n \n-			if (!g_strcmp0(caps[i], \"sasl\"))\n+			if (!strcmp(caps[i], \"sasl\"))\n 				got_sasl = TRUE;\n \n 			cap_emit_signal(server, \"ack\", caps[i]);\n@@ -228,7 +228,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		if (got_sasl == FALSE)\n 			cap_finish_negotiation(server);\n 	}\n-	else if (!g_strcmp0(evt, \"NAK\")) {\n+	else if (!strcmp(evt, \"NAK\")) {\n 		g_warning(\"The server answered with a NAK to our CAP request, this should not happen\");\n \n 		/* A NAK\'d request means that a required cap can\'t be enabled or disabled, don\'t update the\n','false','false','none'),('irssi','1.0.6','f683e81880ac4408693582df3ec11d640684c78d','LemonBoy','prevent a null pointer deference\n\nalways create the cap_supported table when a cap event is received.','irc-cap.c','202','52','9','7','MODIFY','@@ -135,19 +135,21 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		return;\n 	}\n \n+	/* The table is created only when needed */\n+	if (server->cap_supported == NULL) {\n+		server->cap_supported = g_hash_table_new_full(g_str_hash,\n+							      g_str_equal,\n+							      g_free, g_free);\n+	}\n+\n 	/* Strip the trailing whitespaces before splitting the string, some servers send responses with\n 	 * superfluous whitespaces that g_strsplit the interprets as tokens */\n 	caps = g_strsplit(g_strchomp(list), \" \", -1);\n 	caps_length = g_strv_length(caps);\n \n 	if (!strcmp(evt, \"LS\")) {\n-		if (server->cap_supported) {\n-			g_hash_table_destroy(server->cap_supported);\n-		}\n-		/* Start with a fresh table */\n-		server->cap_supported = g_hash_table_new_full(g_str_hash,\n-							      g_str_equal,\n-							      g_free, g_free);\n+		/* Throw away everything and start from scratch */\n+		g_hash_table_remove_all(server->cap_supported);\n \n 		/* Create a list of the supported caps */\n 		for (i = 0; i < caps_length; i++) {\n','false','true','none'),('irssi','1.0.6','74409aa85071390a3969fffa21c08a6736efe314','LemonBoy','miscellaneous fixes\n\nstylistic stuff, please ignore.','irc-cap.c','202','52','2','2','MODIFY','@@ -86,14 +86,14 @@ static gboolean parse_cap_name(char *name, char **key, char **val)\n \n 	const char *eq = strchr(name, \'=\');\n 	/* KEY only value */\n-	if (!eq) {\n+	if (eq == NULL) {\n 		*key = g_strdup(name);\n 		*val = NULL;\n 		return TRUE;\n 	}\n 	/* Some values are in a KEY=VALUE form, parse them */\n 	else if (eq[1] != \'\\0\') {\n-		*key = g_strndup(name, (int)(eq - name));\n+		*key = g_strndup(name, (gsize)(eq - name));\n 		*val = g_strdup(eq + 1);\n 		return TRUE;\n 	}\n','true','false','none'),('irssi','1.0.6','cd107deb463934f7a8611cdc8d17b861a93d97f9','LemonBoy','prevent a memory leak\n\nwhen a cap del is received the key/val pair is not stored in the\nhashtable at all so just free them when we\'re done.','irc-cap.c','204','52','4','0','MODIFY','@@ -266,6 +266,10 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			/* The server removed this CAP, remove it from the list\n 			 * of the active ones if we had requested it */\n 			server->cap_active = gslist_delete_string(server->cap_active, key, g_free);\n+			/* We don\'t transfer the ownership of those two\n+			 * variables this time, just free them when we\'re done. */\n+			g_free(key);\n+			g_free(val);\n 		}\n 	}\n 	else {\n','false','false','none'),('irssi','1.0.6','9160ddaffd45b03c523320ef8f71bb3a8a9fb87a','LemonBoy','keep processing the caps on error\n\nif an invalid cap is found we keep going by parsing the next one.','irc-cap.c','207','52','3','1','MODIFY','@@ -165,8 +165,8 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			}\n 			else {\n 				g_warning(\"Invalid CAP %s key/value pair\", evt);\n+				continue;\n 			}\n-\n 		}\n \n 		/* A multiline response is always terminated by a normal one,\n@@ -248,6 +248,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			}\n 			else {\n 				g_warning(\"Invalid CAP %s key/value pair\", evt);\n+				continue;\n 			}\n 			cap_emit_signal(server, \"new\", key);\n 		}\n@@ -261,6 +262,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			}\n 			else {\n 				g_warning(\"Invalid CAP %s key/value pair\", evt);\n+				continue;\n 			}\n 			cap_emit_signal(server, \"delete\", key);\n 			/* The server removed this CAP, remove it from the list\n','true','false','none'),('irssi','1.0.6','c00132ac4cf78702b4f72fc6a0085432bcef2fac','LemonBoy','simplify the code\n\nearly exit, simpler code.','irc-cap.c','199','52','13','18','MODIFY','@@ -155,18 +155,16 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		for (i = 0; i < caps_length; i++) {\n 			char *key, *val;\n \n-			if (parse_cap_name(caps[i], &key, &val)) {\n-				if (!g_hash_table_insert(server->cap_supported,\n-							 key, val)) {\n-					/* The specification doesn\'t say anything about\n-					 * duplicated values, let\'s just warn the user */\n-					g_warning(\"Duplicate value %s\", key);\n-				}\n-			}\n-			else {\n+			if (!parse_cap_name(caps[i], &key, &val)) {\n 				g_warning(\"Invalid CAP %s key/value pair\", evt);\n 				continue;\n 			}\n+\n+			if (!g_hash_table_insert(server->cap_supported, key, val)) {\n+				/* The specification doesn\'t say anything about\n+				 * duplicated values, let\'s just warn the user */\n+				g_warning(\"Duplicate value %s\", key);\n+			}\n 		}\n \n 		/* A multiline response is always terminated by a normal one,\n@@ -242,14 +240,12 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		for (i = 0; i < caps_length; i++) {\n 			char *key, *val;\n \n-			if (parse_cap_name(caps[i], &key, &val)) {\n-				g_hash_table_insert(server->cap_supported,\n-						    key, val);\n-			}\n-			else {\n+			if (!parse_cap_name(caps[i], &key, &val)) {\n 				g_warning(\"Invalid CAP %s key/value pair\", evt);\n 				continue;\n 			}\n+\n+			g_hash_table_insert(server->cap_supported, key, val);\n 			cap_emit_signal(server, \"new\", key);\n 		}\n 	}\n@@ -257,13 +253,12 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		for (i = 0; i < caps_length; i++) {\n 			char *key, *val;\n \n-			if (parse_cap_name(caps[i], &key, &val)) {\n-				g_hash_table_remove(server->cap_supported, key);\n-			}\n-			else {\n+			if (!parse_cap_name(caps[i], &key, &val)) {\n 				g_warning(\"Invalid CAP %s key/value pair\", evt);\n 				continue;\n 			}\n+\n+			g_hash_table_remove(server->cap_supported, key);\n 			cap_emit_signal(server, \"delete\", key);\n 			/* The server removed this CAP, remove it from the list\n 			 * of the active ones if we had requested it */\n','false','false','none'),('irssi','1.0.6','6c45ab0493e42bca08016ad70a54bb523282b7b8','LemonBoy','command names may be in lower-case\n\ndo not take the string case into account when comparing the command\nname.','irc-cap.c','199','52','5','5','MODIFY','@@ -147,7 +147,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 	caps = g_strsplit(g_strchomp(list), \" \", -1);\n 	caps_length = g_strv_length(caps);\n \n-	if (!strcmp(evt, \"LS\")) {\n+	if (!g_ascii_strcasecmp(evt, \"LS\")) {\n 		/* Throw away everything and start from scratch */\n 		g_hash_table_remove_all(server->cap_supported);\n \n@@ -204,7 +204,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			}\n 		}\n 	}\n-	else if (!strcmp(evt, \"ACK\")) {\n+	else if (!g_ascii_strcasecmp(evt, \"ACK\")) {\n 		int got_sasl = FALSE;\n \n 		/* Emit a signal for every ack\'d cap */\n@@ -228,7 +228,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		if (got_sasl == FALSE)\n 			cap_finish_negotiation(server);\n 	}\n-	else if (!strcmp(evt, \"NAK\")) {\n+	else if (!g_ascii_strcasecmp(evt, \"NAK\")) {\n 		g_warning(\"The server answered with a NAK to our CAP request, this should not happen\");\n \n 		/* A NAK\'d request means that a required cap can\'t be enabled or disabled, don\'t update the\n@@ -236,7 +236,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 		for (i = 0; i < caps_length; i++)\n 			cap_emit_signal(server, \"nak\", caps[i]);\n 	}\n-	else if (!strcmp(evt, \"NEW\")) {\n+	else if (!g_ascii_strcasecmp(evt, \"NEW\")) {\n 		for (i = 0; i < caps_length; i++) {\n 			char *key, *val;\n \n@@ -249,7 +249,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			cap_emit_signal(server, \"new\", key);\n 		}\n 	}\n-	else if (!strcmp(evt, \"DEL\")) {\n+	else if (!g_ascii_strcasecmp(evt, \"DEL\")) {\n 		for (i = 0; i < caps_length; i++) {\n 			char *key, *val;\n \n','false','false','none'),('irssi','1.0.6','f3a535564880d73b75263b685794a7165e56f9bd','LemonBoy','match ls instead of checking the first letter only','irc-cap.c','199','52','1','1','MODIFY','@@ -119,7 +119,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n \n 	/* Multiline responses have an additional parameter and we have to do\n 	 * this stupid dance to parse them */\n-	if (evt[0] == \'L\' && !strcmp(star, \"*\")) {\n+	if (!g_ascii_strcasecmp(evt, \"LS\") && !strcmp(star, \"*\")) {\n 		multiline = TRUE;\n 	}\n 	/* This branch covers the \'*\' parameter isn\'t present, adjust the\n','false','false','none'),('irssi','1.0.6','4b9fcbc15ae3561c34944e30e24fd1d54346bb99','LemonBoy','nicer error message when a duplicate cap in ls','irc-cap.c','199','52','1','1','MODIFY','@@ -163,7 +163,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 			if (!g_hash_table_insert(server->cap_supported, key, val)) {\n 				/* The specification doesn\'t say anything about\n 				 * duplicated values, let\'s just warn the user */\n-				g_warning(\"Duplicate value %s\", key);\n+				g_warning(\"The server sent the %s capability twice\", key);\n 			}\n 		}\n \n','true','false','none'),('irssi','1.0.6','fed791ed9100552edbe643d8b3d0e0bc271e88d4','LemonBoy','fix a problem with multiline responses\n\ndo not clear the whole table every time a response is received.','irc-cap.c','202','53','6','2','MODIFY','@@ -148,8 +148,12 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add\n 	caps_length = g_strv_length(caps);\n \n 	if (!g_ascii_strcasecmp(evt, \"LS\")) {\n-		/* Throw away everything and start from scratch */\n-		g_hash_table_remove_all(server->cap_supported);\n+		if (!server->cap_in_multiline) {\n+			/* Throw away everything and start from scratch */\n+			g_hash_table_remove_all(server->cap_supported);\n+		}\n+\n+		server->cap_in_multiline = multiline;\n \n 		/* Create a list of the supported caps */\n 		for (i = 0; i < caps_length; i++) {\n','true','false','none'),('irssi','1.0.6','fed791ed9100552edbe643d8b3d0e0bc271e88d4','LemonBoy','fix a problem with multiline responses\n\ndo not clear the whole table every time a response is received.','irc-servers.h','82','0','1','0','MODIFY','@@ -68,6 +68,7 @@ struct _IRC_SERVER_REC {\n 	unsigned int motd_got:1; /* We\'ve received MOTD */\n 	unsigned int isupport_sent:1; /* Server has sent us an isupport reply */\n 	unsigned int cap_complete:1; /* We\'ve done the initial CAP negotiation */\n+	unsigned int cap_in_multiline:1; /* We\'re waiting for the multiline response to end */\n 	unsigned int sasl_success:1; /* Did we authenticate successfully ? */\n \n 	int max_kicks_in_cmd; /* max. number of people to kick with one /KICK command */\n','true','false','none'),('irssi','1.0.6','063c85da6c4e73a292525aa01b5cad70ed6bf82b','ailin-nemui','fix space in message','term-terminfo.c','553','177','1','1','MODIFY','@@ -735,7 +735,7 @@ void term_gets(GArray *buffer, int *line_count)\n }\n \n static const char* term_env_warning =\n-	\"You seem to be running Irssi inside %2$s, but the TERM environment variable\"\n+	\"You seem to be running Irssi inside %2$s, but the TERM environment variable \"\n 	\"is set to \'%1$s\', which can cause display glitches.\\n\"\n 	\"Consider changing TERM to \'%2$s\' or \'%2$s-256color\' instead.\";\n \n','true','false','none');
/*!40000 ALTER TABLE `irssi` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-03-22 10:44:04
