-- MySQL dump 10.13  Distrib 8.0.18, for Win64 (x86_64)
--
-- Host: localhost    Database: dataset
-- ------------------------------------------------------
-- Server version	8.0.18

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `irssi`
--

DROP TABLE IF EXISTS `irssi`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `irssi` (
  `name` varchar(255) DEFAULT NULL,
  `release_number` varchar(255) DEFAULT NULL,
  `commit_hash` longtext,
  `commit_author` varchar(255) DEFAULT NULL,
  `commit_msg` longtext,
  `filename` varchar(255) DEFAULT NULL,
  `nloc` varchar(255) DEFAULT NULL,
  `cycomplexity` varchar(255) DEFAULT NULL,
  `lines_added` varchar(255) DEFAULT NULL,
  `lines_removed` varchar(255) DEFAULT NULL,
  `change_type` varchar(255) DEFAULT NULL,
  `diff` longtext
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `irssi`
--

LOCK TABLES `irssi` WRITE;
/*!40000 ALTER TABLE `irssi` DISABLE KEYS */;
INSERT INTO `irssi` VALUES ('irssi','1.0.0','ea7826b0ec097b9fdc29336ff7fe7074052773f5','ailin-nemui','tag as 1.0.0','NEWS','2858','0','55','21','MODIFY','@@ -1,22 +1,29 @@ -v0.8.22-head 2017-xx-xx  The Irssi team <staff@irssi.org> -	* Removed --disable-ipv6 +v1.0.0 2017-01-03  The Irssi team <staff@irssi.org> +	* Removed --disable-ipv6 (#408).  	* /connect Network now aborts with an error if no servers have been -	  added to that network. +	  added to that network (#443).  	* /dcc commands now use quotes around spaces consistently. -	+ irssiproxy can now forward all tags through a single port. -	+ irssiproxy can also listen on unix sockets. -	+ send channel -botcmds immediately when no mask is specified (#175). +	* bell_beeps was removed (#524, #565). +	* Switch to GRegex instead of regex.h (#412). +	+ irssiproxy can now forward all tags through a single +	  port. By Lukas Mai (mauke, #425). +	+ irssiproxy can also listen on unix sockets. By Lukas Mai (#427). +	+ send channel -botcmds immediately when no mask is specified (#175, #399).  	+ the kill buffer now remembers consecutive kills.  	  New bindings were added: yank_next_cutbuffer and append_next_kill +	  By Todd A. Pratt (#353, #414, #455)  	+ connections will avoid looking up IPv6 addresses if the machine does  	  not have an IPv6 address assigned (exact behaviour is implementation -	  defined). +	  defined, #410).  	+ Fix potential crash if scripts insert undef values into the completion -	  list. -	+ Paste warning is now also shown on pasting overlong lines. +	  list (#413). +	+ Paste warning is now also shown on pasting overlong +	  lines. By Manish Goregaokar (#426).  	+ autolog_ignore_targets and activity_hide_targets learn a new syntax  	      tag/* and * to ignore whole networks or everything. -	+ /hilight got a -matchcase flag to hilight case sensitively (#421). +	  By Jari Matilainen (vague666, #437) +	+ /hilight got a -matchcase flag to hilight case +	  sensitively. By Thibault B (isundil, #421, #476).  	+ Always build irssi with TLS support.  	+ Rename SSL to TLS in the code and add -tls_* versions of the -ssl_*  	  options to /CONNECT and /SERVER, but make sure the -ssl_* options continue @@ -54,10 +61,36 @@ v0.8.22-head 2017-xx-xx  The Irssi team <staff@irssi.org>  	  does not rely on the libval library. It is causing a lot of troubles for  	  our downstream maintainers.   +	+ /names and $[...] now uses utf8 string operations. By Xavier +          G. (#40, #411, #471, #480). +	+ New setting completion_nicks_match_case (#488). +	+ /channel /server /network now support modify subcommand. By +	  Jari Matilainen (#338, #498). +	+ Irssi::signal_remove now works with coderefs. By Tom Feist (shabble, #512). +	+ /script reset got an -autorun switch (#540, #538). +	+ cap_toggle can now be called from Perl, and fields +	  cap_active and cap_supported can be inspected (#542). +	+ Make it possible to disable empty line completion. By Lauri +	  Tirkkonen (lotheac, #574). +	+ New option sasl_disconnect_on_failure to disconnect when +	  SASL log-in failed (#514).  	- IP addresses are no longer stored when resolve_reverse_lookup is  	  used. -	- /names and $[...] now uses utf8 string operations (#40, #411). -	- Removed broken support for curses. +	- Removed broken support for curses (#521). +	- Removed broken dummy mode (#526). +	- Fix terminal state after suspend (#450, #452). +	- Improve Perl library path detection (#479, #132). +	- Reconnect now works on unix connections (#493). +	- Fix completion warnings (#125, #496, FS#124). +	- Fix a crash in the --more-- item (#501). +	- Fix a display issue in /unignore (#517, bdo#577202). +	- Fix a crash in some netsplits (#529, #500). +	- Fix crashes with some invalid config (#550, #551, #563, #564, #587, #581, #570). +	- Add support for SASL Fragmentation. By Kenny Root (kruton, #506). +	- Improve netsplit dumping (#420, #465). +	- Improve responsibility under DCC I/O strain (#578, #159). +	- Fix query nick change on open (#580, #586). +	- Correct a few help texts.    v0.8.21 2017-01-03  The Irssi team <staff@irssi.org>  	- Correct a NULL pointer dereference in the nickcmp function found by @@ -72,11 +105,11 @@ v0.8.20 2016-09-16  The Irssi team <staff@irssi.org>  	- Correct the name of an emitted sasl signal (#484)  	- Correct the prototype for the \'message private\' signal (#515)  	- Corrections in away and hilight help text (#477, #518) -	- /squery and /servlist commands have been restored. +	- /squery and /servlist commands have been restored (#461).  	- Where Irssi would previously only report \"System error\" on connect, -	  it will now try harder to retrieve the system error message. +	  it will now try harder to retrieve the system error message (#467).  	- Fixed issue with +channels not working properly (#533) -	- Fixed crash in optchan when item has no server (#485) +	- Fixed crash in optchan when item has no server (#485, bdo#826525)  	- Fixed random remote crash in the nicklist handling (#529)  	- Fixed remote crash due to incorrect bounds checking on  	  formats, reported by Gabriel Campana and Adrien Guinet from @@ -84,16 +117,17 @@ v0.8.20 2016-09-16  The Irssi team <staff@irssi.org>    v0.8.19 2016-03-23  The Irssi team <staff@irssi.org>  	- Fixed regression when joining and parting channels on IRCnet (#435) -	- Fixed SASL EXTERNAL (#432) +	- Fixed SASL EXTERNAL. By Mantas MikulÄ—nas (grawity, #432)  	- Fixed regression when not using SASL (#438) -	- Fixed incorrect SSL disconnects when using SSL from modules/scripts -	  (#439) +	- Fixed incorrect SSL disconnects when using SSL from modules/scripts. +	  By Will Storey (horgh, #439)  	- Fixed regression where proxy_string could not be configured or -	  certain file transfers could not be accepted (#445) -	- Fixed storing layout of !channels (#183) -	- Fixed restoration of bracketed paste mode on quit (#449) +	  certain file transfers could not be accepted (#445, #446) +	- Fixed storing layout of !channels (#183, #405) +	- Fixed restoration of bracketed paste mode on quit (#449, #457)  	- Make the usage of meta-O for cursor keys configurable with  	      /set term_appkey_mode off +	  (#430, #459)    v0.8.18 2016-02-13  The Irssi team <staff@irssi.org>  	* Modules will now require to define a '),('irssi','1.0.0','ea7826b0ec097b9fdc29336ff7fe7074052773f5','ailin-nemui','tag as 1.0.0','configure.ac','618','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -AC_INIT(irssi, 0.8.22-head) +AC_INIT(irssi, 1.0.0)  AC_CONFIG_SRCDIR([src])  AC_CONFIG_AUX_DIR(build-aux)  AC_PREREQ(2.50) '),('irssi','1.0.0','cbb931ed1da91b2cee36f89673edd6a526d56e9a','ailin-nemui','continue head','NEWS','2859','0','2','0','MODIFY','@@ -1,3 +1,5 @@ +v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org> +  v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>  	* Removed --disable-ipv6 (#408).  	* /connect Network now aborts with an error if no servers have been '),('irssi','1.0.0','cbb931ed1da91b2cee36f89673edd6a526d56e9a','ailin-nemui','continue head','configure.ac','618','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -AC_INIT(irssi, 1.0.0) +AC_INIT(irssi, 1.1-head)  AC_CONFIG_SRCDIR([src])  AC_CONFIG_AUX_DIR(build-aux)  AC_PREREQ(2.50) '),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory  irssi 1.0.0 will not build if Perl is enabled and a separate object code directory is used. The problem was a relative path to an internal Perl dependency in four Makefile.PL.in files.','Makefile.PL.in','6','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi\',                \'LIBS\' => \'\', '),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory  irssi 1.0.0 will not build if Perl is enabled and a separate object code directory is used. The problem was a relative path to an internal Perl dependency in four Makefile.PL.in files.','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi::Irc\',                \'LIBS\' => \'\', '),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory  irssi 1.0.0 will not build if Perl is enabled and a separate object code directory is used. The problem was a relative path to an internal Perl dependency in four Makefile.PL.in files.','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi::TextUI\',                \'LIBS\' => \'\', '),('irssi','1.0.0','c9c45e4f89bc42fec00b71c50844a946bfcc6e0c','Martijn Dekker','make irssi --with-perl build with separate object directory  irssi 1.0.0 will not build if Perl is enabled and a separate object code directory is used. The problem was a relative path to an internal Perl dependency in four Makefile.PL.in files.','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi::UI\',                \'LIBS\' => \'\', '),('irssi','1.0.0','752f484c6ce4c2aa7284b617a59a8906b269281c','dequis','Add OPENSSL_NO_EC for solaris 11.3, see issue #598  Original patch by \'Slarky\'  According to that ticket, the next major version of solaris won\'t need this. Consider reverting this when solaris 11.3 stops being relevant.','network-openssl.c','629','135','6','0','MODIFY','@@ -646,7 +646,11 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  #ifdef SSL_get_server_tmp_key  	// Show ephemeral key information.  	EVP_PKEY *ephemeral_key = NULL; + +	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 +#ifndef OPENSSL_NO_EC  	EC_KEY *ec_key = NULL; +#endif  	char *ephemeral_key_algorithm = NULL;  	char *cname = NULL;  	int nid; @@ -658,6 +662,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  				tls_rec_set_ephemeral_key_size(tls, EVP_PKEY_bits(ephemeral_key));  				break;   +#ifndef OPENSSL_NO_EC  			case EVP_PKEY_EC:  				ec_key = EVP_PKEY_get1_EC_KEY(ephemeral_key);  				nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key)); @@ -670,6 +675,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)    				g_free_and_null(ephemeral_key_algorithm);  				break; +#endif    			default:  				tls_rec_set_ephemeral_key_algorithm(tls, \"Unknown\"); '),('irssi','1.0.0','ef9da295cdd8af0036396e7fc772fcee8a1c7c51','Lasse Toimela','Fix syntax on /help SERVER example','server.in','65','0','1','1','MODIFY','@@ -64,7 +64,7 @@      /SERVER CONNECT chat.freenode.net      /SERVER CONNECT +chat.freenode.net      /SERVER ADD -network Freenode -noautosendcmd orwell.freenode.net -    /SERVER ADD -! -auto -host staff.irssi.org -port 6667 -4 -network Freenode -noproxy orwell.freenode.net +    /SERVER ADD -! -auto -host staff.irssi.org -4 -network Freenode -noproxy orwell.freenode.net 6667      /SERVER MODIFY -network Freenode -noauto orwell.freenode.net      /SERVER REMOVE orwell.freenode.net 6667 Freenode      /SERVER PURGE '),('irssi','1.0.0','1831a8e1a710decbbcae524c60cdf6216f19a121','dequis','Don\'t reset wait_cmd during connection registration (fixes early ISON)','irc-servers.c','780','196','6','0','MODIFY','@@ -527,6 +527,12 @@ void irc_server_send_data(IRC_SERVER_REC *server, const char *data, int len)  		return;  	}   +	/* Don\'t reset wait_cmd during connection registration +	 * (while sending CAP / SASL related commands) */ +	if (!server->connected) { +		return; +	} +  	g_get_current_time(&server->last_cmd);    	/* A bit kludgy way to do the flood protection. In ircnet, there '),('irssi','1.0.0','69e112fbd1b44a6f9f3380167c12bbe0f76693a1','dequis','NEWS: Avoid explicitly mentioning freenode in the pinning examples  They have proper certs, so using them as an example is wrong. Particularly worse since they started using letsencrypt recently so every server has a different cert and pubkey.  We\'ll figure out how to link this from the release notes later.','NEWS','2858','0','4','4','MODIFY','@@ -39,16 +39,16 @@ v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>  	  values like this: Start by downloading the certificate from a given IRC  	  server:   -	      $ openssl s_client -connect chat.freenode.net:6697 < /dev/null 2>/dev/null | \\ -	        openssl x509 > freenode.cert +	      $ openssl s_client -connect irc.example.net:6697 < /dev/null 2>/dev/null | \\ +	        openssl x509 > example.cert    	  Find the value for -tls_pinned_cert:   -	      $ openssl x509 -in freenode.cert -fingerprint -sha256 -noout +	      $ openssl x509 -in example.cert -fingerprint -sha256 -noout    	  Find the value for -tls_pinned_pubkey:   -	      $ openssl x509 -in freenode.cert -pubkey -noout | \\ +	      $ openssl x509 -in example.cert -pubkey -noout | \\  	        openssl pkey -pubin -outform der | \\  	        openssl dgst -sha256 -c | \\  	        tr a-z A-Z '),('irssi','1.0.0','5917bc6f75dd87806807d3d526826b64e8271a5b','Tim Konick','Follow g_strsplit with call to g_strfreev','modes.c','700','195','2','1','MODIFY','@@ -743,6 +743,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,  			    g_hash_table_lookup(optlist, \"yes\") == NULL) {                                  /* too many matches */  				g_string_free(str, TRUE); +				g_strfreev(matches);  				cmd_params_free(free_arg);    				signal_emit(\"error command\", 1, @@ -756,7 +757,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,          if (str->len > 0) g_string_truncate(str, str->len-1);  	ret = str->str;  	g_string_free(str, FALSE); - +	g_strfreev(matches);  	cmd_params_free(free_arg);    	*ret_channel = channel; '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','.gitignore','53','0','4','0','MODIFY','@@ -32,6 +32,7 @@ docs/help/[a-z]*  docs/help/in/Makefile.am    src/fe-text/irssi +src/fe-fuzz/irssi-fuzz    src/fe-common/irc/irc-modules.c  src/irc/irc.c @@ -46,6 +47,9 @@ src/perl/ui/*.c  src/perl/*/MYMETA.*  src/perl/*/Makefile.old   +src/fe-fuzz/crash-* +src/fe-fuzz/oom-* +  *.a  *.bs  *.la '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','configure.ac','662','4','40','0','MODIFY','@@ -52,6 +52,19 @@ AC_ARG_WITH(bot,  	fi,  	want_irssibot=no)   +AC_ARG_WITH(fuzzer, +[  --with-fuzzer           Build irssi-fuzzer], +	if test x$withval = xno; then +		want_irssifuzzer=no +	else +		want_irssifuzzer=yes +	fi, +	want_irssifuzzer=no) + +AC_ARG_WITH(fuzzer-lib, +[  --with-fuzzer-lib       Specify path to fuzzer library], +	fuzzerlibpath=\"$withval\") +  AC_ARG_WITH(proxy,  [  --with-proxy            Build irssi-proxy],  	if test x$withval = xno; then @@ -297,6 +310,30 @@ if test \"x$want_textui\" != \"xno\"; then    fi   +dnl ** +dnl ** irssifuzzer checks +dnl ** + +if test \"$want_irssifuzzer\" != \"no\"; then +	dnl * we need to build with -fsanitize-coverage=trace-pc-guard +	dnl * otherwise fuzzer won\'t be very successful at finding bugs :) +	if test -z \"$SANFLAGS\"; then +		SANFLAGS=\"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\" +	fi +	CFLAGS=\"$CFLAGS $SANFLAGS\" +	CXXFLAGS=\"$CXXFLAGS $SANFLAGS\" + +	AC_MSG_CHECKING(for fuzzer library) + +	if test -z \"$fuzzerlibpath\"; then +		AC_MSG_RESULT([not found, building without fuzzer front end]) +		want_irssifuzzer=no +	else +		FUZZER_LIBS=\"$fuzzerlibpath\" +		AC_SUBST(FUZZER_LIBS) +	fi +fi +  dnl **  dnl ** perl checks  dnl ** @@ -456,6 +493,7 @@ fi  dnl ** check what we want to build  AM_CONDITIONAL(BUILD_TEXTUI, test \"$want_textui\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\") +AM_CONDITIONAL(BUILD_IRSSIFUZZER, test \"$want_irssifuzzer\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIPROXY, test \"$want_irssiproxy\" = \"yes\")  AM_CONDITIONAL(HAVE_PERL, test \"$want_perl\" != \"no\")   @@ -572,6 +610,7 @@ src/fe-common/core/Makefile  src/fe-common/irc/Makefile  src/fe-common/irc/dcc/Makefile  src/fe-common/irc/notifylist/Makefile +src/fe-fuzz/Makefile  src/fe-none/Makefile  src/fe-text/Makefile  src/lib-config/Makefile @@ -611,6 +650,7 @@ echo    echo \"Building text frontend ........... : $want_textui\"  echo \"Building irssi bot ............... : $want_irssibot\" +echo \"Building irssi fuzzer ............ : $want_irssifuzzer\"  echo \"Building irssi proxy ............. : $want_irssiproxy\"  if test \"x$have_gmodule\" = \"xyes\"; then  	echo \"Building with module support ..... : yes\" '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','Makefile.am','16','0','5','1','MODIFY','@@ -6,6 +6,10 @@ if BUILD_IRSSIBOT  BOTUI=fe-none  endif   +if BUILD_IRSSIFUZZER +FUZZERUI=fe-fuzz +endif +  if HAVE_PERL  PERLDIR=perl  endif @@ -14,4 +18,4 @@ pkginc_srcdir=$(pkgincludedir)/src  pkginc_src_HEADERS = \\  	common.h   -SUBDIRS = lib-config core irc fe-common $(PERLDIR) $(TEXTUI) $(BOTUI) +SUBDIRS = lib-config core irc fe-common $(PERLDIR) $(TEXTUI) $(BOTUI) $(FUZZERUI) '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','Makefile.am','18','0','25','0','ADD','@@ -0,0 +1,25 @@ +bin_PROGRAMS = irssi-fuzz + +# Force link with clang++ for libfuzzer support +CCLD=clang++ $(CXXFLAGS) + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core/ \\ +	-I$(top_srcdir)/src/irc/core/ \\ +	-I$(top_srcdir)/src/fe-common/core/ \\ +	$(GLIB_CFLAGS) + +irssi_fuzz_DEPENDENCIES = @COMMON_LIBS@ + +irssi_fuzz_LDADD = \\ +	@COMMON_LIBS@ \\ +	@PROG_LIBS@ \\ +	$(FUZZER_LIBS) + +irssi_fuzz_SOURCES = \\ +        irssi.c \\ +	module-formats.c + +noinst_HEADERS = \\ +	module-formats.h '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','irssi.c','34','2','58','0','ADD','@@ -0,0 +1,58 @@ +/* + irssi.c : irssi + +    Copyright (C) 2017 Joseph Bisch + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"modules-load.h\" +#include \"levels.h\" +#include \"module-formats.h\" +#include \"themes.h\" +#include \"core.h\" +#include \"fe-common-core.h\" +#include \"args.h\" +#include \"printtext.h\" + +#include <stdbool.h> +#include <stddef.h> +#include <stdint.h> +#include <stdlib.h> +#include <string.h> + +int LLVMFuzzerInitialize(int *argc, char ***argv) { +	core_register_options(); +	fe_common_core_register_options(); +	/* no args */ +	args_execute(0, NULL); +	core_preinit((*argv)[0]); +	core_init(); +	fe_common_core_init(); +	theme_register(gui_text_formats); +	module_register(\"core\", \"fe-fuzz\"); +	printtext_string(NULL, NULL, MSGLEVEL_CLIENTCRAP, \"init\"); +	return 0; +} + +int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { +	char *copy = (char *)malloc(sizeof(char)*(size+1)); +	memcpy(copy, data, size); +	copy[size] = \'\\0\'; +	printtext_string(NULL, NULL, MSGLEVEL_CLIENTCRAP, copy); +	free(copy); +	return 0; +} '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','module-formats.c','48','0','82','0','ADD','@@ -0,0 +1,82 @@ +/* + module-formats.c : irssi + +    Copyright (C) 2000 Timo Sirainen + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"formats.h\" + +FORMAT_REC gui_text_formats[] = +{ +	{ MODULE_NAME, \"Text user interface\", 0 }, + +	/* ---- */ +	{ NULL, \"Lastlog\", 0 }, + +	{ \"lastlog_too_long\", \"/LASTLOG would print $0 lines. If you really want to print all these lines use -force option.\", 1, { 1 } }, +	{ \"lastlog_count\", \"{hilight Lastlog}: $0 lines\", 1, { 1 } }, +	{ \"lastlog_start\", \"{hilight Lastlog}:\", 0 }, +	{ \"lastlog_end\", \"{hilight End of Lastlog}\", 0 }, +	{ \"lastlog_separator\", \"--\", 0 }, +	{ \"lastlog_date\", \"%%F \", 0 }, + +	/* ---- */ +	{ NULL, \"Windows\", 0 }, + +	{ \"refnum_not_found\", \"Window number $0 not found\", 1, { 0 } }, +	{ \"window_too_small\", \"Not enough room to resize this window\", 0 }, +	{ \"cant_hide_last\", \"You can\'t hide the last window\", 0 }, +	{ \"cant_hide_sticky_windows\", \"You can\'t hide sticky windows (use /WINDOW STICK OFF)\", 0 }, +	{ \"cant_show_sticky_windows\", \"You can\'t show sticky windows (use /WINDOW STICK OFF)\", 0 }, +	{ \"window_not_sticky\", \"Window is not sticky\", 0 }, +	{ \"window_set_sticky\", \"Window set sticky\", 0 }, +	{ \"window_unset_sticky\", \"Window is not sticky anymore\", 0 }, +	{ \"window_info_sticky\", \"%#Sticky  : $0\", 1, { 0 } }, +	{ \"window_info_scroll\", \"%#Scroll  : $0\", 1, { 0 } }, +	{ \"window_scroll\", \"Window scroll mode is now $0\", 1, { 0 } }, +	{ \"window_scroll_unknown\", \"Unknown scroll mode $0, must be ON, OFF or DEFAULT\", 1, { 0 } }, + +	/* ---- */ +	{ NULL, \"Statusbars\", 0 }, + +	{ \"statusbar_list_header\", \"%#Name                           Type   Placement Position Visible\", 0 }, +	{ \"statusbar_list_footer\", \"\", 0 }, +	{ \"statusbar_list\", \"%#$[30]0 $[6]1 $[9]2 $[8]3 $4\", 5, { 0, 0, 0, 1, 0 } }, +	{ \"statusbar_info_name\", \"%#Statusbar: {hilight $0}\", 1, { 0 } }, +	{ \"statusbar_info_type\", \"%#Type     : $0\", 1, { 0 } }, +	{ \"statusbar_info_placement\", \"%#Placement: $0\", 1, { 0 } }, +	{ \"statusbar_info_position\", \"%#Position : $0\", 1, { 1 } }, +	{ \"statusbar_info_visible\", \"%#Visible  : $0\", 1, { 0 } }, +	{ \"statusbar_info_item_header\", \"%#Items    : Name                                Priority  Alignment\", 0 }, +	{ \"statusbar_info_item_footer\", \"\", 0 }, +	{ \"statusbar_info_item_name\",  \"%#         : $[35]0 $[9]1 $2\", 3, { 0, 1, 0 } }, +	{ \"statusbar_not_found\", \"Statusbar doesn\'t exist: $0\", 1, { 0 } }, +	{ \"statusbar_item_not_found\", \"Statusbar item doesn\'t exist: $0\", 1, { 0 } }, +	{ \"statusbar_unknown_command\", \"Unknown statusbar command: $0\", 1, { 0 } }, +	{ \"statusbar_unknown_type\", \"Statusbar type must be \'window\' or \'root\'\", 1, { 0 } }, +	{ \"statusbar_unknown_placement\", \"Statusbar placement must be \'top\' or \'bottom\'\", 1, { 0 } }, +	{ \"statusbar_unknown_visibility\", \"Statusbar visibility must be \'always\', \'active\' or \'inactive\'\", 1, { 0 } }, + +	/* ---- */ +	{ NULL, \"Pasting\", 0 }, + +	{ \"paste_warning\", \"Pasting $0 lines to $1. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.\", 2, { 1, 0 } }, +	{ \"paste_prompt\", \"Hit Ctrl-K to paste, Ctrl-C to abort?\", 0 }, + +	{ NULL, NULL, 0 } +}; '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','module-formats.h','47','0','58','0','ADD','@@ -0,0 +1,58 @@ +#include \"formats.h\" + +enum { +	TXT_MODULE_NAME, + +	TXT_FILL_1, + +        TXT_LASTLOG_TOO_LONG, +        TXT_LASTLOG_COUNT, +	TXT_LASTLOG_START, +	TXT_LASTLOG_END, +	TXT_LASTLOG_SEPARATOR, +	TXT_LASTLOG_DATE, + +	TXT_FILL_2, + +        TXT_REFNUM_NOT_FOUND, +        TXT_WINDOW_TOO_SMALL, +        TXT_CANT_HIDE_LAST, +	TXT_CANT_HIDE_STICKY_WINDOWS, +        TXT_CANT_SHOW_STICKY_WINDOWS, +        TXT_WINDOW_NOT_STICKY, +        TXT_WINDOW_SET_STICKY, +	TXT_WINDOW_UNSET_STICKY, +	TXT_WINDOW_INFO_STICKY, +        TXT_WINDOW_INFO_SCROLL, +        TXT_WINDOW_SCROLL, +        TXT_WINDOW_SCROLL_UNKNOWN, + +	TXT_FILL_3, + +        TXT_STATUSBAR_LIST_HEADER, +	TXT_STATUSBAR_LIST_FOOTER, +	TXT_STATUSBAR_LIST, +	TXT_STATUSBAR_INFO_NAME, +	TXT_STATUSBAR_INFO_TYPE, +        TXT_STATUSBAR_INFO_PLACEMENT, +	TXT_STATUSBAR_INFO_POSITION, +	TXT_STATUSBAR_INFO_VISIBLE, +        TXT_STATUSBAR_INFO_ITEM_HEADER, +	TXT_STATUSBAR_INFO_ITEM_FOOTER, +        TXT_STATUSBAR_INFO_ITEM_NAME, +        TXT_STATUSBAR_NOT_FOUND, +        TXT_STATUSBAR_ITEM_NOT_FOUND, +	TXT_STATUSBAR_UNKNOWN_COMMAND, +        TXT_STATUSBAR_UNKNOWN_TYPE, +	TXT_STATUSBAR_UNKNOWN_PLACEMENT, +        TXT_STATUSBAR_UNKNOWN_VISIBILITY, + +	TXT_FILL_4, + +	TXT_PASTE_WARNING, +	TXT_PASTE_PROMPT, + +	TXT_COUNT +}; + +extern FORMAT_REC gui_text_formats[TXT_COUNT+1]; '),('irssi','1.0.0','cf4690725667211bc8a8998e362c6bda24dd7528','Joseph Bisch','Add frontend for fuzzing  Use the following configure command:  $ ./configure --with-fuzzer --with-fuzzer-lib=/path/to/libFuzzer.a \\       CC=clang CXX=clang++  Places an irssi-fuzz in src/fe-fuzz/ after build.  Also can specify SANFLAGS to override the chosen sanitizer flags (defaults to \"-g -fsanitize=address -fsanitize-coverage=trace-pc-guard\").','tokens.txt','143','0','143','0','ADD','@@ -0,0 +1,143 @@ +\"@%+\" +\"*@*!*\" +\"001\" +\"002\" +\"003\" +\"004\" +\"005\" +\"221\" +\"254\" +\"271\" +\"272\" +\"281\" +\"301\" +\"302\" +\"303\" +\"305\" +\"306\" +\"311\" +\"312\" +\"313\" +\"314\" +\"315\" +\"317\" +\"318\" +\"319\" +\"324\" +\"326\" +\"327\" +\"328\" +\"329\" +\"330\" +\"332\" +\"333\" +\"338\" +\"341\" +\"344\" +\"345\" +\"346\" +\"347\" +\"348\" +\"349\" +\"352\" +\"353\" +\"364\" +\"365\" +\"366\" +\"367\" +\"368\" +\"369\" +\"372\" +\"375\" +\"376\" +\"377\" +\"378\" +\"379\" +\"381\" +\"386\" +\"387\" +\"388\" +\"389\" +\"396\" +\"401\" +\"403\" +\"404\" +\"405\" +\"407\" +\"408\" +\"410\" +\"421\" +\"422\" +\"433\" +\"436\" +\"437\" +\"438\" +\"439\" +\"442\" +\"465\" +\"470\" +\"471\" +\"472\" +\"473\" +\"474\" +\"475\" +\"476\" +\"477\" +\"478\" +\"479\" +\"482\" +\"486\" +\"489\" +\"494\" +\"506\" +\"707\" +\"716\" +\"717\" +\"728\" +\"729\" +\"902\" +\"903\" +\"904\" +\"905\" +\"906\" +\"907\" +\":a\" +\"+a\" +\"ACK\" +\"authenticate\" +\"away\" +\"-b\" +\"+b\" +\"cap\" +\"#chan\" +\"connected\" +\"empty\" +\"error\" +\"invite\" +\"join\" +\"kick\" +\"kill\" +\"LS\" +\"mode\" +\"multi-prefix\" +\"NAK\" +\"network\" +\"nick\" +\"nicklen\" +\"notice\" +\"-o\" +\"+o\" +\"part\" +\"ping\" +\"pong\" +\"prefix\" +\"privmsg\" +\"quit\" +\"sasl\" +\"topic\" +\"wallops\" +\"watch\" +\":\\x01\" +\":\\x01ACTION\" +\":\\x01PING\" +\":\\x01VERSION\" '),('irssi','1.0.0','17fc77565e3278ffc19c5294be57c2467f43974b','ailin-nemui','fix regression in completion  fixes #609','completion.c','639','180','1','1','MODIFY','@@ -191,7 +191,7 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  				g_strdup_printf(\"%s%c%s\",  						/* do not accidentally duplicate the word separator */  						line == wordstart - 1 ? \"\" : linestart, -						wordstart[-1], word); +						old_wordstart[-1], word);  			g_free(old);    			g_free(word); '),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','Don\'t duplicate module-formats.* in fe-fuzz','Makefile.am','18','0','2','2','MODIFY','@@ -19,7 +19,7 @@ irssi_fuzz_LDADD = \\    irssi_fuzz_SOURCES = \\          irssi.c \\ -	module-formats.c +	$(top_srcdir)/src/fe-text/module-formats.c    noinst_HEADERS = \\ -	module-formats.h +	$(top_srcdir)/src/fe-text/module-formats.h '),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','Don\'t duplicate module-formats.* in fe-fuzz','irssi.c','34','2','1','1','MODIFY','@@ -21,7 +21,7 @@  #include \"module.h\"  #include \"modules-load.h\"  #include \"levels.h\" -#include \"module-formats.h\" +#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text  #include \"themes.h\"  #include \"core.h\"  #include \"fe-common-core.h\" '),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','Don\'t duplicate module-formats.* in fe-fuzz','module-formats.c','None','None','0','82','DELETE','@@ -1,82 +0,0 @@ -/* - module-formats.c : irssi - -    Copyright (C) 2000 Timo Sirainen - -    This program is free software; you can redistribute it and/or modify -    it under the terms of the GNU General Public License as published by -    the Free Software Foundation; either version 2 of the License, or -    (at your option) any later version. - -    This program is distributed in the hope that it will be useful, -    but WITHOUT ANY WARRANTY; without even the implied warranty of -    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -    GNU General Public License for more details. - -    You should have received a copy of the GNU General Public License along -    with this program; if not, write to the Free Software Foundation, Inc., -    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. -*/ - -#include \"module.h\" -#include \"formats.h\" - -FORMAT_REC gui_text_formats[] = -{ -	{ MODULE_NAME, \"Text user interface\", 0 }, - -	/* ---- */ -	{ NULL, \"Lastlog\", 0 }, - -	{ \"lastlog_too_long\", \"/LASTLOG would print $0 lines. If you really want to print all these lines use -force option.\", 1, { 1 } }, -	{ \"lastlog_count\", \"{hilight Lastlog}: $0 lines\", 1, { 1 } }, -	{ \"lastlog_start\", \"{hilight Lastlog}:\", 0 }, -	{ \"lastlog_end\", \"{hilight End of Lastlog}\", 0 }, -	{ \"lastlog_separator\", \"--\", 0 }, -	{ \"lastlog_date\", \"%%F \", 0 }, - -	/* ---- */ -	{ NULL, \"Windows\", 0 }, - -	{ \"refnum_not_found\", \"Window number $0 not found\", 1, { 0 } }, -	{ \"window_too_small\", \"Not enough room to resize this window\", 0 }, -	{ \"cant_hide_last\", \"You can\'t hide the last window\", 0 }, -	{ \"cant_hide_sticky_windows\", \"You can\'t hide sticky windows (use /WINDOW STICK OFF)\", 0 }, -	{ \"cant_show_sticky_windows\", \"You can\'t show sticky windows (use /WINDOW STICK OFF)\", 0 }, -	{ \"window_not_sticky\", \"Window is not sticky\", 0 }, -	{ \"window_set_sticky\", \"Window set sticky\", 0 }, -	{ \"window_unset_sticky\", \"Window is not sticky anymore\", 0 }, -	{ \"window_info_sticky\", \"%#Sticky  : $0\", 1, { 0 } }, -	{ \"window_info_scroll\", \"%#Scroll  : $0\", 1, { 0 } }, -	{ \"window_scroll\", \"Window scroll mode is now $0\", 1, { 0 } }, -	{ \"window_scroll_unknown\", \"Unknown scroll mode $0, must be ON, OFF or DEFAULT\", 1, { 0 } }, - -	/* ---- */ -	{ NULL, \"Statusbars\", 0 }, - -	{ \"statusbar_list_header\", \"%#Name                           Type   Placement Position Visible\", 0 }, -	{ \"statusbar_list_footer\", \"\", 0 }, -	{ \"statusbar_list\", \"%#$[30]0 $[6]1 $[9]2 $[8]3 $4\", 5, { 0, 0, 0, 1, 0 } }, -	{ \"statusbar_info_name\", \"%#Statusbar: {hilight $0}\", 1, { 0 } }, -	{ \"statusbar_info_type\", \"%#Type     : $0\", 1, { 0 } }, -	{ \"statusbar_info_placement\", \"%#Placement: $0\", 1, { 0 } }, -	{ \"statusbar_info_position\", \"%#Position : $0\", 1, { 1 } }, -	{ \"statusbar_info_visible\", \"%#Visible  : $0\", 1, { 0 } }, -	{ \"statusbar_info_item_header\", \"%#Items    : Name                                Priority  Alignment\", 0 }, -	{ \"statusbar_info_item_footer\", \"\", 0 }, -	{ \"statusbar_info_item_name\",  \"%#         : $[35]0 $[9]1 $2\", 3, { 0, 1, 0 } }, -	{ \"statusbar_not_found\", \"Statusbar doesn\'t exist: $0\", 1, { 0 } }, -	{ \"statusbar_item_not_found\", \"Statusbar item doesn\'t exist: $0\", 1, { 0 } }, -	{ \"statusbar_unknown_command\", \"Unknown statusbar command: $0\", 1, { 0 } }, -	{ \"statusbar_unknown_type\", \"Statusbar type must be \'window\' or \'root\'\", 1, { 0 } }, -	{ \"statusbar_unknown_placement\", \"Statusbar placement must be \'top\' or \'bottom\'\", 1, { 0 } }, -	{ \"statusbar_unknown_visibility\", \"Statusbar visibility must be \'always\', \'active\' or \'inactive\'\", 1, { 0 } }, - -	/* ---- */ -	{ NULL, \"Pasting\", 0 }, - -	{ \"paste_warning\", \"Pasting $0 lines to $1. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.\", 2, { 1, 0 } }, -	{ \"paste_prompt\", \"Hit Ctrl-K to paste, Ctrl-C to abort?\", 0 }, - -	{ NULL, NULL, 0 } -}; '),('irssi','1.0.0','abdae2d5fcc83ef73c7233da4a169ef3305c9743','Joseph Bisch','Don\'t duplicate module-formats.* in fe-fuzz','module-formats.h','None','None','0','58','DELETE','@@ -1,58 +0,0 @@ -#include \"formats.h\" - -enum { -	TXT_MODULE_NAME, - -	TXT_FILL_1, - -        TXT_LASTLOG_TOO_LONG, -        TXT_LASTLOG_COUNT, -	TXT_LASTLOG_START, -	TXT_LASTLOG_END, -	TXT_LASTLOG_SEPARATOR, -	TXT_LASTLOG_DATE, - -	TXT_FILL_2, - -        TXT_REFNUM_NOT_FOUND, -        TXT_WINDOW_TOO_SMALL, -        TXT_CANT_HIDE_LAST, -	TXT_CANT_HIDE_STICKY_WINDOWS, -        TXT_CANT_SHOW_STICKY_WINDOWS, -        TXT_WINDOW_NOT_STICKY, -        TXT_WINDOW_SET_STICKY, -	TXT_WINDOW_UNSET_STICKY, -	TXT_WINDOW_INFO_STICKY, -        TXT_WINDOW_INFO_SCROLL, -        TXT_WINDOW_SCROLL, -        TXT_WINDOW_SCROLL_UNKNOWN, - -	TXT_FILL_3, - -        TXT_STATUSBAR_LIST_HEADER, -	TXT_STATUSBAR_LIST_FOOTER, -	TXT_STATUSBAR_LIST, -	TXT_STATUSBAR_INFO_NAME, -	TXT_STATUSBAR_INFO_TYPE, -        TXT_STATUSBAR_INFO_PLACEMENT, -	TXT_STATUSBAR_INFO_POSITION, -	TXT_STATUSBAR_INFO_VISIBLE, -        TXT_STATUSBAR_INFO_ITEM_HEADER, -	TXT_STATUSBAR_INFO_ITEM_FOOTER, -        TXT_STATUSBAR_INFO_ITEM_NAME, -        TXT_STATUSBAR_NOT_FOUND, -        TXT_STATUSBAR_ITEM_NOT_FOUND, -	TXT_STATUSBAR_UNKNOWN_COMMAND, -        TXT_STATUSBAR_UNKNOWN_TYPE, -	TXT_STATUSBAR_UNKNOWN_PLACEMENT, -        TXT_STATUSBAR_UNKNOWN_VISIBILITY, - -	TXT_FILL_4, - -	TXT_PASTE_WARNING, -	TXT_PASTE_PROMPT, - -	TXT_COUNT -}; - -extern FORMAT_REC gui_text_formats[TXT_COUNT+1]; '),('irssi','1.0.0','b15c27cc63fa967f3e8fe98fdc6d093dd8692c93','dx','Revert \"Don\'t reset wait_cmd during connection registration (fixes early ISON)\"','irc-servers.c','777','195','0','6','MODIFY','@@ -527,12 +527,6 @@ void irc_server_send_data(IRC_SERVER_REC *server, const char *data, int len)  		return;  	}   -	/* Don\'t reset wait_cmd during connection registration -	 * (while sending CAP / SASL related commands) */ -	if (!server->connected) { -		return; -	} -  	g_get_current_time(&server->last_cmd);    	/* A bit kludgy way to do the flood protection. In ircnet, there '),('irssi','1.0.0','fe1ea4b80a3467c23b1ec2d30bdfe4cfaf9b94d6','Joseph Bisch','Fix fe-fuzz nits','configure.ac','661','4','0','1','MODIFY','@@ -650,7 +650,6 @@ echo    echo \"Building text frontend ........... : $want_textui\"  echo \"Building irssi bot ............... : $want_irssibot\" -echo \"Building irssi fuzzer ............ : $want_irssifuzzer\"  echo \"Building irssi proxy ............. : $want_irssiproxy\"  if test \"x$have_gmodule\" = \"xyes\"; then  	echo \"Building with module support ..... : yes\" '),('irssi','1.0.0','fe1ea4b80a3467c23b1ec2d30bdfe4cfaf9b94d6','Joseph Bisch','Fix fe-fuzz nits','irssi.c','33','2','0','1','MODIFY','@@ -28,7 +28,6 @@  #include \"args.h\"  #include \"printtext.h\"   -#include <stdbool.h>  #include <stddef.h>  #include <stdint.h>  #include <stdlib.h> '),('irssi','1.0.0','677fb1f55ca52d0e43c93f7d8361d333ff5bffd6','Hanno','perl_parse needs NULL terminated parameter list.','perl-core.c','321','60','2','2','MODIFY','@@ -41,7 +41,7 @@ GSList *perl_scripts;  PerlInterpreter *my_perl;    static int print_script_errors; -static char *perl_args[] = {\"\", \"-e\", \"0\"}; +static char *perl_args[] = {\"\", \"-e\", \"0\", NULL};    #define IS_PERL_SCRIPT(file) \\  	(strlen(file) > 3 && g_strcmp0(file+strlen(file)-3, \".pl\") == 0) @@ -123,7 +123,7 @@ void perl_scripts_init(void)  	my_perl = perl_alloc();  	perl_construct(my_perl);   -	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args), perl_args, NULL); +	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args)-1, perl_args, NULL);  #if PERL_STATIC_LIBS == 1  	perl_eval_pv(\"Irssi::Core::->boot_Irssi_Core(0.9);\", TRUE);  #endif '),('irssi','1.0.0','c8dafe2a76f199f35e24440ca85796454717965e','Joseph Bisch','Add SUPPRESS_PRINTF_FALLBACK  There are some cases (such as fuzzing with fe-fuzz) where suppressing printf output may be desirable.','printtext.c','400','72','2','0','MODIFY','@@ -446,7 +446,9 @@ static void sig_print_text(TEXT_DEST_REC *dest, const char *text)    	if (dest->window == NULL) {                  str = strip_codes(text); +#ifndef SUPPRESS_PRINTF_FALLBACK  		printf(\"NO WINDOWS: %s\\n\", str); +#endif                  g_free(str);                  return;  	} '),('irssi','1.0.0','6221ce520644efe4095bfecbc29f11c9c6962e0f','Joseph Bisch','Fix glib-2.0.m4 so that $PKG_CONFIG doesn\'t break configure script  If $PKG_CONFIG contains a space, then the test may not work, so surround with quotation mark characters. (for example, PKG_CONFIG=\"pkg-config --static\" breaks configure before this commit).','glib-2.0.m4','199','0','1','1','MODIFY','@@ -43,7 +43,7 @@ AC_ARG_ENABLE(glibtest, [  --disable-glibtest      do not try to compile and run    min_glib_version=ifelse([$1], ,2.0.0,$1)    AC_MSG_CHECKING(for GLIB - version >= $min_glib_version)   -  if test x$PKG_CONFIG != xno ; then +  if test \"x$PKG_CONFIG\" != xno ; then      ## don\'t try to run the test against uninstalled libtool libs      if $PKG_CONFIG --uninstalled $pkg_config_args; then  	  echo \"Will use uninstalled version of GLib found in PKG_CONFIG_PATH\" '),('irssi','1.0.0','bc1ff509d2a9dc5592e7c2cb996d0c32cde026ff','ailin-nemui','sync mail.pl','mail.pl','388','0','13','14','MODIFY','@@ -30,6 +30,7 @@ $VERSION = \"2.92\";  # Check /mailbox help for help.    use Irssi::TextUI; +use Irssi;    my $maildirmode = 0; # maildir=1, file(spools)=0  my $old_is_not_new = 0;  @@ -37,7 +38,7 @@ my $extprog;  my ($last_refresh_time, $refresh_tag);    # for mbox caching -my $last_size, $last_mtime, $last_mailcount, $last_mode; +my ($last_size, $last_mtime, $last_mailcount, $last_mode);    # list of mailboxes  my %mailboxes = ();  @@ -101,8 +102,9 @@ sub mbox_count {    my $old_is_not_new=Irssi::settings_get_bool(\'mail_oldnotnew\');      if ($extprog ne \"\") { -     $total = `$extprog`; -     chomp $unread; +     my $total = `$extprog`; +     chomp $total; +     ($read, $unread) = split \' \', $total, 2;    } else {      if (!$maildirmode) {        if (-f $mailfile) { @@ -115,8 +117,7 @@ sub mbox_count {  	$last_size = $size;  	$last_mtime = $mtime;   -	my $f = gensym; -	return 0 if (!open($f, \"<\", $mailfile)); +	return 0 if (!open(my $f, \"<\", $mailfile));    	# count new mails only  	my $internal_removed = 0; @@ -205,7 +206,7 @@ sub mail {    my $total = 0;      # check all mailboxes for new email -  foreach $name (keys(%mailboxes)) { +  foreach my $name (keys(%mailboxes)) {      my $box = $mailboxes{$name};      # replace \"~/\" at the beginning by the user\'s home dir      $box =~ s/^~\\//$ENV{\'HOME\'}\\//; @@ -233,7 +234,7 @@ sub mail {      # Show this only if there are any new, unread messages.      if (Irssi::settings_get_bool(\'mail_show_message\') &&          $unread > $new_mails_in_box{$name}) { -      $new_mails = $unread - $new_mails_in_box{$name}; +      my $new_mails = $unread - $new_mails_in_box{$name};        if ($nummailboxes == 1) {          Irssi::print(\"You have $new_mails new message\" . ($new_mails != 1 ? \"s.\" : \".\"), MSGLEVEL_CRAP);        } else { @@ -263,11 +264,9 @@ sub add_mailboxes {    my $boxstring = $_[0];    my @boxes = split(/,/, $boxstring);   -  foreach $dbox(@boxes) { -    my $name = $dbox; -    $name = substr($dbox, 0, index($dbox, \'=\')); -    my $box = $dbox; -    $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox)); +  foreach my $dbox(@boxes) { +    my $name = substr($dbox, 0, index($dbox, \'=\')); +    my $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox));      addmailbox($name, $box);    }  } @@ -306,7 +305,7 @@ sub delmailbox {  sub update_settings_string {    my $setting;   -  foreach $name (keys(%mailboxes)) { +  foreach my $name (keys(%mailboxes)) {      $setting .= $name . \"=\" . $mailboxes{$name} . \",\";    }   @@ -345,7 +344,7 @@ sub cmd_showmailboxes {      return;    }    Irssi::print(\"Mailboxes:\", MSGLEVEL_CRAP); -  foreach $box (keys(%mailboxes)) { +  foreach my $box (keys(%mailboxes)) {      Irssi::print(\"$box: \" . $mailboxes{$box}, MSGLEVEL_CRAP);    }  } '),('irssi','1.0.0','876c1dd93e06b9e627918f142f547e3deea682be','ailin-nemui','implement break_wide  for more pleasant east asian mixed display','gui-windows.c','218','51','7','3','MODIFY','@@ -49,6 +49,7 @@ static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,  					   settings_get_int(\"indent\"),  					   !settings_get_bool(\"indent_always\"),  					   get_default_indent_func()); +	textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));  	if (parent->active == window)  		textbuffer_view_set_window(gui->view, parent->screen_win);  	return gui; @@ -201,12 +202,14 @@ void gui_windows_reset_settings(void)    	for (tmp = windows; tmp != NULL; tmp = tmp->next) {  		WINDOW_REC *rec = tmp->data; -                GUI_WINDOW_REC *gui = WINDOW_GUI(rec); +		GUI_WINDOW_REC *gui = WINDOW_GUI(rec);   -                textbuffer_view_set_default_indent(gui->view, +		textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\")); + +		textbuffer_view_set_default_indent(gui->view,  						   settings_get_int(\"indent\"),  						   !settings_get_bool(\"indent_always\"), -                                                   get_default_indent_func()); +						   get_default_indent_func());    		textbuffer_view_set_scroll(gui->view,  					   gui->use_scroll ? gui->scroll : @@ -281,6 +284,7 @@ void gui_windows_init(void)          settings_add_bool(\"lookandfeel\", \"autostick_split_windows\", TRUE);  	settings_add_int(\"lookandfeel\", \"indent\", 10);  	settings_add_bool(\"lookandfeel\", \"indent_always\", FALSE); +	settings_add_bool(\"lookandfeel\", \"break_wide\", FALSE);  	settings_add_bool(\"lookandfeel\", \"scroll\", TRUE);    	window_create_override = -1; '),('irssi','1.0.0','876c1dd93e06b9e627918f142f547e3deea682be','ailin-nemui','implement break_wide  for more pleasant east asian mixed display','textbuffer-view.c','1043','251','11','1','MODIFY','@@ -307,7 +307,7 @@ view_update_line_cache(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line)  			continue;  		}   -		if (!view->utf8 && char_width > 1) { +		if (view->break_wide && char_width > 1) {  			last_space = xpos;  			last_space_ptr = next_ptr;  			last_color = color; last_fg24 = fg24; last_bg24 = bg24; @@ -665,6 +665,16 @@ void textbuffer_view_set_default_indent(TEXT_BUFFER_VIEW_REC *view,  	view->default_indent_func = indent_func;  }   +/* Enable breaking of wide chars */ +void textbuffer_view_set_break_wide(TEXT_BUFFER_VIEW_REC *view, +				    gboolean break_wide) +{ +	if (view->break_wide != break_wide) { +		view->break_wide = break_wide; +		view_reset_cache(view); +	} +} +  static void view_unregister_indent_func(TEXT_BUFFER_VIEW_REC *view,  					INDENT_FUNC indent_func)  { '),('irssi','1.0.0','876c1dd93e06b9e627918f142f547e3deea682be','ailin-nemui','implement break_wide  for more pleasant east asian mixed display','textbuffer-view.h','82','0','3','0','MODIFY','@@ -59,6 +59,7 @@ struct _TEXT_BUFFER_VIEW_REC {  	unsigned int longword_noindent:1;  	unsigned int scroll:1; /* scroll down automatically when at bottom */  	unsigned int utf8:1; /* use UTF8 in this view */ +	unsigned int break_wide:1; /* Break wide chars in this view */    	TEXT_BUFFER_CACHE_REC *cache;  	int ypos; /* cursor position - visible area is 0..height-1 */ @@ -97,6 +98,8 @@ void textbuffer_view_set_default_indent(TEXT_BUFFER_VIEW_REC *view,  					int longword_noindent,  					INDENT_FUNC indent_func);  void textbuffer_views_unregister_indent_func(INDENT_FUNC indent_func); +void textbuffer_view_set_break_wide(TEXT_BUFFER_VIEW_REC *view, +				    gboolean break_wide);    void textbuffer_view_set_scroll(TEXT_BUFFER_VIEW_REC *view, int scroll);  void textbuffer_view_set_utf8(TEXT_BUFFER_VIEW_REC *view, int utf8); '),('irssi','1.0.0','697dd19d887c58930c76de68268d58f2251904d6','LemonBoy','Check whether the client certificate is expired.  Right now we only warn the user, the connection keeps going. Fixes #211','network-openssl.c','643','139','29','7','MODIFY','@@ -420,16 +420,38 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_    	if (mycert && *mycert) {  		char *scert = NULL, *spkey = NULL; +		FILE *fp;  		scert = convert_home(mycert);  		if (mypkey && *mypkey)  			spkey = convert_home(mypkey); -		ERR_clear_error(); -		if (! SSL_CTX_use_certificate_file(ctx, scert, SSL_FILETYPE_PEM)) -			g_warning(\"Loading of client certificate \'%s\' failed: %s\", mycert, ERR_reason_error_string(ERR_get_error())); -		else if (! SSL_CTX_use_PrivateKey_file(ctx, spkey ? spkey : scert, SSL_FILETYPE_PEM)) -			g_warning(\"Loading of private key \'%s\' failed: %s\", mypkey ? mypkey : mycert, ERR_reason_error_string(ERR_get_error())); -		else if (! SSL_CTX_check_private_key(ctx)) -			g_warning(\"Private key does not match the certificate\"); + +		if ((fp = fopen(scert, \"r\"))) { +			X509 *cert; +			/* Let\'s parse the certificate by hand instead of using +			 * SSL_CTX_use_certificate_file so that we can validate +			 * some parts of it. */ +			cert = PEM_read_X509(fp, NULL, get_pem_password_callback, (void *)mypass); +			if (cert != NULL) { +				/* Only the expiration date is checked right now */ +				if (X509_cmp_current_time(X509_get_notAfter(cert))  <= 0 || +				    X509_cmp_current_time(X509_get_notBefore(cert)) >= 0) +					g_warning(\"The client certificate is expired\"); + +				ERR_clear_error(); +				if (! SSL_CTX_use_certificate(ctx, cert)) +					g_warning(\"Loading of client certificate \'%s\' failed: %s\", mycert, ERR_reason_error_string(ERR_get_error())); +				else if (! SSL_CTX_use_PrivateKey_file(ctx, spkey ? spkey : scert, SSL_FILETYPE_PEM)) +					g_warning(\"Loading of private key \'%s\' failed: %s\", mypkey ? mypkey : mycert, ERR_reason_error_string(ERR_get_error())); +				else if (! SSL_CTX_check_private_key(ctx)) +					g_warning(\"Private key does not match the certificate\"); + +				X509_free(cert); +			} else +				g_warning(\"Loading of client certificate \'%s\' failed: %s\", mycert, ERR_reason_error_string(ERR_get_error())); + +			fclose(fp); +		} else +			g_warning(\"Could not find client certificate \'%s\'\", scert);  		g_free(scert);  		g_free(spkey);  	} '),('irssi','1.0.0','19c51789967a2f63da033e60f6ef08848b9cd144','LemonBoy','Prevent a memory leak during the processing of the SASL response.  We also get rid of an allocation in the process of doing so.','sasl.c','199','35','10','4','MODIFY','@@ -174,10 +174,16 @@ static gboolean sasl_reassemble_incoming(IRC_SERVER_REC *server, const char *fra  		*decoded = g_string_new_len(\"\", 0);  	} else {  		gsize dec_len; -		gchar *tmp; - -		tmp = (gchar *) g_base64_decode(enc_req->str, &dec_len); -		*decoded = g_string_new_len(tmp, dec_len); +		gint state = 0; +		guint save = 0; + +		/* Since we\'re not going to use the enc_req GString anymore we +		 * can perform the decoding in place. */ +		dec_len = g_base64_decode_step(enc_req->str, enc_req->len, +					       (guchar *)enc_req->str, +					       &state, &save); +		/* A copy of the data is made when the GString is created. */ +		*decoded = g_string_new_len(enc_req->str, dec_len);  	}    	g_string_free(enc_req, TRUE); '),('irssi','1.0.0','73e8a065bd24092a03c0938eb6c93fec3ee0f4d9','LemonBoy','Support OpenSSL 1.1.0.  - X509_get_notBefore becomes X509_get0_notBefore - X509_get_notAfter becomes X509_get0_notAfter - ASN1_STRING_data becomes ASN1_STRING_get0_data (and drops the const) - The whole library is now initialized by OPENSSL_init_ssl  Closes #597','network-openssl.c','633','137','18','1','MODIFY','@@ -32,6 +32,17 @@  #include <openssl/ssl.h>  #include <openssl/err.h>   +/* OpenSSL 1.1.0 introduced some backward-incompatible changes to the api */ +#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER) +/* The two functions below could be already defined if OPENSSL_API_COMPAT is + * below the 1.1.0 version so let\'s do a clean start */ +#undef  X509_get_notBefore +#undef  X509_get_notAfter +#define X509_get_notBefore(x)     X509_get0_notBefore(x) +#define X509_get_notAfter(x)      X509_get0_notAfter(x) +#define ASN1_STRING_data(x)       ASN1_STRING_get0_data(x) +#endif +  /* ssl i/o channel object */  typedef struct  { @@ -352,13 +363,19 @@ static GIOFuncs irssi_ssl_channel_funcs = {    static gboolean irssi_ssl_init(void)  { +#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER) +	if (!OPENSSL_init_ssl(OPENSSL_INIT_SSL_DEFAULT, NULL)) { +		g_error(\"Could not initialize OpenSSL\"); +		return FALSE; +	} +#else  	SSL_library_init();  	SSL_load_error_strings();  	OpenSSL_add_all_algorithms(); +#endif  	ssl_inited = TRUE;    	return TRUE; -  }    static int get_pem_password_callback(char *buffer, int max_length, int rwflag, void *pass) '),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','Merge pull request #602 from McDutchie/master  make irssi --with-perl build with separate object directory','Makefile.PL.in','6','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi\',                \'LIBS\' => \'\', '),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','Merge pull request #602 from McDutchie/master  make irssi --with-perl build with separate object directory','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi::Irc\',                \'LIBS\' => \'\', '),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','Merge pull request #602 from McDutchie/master  make irssi --with-perl build with separate object directory','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi::TextUI\',                \'LIBS\' => \'\', '),('irssi','1.0.0','7c49ed2d17d2325d7bceef632ac38b66a44e8b63','ailin-nemui','Merge pull request #602 from McDutchie/master  make irssi --with-perl build with separate object directory','Makefile.PL.in','7','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"../Makefile_silent.pm\"; +use ExtUtils::MakeMaker;our $AM_DEFAULT_VERBOSITY=\'@AM_DEFAULT_VERBOSITY@\';require \"@top_srcdir@/src/perl/Makefile_silent.pm\";    WriteMakefile(\'NAME\' => \'Irssi::UI\',                \'LIBS\' => \'\', '),('irssi','1.0.0','8dbf186ad6e808c269fa10c22444c89df63f2d7d','ailin-nemui','Merge pull request #604 from dequis/solaris  Add OPENSSL_NO_EC for solaris 11.3, see issue #598','network-openssl.c','629','135','6','0','MODIFY','@@ -646,7 +646,11 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  #ifdef SSL_get_server_tmp_key  	// Show ephemeral key information.  	EVP_PKEY *ephemeral_key = NULL; + +	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 +#ifndef OPENSSL_NO_EC  	EC_KEY *ec_key = NULL; +#endif  	char *ephemeral_key_algorithm = NULL;  	char *cname = NULL;  	int nid; @@ -658,6 +662,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  				tls_rec_set_ephemeral_key_size(tls, EVP_PKEY_bits(ephemeral_key));  				break;   +#ifndef OPENSSL_NO_EC  			case EVP_PKEY_EC:  				ec_key = EVP_PKEY_get1_EC_KEY(ephemeral_key);  				nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key)); @@ -670,6 +675,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)    				g_free_and_null(ephemeral_key_algorithm);  				break; +#endif    			default:  				tls_rec_set_ephemeral_key_algorithm(tls, \"Unknown\"); '),('irssi','1.0.0','3a3b34fc633fe8e045bf4b696c41857c9f8c5ba5','ailin-nemui','Merge pull request #606 from or4n/master  Fix syntax on /help SERVER example','server.in','65','0','1','1','MODIFY','@@ -64,7 +64,7 @@      /SERVER CONNECT chat.freenode.net      /SERVER CONNECT +chat.freenode.net      /SERVER ADD -network Freenode -noautosendcmd orwell.freenode.net -    /SERVER ADD -! -auto -host staff.irssi.org -port 6667 -4 -network Freenode -noproxy orwell.freenode.net +    /SERVER ADD -! -auto -host staff.irssi.org -4 -network Freenode -noproxy orwell.freenode.net 6667      /SERVER MODIFY -network Freenode -noauto orwell.freenode.net      /SERVER REMOVE orwell.freenode.net 6667 Freenode      /SERVER PURGE '),('irssi','1.0.0','929c9477477a4ccf03626388499192d8003b96d5','LemonBoy','Merge pull request #608 from tijko/master  Follow g_strsplit with call to g_strfreev','modes.c','700','195','2','1','MODIFY','@@ -743,6 +743,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,  			    g_hash_table_lookup(optlist, \"yes\") == NULL) {                                  /* too many matches */  				g_string_free(str, TRUE); +				g_strfreev(matches);  				cmd_params_free(free_arg);    				signal_emit(\"error command\", 1, @@ -756,7 +757,7 @@ static char *get_nicks(IRC_SERVER_REC *server, WI_ITEM_REC *item,          if (str->len > 0) g_string_truncate(str, str->len-1);  	ret = str->str;  	g_string_free(str, FALSE); - +	g_strfreev(matches);  	cmd_params_free(free_arg);    	*ret_channel = channel; '),('irssi','1.0.0','d63c93ae1dbb1254a92e8e4fafc39fe8d69d00ae','LemonBoy','Merge pull request #613 from ailin-nemui/fix_completion  fix regression in completion','completion.c','639','180','1','1','MODIFY','@@ -191,7 +191,7 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  				g_strdup_printf(\"%s%c%s\",  						/* do not accidentally duplicate the word separator */  						line == wordstart - 1 ? \"\" : linestart, -						wordstart[-1], word); +						old_wordstart[-1], word);  			g_free(old);    			g_free(word); '),('irssi','1.0.0','1f42d2aa950e4d70bf4c4aebae3a7040bd710cf3','LemonBoy','Merge pull request #619 from hannob/master  perl_parse needs NULL terminated parameter list.','perl-core.c','321','60','2','2','MODIFY','@@ -41,7 +41,7 @@ GSList *perl_scripts;  PerlInterpreter *my_perl;    static int print_script_errors; -static char *perl_args[] = {\"\", \"-e\", \"0\"}; +static char *perl_args[] = {\"\", \"-e\", \"0\", NULL};    #define IS_PERL_SCRIPT(file) \\  	(strlen(file) > 3 && g_strcmp0(file+strlen(file)-3, \".pl\") == 0) @@ -123,7 +123,7 @@ void perl_scripts_init(void)  	my_perl = perl_alloc();  	perl_construct(my_perl);   -	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args), perl_args, NULL); +	perl_parse(my_perl, xs_init, G_N_ELEMENTS(perl_args)-1, perl_args, NULL);  #if PERL_STATIC_LIBS == 1  	perl_eval_pv(\"Irssi::Core::->boot_Irssi_Core(0.9);\", TRUE);  #endif '),('irssi','1.0.0','ca5e9bd623862bd9a640bf8799aafa53502b79f6','ailin-nemui','Merge pull request #624 from ailin-nemui/mail_pl  sync mail.pl','mail.pl','388','0','13','14','MODIFY','@@ -30,6 +30,7 @@ $VERSION = \"2.92\";  # Check /mailbox help for help.    use Irssi::TextUI; +use Irssi;    my $maildirmode = 0; # maildir=1, file(spools)=0  my $old_is_not_new = 0;  @@ -37,7 +38,7 @@ my $extprog;  my ($last_refresh_time, $refresh_tag);    # for mbox caching -my $last_size, $last_mtime, $last_mailcount, $last_mode; +my ($last_size, $last_mtime, $last_mailcount, $last_mode);    # list of mailboxes  my %mailboxes = ();  @@ -101,8 +102,9 @@ sub mbox_count {    my $old_is_not_new=Irssi::settings_get_bool(\'mail_oldnotnew\');      if ($extprog ne \"\") { -     $total = `$extprog`; -     chomp $unread; +     my $total = `$extprog`; +     chomp $total; +     ($read, $unread) = split \' \', $total, 2;    } else {      if (!$maildirmode) {        if (-f $mailfile) { @@ -115,8 +117,7 @@ sub mbox_count {  	$last_size = $size;  	$last_mtime = $mtime;   -	my $f = gensym; -	return 0 if (!open($f, \"<\", $mailfile)); +	return 0 if (!open(my $f, \"<\", $mailfile));    	# count new mails only  	my $internal_removed = 0; @@ -205,7 +206,7 @@ sub mail {    my $total = 0;      # check all mailboxes for new email -  foreach $name (keys(%mailboxes)) { +  foreach my $name (keys(%mailboxes)) {      my $box = $mailboxes{$name};      # replace \"~/\" at the beginning by the user\'s home dir      $box =~ s/^~\\//$ENV{\'HOME\'}\\//; @@ -233,7 +234,7 @@ sub mail {      # Show this only if there are any new, unread messages.      if (Irssi::settings_get_bool(\'mail_show_message\') &&          $unread > $new_mails_in_box{$name}) { -      $new_mails = $unread - $new_mails_in_box{$name}; +      my $new_mails = $unread - $new_mails_in_box{$name};        if ($nummailboxes == 1) {          Irssi::print(\"You have $new_mails new message\" . ($new_mails != 1 ? \"s.\" : \".\"), MSGLEVEL_CRAP);        } else { @@ -263,11 +264,9 @@ sub add_mailboxes {    my $boxstring = $_[0];    my @boxes = split(/,/, $boxstring);   -  foreach $dbox(@boxes) { -    my $name = $dbox; -    $name = substr($dbox, 0, index($dbox, \'=\')); -    my $box = $dbox; -    $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox)); +  foreach my $dbox(@boxes) { +    my $name = substr($dbox, 0, index($dbox, \'=\')); +    my $box = substr($dbox, index($dbox, \'=\') + 1, length($dbox));      addmailbox($name, $box);    }  } @@ -306,7 +305,7 @@ sub delmailbox {  sub update_settings_string {    my $setting;   -  foreach $name (keys(%mailboxes)) { +  foreach my $name (keys(%mailboxes)) {      $setting .= $name . \"=\" . $mailboxes{$name} . \",\";    }   @@ -345,7 +344,7 @@ sub cmd_showmailboxes {      return;    }    Irssi::print(\"Mailboxes:\", MSGLEVEL_CRAP); -  foreach $box (keys(%mailboxes)) { +  foreach my $box (keys(%mailboxes)) {      Irssi::print(\"$box: \" . $mailboxes{$box}, MSGLEVEL_CRAP);    }  } '),('irssi','1.0.0','97b182089eec8cc158313c424b453dcaa39e05af','Nei','Merge branch \'dub-the-wub\' into \'master\'\r \r Prevent a memory leak during the processing of the SASL response.\r \r See merge request !8','sasl.c','199','35','10','4','MODIFY','@@ -174,10 +174,16 @@ static gboolean sasl_reassemble_incoming(IRC_SERVER_REC *server, const char *fra  		*decoded = g_string_new_len(\"\", 0);  	} else {  		gsize dec_len; -		gchar *tmp; - -		tmp = (gchar *) g_base64_decode(enc_req->str, &dec_len); -		*decoded = g_string_new_len(tmp, dec_len); +		gint state = 0; +		guint save = 0; + +		/* Since we\'re not going to use the enc_req GString anymore we +		 * can perform the decoding in place. */ +		dec_len = g_base64_decode_step(enc_req->str, enc_req->len, +					       (guchar *)enc_req->str, +					       &state, &save); +		/* A copy of the data is made when the GString is created. */ +		*decoded = g_string_new_len(enc_req->str, dec_len);  	}    	g_string_free(enc_req, TRUE); '),('irssi','1.0.1','8ec923082737276bce122e082998928ac038bf7f','Paolo','Make themes\' docs more consistent.  Mentioning \"sb-item\" was misleading in that there is no such template, nor any occurrence of that exact string anywhere else in the source.  In going from `sb-item` to `\"sb\"` I am following the pattern established in a couple of comments above:  	\"msgownnick\" specifies the styling â€¦ 	\"ownmsgnick\" specifies â€¦','colorless.theme','236','0','2','2','MODIFY','@@ -261,8 +261,8 @@ abstracts = {    # background for topicbar (same default)    #sb_topic_bg = \"%8\";   -  # text at the beginning of statusbars. sb-item already puts -  # space there,so we don\'t use anything by default. +  # text at the beginning of statusbars. \"sb\" already puts a space there, +  # so we don\'t use anything by default.    sbstart = \"\";    # text at the end of statusbars. Use space so that it\'s never    # used for anything. '),('irssi','1.0.1','8ec923082737276bce122e082998928ac038bf7f','Paolo','Make themes\' docs more consistent.  Mentioning \"sb-item\" was misleading in that there is no such template, nor any occurrence of that exact string anywhere else in the source.  In going from `sb-item` to `\"sb\"` I am following the pattern established in a couple of comments above:  	\"msgownnick\" specifies the styling â€¦ 	\"ownmsgnick\" specifies â€¦','default.theme','240','0','2','2','MODIFY','@@ -261,8 +261,8 @@ abstracts = {    # background for topicbar (same default)    #sb_topic_bg = \"%4\";   -  # text at the beginning of statusbars. sb-item already puts -  # space there,so we don\'t use anything by default. +  # text at the beginning of statusbars. \"sb\" already puts a space there, +  # so we don\'t use anything by default.    sbstart = \"\";    # text at the end of statusbars. Use space so that it\'s never    # used for anything. '),('irssi','1.0.1','99e3d8a30bdf68775825eb79e5c29f3af12cd255','ailin-nemui','tag as 1.0.1','NEWS','2866','0','9','0','MODIFY','@@ -1,3 +1,12 @@ +v1.0.1 2017-02-03  The Irssi team <staff@irssi.org> +	- Fix Perl compilation in object dir. By Martijn Dekker (#602, #623). +	- Disable EC cryptography on Solaris to fix build (#604, #598). +	- Fix incorrect HELP SERVER example (#606, #519). +	- Correct memory leak in /OP and /VOICE. By Tim Konick (#608). +	- Fix regression that broke second level completion (#613, #609). +	- Correct missing NULL termination in perl_parse. By Hanno BÃ¶ck (#619). +	- Sync broken mail.pl script (#624, #607). +  v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>  	* Removed --disable-ipv6 (#408).  	* /connect Network now aborts with an error if no servers have been '),('irssi','1.0.1','99e3d8a30bdf68775825eb79e5c29f3af12cd255','ailin-nemui','tag as 1.0.1','configure.ac','618','0','1','1','MODIFY','@@ -1,4 +1,4 @@ -AC_INIT(irssi, 1.0.0) +AC_INIT(irssi, 1.0.1)  AC_CONFIG_SRCDIR([src])  AC_CONFIG_AUX_DIR(build-aux)  AC_PREREQ(2.50) '),('irssi','1.0.1','28df637055bc6f20f26ec40158f428ed4dac3c3d','ailin-nemui','provide net_start_ssl api  fixes #615','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 7 +#define IRSSI_ABI_VERSION 8    #define DEFAULT_SERVER_ADD_PORT 6667   '),('irssi','1.0.1','28df637055bc6f20f26ec40158f428ed4dac3c3d','ailin-nemui','provide net_start_ssl api  fixes #615','network-openssl.c','640','137','16','0','MODIFY','@@ -20,6 +20,7 @@    #include \"module.h\"  #include \"network.h\" +#include \"net-sendbuffer.h\"  #include \"misc.h\"  #include \"servers.h\"  #include \"signals.h\" @@ -701,6 +702,21 @@ GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *  	return ssl_handle;  }   +GIOChannel *net_start_ssl(SERVER_REC *server) +{ +	GIOChannel *handle, *ssl_handle; + +	g_return_val_if_fail(server != NULL, NULL); + +	handle = net_sendbuffer_handle(server->handle); +	if (handle == NULL) +		return NULL; + +	ssl_handle  = irssi_ssl_get_iochannel(handle, server->connrec->port, server); +	return ssl_handle; +} + +  int irssi_ssl_handshake(GIOChannel *handle)  {  	GIOSSLChannel *chan = (GIOSSLChannel *)handle; '),('irssi','1.0.1','28df637055bc6f20f26ec40158f428ed4dac3c3d','ailin-nemui','provide net_start_ssl api  fixes #615','network.h','35','0','3','0','MODIFY','@@ -40,6 +40,9 @@ int net_ip_compare(IPADDR *ip1, IPADDR *ip2);  GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED;  /* Connect to socket with ip address and SSL*/  GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server); +/* Start TLS */ +GIOChannel *net_start_ssl(SERVER_REC *server); +  int irssi_ssl_handshake(GIOChannel *handle);  /* Connect to socket with ip address */  GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip); '),('irssi','1.0.1','15736ba5ab63d62bfbf8c7907835e5530ba58311','dequis','notify-ison: Don\'t send ison before the connection is done','notify-ison.c','239','44','4','0','MODIFY','@@ -80,6 +80,10 @@ static void ison_send(IRC_SERVER_REC *server, GString *cmd)  {  	MODULE_SERVER_REC *mserver;   +	if (!server->connected) { +		return; +	} +  	mserver = MODULE_DATA(server);  	mserver->ison_count++;   '),('irssi','1.0.1','98ead50b4eea7cda4b357f1c4b19a741205c6fa4','LemonBoy','Prevent some potential null-pointer deferences.  Spotted by our friend scan-build.','fe-channels.c','520','131','1','1','MODIFY','@@ -453,7 +453,7 @@ static void display_sorted_nicks(CHANNEL_REC *channel, GSList *nicklist)  		}  	}   -	if (str->len > strlen(prefix_format)) { +	if (prefix_format != NULL && str->len > strlen(prefix_format)) {  		printtext(channel->server, channel->visible_name,  		          MSGLEVEL_CLIENTCRAP, \"%s\", str->str);  	} '),('irssi','1.0.1','98ead50b4eea7cda4b357f1c4b19a741205c6fa4','LemonBoy','Prevent some potential null-pointer deferences.  Spotted by our friend scan-build.','fe-netsplit.c','285','62','2','0','MODIFY','@@ -148,6 +148,8 @@ static void print_server_splits(IRC_SERVER_REC *server, TEMP_SPLIT_REC *rec, con  	char *sourceserver;  	GSList *tmp;   +	g_return_if_fail(rec->servers != NULL); +  	destservers = g_string_new(NULL);  	for (tmp = rec->servers; tmp != NULL; tmp = tmp->next) {  		NETSPLIT_SERVER_REC *rec = tmp->data; '),('irssi','1.0.1','98ead50b4eea7cda4b357f1c4b19a741205c6fa4','LemonBoy','Prevent some potential null-pointer deferences.  Spotted by our friend scan-build.','mainwindows-layout.c','160','37','2','0','MODIFY','@@ -121,6 +121,8 @@ static void sig_layout_restore(void)  	if (node == NULL) return;    	sorted_config = get_sorted_windows_config(node); +	if (sorted_config == NULL) return; +          windows_count = g_slist_length(sorted_config);            /* calculate the saved terminal height */ '),('irssi','1.0.1','c067f8e99b9332ca485bf1e1809b745878c80f4a','LemonBoy','Do not alias /server <hostname> to /server connect <hostname>  Closes #559.','server.in','63','0','0','2','MODIFY','@@ -59,8 +59,6 @@  %9Examples:%9        /SERVER -    /SERVER chat.freenode.net -    /SERVER +chat.freenode.net      /SERVER CONNECT chat.freenode.net      /SERVER CONNECT +chat.freenode.net      /SERVER ADD -network Freenode -noautosendcmd orwell.freenode.net '),('irssi','1.0.1','c067f8e99b9332ca485bf1e1809b745878c80f4a','LemonBoy','Do not alias /server <hostname> to /server connect <hostname>  Closes #559.','chat-commands.c','366','114','6','13','MODIFY','@@ -250,19 +250,14 @@ static void cmd_server(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  	command_runsub(\"server\", data, server, item);  }   -static void sig_default_command_server(const char *data, SERVER_REC *server, -				       WI_ITEM_REC *item) -{ -        signal_emit(\"command server connect\", 3, data, server, item); -} - -/* SYNTAX: SERVER [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>] [-ssl_pass <password>] -                  [-ssl_verify] [-ssl_cafile <cafile>] [-ssl_capath <capath>] -                  [-ssl_ciphers <list>] -                  [-!] [-noautosendcmd] +/* SYNTAX: SERVER CONNECT [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>]  +		  [-ssl_pass <password>] [-ssl_verify] [-ssl_cafile <cafile>]  +		  [-ssl_capath <capath>] +		  [-ssl_ciphers <list>] +		  [-!] [-noautosendcmd]  		  [-noproxy] [-network <network>] [-host <hostname>]  		  [-rawlog <file>] -                  [+]<address>|<chatnet> [<port> [<password> [<nick>]]] */ +		  [+]<address>|<chatnet> [<port> [<password> [<nick>]]] */  /* NOTE: -network replaces the old -ircnet flag. */  static void cmd_server_connect(const char *data, SERVER_REC *server)  { @@ -495,7 +490,6 @@ void chat_commands_init(void)  	command_bind(\"foreach channel\", NULL, (SIGNAL_FUNC) cmd_foreach_channel);  	command_bind(\"foreach query\", NULL, (SIGNAL_FUNC) cmd_foreach_query);   -	signal_add(\"default command server\", (SIGNAL_FUNC) sig_default_command_server);  	signal_add(\"server sendmsg\", (SIGNAL_FUNC) sig_server_sendmsg);    	command_set_options(\"connect\", \"4 6 !! -network ssl +ssl_cert +ssl_pkey +ssl_pass ssl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_pinned_cert +ssl_pinned_pubkey tls +tls_cert +tls_pkey +tls_pass tls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey +host noproxy -rawlog noautosendcmd\"); @@ -515,6 +509,5 @@ void chat_commands_deinit(void)  	command_unbind(\"foreach channel\", (SIGNAL_FUNC) cmd_foreach_channel);  	command_unbind(\"foreach query\", (SIGNAL_FUNC) cmd_foreach_query);   -        signal_remove(\"default command server\", (SIGNAL_FUNC) sig_default_command_server);  	signal_remove(\"server sendmsg\", (SIGNAL_FUNC) sig_server_sendmsg);  } '),('irssi','1.0.1','9cae98e6421cb454ecc9b3b48d06cce5a042bb6a','LemonBoy','Execute what\'s left in the input queue when the timeout expires.  Similar to how vim behaves.','keyboard.c','675','147','45','1','MODIFY','@@ -35,6 +35,7 @@    GSList *keyinfos;  static GHashTable *keys, *default_keys; +static int key_timeout;    /* A cache of some sort for key presses that generate a single char only.     If the key isn\'t used, used_keys[key] is zero. */ @@ -48,7 +49,8 @@ static int key_config_frozen;    struct _KEYBOARD_REC {  	char *key_state; /* the ongoing key combo */ -        void *gui_data; /* GUI specific data sent in \"key pressed\" signal */ +	guint timer_tag; /* used to check when a pending combo has expired */ +	void *gui_data; /* GUI specific data sent in \"key pressed\" signal */  };    /* Creates a new \"keyboard\" - this is used only for keeping track of @@ -60,6 +62,7 @@ KEYBOARD_REC *keyboard_create(void *data)    	rec = g_new0(KEYBOARD_REC, 1);  	rec->gui_data = data; +	rec->timer_tag = 0;    	signal_emit(\"keyboard created\", 1, rec);          return rec; @@ -68,6 +71,11 @@ KEYBOARD_REC *keyboard_create(void *data)  /* Destroys a keyboard */  void keyboard_destroy(KEYBOARD_REC *keyboard)  { +	if (keyboard->timer_tag > 0) { +		g_source_remove(keyboard->timer_tag); +		keyboard->timer_tag = 0; +	} +  	signal_emit(\"keyboard destroyed\", 1, keyboard);            g_free_not_null(keyboard->key_state); @@ -592,6 +600,25 @@ static int key_states_search(const unsigned char *combo,          return 0;  }   +static gboolean key_timeout_expired(KEYBOARD_REC *keyboard) +{ +	KEY_REC *rec; + +	keyboard->timer_tag = 0; + +	/* So, the timeout has expired with the input queue full, let\'s see if +	 * what we\'ve got is bound to some action. */ +	rec = g_tree_lookup(key_states, keyboard->key_state); +	/* Drain the queue anyway. */ +	g_free_and_null(keyboard->key_state); + +	if (rec != NULL) { +		(void)key_emit_signal(keyboard, rec); +	} + +	return FALSE; +} +  int key_pressed(KEYBOARD_REC *keyboard, const char *key)  {  	KEY_REC *rec; @@ -601,6 +628,11 @@ int key_pressed(KEYBOARD_REC *keyboard, const char *key)  	g_return_val_if_fail(keyboard != NULL, FALSE);  	g_return_val_if_fail(key != NULL && *key != \'\\0\', FALSE);   +	if (keyboard->timer_tag > 0) { +		g_source_remove(keyboard->timer_tag); +		keyboard->timer_tag = 0; +	} +  	if (keyboard->key_state == NULL && key[1] == \'\\0\' &&  	    !used_keys[(int) (unsigned char) key[0]]) {  		/* fast check - key not used */ @@ -625,6 +657,13 @@ int key_pressed(KEYBOARD_REC *keyboard, const char *key)  	if (g_tree_lookup(key_states, combo) != rec) {  		/* key combo continues.. */  		keyboard->key_state = combo; +		/* respect the timeout if specified by the user */ +		if (key_timeout > 0) { +			keyboard->timer_tag = +				g_timeout_add(key_timeout, +					      (GSourceFunc) key_timeout_expired, +					      keyboard); +		}                  return 0;  	}   @@ -870,6 +909,9 @@ static void read_keyboard_config(void)  		key_config_read(tmp->data);            key_configure_thaw(); + +	/* any positive value other than 0 enables the timeout (in ms). */ +	key_timeout = settings_get_int(\"key_timeout\");  }    void keyboard_init(void) @@ -883,6 +925,8 @@ void keyboard_init(void)          key_config_frozen = 0;  	memset(used_keys, 0, sizeof(used_keys));   +	settings_add_int(\"misc\", \"key_timeout\", 0); +  	key_bind(\"command\", \"Run any command\", NULL, NULL, (SIGNAL_FUNC) sig_command);  	key_bind(\"key\", \"Specify name for key binding\", NULL, NULL, (SIGNAL_FUNC) sig_key);  	key_bind(\"multi\", \"Run multiple commands\", NULL, NULL, (SIGNAL_FUNC) sig_multi); '),('irssi','1.0.1','db85ab7c90f23e00cd444728f6a5b3d1f63254df','LemonBoy','Quote the filename when dcc requests are auto accepted.  PR #453 forces the user to quote the filenames given to /DCC commands when they contain spaces but the autoget functionality didn\'t get updated so the filename was always passed without quotes.  Closes #656.','dcc-autoget.c','51','18','1','1','MODIFY','@@ -70,7 +70,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)  	file = dcc_get_download_path(dcc->arg);  	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&  			      stat(file, &statbuf) == 0 ? -			      \"RESUME %s %s\" : \"GET %s %s\", +			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\",  			      dcc->nick, dcc->arg);  	signal_emit(\"command dcc\", 2, str, dcc->server);          g_free(file); '),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','Handle file names with quotes.  Let\'s repurpose escape_string and make it more flexible by letting us choose the characters to escape.','misc.c','707','237','11','9','MODIFY','@@ -724,18 +724,20 @@ int expand_escape(const char **data)  	}  }   -/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */ -char *escape_string(const char *str) +/* Escape all the characters in `what\' with a backslash */ +char *escape_string(const char *str, const char *what)  { -	char *ret, *p; +	const char *p; +	char *ret;   -	p = ret = g_malloc(strlen(str)*2+1); -	while (*str != \'\\0\') { -		if (*str == \'\"\' || *str == \'\\\'\' || *str == \'\\\\\') -			*p++ = \'\\\\\'; -		*p++ = *str++; +	ret = g_malloc(strlen(str) * 2 + 1); +	for (p = str; *p != \'\\0\'; p++, ret++) { +		if (strchr(what, *p) != NULL) { +			*ret++ = \'\\\\\'; +		} +		*ret = *p;  	} -	*p = \'\\0\'; +	*ret = \'\\0\';    	return ret;  } '),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','Handle file names with quotes.  Let\'s repurpose escape_string and make it more flexible by letting us choose the characters to escape.','misc.h','47','0','2','2','MODIFY','@@ -88,8 +88,8 @@ char *stristr_full(const char *data, const char *key);  char *ascii_strup(char *str);  char *ascii_strdown(char *str);   -/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */ -char *escape_string(const char *str); +/* Escape all the characters in `what\' with a backslash */ +char *escape_string(const char *str, const char *what);    /* convert all low-ascii (<32) to ^<A..> combinations */  char *show_lowascii(const char *str); '),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','Handle file names with quotes.  Let\'s repurpose escape_string and make it more flexible by letting us choose the characters to escape.','chat-completion.c','954','227','1','1','MODIFY','@@ -1113,7 +1113,7 @@ static void event_text(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  	/* the nick is quoted in case it contains \'-\' character. also  	   spaces should work too now :) The nick is also escaped in case  	   it contains \'\\\' characters */ -	target = escape_string(window_item_get_target(item)); +	target = escape_string(window_item_get_target(item), \"\\\"\'\\\\\");  	str = g_strdup_printf(IS_CHANNEL(item) ? \"-channel \\\"%s\\\" %s\" :  			      IS_QUERY(item) ? \"-nick \\\"%s\\\" %s\" : \"%s %s\",  			      target, line); '),('irssi','1.0.1','027acffb4208d7e6ba8e229cbf6c3dae6f5dabaf','LemonBoy','Handle file names with quotes.  Let\'s repurpose escape_string and make it more flexible by letting us choose the characters to escape.','dcc-autoget.c','54','18','6','2','MODIFY','@@ -23,6 +23,7 @@  #include \"masks.h\"  #include \"settings.h\"  #include \"servers.h\" +#include \"misc.h\"    #include \"dcc-get.h\"   @@ -30,7 +31,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)  {          struct stat statbuf;  	const char *masks; -        char *str, *file; +        char *str, *file, *esc_arg;          int max_size;            if (!IS_DCC_GET(dcc)) return; @@ -68,11 +69,14 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)    	/* ok. but do we want/need to resume? */  	file = dcc_get_download_path(dcc->arg); +	/* we have to escape the quotes as the whole file name gets quoted */ +	esc_arg = escape_string(dcc->arg, \"\\\"\");  	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&  			      stat(file, &statbuf) == 0 ?  			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\", -			      dcc->nick, dcc->arg); +			      dcc->nick, esc_arg);  	signal_emit(\"command dcc\", 2, str, dcc->server); +	g_free(esc_arg);          g_free(file);  	g_free(str);  } '),('irssi','1.0.1','9aaa6449a0a554c83d40b56ce0a87bd0cba8bdbf','ailin-nemui','make foreach send commands','chat-commands.c','384','117','34','9','MODIFY','@@ -438,41 +438,66 @@ static void cmd_foreach(const char *data, SERVER_REC *server,  /* SYNTAX: FOREACH SERVER <command> */  static void cmd_foreach_server(const char *data, SERVER_REC *server)  { -        GSList *list; +	GSList *list; +	const char *cmdchars; +	char *str; + +	cmdchars = settings_get_str(\"cmdchars\"); +	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) : +		g_strdup_printf(\"%c%s\", *cmdchars, data);    	list = g_slist_copy(servers);  	while (list != NULL) { -		signal_emit(\"send command\", 3, data, list->data, NULL); -                list = g_slist_remove(list, list->data); +		signal_emit(\"send command\", 3, str, list->data, NULL); +		list = g_slist_remove(list, list->data);  	} + +	g_free(str);  }    /* SYNTAX: FOREACH CHANNEL <command> */  static void cmd_foreach_channel(const char *data)  { -        GSList *list; +	GSList *list; +	const char *cmdchars; +	char *str; + +	cmdchars = settings_get_str(\"cmdchars\"); +	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) : +		g_strdup_printf(\"%c%s\", *cmdchars, data);    	list = g_slist_copy(channels);  	while (list != NULL) {  		CHANNEL_REC *rec = list->data;   -		signal_emit(\"send command\", 3, data, rec->server, rec); -                list = g_slist_remove(list, list->data); +		signal_emit(\"send command\", 3, str, rec->server, rec); +		list = g_slist_remove(list, list->data);  	} + +	g_free(str);  }    /* SYNTAX: FOREACH QUERY <command> */  static void cmd_foreach_query(const char *data)  { -        GSList *list; +	GSList *list; +	const char *cmdchars; +	char *str; + +	cmdchars = settings_get_str(\"cmdchars\"); +	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) : +		g_strdup_printf(\"%c%s\", *cmdchars, data); +    	list = g_slist_copy(queries);  	while (list != NULL) {  		QUERY_REC *rec = list->data;   -		signal_emit(\"send command\", 3, data, rec->server, rec); -                list = g_slist_remove(list, list->data); +		signal_emit(\"send command\", 3, str, rec->server, rec); +		list = g_slist_remove(list, list->data);  	} + +	g_free(str);  }    void chat_commands_init(void) '),('irssi','1.0.1','9aaa6449a0a554c83d40b56ce0a87bd0cba8bdbf','ailin-nemui','make foreach send commands','window-commands.c','711','178','13','5','MODIFY','@@ -839,23 +839,31 @@ static void cmd_layout(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  /* SYNTAX: FOREACH WINDOW <command> */  static void cmd_foreach_window(const char *data)  { -        WINDOW_REC *old; -        GSList *list; +	WINDOW_REC *old; +	GSList *list; +	const char *cmdchars; +	char *str;   -        old = active_win; +	cmdchars = settings_get_str(\"cmdchars\"); +	str = strchr(cmdchars, *data) != NULL ? g_strdup(data) : +		g_strdup_printf(\"%c%s\", *cmdchars, data); + +	old = active_win;    	list = g_slist_copy(windows);  	while (list != NULL) {  		WINDOW_REC *rec = list->data;    		active_win = rec; -		signal_emit(\"send command\", 3, data, rec->active_server, +		signal_emit(\"send command\", 3, str, rec->active_server,  			    rec->active); -                list = g_slist_remove(list, list->data); +		list = g_slist_remove(list, list->data);  	}    	if (g_slist_find(windows, old) != NULL)  		active_win = old; + +	g_free(str);  }    void window_commands_init(void) '),('irssi','1.0.1','7c09b72848f99886964266ff531b41c69fe138f5','dequis','fe-netjoin: remove irc servers on \"server disconnected\" signal','fe-netjoin.c','375','91','16','0','MODIFY','@@ -470,6 +470,20 @@ static void read_settings(void)  	}  }   +static void sig_server_disconnected(IRC_SERVER_REC *server) +{ +	NETJOIN_SERVER_REC *netjoin_server; + +	g_return_if_fail(server != NULL); + +	if (!IS_IRC_SERVER(server)) +		return; + +	if ((netjoin_server = netjoin_find_server(server))) { +		netjoin_server_remove(netjoin_server); +	} +} +  void fe_netjoin_init(void)  {  	settings_add_bool(\"misc\", \"hide_netsplit_quits\", TRUE); @@ -480,6 +494,7 @@ void fe_netjoin_init(void)    	read_settings();  	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings); +	signal_add(\"server disconnected\", (SIGNAL_FUNC) sig_server_disconnected);  }    void fe_netjoin_deinit(void) @@ -492,6 +507,7 @@ void fe_netjoin_deinit(void)  	}    	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings); +	signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_server_disconnected);    	signal_remove(\"message quit\", (SIGNAL_FUNC) msg_quit);  	signal_remove(\"message join\", (SIGNAL_FUNC) msg_join); '),('irssi','1.0.1','5c4e6304ce12a3c94cc58eec01d4ef45db4dabc3','Stephen Oberholtzer','Don\'t emit the script destroyed signal before script is actually destroyed  The script unloading code originally worked like this:  1. Destroy package 2. Emit \'script destroyed\' signal 3. Unhook script\'s signal handlers  If a script added a \'script destroyed\' signal handler, unloading that script would cause the \'script destroyed\' signal to be sent to the (already destroyed) package.  This would cause a script error, which would trigger a script unload, which would start the whole process over again, until we run out of heap or stack space and segfault.  This commit simply reorders the operations so that the \'script destroyed\' signal is sent *after* the script is fully destroyed.','perl-core.c','321','60','2','2','MODIFY','@@ -67,11 +67,11 @@ static void perl_script_destroy(PERL_SCRIPT_REC *script)  {  	perl_scripts = g_slist_remove(perl_scripts, script);   -	signal_emit(\"script destroyed\", 1, script); -  	perl_signal_remove_script(script);  	perl_source_remove_script(script);   +	signal_emit(\"script destroyed\", 1, script); +  	g_free(script->name);  	g_free(script->package);          g_free_not_null(script->path); '),('irssi','1.0.1','dc99f8d7a5f90eebd4c52cef8d186bf20e2a9912','LemonBoy','Properly check the command arguments in tail place.  A command requiring an argument and given in tail position would not raise an error but silently set the value to the empty string \'\'.','commands.c','711','187','3','2','MODIFY','@@ -567,13 +567,14 @@ static int get_cmd_options(char **data, int ignore_unknown,    	option = NULL; pos = -1;  	for (;;) { -		if (**data == \'-\') { +		if (**data == \'\\0\' || **data == \'-\') {  			if (option != NULL && *optlist[pos] == \'+\') {  				/* required argument missing! */                                  *data = optlist[pos] + 1;  				return CMDERR_OPTION_ARG_MISSING;  			} - +		} +		if (**data == \'-\') {  			(*data)++;  			if (**data == \'-\' && (*data)[1] == \' \') {  				/* -- option means end of options even '),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','Revert \"Quote the filename when dcc requests are auto accepted.\"','misc.c','705','239','9','11','MODIFY','@@ -724,20 +724,18 @@ int expand_escape(const char **data)  	}  }   -/* Escape all the characters in `what\' with a backslash */ -char *escape_string(const char *str, const char *what) +/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */ +char *escape_string(const char *str)  { -	const char *p; -	char *ret; +	char *ret, *p;   -	ret = g_malloc(strlen(str) * 2 + 1); -	for (p = str; *p != \'\\0\'; p++, ret++) { -		if (strchr(what, *p) != NULL) { -			*ret++ = \'\\\\\'; -		} -		*ret = *p; +	p = ret = g_malloc(strlen(str)*2+1); +	while (*str != \'\\0\') { +		if (*str == \'\"\' || *str == \'\\\'\' || *str == \'\\\\\') +			*p++ = \'\\\\\'; +		*p++ = *str++;  	} -	*ret = \'\\0\'; +	*p = \'\\0\';    	return ret;  } '),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','Revert \"Quote the filename when dcc requests are auto accepted.\"','misc.h','47','0','2','2','MODIFY','@@ -88,8 +88,8 @@ char *stristr_full(const char *data, const char *key);  char *ascii_strup(char *str);  char *ascii_strdown(char *str);   -/* Escape all the characters in `what\' with a backslash */ -char *escape_string(const char *str, const char *what); +/* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */ +char *escape_string(const char *str);    /* convert all low-ascii (<32) to ^<A..> combinations */  char *show_lowascii(const char *str); '),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','Revert \"Quote the filename when dcc requests are auto accepted.\"','chat-completion.c','954','227','1','1','MODIFY','@@ -1113,7 +1113,7 @@ static void event_text(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  	/* the nick is quoted in case it contains \'-\' character. also  	   spaces should work too now :) The nick is also escaped in case  	   it contains \'\\\' characters */ -	target = escape_string(window_item_get_target(item), \"\\\"\'\\\\\"); +	target = escape_string(window_item_get_target(item));  	str = g_strdup_printf(IS_CHANNEL(item) ? \"-channel \\\"%s\\\" %s\" :  			      IS_QUERY(item) ? \"-nick \\\"%s\\\" %s\" : \"%s %s\",  			      target, line); '),('irssi','1.0.1','62fd3ac1804d5d45bc2302ceac9ee9c7ef372e1a','ailin-nemui','Revert \"Quote the filename when dcc requests are auto accepted.\"','dcc-autoget.c','51','18','3','7','MODIFY','@@ -23,7 +23,6 @@  #include \"masks.h\"  #include \"settings.h\"  #include \"servers.h\" -#include \"misc.h\"    #include \"dcc-get.h\"   @@ -31,7 +30,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)  {          struct stat statbuf;  	const char *masks; -        char *str, *file, *esc_arg; +        char *str, *file;          int max_size;            if (!IS_DCC_GET(dcc)) return; @@ -69,14 +68,11 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)    	/* ok. but do we want/need to resume? */  	file = dcc_get_download_path(dcc->arg); -	/* we have to escape the quotes as the whole file name gets quoted */ -	esc_arg = escape_string(dcc->arg, \"\\\"\");  	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&  			      stat(file, &statbuf) == 0 ? -			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\", -			      dcc->nick, esc_arg); +			      \"RESUME %s %s\" : \"GET %s %s\", +			      dcc->nick, dcc->arg);  	signal_emit(\"command dcc\", 2, str, dcc->server); -	g_free(esc_arg);          g_free(file);  	g_free(str);  } '),('irssi','1.0.1','7bd1b80687cc97010094de0d398b429480e0a608','ailin-nemui','fix dcc get  fixes #656','dcc-autoget.c','54','18','6','3','MODIFY','@@ -23,6 +23,7 @@  #include \"masks.h\"  #include \"settings.h\"  #include \"servers.h\" +#include \"misc.h\"    #include \"dcc-get.h\"   @@ -30,7 +31,7 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)  {          struct stat statbuf;  	const char *masks; -        char *str, *file; +        char *str, *file, *esc_arg;          int max_size;            if (!IS_DCC_GET(dcc)) return; @@ -68,11 +69,13 @@ static void sig_dcc_request(GET_DCC_REC *dcc, const char *nickaddr)    	/* ok. but do we want/need to resume? */  	file = dcc_get_download_path(dcc->arg); +	esc_arg = escape_string(dcc->arg);  	str = g_strdup_printf(settings_get_bool(\"dcc_autoresume\") &&  			      stat(file, &statbuf) == 0 ? -			      \"RESUME %s %s\" : \"GET %s %s\", -			      dcc->nick, dcc->arg); +			      \"RESUME %s \\\"%s\\\"\" : \"GET %s \\\"%s\\\"\", +			      dcc->nick, esc_arg);  	signal_emit(\"command dcc\", 2, str, dcc->server); +	g_free(esc_arg);          g_free(file);  	g_free(str);  } '),('irssi','1.0.1','93c158d8156293bd95e4bf5bdb75cf8d44bc4eab','dequis','expand_escape: expand double backslash as a backslash','misc.c','707','240','2','0','MODIFY','@@ -690,6 +690,8 @@ int expand_escape(const char **data)  		return \'\\n\';  	case \'e\':  		return 27; /* ESC */ +	case \'\\\\\': +		return \'\\\\\';    	case \'x\':                  /* hex digit */ '),('irssi','1.0.1','22bc7fcc3906ff3dd6e3837e049d37dc352edf94','ailin-nemui','amend forgotten fix  (cherry picked from commit 0ada284a257cfb08da984a78dab24c3ddaf09ec7)','NEWS','2869','0','2','0','MODIFY','@@ -8,6 +8,8 @@ v1.0.1 2017-02-03  The Irssi team <staff@irssi.org>  	- Fix regression that broke second level completion (#613, #609).  	- Correct missing NULL termination in perl_parse. By Hanno BÃ¶ck (#619).  	- Sync broken mail.pl script (#624, #607). +	- Prevent a memory leak during the processing of the SASL +	  response (GL!8, GL#5)    v1.0.0 2017-01-03  The Irssi team <staff@irssi.org>  	* Removed --disable-ipv6 (#408). '),('irssi','1.0.2','3930f91edcf4b1e96c9d857233d58f7cb45c8a86','Ailin Nemui','tag as 1.0.2  (cherry picked from commit 2a53853f369b47e42e32e183c8109e3d63808899)','NEWS','2878','0','10','0','MODIFY','@@ -1,5 +1,15 @@  v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>   +v1.0.2 2017-03-10  The Irssi team <staff@irssi.org> +	- Prevent some null-pointer crashes (GL!9). +	- Fix compilation with OpenSSL 1.1.0 (#628, #597). +	- Correct dereferencing of already freed server objects during +	  output of netjoins. Found by APic (GL!10, GL#7). +	- Fix in command arg parser to detect missing arguments in tail place +	  (#652, #651). +	- Fix regression that broke incoming DCC file transfers (#667, #656). +	- Fix issue with escaping \\ in evaluated strings (#669, #520). +  v1.0.1 2017-02-03  The Irssi team <staff@irssi.org>  	- Fix Perl compilation in object dir. By Martijn Dekker (#602, #623).  	- Disable EC cryptography on Solaris to fix build (#604, #598). '),('irssi','1.0.2','966efced3c178031f5f75a1009acc0ec8f897b4a','ailin-nemui','up abi ver','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 8 +#define IRSSI_ABI_VERSION 9    #define DEFAULT_SERVER_ADD_PORT 6667   '),('irssi','1.0.2','a720c3b5efdcd9b580110441bb22be91a4a16732','Rodrigo Rebello','Get back to using pkg-config to check for OpenSSL  Commit 6300dfec7 removed the option to disable SSL support from the configure script since it became a requirement, but it also removed the use of pkg-config for finding the OpenSSL library and its dependencies.  This had the unfortunate consequence of breaking the correct detection of library flags in many static linking scenarios. In some cases, for example, OpenSSL might have been built with zlib, which requires `-lz` to be passed to the linker when doing a static link of the irssi executable. Thus, pkg-config becomes an invaluable tool in such situations, since no guessing work is needed as the OpenSSL .pc file provides all the necessary flags.  So, this commit re-inserts the PKG_CHECK_MODULES macro in the configure script when looking for OpenSSL. The test using AC_CHECK_LIB remains, but only as a last resort in case the one using pkg-config fails.  Also, because the macro AM_PATH_GLIB_2_0 contains an unconditional call to PKG_PROG_PKG_CONFIG, the OpenSSL checks are moved so that they come after the Glib ones in order to avoid doubly checking for the pkg-config binary (PKG_CHECK_MODULES skips that check if it has been performed before, but PKG_PROG_PKG_CONFIG does not).','configure.ac','670','4','15','6','MODIFY','@@ -243,11 +243,6 @@ if test \"x$want_socks\" = \"xyes\"; then  	])  fi   -dnl ** -dnl ** OpenSSL checks -dnl ** -AC_CHECK_LIB([ssl], [SSL_library_init]) -  dnl **  dnl ** fe-text checks  dnl ** @@ -289,7 +284,21 @@ if test -z \"$GLIB_LIBS\"; then    AC_ERROR([GLIB is required to build irssi.])  fi   -LIBS=\"$LIBS $GLIB_LIBS -lssl -lcrypto\" +LIBS=\"$LIBS $GLIB_LIBS\" + +dnl ** +dnl ** OpenSSL checks +dnl ** +PKG_CHECK_MODULES([OPENSSL], [openssl], [ +	CFLAGS=\"$CFLAGS $OPENSSL_CFLAGS\" +	LIBS=\"$LIBS $OPENSSL_LIBS\" +], [ +	AC_CHECK_LIB([ssl], [SSL_library_init], [ +		LIBS=\"$LIBS -lssl -lcrypto\" +	], [ +		AC_MSG_ERROR([The OpenSSL library was not found]) +	]) +])    dnl **  dnl ** curses checks '),('irssi','1.0.2','449b8a4589f1fcadae44387999260ed5f8c6c2bf','Rodrigo Rebello','Remove outdated information from INSTALL  Disabling SSL support is no longer an option.','INSTALL','80','0','0','4','MODIFY','@@ -30,10 +30,6 @@ configure options      Build the irssi proxy (see startup-HOWTO).   -  --disable-ssl - -  Disable SSL support. -    --with-perl=[yes|no|module]      Enable Perl support '),('irssi','1.0.2','70f9db3cbdc0a3c6b622e64edbd504592f921892','Stephen Oberholtzer','Fix delay at startup when running against glib 2.49.3+  In glib v2.49.3, an optimization was made to eliminate certain unnecessary wakeups.  (The specific change was made in e4ee3079c5afc3c1c3d2415f20c3e8605728f074). Before this change, the first call to g_main_iteration would always complete immediately. In Irssi, this effectively reversed the order of the main loop, causing the reload_config check and the dirty_check to run *before* the first blocking call to g_main_iteration.  With the new logic, the first g_main_iteration call now blocks, preventing the screen from being refreshed until the user starts typing or a timer goes off.  (It also delays processing of SIGHUP, but I expect that is not a common situation.)  This commit reorders the main loop to wait at the end of the loop, rather than the beginning, addressing the problem.  (This closes Debian bug #856201.)','irssi.c','224','24','4','4','MODIFY','@@ -317,10 +317,6 @@ int main(int argc, char **argv)  	/* Does the same as g_main_run(main_loop), except we  	   can call our dirty-checker after each iteration */  	while (!quitting) { -		term_refresh_freeze(); -		g_main_iteration(TRUE); -                term_refresh_thaw(); -  		if (reload_config) {                          /* SIGHUP received, do /RELOAD */  			reload_config = FALSE; @@ -328,6 +324,10 @@ int main(int argc, char **argv)  		}    		dirty_check(); + +		term_refresh_freeze(); +		g_main_iteration(TRUE); +                term_refresh_thaw();  	}    	g_main_destroy(main_loop); '),('irssi','1.0.2','2b9be6e2ed446293008d0e850fd726aad30fbcd2','Stephen Oberholtzer','Intentation/whitespace fixes  Change several instances of space-indentation to tabs, matching the surrounding code.','irssi.c','224','24','4','4','MODIFY','@@ -318,21 +318,21 @@ int main(int argc, char **argv)  	   can call our dirty-checker after each iteration */  	while (!quitting) {  		if (reload_config) { -                        /* SIGHUP received, do /RELOAD */ +			/* SIGHUP received, do /RELOAD */  			reload_config = FALSE; -                        signal_emit(\"command reload\", 1, \"\"); +			signal_emit(\"command reload\", 1, \"\");  		}    		dirty_check();    		term_refresh_freeze();  		g_main_iteration(TRUE); -                term_refresh_thaw(); +		term_refresh_thaw();  	}    	g_main_destroy(main_loop);  	textui_deinit();   -        session_upgrade(); /* if we /UPGRADEd, start the new process */ +	session_upgrade(); /* if we /UPGRADEd, start the new process */  	return 0;  } '),('irssi','1.0.2','a4cc4e0ad7278835d976aa5e75ca2b42443f5bb1','Joseph Bisch','Fix off by one error with char_expandos','expandos.c','547','114','1','1','MODIFY','@@ -51,7 +51,7 @@ const char *current_expando = NULL;    static int timer_tag;   -static EXPANDO_REC *char_expandos[255]; +static EXPANDO_REC *char_expandos[256];  static GHashTable *expandos;  static char *last_sent_msg, *last_sent_msg_body;  static char *last_privmsg_from, *last_public_from; '),('irssi','1.0.2','41776d71f76924664bce1562ebe37743ba0cc9b7','Joseph Bisch','Fix strange history behavior when history is empty  If text is being entered and then the user presses the up arrow followed by the down arrow, the expected behavior is to return to the text being entered. Prior to this commit that was not the case.  Fixes #462','command-history.c','227','55','2','0','MODIFY','@@ -116,6 +116,8 @@ const char *command_history_prev(WINDOW_REC *window, const char *text)  		history->pos = history->pos->prev;  		if (history->pos == NULL)                          history->over_counter++; +	} else if (history->lines == 0) { +		history->over_counter++;  	} else {  		history->pos = g_list_last(history->list);  	} '),('irssi','1.0.2','7c86575b02d4f80539bcd2da3bef8195b963fa92','Joseph Bisch','Don\'t allow command history to wrap around  This changes the behavior of the command history to avoid wrapping back to the bottom once the top of the history is reached.','command-history.c','220','53','4','10','MODIFY','@@ -113,11 +113,9 @@ const char *command_history_prev(WINDOW_REC *window, const char *text)  	pos = history->pos;    	if (pos != NULL) { -		history->pos = history->pos->prev; -		if (history->pos == NULL) -                        history->over_counter++; -	} else if (history->lines == 0) { -		history->over_counter++; +		/* don\'t go past the first entry (no wrap around) */ +		if (history->pos->prev != NULL) +			history->pos = history->pos->prev;  	} else {  		history->pos = g_list_last(history->list);  	} @@ -128,7 +126,7 @@ const char *command_history_prev(WINDOW_REC *window, const char *text)  		command_history_add(history, text);  	}   -	return history->pos == NULL ? \"\" : history->pos->data; +	return history->pos == NULL ? text : history->pos->data;  }    const char *command_history_next(WINDOW_REC *window, const char *text) @@ -141,10 +139,6 @@ const char *command_history_next(WINDOW_REC *window, const char *text)    	if (pos != NULL)  		history->pos = history->pos->next; -	else if (history->over_counter > 0) { -		history->over_counter--; -		history->pos = history->list; -	}    	if (*text != \'\\0\' &&  	    (pos == NULL || g_strcmp0(pos->data, text) != 0)) { '),('irssi','1.0.2','405136440cbfd18a39e2d5aa01c812a1247c369d','Joseph Bisch','Remove over_counter  We are no longer using over_counter for any functional purpose, so remove it.','command-history.c','219','53','0','1','MODIFY','@@ -150,7 +150,6 @@ const char *command_history_next(WINDOW_REC *window, const char *text)    void command_history_clear_pos_func(HISTORY_REC *history, gpointer user_data)  { -	history->over_counter = 0;  	history->pos = NULL;  }   '),('irssi','1.0.2','405136440cbfd18a39e2d5aa01c812a1247c369d','Joseph Bisch','Remove over_counter  We are no longer using over_counter for any functional purpose, so remove it.','command-history.h','21','0','1','1','MODIFY','@@ -7,7 +7,7 @@ typedef struct {  	char *name;    	GList *list, *pos; -	int lines, over_counter; +	int lines;    	int refcount;  } HISTORY_REC; '),('irssi','1.0.2','3297fafcd9be1fc3f48557a12023a1ef20884985','Joseph Bisch','Add syntax info for completion  Allows syntax info to be picked up and displayed by help command.  Fixes #687','completion.c','639','180','1','0','MODIFY','@@ -784,6 +784,7 @@ static void sig_complete_command(GList **list, WINDOW_REC *window,  	if (*list != NULL) signal_stop();  }   +/* SYNTAX: COMPLETION [-auto] [-delete] <key> <value> */  static void cmd_completion(const char *data)  {  	GHashTable *optlist; '),('irssi','1.0.2','c8a19e112499c0ca1d2b07a98d68415ca1509614','ailin-nemui','detect Netbsd terminfo  fixes #694','configure.ac','670','4','1','1','MODIFY','@@ -308,7 +308,7 @@ if test \"x$want_textui\" != \"xno\"; then    	TEXTUI_NO_LIBS=\"$LIBS\"  	LIBS= -	AC_SEARCH_LIBS([setupterm], [tinfo ncursesw ncurses], [want_textui=yes], [ +	AC_SEARCH_LIBS([setupterm], [tinfo ncursesw ncurses terminfo], [want_textui=yes], [  		AC_ERROR(Terminfo not found - install libncurses-dev or ncurses-devel package)  		want_textui=\"no, Terminfo not found\"  	]) '),('irssi','1.0.2','0c760b0c1bd86134fd5f55205b2ea45ba8e2f4af','Joseph Bisch','Add fuzz.diff for fuzzing with afl  Authored by dx.','fuzz.diff','226','0','257','0','ADD','@@ -0,0 +1,269 @@ +diff --git a/src/core/network.c b/src/core/network.c +index 3e1b7c7..1e5324a 100644 +--- a/src/core/network.c ++++ b/src/core/network.c +@@ -199,6 +199,10 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip) + /* Connect to named UNIX socket */ + GIOChannel *net_connect_unix(const char *path) + { ++	if (strcmp(path, \"/dev/stdin\") == 0) { ++		return g_io_channel_new(0); ++	} ++ + 	struct sockaddr_un sa; + 	int handle, ret; +  +@@ -336,6 +340,8 @@ int net_receive(GIOChannel *handle, char *buf, int len) + /* Transmit data, return number of bytes sent, -1 = error */ + int net_transmit(GIOChannel *handle, const char *data, int len) + { ++	return write(1, data, len); ++ +         gsize ret; + 	GIOStatus status; + 	GError *err = NULL; +@@ -495,6 +501,7 @@ int net_host2ip(const char *host, IPADDR *ip) + /* Get socket error */ + int net_geterror(GIOChannel *handle) + { ++	return 0; + 	int data; + 	socklen_t len = sizeof(data); +  +diff --git a/src/core/servers-reconnect.c b/src/core/servers-reconnect.c +index 58c9dd0..0c6ec1b 100644 +--- a/src/core/servers-reconnect.c ++++ b/src/core/servers-reconnect.c +@@ -484,7 +484,8 @@ void servers_reconnect_init(void) + 	reconnects = NULL; + 	last_reconnect_tag = 0; +  +-	reconnect_timeout_tag = g_timeout_add(1000, (GSourceFunc) server_reconnect_timeout, NULL); ++	(void) server_reconnect_timeout; ++ + 	read_settings(); +  + 	signal_add(\"server connect failed\", (SIGNAL_FUNC) sig_reconnect); +diff --git a/src/core/settings.c b/src/core/settings.c +index e65ceb2..f9dc678 100644 +--- a/src/core/settings.c ++++ b/src/core/settings.c +@@ -704,7 +704,10 @@ int irssi_config_is_changed(const char *fname) +  + static CONFIG_REC *parse_configfile(const char *fname) + { +-	CONFIG_REC *config; ++	CONFIG_REC *config = config_open(NULL, -1); ++	config_parse_data(config, default_config, \"internal\"); ++	return config; ++ + 	struct stat statbuf; +         const char *path; + 	char *str; +@@ -871,8 +874,6 @@ void settings_init(void) + 	init_configfile(); +  + 	settings_add_bool(\"misc\", \"settings_autosave\", TRUE); +-	timeout_tag = g_timeout_add(SETTINGS_AUTOSAVE_TIMEOUT, +-				    (GSourceFunc) sig_autosave, NULL); + 	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished); + 	signal_add(\"gui exit\", (SIGNAL_FUNC) sig_autosave); + } +diff --git a/src/fe-common/core/fe-common-core.c b/src/fe-common/core/fe-common-core.c +index 1b2ab1e..4344cd9 100644 +--- a/src/fe-common/core/fe-common-core.c ++++ b/src/fe-common/core/fe-common-core.c +@@ -320,6 +320,8 @@ static void autoconnect_servers(void) + 	GSList *tmp, *chatnets; + 	char *str; +  ++	return; ++ + 	if (autocon_server != NULL) { + 		/* connect to specified server */ + 		if (autocon_password == NULL) +@@ -390,6 +392,7 @@ static void sig_setup_changed(void) +  + static void autorun_startup(void) + { ++	return; + 	char *path; + 	GIOChannel *handle; + 	GString *buf; +diff --git a/src/fe-common/core/themes.c b/src/fe-common/core/themes.c +index 2b1459b..2e518a1 100644 +--- a/src/fe-common/core/themes.c ++++ b/src/fe-common/core/themes.c +@@ -790,9 +790,8 @@ static void theme_read_module(THEME_REC *theme, const char *module) + { + 	CONFIG_REC *config; +  +-	config = config_open(theme->path, -1); +-	if (config != NULL) +-		config_parse(config); ++	config = config_open(NULL, -1); ++	config_parse_data(config, default_theme, \"internal\"); +  + 	theme_init_module(theme, module, config); +  +@@ -987,7 +986,7 @@ static int theme_read(THEME_REC *theme, const char *path) + 	THEME_READ_REC rec; +         char *str; +  +-	config = config_open(path, -1) ; ++	config = config_open(NULL, -1) ; + 	if (config == NULL) { + 		/* didn\'t exist or no access? */ + 		str = g_strdup_printf(\"Error reading theme file %s: %s\", +@@ -997,7 +996,7 @@ static int theme_read(THEME_REC *theme, const char *path) + 		return FALSE; + 	} +  +-	if (path == NULL) ++	if (1) + 		config_parse_data(config, default_theme, \"internal\"); +         else + 		config_parse(config); +@@ -1200,6 +1199,7 @@ static void module_save(const char *module, MODULE_THEME_REC *rec, +  + static void theme_save(THEME_REC *theme, int save_all) + { ++	return; + 	CONFIG_REC *config; + 	THEME_SAVE_REC data; + 	char *path; +diff --git a/src/fe-text/gui-readline.c b/src/fe-text/gui-readline.c +index 7c71edd..6bf2177 100644 +--- a/src/fe-text/gui-readline.c ++++ b/src/fe-text/gui-readline.c +@@ -1126,7 +1126,6 @@ void gui_readline_init(void) + 	paste_timeout_id = -1; + 	paste_bracketed_mode = FALSE; + 	g_get_current_time(&last_keypress); +-        input_listen_init(STDIN_FILENO); +  + 	settings_add_bool(\"lookandfeel\", \"term_appkey_mode\", TRUE); + 	settings_add_str(\"history\", \"scroll_page_count\", \"/2\"); +diff --git a/src/fe-text/irssi.c b/src/fe-text/irssi.c +index ad79e0c..84d0c5c 100644 +--- a/src/fe-text/irssi.c ++++ b/src/fe-text/irssi.c +@@ -314,20 +314,16 @@ int main(int argc, char **argv) + 	textui_finish_init(); + 	main_loop = g_main_new(TRUE); +  ++#ifdef __AFL_HAVE_MANUAL_CONTROL ++	__AFL_INIT(); ++#endif ++ ++	signal_emit(\"command connect\", 1, \"/dev/stdin 6667\"); ++ + 	/* Does the same as g_main_run(main_loop), except we + 	   can call our dirty-checker after each iteration */ + 	while (!quitting) { +-		term_refresh_freeze(); + 		g_main_iteration(TRUE); +-                term_refresh_thaw(); +- +-		if (reload_config) { +-                        /* SIGHUP received, do /RELOAD */ +-			reload_config = FALSE; +-                        signal_emit(\"command reload\", 1, \"\"); +-		} +- +-		dirty_check(); + 	} +  + 	g_main_destroy(main_loop); +diff --git a/src/fe-text/term-terminfo.c b/src/fe-text/term-terminfo.c +index b2478c6..cebe260 100644 +--- a/src/fe-text/term-terminfo.c ++++ b/src/fe-text/term-terminfo.c +@@ -29,6 +29,10 @@ + #include <termios.h> + #include <stdio.h> +  ++#undef putc ++#define putc(x, y) (void) (x) ++#define fputc(x, y) (void) (x), 0 ++ + /* returns number of characters in the beginning of the buffer being a +    a single character, or -1 if more input is needed. The character will be +    saved in result */ +@@ -113,7 +117,8 @@ int term_init(void) + 	vcmove = FALSE; cforcemove = TRUE; +         curs_visible = TRUE; +  +-	current_term = terminfo_core_init(stdin, stdout); ++	FILE *devnull = fopen(\"/dev/null\", \"r+\"); ++	current_term = terminfo_core_init(devnull, devnull); + 	if (current_term == NULL) + 		return FALSE; +  +@@ -670,6 +675,7 @@ void term_set_input_type(int type) +  + void term_gets(GArray *buffer, int *line_count) + { ++	return; + 	int ret, i, char_len; +  +         /* fread() doesn\'t work */ +diff --git a/src/fe-text/terminfo-core.c b/src/fe-text/terminfo-core.c +index 9c9179a..6349935 100644 +--- a/src/fe-text/terminfo-core.c ++++ b/src/fe-text/terminfo-core.c +@@ -6,6 +6,10 @@ + #  define _POSIX_VDISABLE 0 + #endif +  ++#undef putc ++#define putc(x, y) (void) (x) ++#define fputc(x, y) (void) (x), 0 ++ + #define tput(s) tputs(s, 0, term_putchar) + inline static int term_putchar(int c) + { +diff --git a/src/irc/core/irc.c b/src/irc/core/irc.c +index 4dce3fc..25fbb34 100644 +--- a/src/irc/core/irc.c ++++ b/src/irc/core/irc.c +@@ -383,12 +383,13 @@ static void irc_parse_incoming(SERVER_REC *server) + 		signal_emit_id(signal_server_incoming, 2, server, str); +  + 		if (server->connection_lost) +-			server_disconnect(server); ++			exit(0); +  + 		count++; + 	} + 	if (ret == -1) { + 		/* connection lost */ ++		exit(0); + 		server->connection_lost = TRUE; + 		server_disconnect(server); + 	} +diff --git a/src/lib-config/write.c b/src/lib-config/write.c +index 37e51f0..ee82726 100644 +--- a/src/lib-config/write.c ++++ b/src/lib-config/write.c +@@ -299,6 +299,8 @@ static int config_write_block(CONFIG_REC *rec, CONFIG_NODE *node, int list, int +  + int config_write(CONFIG_REC *rec, const char *fname, int create_mode) + { ++	return 0; ++ + 	int ret; + 	int fd; +  +diff --git a/src/perl/perl-core.c b/src/perl/perl-core.c +index 2c61df7..485fe25 100644 +--- a/src/perl/perl-core.c ++++ b/src/perl/perl-core.c +@@ -395,6 +395,7 @@ int perl_get_api_version(void) +  + void perl_scripts_autorun(void) + { ++	return; + 	DIR *dirp; + 	struct dirent *dp; + 	struct stat statbuf; '),('irssi','1.0.2','dbde9f0fe3c9fcd7eb8e56e9b1beffb71b0607e1','Jari Matilainen','Added support for -notls and -notls_verify','fe-server.c','372','109','8','2','MODIFY','@@ -156,6 +156,10 @@ static void cmd_server_add_modify(const char *data, gboolean add)    	if (g_hash_table_lookup(optlist, \"tls\") || g_hash_table_lookup(optlist, \"ssl\"))  		rec->use_tls = TRUE; +	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) { +		rec->use_tls = FALSE; +		rec->tls_verify = FALSE; +	}    	value = g_hash_table_lookup(optlist, \"tls_cert\");  	if (value == NULL) @@ -177,6 +181,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)    	if (g_hash_table_lookup(optlist, \"tls_verify\") || g_hash_table_lookup(optlist, \"ssl_verify\"))  		rec->tls_verify = TRUE; +	else if (g_hash_table_lookup(optlist, \"notls_verify\") || g_hash_table_lookup(optlist, \"nossl_verify\")) +		rec->tls_verify = FALSE;    	value = g_hash_table_lookup(optlist, \"tls_cafile\");  	if (value == NULL) @@ -434,8 +440,8 @@ void fe_server_init(void)  	command_bind_first(\"server\", NULL, (SIGNAL_FUNC) server_command);  	command_bind_first(\"disconnect\", NULL, (SIGNAL_FUNC) server_command);   -	command_set_options(\"server add\", \"4 6 !! ssl +ssl_cert +ssl_pkey +ssl_pass ssl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls +tls_cert +tls_pkey +tls_pass tls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\"); -	command_set_options(\"server modify\", \"4 6 !! ssl +ssl_cert +ssl_pkey +ssl_pass ssl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls +tls_cert +tls_pkey +tls_pass tls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\"); +	command_set_options(\"server add\", \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\"); +	command_set_options(\"server modify\", \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\");    	signal_add(\"server looking\", (SIGNAL_FUNC) sig_server_looking);  	signal_add(\"server connecting\", (SIGNAL_FUNC) sig_server_connecting); '),('irssi','1.0.2','f060292a9cd0835dd9cc8c24a4ede67909a2b68b','Jari Matilainen','Added braces','fe-server.c','373','109','2','1','MODIFY','@@ -154,8 +154,9 @@ static void cmd_server_add_modify(const char *data, gboolean add)          else if (g_hash_table_lookup(optlist, \"4\"))  		rec->family = AF_INET;   -	if (g_hash_table_lookup(optlist, \"tls\") || g_hash_table_lookup(optlist, \"ssl\")) +	if (g_hash_table_lookup(optlist, \"tls\") || g_hash_table_lookup(optlist, \"ssl\")) {  		rec->use_tls = TRUE; +	}  	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) {  		rec->use_tls = FALSE;  		rec->tls_verify = FALSE; '),('irssi','1.0.2','25f9c71f690f9fd846a39e646fbd11f715ffbfa5','Jari Matilainen','Allow -port <num> or irc.host.tld <port num> in /server add and /server modify','fe-server.c','367','105','7','5','MODIFY','@@ -117,7 +117,11 @@ static void cmd_server_add_modify(const char *data, gboolean add)  		return;    	if (*addr == \'\\0\') cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); -	port = *portstr == \'\\0\' ? DEFAULT_SERVER_ADD_PORT : atoi(portstr); + +        value = g_hash_table_lookup(optlist, \"port\"); +        port = *portstr == \'\\0\' ? +                (value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT) +		: atoi(portstr);    	chatnet = g_hash_table_lookup(optlist, \"network\");   @@ -137,11 +141,7 @@ static void cmd_server_add_modify(const char *data, gboolean add)  			return;  		}  		rec->address = g_strdup(addr); -		rec->port = port;  	} else { -		value = g_hash_table_lookup(optlist, \"port\"); -		if (value != NULL && *value != \'\\0\') rec->port = atoi(value); -  		if (*password != \'\\0\') g_free_and_null(rec->password);  		if (g_hash_table_lookup(optlist, \"host\")) {  			g_free_and_null(rec->own_host); @@ -149,6 +149,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)  		}  	}   +	rec->port = port; +  	if (g_hash_table_lookup(optlist, \"6\"))  		rec->family = AF_INET6;          else if (g_hash_table_lookup(optlist, \"4\")) '),('irssi','1.0.2','783458e9ba068117089d23730add317069cf6447','Jari Matilainen','Added code comments','fe-server.c','373','109','2','0','MODIFY','@@ -159,6 +159,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)  	}  	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) {  		rec->use_tls = FALSE; +		/* if rec has tls_verify = TRUE then use_tls will be set to true on lines 224-225 +		   so explicitly set tls_verify to FALSE when -notls is used */  		rec->tls_verify = FALSE;  	}   '),('irssi','1.0.2','787e192567626dab7788e54363dbccda52d5322c','ailin-nemui','improve nicklist performance','nicklist.c','415','102','31','22','MODIFY','@@ -166,41 +166,50 @@ void nicklist_rename_unique(SERVER_REC *server,  			     nicklist_get_same_unique(server, old_nick_id));  }   +#define NICKLIST_GETNICKS_LOOP_INIT(hashtable)			 \\ +	do {							 \\ +		GHashTableIter _iter;				 \\ +		g_hash_table_iter_init(&_iter, (hashtable));		\\ +		while (g_hash_table_iter_next(&_iter, NULL, (void*)&nick)) { \\ +			while (nick != NULL) { +#define NICKLIST_GETNICKS_LOOP_END					\\ +				nick = nick->next;			\\ +			}						\\ +		}							\\ +	} while (0) +  static NICK_REC *nicklist_find_wildcards(CHANNEL_REC *channel,  					 const char *mask)  { -	GSList *nicks, *tmp;  	NICK_REC *nick;   -	nicks = nicklist_getnicks(channel); -	nick = NULL; -	for (tmp = nicks; tmp != NULL; tmp = tmp->next) { -		nick = tmp->data; +	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks);   -		if (mask_match_address(channel->server, mask, -				       nick->nick, nick->host)) -			break; -	} -	g_slist_free(nicks); -	return tmp == NULL ? NULL : nick; +	if (mask_match_address(channel->server, mask, +			       nick->nick, nick->host)) +		return nick; + +	NICKLIST_GETNICKS_LOOP_END; +	return NULL;  }    GSList *nicklist_find_multiple(CHANNEL_REC *channel, const char *mask)  { -	GSList *nicks, *tmp, *next; +	GSList *nicks; +	NICK_REC *nick;    	g_return_val_if_fail(IS_CHANNEL(channel), NULL);  	g_return_val_if_fail(mask != NULL, NULL);   -	nicks = nicklist_getnicks(channel); -	for (tmp = nicks; tmp != NULL; tmp = next) { -		NICK_REC *nick = tmp->data; +	nicks = NULL;   -		next = tmp->next; -		if (!mask_match_address(channel->server, mask, -					nick->nick, nick->host)) -                        nicks = g_slist_remove(nicks, tmp->data); -	} +	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks); + +	if (mask_match_address(channel->server, mask, +			       nick->nick, nick->host)) +		nicks = g_slist_prepend(nicks, nick); + +	NICKLIST_GETNICKS_LOOP_END;    	return nicks;  } @@ -264,8 +273,8 @@ NICK_REC *nicklist_find_mask(CHANNEL_REC *channel, const char *mask)  static void get_nicks_hash(gpointer key, NICK_REC *rec, GSList **list)  {  	while (rec != NULL) { -		*list = g_slist_append(*list, rec); -                rec = rec->next; +		*list = g_slist_prepend(*list, rec); +		rec = rec->next;  	}  }   '),('irssi','1.0.2','371eb7f5052b9cce7efcbcc4086cd6f6716e21fd','ailin-nemui','expand macro','nicklist.c','423','106','19','26','MODIFY','@@ -166,30 +166,21 @@ void nicklist_rename_unique(SERVER_REC *server,  			     nicklist_get_same_unique(server, old_nick_id));  }   -#define NICKLIST_GETNICKS_LOOP_INIT(hashtable)			 \\ -	do {							 \\ -		GHashTableIter _iter;				 \\ -		g_hash_table_iter_init(&_iter, (hashtable));		\\ -		while (g_hash_table_iter_next(&_iter, NULL, (void*)&nick)) { \\ -			while (nick != NULL) { -#define NICKLIST_GETNICKS_LOOP_END					\\ -				nick = nick->next;			\\ -			}						\\ -		}							\\ -	} while (0) -  static NICK_REC *nicklist_find_wildcards(CHANNEL_REC *channel,  					 const char *mask)  {  	NICK_REC *nick; +	GHashTableIter iter; + +	g_hash_table_iter_init(&iter, channel->nicks); +	while (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) { +		for (; nick != NULL; nick = nick->next) { +			if (mask_match_address(channel->server, mask, +					       nick->nick, nick->host)) +				return nick; +		} +	}   -	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks); - -	if (mask_match_address(channel->server, mask, -			       nick->nick, nick->host)) -		return nick; - -	NICKLIST_GETNICKS_LOOP_END;  	return NULL;  }   @@ -197,19 +188,21 @@ GSList *nicklist_find_multiple(CHANNEL_REC *channel, const char *mask)  {  	GSList *nicks;  	NICK_REC *nick; +	GHashTableIter iter;    	g_return_val_if_fail(IS_CHANNEL(channel), NULL);  	g_return_val_if_fail(mask != NULL, NULL);    	nicks = NULL;   -	NICKLIST_GETNICKS_LOOP_INIT(channel->nicks); - -	if (mask_match_address(channel->server, mask, -			       nick->nick, nick->host)) -		nicks = g_slist_prepend(nicks, nick); - -	NICKLIST_GETNICKS_LOOP_END; +	g_hash_table_iter_init(&iter, channel->nicks); +	while (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) { +		for (; nick != NULL; nick = nick->next) { +			if (mask_match_address(channel->server, mask, +					       nick->nick, nick->host)) +				nicks = g_slist_prepend(nicks, nick); +		} +	}    	return nicks;  } '),('irssi','1.0.2','4a6fbdbe7891859ffd7b51a87147ecb6158df141','Jari Matilainen','Spaces to tabs','fe-server.c','367','105','3','3','MODIFY','@@ -118,9 +118,9 @@ static void cmd_server_add_modify(const char *data, gboolean add)    	if (*addr == \'\\0\') cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);   -        value = g_hash_table_lookup(optlist, \"port\"); -        port = *portstr == \'\\0\' ? -                (value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT) +	value = g_hash_table_lookup(optlist, \"port\"); +	port = *portstr == \'\\0\' ? +		(value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT)  		: atoi(portstr);    	chatnet = g_hash_table_lookup(optlist, \"network\"); '),('irssi','1.0.2','81cf8d8813c4226e0d9db5f776e0f6a6904813e0','ailin-nemui','Update fe-server.c','fe-server.c','373','109','1','2','MODIFY','@@ -159,8 +159,7 @@ static void cmd_server_add_modify(const char *data, gboolean add)  	}  	else if (g_hash_table_lookup(optlist, \"notls\") || g_hash_table_lookup(optlist, \"nossl\")) {  		rec->use_tls = FALSE; -		/* if rec has tls_verify = TRUE then use_tls will be set to true on lines 224-225 -		   so explicitly set tls_verify to FALSE when -notls is used */ +		/* tls_verify implies use_tls, disable it explicitly */  		rec->tls_verify = FALSE;  	}   '),('irssi','1.0.2','0c26aeb9fc716416aa7dde2356cc59643f7cc793','Jari Matilainen','Make sure port is only set on /server modify if specified','fe-server.c','370','107','6','3','MODIFY','@@ -120,7 +120,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)    	value = g_hash_table_lookup(optlist, \"port\");  	port = *portstr == \'\\0\' ? -		(value != NULL && *value != \'\\0\' ? atoi(value) : DEFAULT_SERVER_ADD_PORT) +			(value != NULL && *value != \'\\0\' ? +			atoi(value) : DEFAULT_SERVER_ADD_PORT)  		: atoi(portstr);    	chatnet = g_hash_table_lookup(optlist, \"network\"); @@ -141,7 +142,11 @@ static void cmd_server_add_modify(const char *data, gboolean add)  			return;  		}  		rec->address = g_strdup(addr); +		rec->port = port;  	} else { +		if (*portstr != \'\\0\' || g_hash_table_lookup(optlist, \"port\")) +			rec->port = port; +  		if (*password != \'\\0\') g_free_and_null(rec->password);  		if (g_hash_table_lookup(optlist, \"host\")) {  			g_free_and_null(rec->own_host); @@ -149,8 +154,6 @@ static void cmd_server_add_modify(const char *data, gboolean add)  		}  	}   -	rec->port = port; -  	if (g_hash_table_lookup(optlist, \"6\"))  		rec->family = AF_INET6;          else if (g_hash_table_lookup(optlist, \"4\")) '),('irssi','1.0.2','5045f4766a72f18a3d682d1c9eeeffb40ab32569','mh','dcc.in: fixed typo \'resolved\' -&gt; \'resolves\'  n/t','dcc.in','31','0','1','1','MODIFY','@@ -27,7 +27,7 @@      and file transfers.        If you are behind NAT, or if the firewall is too restrictive, you might -    want to try if using the passive parameter resolved your connection +    want to try if using the passive parameter resolves your connection      problem.        You can send files which contain special character or spaces by enclosing '),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','Add parse_uint function to improve integer overflow handling  Originally found by oss-fuzz (issue 525) in get_ansi_color using ubsan. After a lot of analysis I\'m 99% sure this isn\'t security relevant so it\'s fine to handle this publicly.  The fix is mainly adding a function that does it right and use it everywhere. This is harder than it seems because the strtol() family of functions doesn\'t have the friendliest of interfaces.  Aside from get_ansi_color(), there were other pieces of code that used the same (out*10+(*in-\'0\')) pattern, like the parse_size() and parse_time_interval() functions, which are mostly used for settings. Those are interesting cases, since they multiply the parsed number (resulting in more overflows) and they write to a signed integer parameter (which can accidentally make the uints negative without UB)  Thanks to Pascal Cuoq for enlightening me about the undefined behavior of parse_size (and, in particular, the implementation-defined behavior of one of the WIP versions of this commit, where something like signed integer overflow happened, but it was legal). Also for writing tis-interpreter, which is better than ubsan to verify these things.','misc.c','771','255','103','16','MODIFY','@@ -750,10 +750,42 @@ int nearest_power(int num)  	return n;  }   -int parse_time_interval(const char *time, int *msecs) +/* Parses unsigned integers from strings with decent error checking. + * Returns true on success, false otherwise (overflow, no valid number, etc) + * There\'s a 31 bit limit so the output can be assigned to signed positive ints */ +int parse_uint(const char *nptr, char **endptr, int base, guint *number) +{ +	char *endptr_; +	gulong parsed; + +	/* strtoul accepts whitespace and plus/minus signs, for some reason */ +	if (!i_isdigit(*nptr)) { +		return FALSE; +	} + +	errno = 0; +	parsed = strtoul(nptr, &endptr_, base); + +	if (errno || endptr_ == nptr || parsed >= (1U << 31)) { +		return FALSE; +	} + +	if (endptr) { +		*endptr = endptr_; +	} + +	if (number) { +		*number = (guint) parsed; +	} + +	return TRUE; +} + +static int parse_time_interval_uint(const char *time, guint *msecs)  {  	const char *desc; -	int number, sign, len, ret, digits; +	guint number; +	int sign, len, ret, digits;    	*msecs = 0;   @@ -769,8 +801,11 @@ int parse_time_interval(const char *time, int *msecs)  	}  	for (;;) {  		if (i_isdigit(*time)) { -			number = number*10 + (*time - \'0\'); -			time++; +			char *endptr; +			if (!parse_uint(time, &endptr, 10, &number)) { +				return FALSE; +			} +			time = endptr;  			digits = TRUE;  			continue;  		} @@ -835,10 +870,11 @@ int parse_time_interval(const char *time, int *msecs)  	return ret;  }   -int parse_size(const char *size, int *bytes) +static int parse_size_uint(const char *size, guint *bytes)  {  	const char *desc; -	int number, len; +	guint number, multiplier, limit; +	int len;    	*bytes = 0;   @@ -846,8 +882,11 @@ int parse_size(const char *size, int *bytes)  	number = 0;  	while (*size != \'\\0\') {  		if (i_isdigit(*size)) { -			number = number*10 + (*size - \'0\'); -			size++; +			char *endptr; +			if (!parse_uint(size, &endptr, 10, &number)) { +				return FALSE; +			} +			size = endptr;  			continue;  		}   @@ -869,14 +908,31 @@ int parse_size(const char *size, int *bytes)  			return FALSE;  		}   -		if (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0) -			*bytes += number * 1024*1024*1024; -		if (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0) -			*bytes += number * 1024*1024; -		if (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0) -			*bytes += number * 1024; -		if (g_ascii_strncasecmp(desc, \"bytes\", len) == 0) -			*bytes += number; +		multiplier = 0; +		limit = 0; + +		if (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0) { +			multiplier = 1U << 30; +			limit = 2U << 0; +		} +		if (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0) { +			multiplier = 1U << 20; +			limit = 2U << 10; +		} +		if (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0) { +			multiplier = 1U << 10; +			limit = 2U << 20; +		} +		if (g_ascii_strncasecmp(desc, \"bytes\", len) == 0) { +			multiplier = 1; +			limit = 2U << 30; +		} + +		if (limit && number > limit) { +			return FALSE; +		} + +		*bytes += number * multiplier;    		/* skip punctuation */  		while (*size != \'\\0\' && i_ispunct(*size)) @@ -886,6 +942,37 @@ int parse_size(const char *size, int *bytes)  	return TRUE;  }   +int parse_size(const char *size, int *bytes) +{ +	guint bytes_; +	int ret; + +	ret = parse_size_uint(size, &bytes_); + +	if (bytes_ > (1U << 31)) { +		return FALSE; +	} + +	*bytes = bytes_; +	return ret; +} + +int parse_time_interval(const char *time, int *msecs) +{ +	guint msecs_; +	int ret; + +	ret = parse_time_interval_uint(time, &msecs_); + +	if (msecs_ > (1U << 31)) { +		return FALSE; +	} + +	*msecs = msecs_; +	return ret; +} + +  char *ascii_strup(char *str)  {  	char *s; '),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','Add parse_uint function to improve integer overflow handling  Originally found by oss-fuzz (issue 525) in get_ansi_color using ubsan. After a lot of analysis I\'m 99% sure this isn\'t security relevant so it\'s fine to handle this publicly.  The fix is mainly adding a function that does it right and use it everywhere. This is harder than it seems because the strtol() family of functions doesn\'t have the friendliest of interfaces.  Aside from get_ansi_color(), there were other pieces of code that used the same (out*10+(*in-\'0\')) pattern, like the parse_size() and parse_time_interval() functions, which are mostly used for settings. Those are interesting cases, since they multiply the parsed number (resulting in more overflows) and they write to a signed integer parameter (which can accidentally make the uints negative without UB)  Thanks to Pascal Cuoq for enlightening me about the undefined behavior of parse_size (and, in particular, the implementation-defined behavior of one of the WIP versions of this commit, where something like signed integer overflow happened, but it was legal). Also for writing tis-interpreter, which is better than ubsan to verify these things.','misc.h','48','0','1','0','MODIFY','@@ -71,6 +71,7 @@ int expand_escape(const char **data);  int nearest_power(int num);    /* Returns TRUE / FALSE */ +int parse_uint(const char *nptr, char **endptr, int base, guint *number);  int parse_time_interval(const char *time, int *msecs);  int parse_size(const char *size, int *bytes);   '),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','Add parse_uint function to improve integer overflow handling  Originally found by oss-fuzz (issue 525) in get_ansi_color using ubsan. After a lot of analysis I\'m 99% sure this isn\'t security relevant so it\'s fine to handle this publicly.  The fix is mainly adding a function that does it right and use it everywhere. This is harder than it seems because the strtol() family of functions doesn\'t have the friendliest of interfaces.  Aside from get_ansi_color(), there were other pieces of code that used the same (out*10+(*in-\'0\')) pattern, like the parse_size() and parse_time_interval() functions, which are mostly used for settings. Those are interesting cases, since they multiply the parsed number (resulting in more overflows) and they write to a signed integer parameter (which can accidentally make the uints negative without UB)  Thanks to Pascal Cuoq for enlightening me about the undefined behavior of parse_size (and, in particular, the implementation-defined behavior of one of the WIP versions of this commit, where something like signed integer overflow happened, but it was legal). Also for writing tis-interpreter, which is better than ubsan to verify these things.','special-vars.c','540','160','6','3','MODIFY','@@ -275,6 +275,8 @@ static char *get_special_value(char **cmd, SERVER_REC *server, void *item,  static int get_alignment_args(char **data, int *align, int *flags, char *pad)  {  	char *str; +	char *endptr; +	guint align_;    	*align = 0;  	*flags = ALIGN_CUT|ALIGN_PAD; @@ -295,10 +297,11 @@ static int get_alignment_args(char **data, int *align, int *flags, char *pad)  		return FALSE; /* expecting number */    	/* get the alignment size */ -	while (i_isdigit(*str)) { -		*align = (*align) * 10 + (*str-\'0\'); -		str++; +	if (!parse_uint(str, &endptr, 10, &align_)) { +		return FALSE;  	} +	str = endptr; +	*align = align_;    	/* get the pad character */  	while (*str != \'\\0\' && *str != \']\') { '),('irssi','1.0.2','632b0ce5e68ce32ade90382cb64fbb8d1e75090d','dequis','Add parse_uint function to improve integer overflow handling  Originally found by oss-fuzz (issue 525) in get_ansi_color using ubsan. After a lot of analysis I\'m 99% sure this isn\'t security relevant so it\'s fine to handle this publicly.  The fix is mainly adding a function that does it right and use it everywhere. This is harder than it seems because the strtol() family of functions doesn\'t have the friendliest of interfaces.  Aside from get_ansi_color(), there were other pieces of code that used the same (out*10+(*in-\'0\')) pattern, like the parse_size() and parse_time_interval() functions, which are mostly used for settings. Those are interesting cases, since they multiply the parsed number (resulting in more overflows) and they write to a signed integer parameter (which can accidentally make the uints negative without UB)  Thanks to Pascal Cuoq for enlightening me about the undefined behavior of parse_size (and, in particular, the implementation-defined behavior of one of the WIP versions of this commit, where something like signed integer overflow happened, but it was legal). Also for writing tis-interpreter, which is better than ubsan to verify these things.','formats.c','1133','357','20','8','MODIFY','@@ -33,6 +33,7 @@  #include \"themes.h\"  #include \"recode.h\"  #include \"utf8.h\" +#include \"misc.h\"    static const char *format_backs = \"04261537\";  static const char *format_fores = \"kbgcrmyw\"; @@ -870,8 +871,9 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,  {  	static char ansitab[8] = { 0, 4, 2, 6, 1, 5, 3, 7 };  	const char *start; -	int fg, bg, flags, num, i; -	unsigned int num2; +	char *endptr; +	int fg, bg, flags, i; +	guint num, num2;    	if (*str != \'[\')  		return str; @@ -886,8 +888,10 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,  		if (*str == \'\\0\') return start;    		if (i_isdigit(*str)) { -			num = num*10 + (*str-\'0\'); -			continue; +			if (!parse_uint(str, &endptr, 10, &num)) { +				return start; +			} +			str = endptr;  		}    		if (*str != \';\' && *str != \'m\') @@ -958,8 +962,12 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,  			/* ANSI indexed color or RGB color */  			if (*str != \';\') break;  			str++; -			for (num2 = 0; i_isdigit(*str); str++) -				num2 = num2*10 + (*str-\'0\'); + +			if (!parse_uint(str, &endptr, 10, &num2)) { +				return start; +			} +			str = endptr; +  			if (*str == \'\\0\') return start;    			switch (num2) { @@ -1006,8 +1014,12 @@ static const char *get_ansi_color(THEME_REC *theme, const char *str,  				/* indexed */  				if (*str != \';\') break;  				str++; -				for (num2 = 0; i_isdigit(*str); str++) -					num2 = num2*10 + (*str-\'0\'); + +				if (!parse_uint(str, &endptr, 10, &num2)) { +					return start; +				} +				str = endptr; +  				if (*str == \'\\0\') return start;    				if (num == 38) { '),('irssi','1.0.2','d61c54c32b6383186a8f32d852594cc4e10240d9','ailin-nemui','do not reset true colour bit on colour reset  fixes #710','textbuffer-view.c','1043','252','0','2','MODIFY','@@ -114,7 +114,6 @@ static void update_cmd_color(unsigned char cmd, int *color)  		if (cmd & LINE_COLOR_BG) {  			/* set background color */  			*color &= FGATTR; -			*color &= ~ATTR_FGCOLOR24;  			if ((cmd & LINE_COLOR_DEFAULT) == 0)  				*color |= (cmd & 0x0f) << BG_SHIFT;  			else { @@ -123,7 +122,6 @@ static void update_cmd_color(unsigned char cmd, int *color)  		} else {  			/* set foreground color */  			*color &= BGATTR; -			*color &= ~ATTR_BGCOLOR24;  			if ((cmd & LINE_COLOR_DEFAULT) == 0)  				*color |= cmd & 0x0f;  			else { '),('irssi','1.0.2','601be187746234c36c407a17ca54b17c82264e1b','ailin-nemui','Update list.in  Add a more detailed paragraph about service bots\r \r Fixes #699\r \r I would like to add another paragraph about how freenode is \r broken and spits at you the whole list instead of empty list \r if you attempt to use network side filtering......','list.in','22','0','7','3','MODIFY','@@ -24,11 +24,15 @@    %9Remarks:%9   -    Not all networks support server-side filtering and may provide a network +    Not all networks support server-side filtering. Some provide a network      service or service bot instead; on IRCnet, you may use the List service:   -    /SQUERY List HELP -    /MSG ALIS HELP +    /SQUERY Alis HELP + +    Other networks with service bots (like ChanServ) may also provide a list +    service bot (confirm with /WHOIS ALIS): + +    /MSG Alis HELP    %9See also:%9 STATS, SQUERY, WHOIS   '),('irssi','1.0.2','30a92754bb650c3dedd507d41110443142899a65','Joseph Bisch','Fix oob read of one byte in get_file_params_count{,_resume}  We can use continue to handle cases such as: \"ab<space><space>c\"','dcc-get.c','426','94','2','0','MODIFY','@@ -382,6 +382,8 @@ int get_file_params_count(char **params, int paramcount)  	if (*params[0] == \'\"\') {  		/* quoted file name? */  		for (pos = 0; pos < paramcount-3; pos++) { +			if (strlen(params[pos]) == 0) +				continue;  			if (params[pos][strlen(params[pos])-1] == \'\"\' &&  			    get_params_match(params, pos+1))  				return pos+1; '),('irssi','1.0.2','30a92754bb650c3dedd507d41110443142899a65','Joseph Bisch','Fix oob read of one byte in get_file_params_count{,_resume}  We can use continue to handle cases such as: \"ab<space><space>c\"','dcc-resume.c','174','47','2','0','MODIFY','@@ -62,6 +62,8 @@ int get_file_params_count_resume(char **params, int paramcount)  	if (*params[0] == \'\"\') {  		/* quoted file name? */  		for (pos = 0; pos < paramcount-2; pos++) { +			if (strlen(params[pos]) == 0) +				continue;  			if (params[pos][strlen(params[pos])-1] == \'\"\' &&  			    get_params_match_resume(params, pos+1))  				return pos+1; '),('irssi','1.0.2','528f51bfbe5c65c5b24546faa244009dd5b3c586','Joseph Bisch','Fix dcc_request where addr is NULL','dcc-get.c','427','94','4','0','MODIFY','@@ -428,6 +428,10 @@ static void ctcp_msg_dcc_send(IRC_SERVER_REC *server, const char *data,  	int p_id = -1;  	int passive = FALSE;   +	if (addr == NULL) { +		addr = \"\"; +	} +  	/* SEND <file name> <address> <port> <size> [...] */  	/* SEND <file name> <address> 0 <size> <id> (DCC SEND passive protocol) */  	params = g_strsplit(data, \" \", -1); '),('irssi','1.0.2','1ce9e07be0ad33fbdac9413e9045c45e66afff37','Joseph Bisch','Use CXX for fe-fuzz linking','Makefile.am','18','0','2','2','MODIFY','@@ -1,7 +1,7 @@  bin_PROGRAMS = irssi-fuzz   -# Force link with clang++ for libfuzzer support -CCLD=clang++ $(CXXFLAGS) +# Force link with CXX for libfuzzer support +CCLD=$(CXX) $(CXXFLAGS)    AM_CPPFLAGS = \\  	-I$(top_srcdir)/src \\ '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','configure.ac','671','4','1','0','MODIFY','@@ -505,6 +505,7 @@ AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIFUZZER, test \"$want_irssifuzzer\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIPROXY, test \"$want_irssiproxy\" = \"yes\")  AM_CONDITIONAL(HAVE_PERL, test \"$want_perl\" != \"no\") +AM_CONDITIONAL(USE_GREGEX, test \"x$want_gregex\" = \"xyes\")    # move LIBS to PROG_LIBS so they\'re not tried to be used when linking eg. perl libraries  PROG_LIBS=$LIBS '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','Makefile.am','106','0','8','0','MODIFY','@@ -7,6 +7,12 @@ AM_CPPFLAGS = \\  	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\  	-DMODULEDIR=\\\"\"$(libdir)/irssi/modules\"\\\"   +if USE_GREGEX +regex_impl=iregex-gregex.c +else +regex_impl=iregex-regexh.c +endif +  libcore_a_SOURCES = \\  	args.c \\  	channels.c \\ @@ -45,6 +51,7 @@ libcore_a_SOURCES = \\  	signals.c \\  	special-vars.c \\  	utf8.c \\ +	$(regex_impl) \\  	wcwidth.c \\  	tls.c \\  	write-buffer.c @@ -97,6 +104,7 @@ pkginc_core_HEADERS = \\  	signals.h \\  	special-vars.h \\  	utf8.h \\ +	iregex.h \\  	window-item-def.h \\  	tls.h \\  	write-buffer.h \\ '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','ignore.c','351','132','5','35','MODIFY','@@ -24,6 +24,7 @@  #include \"levels.h\"  #include \"lib-config/iconfig.h\"  #include \"settings.h\" +#include \"iregex.h\"    #include \"masks.h\"  #include \"servers.h\" @@ -67,13 +68,8 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)  		return FALSE;    	if (rec->regexp) { -#ifdef USE_GREGEX  		return rec->preg != NULL && -			g_regex_match(rec->preg, text, 0, NULL); -#else -		return rec->regexp_compiled && -			regexec(&rec->preg, text, 0, NULL, 0) == 0; -#endif +			i_regex_match(rec->preg, text, 0, NULL, NULL);  	}    	return rec->fullword ? @@ -327,41 +323,19 @@ static void ignore_remove_config(IGNORE_REC *rec)    static void ignore_init_rec(IGNORE_REC *rec)  { -#ifdef USE_GREGEX  	if (rec->preg != NULL) -		g_regex_unref(rec->preg); +		i_regex_unref(rec->preg);    	if (rec->regexp && rec->pattern != NULL) {  		GError *re_error = NULL;   -		rec->preg = g_regex_new(rec->pattern, G_REGEX_OPTIMIZE | G_REGEX_RAW | G_REGEX_CASELESS, 0, &re_error); +		rec->preg = i_regex_new(rec->pattern, G_REGEX_OPTIMIZE | G_REGEX_CASELESS, 0, &re_error);    		if (rec->preg == NULL) {  			g_warning(\"Failed to compile regexp \'%s\': %s\", rec->pattern, re_error->message);  			g_error_free(re_error);  		}  	} -#else -	char *errbuf; -	int errcode, errbuf_len; - -	if (rec->regexp_compiled) regfree(&rec->preg); -	rec->regexp_compiled = FALSE; - -	if (rec->regexp && rec->pattern != NULL) { -		errcode = regcomp(&rec->preg, rec->pattern, -				REG_EXTENDED|REG_ICASE|REG_NOSUB); -		if (errcode != 0) { -			errbuf_len = regerror(errcode, &rec->preg, 0, 0); -			errbuf = g_malloc(errbuf_len); -			regerror(errcode, &rec->preg, errbuf, errbuf_len); -			g_warning(\"Failed to compile regexp \'%s\': %s\", rec->pattern, errbuf); -			g_free(errbuf); -		} else { -			rec->regexp_compiled = TRUE; -		} -	} -#endif  }    void ignore_add_rec(IGNORE_REC *rec) @@ -381,11 +355,7 @@ static void ignore_destroy(IGNORE_REC *rec, int send_signal)  	if (send_signal)  		signal_emit(\"ignore destroyed\", 1, rec);   -#ifdef USE_GREGEX -	if (rec->preg != NULL) g_regex_unref(rec->preg); -#else -	if (rec->regexp_compiled) regfree(&rec->preg); -#endif +	if (rec->preg != NULL) i_regex_unref(rec->preg);  	if (rec->channels != NULL) g_strfreev(rec->channels);  	g_free_not_null(rec->mask);  	g_free_not_null(rec->servertag); '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','ignore.h','30','0','2','9','MODIFY','@@ -1,9 +1,7 @@  #ifndef __IGNORE_H  #define __IGNORE_H   -#ifndef USE_GREGEX -#  include <regex.h> -#endif +#include \"iregex.h\"    typedef struct _IGNORE_REC IGNORE_REC;   @@ -20,12 +18,7 @@ struct _IGNORE_REC {  	unsigned int regexp:1;  	unsigned int fullword:1;  	unsigned int replies:1; /* ignore replies to nick in channel */ -#ifdef USE_GREGEX -	GRegex *preg; -#else -	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */ -	regex_t preg; -#endif +	Regex *preg;  };    extern GSList *ignores; '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','iregex-gregex.c','111','24','137','0','ADD','@@ -0,0 +1,137 @@ +#include <string.h> + +#include \"iregex.h\" + +const gchar * +make_valid_utf8(const gchar *text, gboolean *free_ret) +{ +	GString *str; +	const gchar *ptr; +	if (g_utf8_validate(text, -1, NULL)) { +		if (free_ret) +			*free_ret = FALSE; +		return text; +	} + +	str = g_string_sized_new(strlen(text) + 12); + +	ptr = text; +	while (*ptr) { +		gunichar c = g_utf8_get_char_validated(ptr, -1); +		/* the unicode is invalid */ +		if (c == (gunichar)-1 || c == (gunichar)-2) { +			/* encode the byte into PUA-A */ +			g_string_append_unichar(str, (gunichar) (0xfff00 | (*ptr & 0xff))); +			ptr++; +		} else { +			g_string_append_unichar(str, c); +			ptr = g_utf8_next_char(ptr); +		} +	} + +	if (free_ret) +		*free_ret = TRUE; +	return g_string_free(str, FALSE); +} + +Regex * +i_regex_new (const gchar *pattern, +             GRegexCompileFlags compile_options, +             GRegexMatchFlags match_options, +             GError **error) +{ +	const gchar *valid_pattern; +	gboolean free_valid_pattern; +	Regex *ret = NULL; + +	valid_pattern = make_valid_utf8(pattern, &free_valid_pattern); +	ret = g_regex_new(valid_pattern, compile_options, match_options, error); + +	if (free_valid_pattern) +		g_free_not_null((gchar *)valid_pattern); + +	return ret; +} + +void +i_regex_unref (Regex *regex) +{ +	g_regex_unref(regex); +} + +/* if new_string is present, the caller must free new_string. +   otherwise, g_match_info_get_string must not be used. */ +gboolean +i_regex_match (const Regex *regex, +               const gchar *string, +               GRegexMatchFlags match_options, +               MatchInfo **match_info, +               const gchar **new_string) +{ +	gboolean ret; +	gboolean free_valid_string; +	const gchar *valid_string = make_valid_utf8(string, &free_valid_string); + +	ret = g_regex_match(regex, valid_string, match_options, match_info); +	if (free_valid_string) { +		if (new_string) +			*new_string = valid_string; +		else +			g_free_not_null((gchar *)valid_string); +	} +	return ret; +} + +gsize +strlen_pua_oddly(const char *str) +{ +	const gchar *ptr; +	gsize ret = 0; +	ptr = str; + +	while (*ptr) { +		const gchar *old; +		gunichar c = g_utf8_get_char(ptr); +		old = ptr; +		ptr = g_utf8_next_char(ptr); + +		/* it is our PUA encoded byte */ +		if ((c & 0xfff00) == 0xfff00) +			ret++; +		else +			ret += ptr - old; +	} + +	return ret; +} + +gboolean +i_match_info_fetch_pos (const MatchInfo *match_info, +                        gint match_num, +                        gint *start_pos, +                        gint *end_pos, +                        const gchar *new_string) +{ +	gint tmp_start, tmp_end, new_start_pos; +	gboolean ret; + +	if (!new_string || (!start_pos && !end_pos)) +		return g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos); + +	ret = g_match_info_fetch_pos(match_info, match_num, &tmp_start, &tmp_end); +	if (start_pos || end_pos) { +		gchar *to_start = g_strndup(new_string, tmp_start); +		new_start_pos = strlen_pua_oddly(to_start); +		g_free_not_null(to_start); + +		if (start_pos) +			*start_pos = new_start_pos; + +		if (end_pos) { +			gchar *to_end = g_strndup(new_string + tmp_start, tmp_end - tmp_start); +			*end_pos = new_start_pos + strlen_pua_oddly(to_end); +			g_free_not_null(to_end); +		} +	} +	return ret; +} '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','iregex-regexh.c','87','17','101','0','ADD','@@ -0,0 +1,101 @@ +#include \"iregex.h\" + +Regex * +i_regex_new (const gchar *pattern, +             GRegexCompileFlags compile_options, +             GRegexMatchFlags match_options, +             GError **error) +{ +	Regex *regex; +	char *errbuf; +	int cflags; +	int errcode, errbuf_len; + +	regex = g_new0(Regex, 1); +	cflags = REG_EXTENDED; +	if (compile_options & G_REGEX_CASELESS) +		cflags |= REG_ICASE; +	if (compile_options & G_REGEX_MULTILINE) +		cflags |= REG_NEWLINE; +	if (match_options & G_REGEX_MATCH_NOTBOL) +		cflags |= REG_NOTBOL; +	if (match_options & G_REGEX_MATCH_NOTEOL) +		cflags |= REG_NOTEOL; + +	errcode = regcomp(regex, pattern, cflags); +	if (errcode != 0) { +		errbuf_len = regerror(errcode, regex, 0, 0); +		errbuf = g_malloc(errbuf_len); +		regerror(errcode, regex, errbuf, errbuf_len); +		g_set_error(error, G_REGEX_ERROR, errcode, \"%s\", errbuf); +		g_free(errbuf); +		g_free(regex); +		return NULL; +	} else { +		return regex; +	} +} + +void +i_regex_unref (Regex *regex) +{ +	regfree(regex); +	g_free(regex); +} + +gboolean +i_regex_match (const Regex *regex, +               const gchar *string, +               GRegexMatchFlags match_options, +               MatchInfo **match_info, +               const gchar **new_string) +{ +	int groups; +	int eflags; + +	g_return_val_if_fail(regex != NULL, FALSE); + +	if (match_info != NULL) { +		groups = 1 + regex->re_nsub; +		*match_info = g_new0(MatchInfo, groups); +	} else { +		groups = 0; +	} + +	eflags = 0; +	if (match_options & G_REGEX_MATCH_NOTBOL) +		eflags |= REG_NOTBOL; +	if (match_options & G_REGEX_MATCH_NOTEOL) +		eflags |= REG_NOTEOL; + +	return regexec(regex, string, groups, groups ? *match_info : NULL, eflags) == 0; +} + +gboolean +i_match_info_fetch_pos (const MatchInfo *match_info, +                        gint match_num, +                        gint *start_pos, +                        gint *end_pos, +                        const gchar *new_string) +{ +	if (start_pos != NULL) +		*start_pos = match_info[match_num].rm_so; +	if (end_pos != NULL) +		*end_pos = match_info[match_num].rm_eo; + +	return TRUE; +} + +gboolean +i_match_info_matches (const MatchInfo *match_info) +{ +	g_return_val_if_fail(match_info != NULL, FALSE); + +	return match_info[0].rm_so != -1; +} + +void +i_match_info_free (MatchInfo *match_info) +{ +	g_free(match_info); +} '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','iregex.h','30','0','52','0','ADD','@@ -0,0 +1,52 @@ +#ifndef __REGEX_H +#define __REGEX_H + +#include \"common.h\" + +#ifdef USE_GREGEX + +#include <glib.h> +typedef	GRegex Regex; +typedef	GMatchInfo MatchInfo; + +#define i_match_info_matches g_match_info_matches +#define i_match_info_free g_match_info_free + +#else + +#include <regex.h> +typedef	regex_t Regex; +typedef regmatch_t MatchInfo; + +gboolean +i_match_info_matches (const MatchInfo *match_info); + +void +i_match_info_free (MatchInfo *match_info); + +#endif + +Regex * +i_regex_new (const gchar *pattern, +             GRegexCompileFlags compile_options, +             GRegexMatchFlags match_options, +             GError **error); + +void +i_regex_unref (Regex *regex); + +gboolean +i_regex_match (const Regex *regex, +               const gchar *string, +               GRegexMatchFlags match_options, +               MatchInfo **match_info, +               const gchar **new_string); + +gboolean +i_match_info_fetch_pos (const MatchInfo *match_info, +                        gint match_num, +                        gint *start_pos, +                        gint *end_pos, +                        const gchar *new_string); + +#endif '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','misc.c','770','255','0','4','MODIFY','@@ -22,10 +22,6 @@  #include \"misc.h\"  #include \"commands.h\"   -#ifndef USE_GREGEX -#  include <regex.h> -#endif -  typedef struct {  	int condition;  	GInputFunction function; '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','fe-ignore.c','214','62','0','5','MODIFY','@@ -58,13 +58,8 @@ static void ignore_print(int index, IGNORE_REC *rec)  		g_string_append(options, \"-regexp \");  		if (rec->pattern == NULL)  			g_string_append(options, \"[INVALID! -pattern missing] \"); -#ifdef USE_GREGEX  		else if (rec->preg == NULL)  			g_string_append(options, \"[INVALID!] \"); -#else -		else if (!rec->regexp_compiled) -			g_string_append(options, \"[INVALID!] \"); -#endif  	}  	if (rec->fullword) g_string_append(options, \"-full \");  	if (rec->replies) g_string_append(options, \"-replies \"); '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','hilight-text.c','542','154','11','40','MODIFY','@@ -26,6 +26,7 @@  #include \"misc.h\"  #include \"lib-config/iconfig.h\"  #include \"settings.h\" +#include \"iregex.h\"    #include \"servers.h\"  #include \"channels.h\" @@ -101,11 +102,7 @@ static void hilight_destroy(HILIGHT_REC *rec)  {  	g_return_if_fail(rec != NULL);   -#ifdef USE_GREGEX -	if (rec->preg != NULL) g_regex_unref(rec->preg); -#else -	if (rec->regexp_compiled) regfree(&rec->preg); -#endif +	if (rec->preg != NULL) i_regex_unref(rec->preg);  	if (rec->channels != NULL) g_strfreev(rec->channels);  	g_free_not_null(rec->color);  	g_free_not_null(rec->act_color); @@ -122,19 +119,10 @@ static void hilights_destroy_all(void)    static void hilight_init_rec(HILIGHT_REC *rec)  { -#ifdef USE_GREGEX  	if (rec->preg != NULL) -		g_regex_unref(rec->preg); +		i_regex_unref(rec->preg);   -	rec->preg = g_regex_new(rec->text, G_REGEX_OPTIMIZE | G_REGEX_RAW | G_REGEX_CASELESS, 0, NULL); -#else -	if (rec->regexp_compiled) regfree(&rec->preg); -	if (!rec->regexp) -		rec->regexp_compiled = FALSE; -	else -		rec->regexp_compiled = regcomp(&rec->preg, rec->text, -				rec->case_sensitive ? REG_EXTENDED : (REG_EXTENDED|REG_ICASE)) == 0; -#endif +	rec->preg = i_regex_new(rec->text, G_REGEX_OPTIMIZE | G_REGEX_CASELESS, 0, NULL);  }    void hilight_create(HILIGHT_REC *rec) @@ -207,30 +195,18 @@ static gboolean hilight_match_text(HILIGHT_REC *rec, const char *text,  	gboolean ret = FALSE;    	if (rec->regexp) { -#ifdef USE_GREGEX  		if (rec->preg != NULL) { -			GMatchInfo *match; +			MatchInfo *match; +			const char *new_text = NULL;   -			g_regex_match (rec->preg, text, 0, &match); +			i_regex_match(rec->preg, text, 0, &match, &new_text);   -			if (g_match_info_matches(match)) -				ret = g_match_info_fetch_pos(match, 0, match_beg, match_end); +			if (i_match_info_matches(match)) +				ret = i_match_info_fetch_pos(match, 0, match_beg, match_end, new_text);   -			g_match_info_free(match); +			i_match_info_free(match); +			g_free_not_null((char *)new_text);  		} -#else -		regmatch_t rmatch[1]; - -		if (rec->regexp_compiled && -			regexec(&rec->preg, text, 1, rmatch, 0) == 0) { -			if (rmatch[0].rm_so > 0 && -				match_beg != NULL && match_end != NULL) { -				*match_beg = rmatch[0].rm_so; -				*match_end = rmatch[0].rm_eo; -			} -			ret = TRUE; -		} -#endif  	} else {  		char *match;   @@ -524,13 +500,8 @@ static void hilight_print(int index, HILIGHT_REC *rec)  	if (rec->case_sensitive) g_string_append(options, \"-matchcase \");  	if (rec->regexp) {  		g_string_append(options, \"-regexp \"); -#ifdef USE_GREGEX  		if (rec->preg == NULL)  			g_string_append(options, \"[INVALID!] \"); -#else -		if (!rec->regexp_compiled) -			g_string_append(options, \"[INVALID!] \"); -#endif  	}    	if (rec->priority != 0) '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','hilight-text.h','32','0','2','10','MODIFY','@@ -1,10 +1,7 @@  #ifndef __HILIGHT_TEXT_H  #define __HILIGHT_TEXT_H   -#ifndef USE_GREGEX -#  include <regex.h> -#endif - +#include \"iregex.h\"  #include \"formats.h\"    struct _HILIGHT_REC { @@ -24,12 +21,7 @@ struct _HILIGHT_REC {  	unsigned int fullword:1; /* match `text\' only for full words */  	unsigned int regexp:1; /* `text\' is a regular expression */  	unsigned int case_sensitive:1;/* `text\' must match case */ -#ifdef USE_GREGEX -	GRegex *preg; -#else -	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid */ -	regex_t preg; -#endif +	Regex *preg;  	char *servertag;  };   '),('irssi','1.0.2','79bbca4644cad7f2dee89c7ac6b8f9acc2c8b427','ailin-nemui','Refactor regex and implement UTF8 mode for GRegex  - with non-unicode byte to Private Use Area A mapping - move all ifdefs to iregex.h file only','textbuffer.c','473','141','8','29','MODIFY','@@ -24,13 +24,10 @@  #include \"misc.h\"  #include \"formats.h\"  #include \"utf8.h\" +#include \"iregex.h\"    #include \"textbuffer.h\"   -#ifndef USE_GREGEX -#  include <regex.h> -#endif -  #define TEXT_CHUNK_USABLE_SIZE (LINE_TEXT_CHUNK_SIZE-2-(int)sizeof(char*))    TEXT_BUFFER_REC *textbuffer_create(void) @@ -545,11 +542,7 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,  			    int before, int after,  			    int regexp, int fullword, int case_sensitive)  { -#ifdef USE_GREGEX -	GRegex *preg; -#else -	regex_t preg; -#endif +	Regex *preg;          LINE_REC *line, *pre_line;  	GList *matches;  	GString *str; @@ -559,23 +552,14 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,  	g_return_val_if_fail(buffer != NULL, NULL);  	g_return_val_if_fail(text != NULL, NULL);   -#ifdef USE_GREGEX  	preg = NULL;    	if (regexp) { -		preg = g_regex_new(text, G_REGEX_RAW | (case_sensitive ? 0 : G_REGEX_CASELESS), 0, NULL); +		preg = i_regex_new(text, case_sensitive ? 0 : G_REGEX_CASELESS, 0, NULL);    		if (preg == NULL)  			return NULL;  	} -#else -	if (regexp) { -		int flags = REG_EXTENDED | REG_NOSUB | -			(case_sensitive ? 0 : REG_ICASE); -		if (regcomp(&preg, text, flags) != 0) -			return NULL; -	} -#endif    	matches = NULL; match_after = 0;          str = g_string_new(NULL); @@ -592,17 +576,16 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,  			(line->info.level & nolevel) == 0;    		if (*text != \'\\0\') { +			const char *tmp = NULL;  			textbuffer_line2text(line, FALSE, str);    			if (line_matched) {  				line_matched = regexp ? -#ifdef USE_GREGEX -				    g_regex_match(preg, str->str, 0, NULL) -#else -				    regexec(&preg, str->str, 0, NULL, 0) == 0 -#endif +					i_regex_match(preg, str->str, 0, NULL, &tmp)  					: match_func(str->str, text) != NULL;  			} +			if (tmp && tmp != str->str) +				g_free_not_null((char *)tmp);  		}    		if (line_matched) { @@ -631,12 +614,8 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,  		}  	}   -#ifdef USE_GREGEX  	if (preg != NULL) -		g_regex_unref(preg); -#else -	if (regexp) regfree(&preg); -#endif +		i_regex_unref(preg);          g_string_free(str, TRUE);  	return matches;  } '),('irssi','1.0.2','e84adeca15084a82c04ff6c3b5c7b8941c297322','Jari Matilainen','change ternary operator to if/else statements, add default ssl port support','common.h','42','0','1','0','MODIFY','@@ -9,6 +9,7 @@  #define IRSSI_ABI_VERSION 9    #define DEFAULT_SERVER_ADD_PORT 6667 +#define DEFAULT_SERVER_ADD_TLS_PORT 6697    #ifdef HAVE_CONFIG_H  #include \"irssi-config.h\" '),('irssi','1.0.2','e84adeca15084a82c04ff6c3b5c7b8941c297322','Jari Matilainen','change ternary operator to if/else statements, add default ssl port support','fe-server.c','374','108','9','4','MODIFY','@@ -119,10 +119,15 @@ static void cmd_server_add_modify(const char *data, gboolean add)  	if (*addr == \'\\0\') cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);    	value = g_hash_table_lookup(optlist, \"port\"); -	port = *portstr == \'\\0\' ? -			(value != NULL && *value != \'\\0\' ? -			atoi(value) : DEFAULT_SERVER_ADD_PORT) -		: atoi(portstr); + +	if (*portstr != \'\\0\') +		port = atoi(portstr); +	else if (value != NULL && *value != \'\\0\') +		port = atoi(value); +	else if (g_hash_table_lookup(optlist, \"tls\")) +		port = DEFAULT_SERVER_ADD_TLS_PORT; +	else +		port = DEFAULT_SERVER_ADD_PORT;    	chatnet = g_hash_table_lookup(optlist, \"network\");   '),('irssi','1.0.2','78a390f4796a97a3624feee2728018484c8485f8','ailin-nemui','abi up','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 9 +#define IRSSI_ABI_VERSION 10    #define DEFAULT_SERVER_ADD_PORT 6667   '),('irssi','1.0.2','f28c64a3dc1e66f9d1e49650d5b2ab15795b9e53','Jari Matilainen','Make backward compatible with ssl flags','fe-server.c','375','109','2','1','MODIFY','@@ -124,7 +124,8 @@ static void cmd_server_add_modify(const char *data, gboolean add)  		port = atoi(portstr);  	else if (value != NULL && *value != \'\\0\')  		port = atoi(value); -	else if (g_hash_table_lookup(optlist, \"tls\")) +	else if (g_hash_table_lookup(optlist, \"tls\") || +		 g_hash_table_lookup(optlist, \"ssl\"))  		port = DEFAULT_SERVER_ADD_TLS_PORT;  	else  		port = DEFAULT_SERVER_ADD_PORT; '),('irssi','1.0.2','00354c365187cecb9bc3ce3c3b3482e32d04729a','ailin-nemui','Update iregex-gregex.c  make helper functions static','iregex-gregex.c','111','24','2','2','MODIFY','@@ -2,7 +2,7 @@    #include \"iregex.h\"   -const gchar * +static const gchar *  make_valid_utf8(const gchar *text, gboolean *free_ret)  {  	GString *str; @@ -82,7 +82,7 @@ i_regex_match (const Regex *regex,  	return ret;  }   -gsize +static gsize  strlen_pua_oddly(const char *str)  {  	const gchar *ptr; '),('irssi','1.0.2','48899a123d68051fbc73acb8ad151e89fdcb6b31','ailin-nemui','Update iregex-gregex.c  add 2 comments about new_string','iregex-gregex.c','111','24','6','1','MODIFY','@@ -60,7 +60,9 @@ i_regex_unref (Regex *regex)  }    /* if new_string is present, the caller must free new_string. -   otherwise, g_match_info_get_string must not be used. */ +   otherwise, g_match_info_get_string must not be used. +   if string is not vali utf8, new_string will be assigned +   a similar, but valid utf8, string */  gboolean  i_regex_match (const Regex *regex,                 const gchar *string, @@ -105,6 +107,9 @@ strlen_pua_oddly(const char *str)  	return ret;  }   +/* new_string should be passed in here from the i_regex_match call.  +   The start_pos and end_pos will then be calculated as if they were on +   the original string */  gboolean  i_match_info_fetch_pos (const MatchInfo *match_info,                          gint match_num, '),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','ignore.c','351','132','1','1','MODIFY','@@ -69,7 +69,7 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)    	if (rec->regexp) {  		return rec->preg != NULL && -			i_regex_match(rec->preg, text, 0, NULL, NULL); +			i_regex_match(rec->preg, text, 0, NULL);  	}    	return rec->fullword ? '),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','iregex-gregex.c','131','28','39','16','MODIFY','@@ -2,6 +2,11 @@    #include \"iregex.h\"   +struct _MatchInfo { +	const char *valid_string; +	GMatchInfo *g_match_info; +}; +  static const gchar *  make_valid_utf8(const gchar *text, gboolean *free_ret)  { @@ -59,28 +64,29 @@ i_regex_unref (Regex *regex)  	g_regex_unref(regex);  }   -/* if new_string is present, the caller must free new_string. -   otherwise, g_match_info_get_string must not be used. -   if string is not vali utf8, new_string will be assigned -   a similar, but valid utf8, string */  gboolean  i_regex_match (const Regex *regex,                 const gchar *string,                 GRegexMatchFlags match_options, -               MatchInfo **match_info, -               const gchar **new_string) +               MatchInfo **match_info)  {  	gboolean ret;  	gboolean free_valid_string;  	const gchar *valid_string = make_valid_utf8(string, &free_valid_string);   -	ret = g_regex_match(regex, valid_string, match_options, match_info); +	if (match_info != NULL) +		*match_info = g_new0(MatchInfo, 1); + +	ret = g_regex_match(regex, valid_string, match_options, +			    match_info != NULL ? &(*match_info)->g_match_info : NULL); +  	if (free_valid_string) { -		if (new_string) -			*new_string = valid_string; +		if (match_info != NULL) +			(*match_info)->valid_string = valid_string;  		else  			g_free_not_null((gchar *)valid_string);  	} +  	return ret;  }   @@ -114,18 +120,20 @@ gboolean  i_match_info_fetch_pos (const MatchInfo *match_info,                          gint match_num,                          gint *start_pos, -                        gint *end_pos, -                        const gchar *new_string) +                        gint *end_pos)  {  	gint tmp_start, tmp_end, new_start_pos;  	gboolean ret;   -	if (!new_string || (!start_pos && !end_pos)) -		return g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos); +	if (!match_info->valid_string || (!start_pos && !end_pos)) +		return g_match_info_fetch_pos(match_info->g_match_info, +					      match_num, start_pos, end_pos);   -	ret = g_match_info_fetch_pos(match_info, match_num, &tmp_start, &tmp_end); +	ret = g_match_info_fetch_pos(match_info->g_match_info, +				     match_num, &tmp_start, &tmp_end);  	if (start_pos || end_pos) { -		gchar *to_start = g_strndup(new_string, tmp_start); +		const gchar *str = match_info->valid_string; +		gchar *to_start = g_strndup(str, tmp_start);  		new_start_pos = strlen_pua_oddly(to_start);  		g_free_not_null(to_start);   @@ -133,10 +141,25 @@ i_match_info_fetch_pos (const MatchInfo *match_info,  			*start_pos = new_start_pos;    		if (end_pos) { -			gchar *to_end = g_strndup(new_string + tmp_start, tmp_end - tmp_start); +			gchar *to_end = g_strndup(str + tmp_start, tmp_end - tmp_start);  			*end_pos = new_start_pos + strlen_pua_oddly(to_end);  			g_free_not_null(to_end);  		}  	}  	return ret;  } + +gboolean +i_match_info_matches (const MatchInfo *match_info) +{ +	g_return_val_if_fail(match_info != NULL, FALSE); + +	return g_match_info_matches(match_info->g_match_info); +} + +void +i_match_info_free (MatchInfo *match_info) +{ +	g_match_info_free(match_info->g_match_info); +	g_free(match_info); +} '),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','iregex-regexh.c','85','17','2','4','MODIFY','@@ -47,8 +47,7 @@ gboolean  i_regex_match (const Regex *regex,                 const gchar *string,                 GRegexMatchFlags match_options, -               MatchInfo **match_info, -               const gchar **new_string) +               MatchInfo **match_info)  {  	int groups;  	int eflags; @@ -75,8 +74,7 @@ gboolean  i_match_info_fetch_pos (const MatchInfo *match_info,                          gint match_num,                          gint *start_pos, -                        gint *end_pos, -                        const gchar *new_string) +                        gint *end_pos)  {  	if (start_pos != NULL)  		*start_pos = match_info[match_num].rm_so; '),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','iregex.h','28','0','5','10','MODIFY','@@ -7,10 +7,7 @@    #include <glib.h>  typedef	GRegex Regex; -typedef	GMatchInfo MatchInfo; - -#define i_match_info_matches g_match_info_matches -#define i_match_info_free g_match_info_free +typedef	struct _MatchInfo MatchInfo;    #else   @@ -18,14 +15,14 @@ typedef	GMatchInfo MatchInfo;  typedef	regex_t Regex;  typedef regmatch_t MatchInfo;   +#endif +  gboolean  i_match_info_matches (const MatchInfo *match_info);    void  i_match_info_free (MatchInfo *match_info);   -#endif -  Regex *  i_regex_new (const gchar *pattern,               GRegexCompileFlags compile_options, @@ -39,14 +36,12 @@ gboolean  i_regex_match (const Regex *regex,                 const gchar *string,                 GRegexMatchFlags match_options, -               MatchInfo **match_info, -               const gchar **new_string); +               MatchInfo **match_info);    gboolean  i_match_info_fetch_pos (const MatchInfo *match_info,                          gint match_num,                          gint *start_pos, -                        gint *end_pos, -                        const gchar *new_string); +                        gint *end_pos);    #endif '),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','hilight-text.c','540','154','2','5','MODIFY','@@ -197,15 +197,12 @@ static gboolean hilight_match_text(HILIGHT_REC *rec, const char *text,  	if (rec->regexp) {  		if (rec->preg != NULL) {  			MatchInfo *match; -			const char *new_text = NULL; - -			i_regex_match(rec->preg, text, 0, &match, &new_text); +			i_regex_match(rec->preg, text, 0, &match);    			if (i_match_info_matches(match)) -				ret = i_match_info_fetch_pos(match, 0, match_beg, match_end, new_text); +				ret = i_match_info_fetch_pos(match, 0, match_beg, match_end);    			i_match_info_free(match); -			g_free_not_null((char *)new_text);  		}  	} else {  		char *match; '),('irssi','1.0.2','4edfccfce794d4c10b2a92c02fe982bb089c6629','ailin-nemui','get rid of new_text','textbuffer.c','470','139','1','4','MODIFY','@@ -576,16 +576,13 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,  			(line->info.level & nolevel) == 0;    		if (*text != \'\\0\') { -			const char *tmp = NULL;  			textbuffer_line2text(line, FALSE, str);    			if (line_matched) {  				line_matched = regexp ? -					i_regex_match(preg, str->str, 0, NULL, &tmp) +					i_regex_match(preg, str->str, 0, NULL)  					: match_func(str->str, text) != NULL;  			} -			if (tmp && tmp != str->str) -				g_free_not_null((char *)tmp);  		}    		if (line_matched) { '),('irssi','1.0.3','52bb06ccd9f9bd639a454045eba1235e4133b034','dequis','fe-dcc-(get|send): Fix some -Wpointer-compare with newer gcc  The warning itself:  >warning: comparison between pointer and zero character constant [-Wpointer-compare]  Harmless stuff as far as I can tell.  The fix adds a null check that probably isn\'t needed. The old code that compared against \'\\0\' worked a lot like a null check so it makes sense to keep that, while also adding the intended check for empty string.  This was visible with \"/dcc close send a\" showing an empty filename. The equivalent for get didn\'t show the filename in the format string.','fe-dcc-get.c','103','21','1','1','MODIFY','@@ -108,7 +108,7 @@ static void dcc_error_close_not_found(const char *type, const char *nick,  	g_return_if_fail(fname != NULL);  	if (g_ascii_strcasecmp(type, \"GET\") != 0) return;   -	if (fname == \'\\0\') fname = \"(ANY)\"; +	if (fname == NULL || *fname == \'\\0\') fname = \"(ANY)\";  	printformat(NULL, NULL, MSGLEVEL_DCC,  		    IRCTXT_DCC_GET_NOT_FOUND, nick, fname);  } '),('irssi','1.0.3','52bb06ccd9f9bd639a454045eba1235e4133b034','dequis','fe-dcc-(get|send): Fix some -Wpointer-compare with newer gcc  The warning itself:  >warning: comparison between pointer and zero character constant [-Wpointer-compare]  Harmless stuff as far as I can tell.  The fix adds a null check that probably isn\'t needed. The old code that compared against \'\\0\' worked a lot like a null check so it makes sense to keep that, while also adding the intended check for empty string.  This was visible with \"/dcc close send a\" showing an empty filename. The equivalent for get didn\'t show the filename in the format string.','fe-dcc-send.c','132','25','1','1','MODIFY','@@ -108,7 +108,7 @@ static void dcc_error_close_not_found(const char *type, const char *nick,  	g_return_if_fail(fname != NULL);  	if (g_ascii_strcasecmp(type, \"SEND\") != 0) return;   -	if (fname == \'\\0\') fname = \"(ANY)\"; +	if (fname == NULL || *fname == \'\\0\') fname = \"(ANY)\";  	printformat(NULL, NULL, MSGLEVEL_DCC,  		    IRCTXT_DCC_SEND_NOT_FOUND, nick, fname);  } '),('irssi','1.0.3','0e44ea891645044f47bf3754e141045ee3b24324','dequis','Performance improvements for /lastlog with big result sets  This applies to \"/lastlog\" with no filters (or with filters that don\'t filter a lot) and with large amounts of text in the scrollback.  Test case:      /exec seq 1 500000     /lastlog -file log.txt  Thanks to morning for reporting this.','textbuffer.c','480','147','5','3','MODIFY','@@ -616,21 +616,23 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,  			}    			for (; pre_line != line; pre_line = pre_line->next) -				matches = g_list_append(matches, pre_line); +				matches = g_list_prepend(matches, pre_line);    			match_after = after;  		}    		if (line_matched || match_after > 0) {  			/* matched */ -			matches = g_list_append(matches, line); +			matches = g_list_prepend(matches, line);    			if ((!line_matched && --match_after == 0) ||  			    (line_matched && match_after == 0 && before > 0)) -				matches = g_list_append(matches, NULL); +				matches = g_list_prepend(matches, NULL);  		}  	}   +	matches = g_list_reverse(matches); +  #ifdef USE_GREGEX  	if (preg != NULL)  		g_regex_unref(preg); '),('irssi','1.0.3','e498265328bd619b231ea4c985734ea43bf89696','dequis','Performance improvements for /lastlog -before  This avoids the use of g_list_find() to find if a match was already added to the list of results, by checking the last two added matches instead.  Checking just the last match isn\'t enough because a NULL match is added as a separator (shown as -- in the UI)','textbuffer.c','481','148','2','1','MODIFY','@@ -610,7 +610,8 @@ GList *textbuffer_find_text(TEXT_BUFFER_REC *buffer, LINE_REC *startline,  			pre_line = line;  			for (i = 0; i < before; i++) {  				if (pre_line->prev == NULL || -				    g_list_find(matches, pre_line->prev) != NULL) +				    g_list_nth_data(matches, 0) == pre_line->prev || +				    g_list_nth_data(matches, 1) == pre_line->prev)  					break;                                  pre_line = pre_line->prev;  			} '),('irssi','1.0.3','fc67fd5111ac84cd101d961fc9a5b0bc1b25613b','Ailin Nemui','Merge tag \'1.0.3\'','NEWS','2895','0','18','0','MODIFY','@@ -1,5 +1,23 @@  v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>   +v1.0.3 2017-06-06  The Irssi team <staff@irssi.org> +	- Fix out of bounds read when scanning expandos (GL!11). +	- Fix invalid memory access with quoted filenames in DCC +	  (GL#8, GL!12). +	- Fix null-pointer dereference on DCC without address (GL#9, GL!13). +	- Improve integer overflow handling. Originally reported by +          oss-fuzz#525 (#706). +	- Improve nicklist performance from O(N^2) to O(N) (#705). +	- Fix initial screen redraw delay. By Stephen Oberholtzer +	  (#680, bdo#856201). +	- Fix incorrect reset of true colours when resetting background. (#711). +	- Fix missing -notls option in /SERVER. By Jari Matilainen (#117, #702). +	- Fix minor history glitch on overcounter (#462, #685). +	- Improved OpenSSL detection at compile time. By Rodrigo Rebello (#677). +	- Improved NetBSD Terminfo detection. By Maya Rashish (#694, #698). +	- Add missing syntax info for COMPLETION (#687, #688). +	- Minor typo correction in help. By Michael Hansen (#707). +  v1.0.2 2017-03-10  The Irssi team <staff@irssi.org>  	- Prevent some null-pointer crashes (GL!9).  	- Fix compilation with OpenSSL 1.1.0 (#628, #597). '),('irssi','1.0.3','4b1c60b2ecb030550716647bffb0f9dd7e97c31a','dequis','term-terminfo: Avoid switching out of alt screen on unexpected exits  Perl sucks and kills the whole process when there\'s a version mismatch in Perl_xs_handshake(). Our atexit handler catches the exit and deinitializes the terminal, removing the error.  This commit uses the \'quitting\' global variable which is set when irssi is voluntarily quitting, and avoids sending TI_rmcup, which restores the original screen and makes the error invisible.','term-terminfo.c','530','168','12','1','MODIFY','@@ -102,6 +102,17 @@ static GSourceFuncs sigcont_funcs = {  	.dispatch = sigcont_dispatch  };   +static void term_atexit(void) +{ +	if (!quitting && current_term && current_term->TI_rmcup) { +		/* Unexpected exit, avoid switching out of alternate screen +		   to keep any on-screen errors (like noperl_die()\'s) */ +		current_term->TI_rmcup = NULL; +	} + +	term_deinit(); +} +  int term_init(void)  {  	struct sigaction act; @@ -140,7 +151,7 @@ int term_init(void)            term_set_input_type(TERM_TYPE_8BIT);  	term_common_init(); -        atexit(term_deinit); +	atexit(term_atexit);          return TRUE;  }   '),('irssi','1.0.3','7354a74c654f1717d08a37c2b118141655974bc0','dequis','parse_time_interval: Allow negative time in settings  This splits sign parsing out of parse_time_interval_uint() so that the negative sign is applied outside of the unsigned context where the number parsing is done, and after all the checks that it\'s lower than (1 << 31)  This fixes issues with settings like `server_reconnect_time`, `server_connect_timeout` and `lag_max_before_disconnect`, which accepted -1 as a valid value.','misc.c','778','256','25','13','MODIFY','@@ -781,24 +781,35 @@ int parse_uint(const char *nptr, char **endptr, int base, guint *number)  	return TRUE;  }   +static int parse_number_sign(const char *input, char **endptr, int *sign) +{ +	int sign_ = 1; + +	while (i_isspace(*input)) +		input++; + +	if (*input == \'-\') { +		sign_ = -sign_; +		input++; +	} + +	*sign = sign_; +	*endptr = (char *) input; +	return TRUE; +} +  static int parse_time_interval_uint(const char *time, guint *msecs)  {  	const char *desc;  	guint number; -	int sign, len, ret, digits; +	int len, ret, digits;    	*msecs = 0;    	/* max. return value is around 24 days */ -	number = 0; sign = 1; ret = TRUE; digits = FALSE; +	number = 0; ret = TRUE; digits = FALSE;  	while (i_isspace(*time))  		time++; -	if (*time == \'-\') { -		sign = -sign; -		time++; -		while (i_isspace(*time)) -			time++; -	}  	for (;;) {  		if (i_isdigit(*time)) {  			char *endptr; @@ -828,7 +839,6 @@ static int parse_time_interval_uint(const char *time, guint *msecs)  			if (*time != \'\\0\')  				return FALSE;  			*msecs += number * 1000; /* assume seconds */ -			*msecs *= sign;  			return TRUE;  		}   @@ -866,7 +876,6 @@ static int parse_time_interval_uint(const char *time, guint *msecs)  		digits = FALSE;  	}   -	*msecs *= sign;  	return ret;  }   @@ -960,15 +969,18 @@ int parse_size(const char *size, int *bytes)  int parse_time_interval(const char *time, int *msecs)  {  	guint msecs_; -	int ret; +	char *number; +	int ret, sign; + +	parse_number_sign(time, &number, &sign);   -	ret = parse_time_interval_uint(time, &msecs_); +	ret = parse_time_interval_uint(number, &msecs_);    	if (msecs_ > (1U << 31)) {  		return FALSE;  	}   -	*msecs = msecs_; +	*msecs = msecs_ * sign;  	return ret;  }   '),('irssi','1.0.3','02a5d1a00b4f484b4b2422785944e022810bbbb0','ailin-nemui','fix weird n-fold unescaping','chat-completion.c','959','227','10','4','MODIFY','@@ -1011,13 +1011,17 @@ static void sig_complete_target(GList **list, WINDOW_REC *window,  	}  }   +static void event_text(const char *data, SERVER_REC *server, WI_ITEM_REC *item); +  /* expand \\n, \\t and \\\\ */  static char *expand_escapes(const char *line, SERVER_REC *server,  			    WI_ITEM_REC *item)  {  	char *ptr, *ret; -        int chr; +	const char *prev; +	int chr;   +	prev = line;  	ret = ptr = g_malloc(strlen(line)+1);  	for (; *line != \'\\0\'; line++) {  		if (*line != \'\\\\\') { @@ -1036,9 +1040,11 @@ static char *expand_escapes(const char *line, SERVER_REC *server,  			/* newline .. we need to send another \"send text\"  			   event to handle it (or actually the text before  			   the newline..) */ -			if (ret != ptr) { -				*ptr = \'\\0\'; -				signal_emit(\"send text\", 3, ret, server, item); +			if (prev != line) { +				const char *prev_line = g_strndup(prev, (line - prev) - 1); +				event_text(prev_line, server, item); +				g_free((char *)prev_line); +				prev = line + 1;  				ptr = ret;  			}  		} else if (chr != -1) { '),('irssi','1.0.3','12d671a05645d67e811264d5be06d9758458452f','Oscar Linderholm','Escape nicks during nick completion when expand_escapes is enabled  Fixes #693','completion.c','645','182','20','5','MODIFY','@@ -137,8 +137,9 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i          int old_startpos, old_wordlen;    	GString *result; -	char *word, *wordstart, *linestart, *ret; -	int continue_complete, want_space; +	const char *cmdchars; +	char *word, *wordstart, *linestart, *ret, *data; +	int continue_complete, want_space, expand_escapes;    	g_return_val_if_fail(line != NULL, NULL);  	g_return_val_if_fail(pos != NULL, NULL); @@ -241,14 +242,24 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  	if (complist == NULL)  		return NULL;   +        /* get the cmd char */ +	cmdchars = settings_get_str(\"cmdchars\"); + +	/* get the expand_escapes setting */ +	expand_escapes = settings_get_bool(\"expand_escapes\"); + +	/* escape if the word doesn\'t begin with \'/\' and expand_escapes are turned on */ +	data = strchr(cmdchars, *line) == NULL && expand_escapes ? +		escape_string(complist->data) : g_strdup(complist->data); +  	/* word completed */ -	*pos = startpos+strlen(complist->data); +	*pos = startpos + strlen(data);    	/* replace the word in line - we need to return  	   a full new line */  	result = g_string_new(line);  	g_string_erase(result, startpos, wordlen); -	g_string_insert(result, startpos, complist->data); +	g_string_insert(result, startpos, data);    	if (want_space) {  		if (!isseparator(result->str[*pos])) @@ -256,13 +267,17 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  		(*pos)++;  	}   -	wordlen = strlen(complist->data); +	wordlen = strlen(data);  	last_line_pos = *pos;  	g_free_not_null(last_line);  	last_line = g_strdup(result->str);    	ret = result->str;  	g_string_free(result, FALSE); + +	/* free the data */ +	g_free(data); +  	return ret;  }   '),('irssi','1.0.3','bbf8b860747c13a478657b9070c191735d35e00a','ailin-nemui','remove const','chat-completion.c','959','227','2','2','MODIFY','@@ -1041,9 +1041,9 @@ static char *expand_escapes(const char *line, SERVER_REC *server,  			   event to handle it (or actually the text before  			   the newline..) */  			if (prev != line) { -				const char *prev_line = g_strndup(prev, (line - prev) - 1); +				char *prev_line = g_strndup(prev, (line - prev) - 1);  				event_text(prev_line, server, item); -				g_free((char *)prev_line); +				g_free(prev_line);  				prev = line + 1;  				ptr = ret;  			} '),('irssi','1.0.3','b483ec5faa76dc38f2e338f89c54a6e4cd06c764','ailin-nemui','test trusty container','.travis.yml','48','0','9','2','MODIFY','@@ -1,8 +1,15 @@  sudo: false +dist: trusty  language: perl  perl: -    - \"5.20-shrplib\" -    - \"5.18-shrplib\" +    # ~stretch +    - \"5.24-shrplib\" +    # ~xenial +    # - \"5.22-shrplib\" +    # ~jessie +    # - \"5.20-shrplib\" +    # ~trusty +    # - \"5.18-shrplib\"      - \"system-perl\"  env:      - CC=clang '),('irssi','1.0.3','29ebac987da1da2c892aed5ed329256b7bc94bca','Nei','Check return value of localtime  Fixes #10','misc.c','780','257','3','0','MODIFY','@@ -560,6 +560,9 @@ char *my_asctime(time_t t)          int len;    	tm = localtime(&t); +	if (tm == NULL) +	    return g_strdup(\"???\"); +  	str = g_strdup(asctime(tm));    	len = strlen(str); '),('irssi','1.0.3','73b851c39c11d01199e6c040749fb20e468f6c8d','ailin-nemui','correct GHashTable usage','nicklist.c','425','105','10','7','MODIFY','@@ -54,23 +54,26 @@ static void nick_hash_add(CHANNEL_REC *channel, NICK_REC *nick)    static void nick_hash_remove(CHANNEL_REC *channel, NICK_REC *nick)  { -	NICK_REC *list; +	NICK_REC *list, *newlist;    	list = g_hash_table_lookup(channel->nicks, nick->nick);  	if (list == NULL)  		return;   -	if (list == nick || list->next == NULL) { -		g_hash_table_remove(channel->nicks, nick->nick); -		if (list->next != NULL) { -			g_hash_table_insert(channel->nicks, nick->next->nick, -					    nick->next); -		} +	if (list == nick) { +		newlist = nick->next;  	} else { +		newlist = list;  		while (list->next != nick)  			list = list->next;  		list->next = nick->next;  	} + +	g_hash_table_remove(channel->nicks, nick->nick); +	if (newlist != NULL) { +		g_hash_table_insert(channel->nicks, newlist->nick, +				    newlist); +	}  }    /* Add new nick to list */ '),('irssi','1.0.3','5d7e54cd998ab48b1dc5d82aa74896bc9a91b705','ailin-nemui','More accurately describe clear','clear.in','10','0','2','2','MODIFY','@@ -12,8 +12,8 @@    %9Description:%9   -    Clears the window of all text; you may use this to clear a windows that -    contains sensitive information or has rendered improperly. +    Scrolls up the text in the window and fill the window with blank lines; you +    may want to use this to make new text start at the top of the window again.    %9See also:%9 REDRAW   '),('irssi','1.0.3','8b82d741b79e1cbb68c9e01d85d344fa0dc817ca','ailin-nemui','Update clear.in','clear.in','10','0','2','2','MODIFY','@@ -12,8 +12,8 @@    %9Description:%9   -    Scrolls up the text in the window and fill the window with blank lines; you +    Scrolls up the text in the window and fills the window with blank lines; you      may want to use this to make new text start at the top of the window again.   -%9See also:%9 REDRAW +%9See also:%9 REDRAW, SCROLLBACK CLEAR   '),('irssi','1.0.4','91ec153c7f89ed96fa592ebae7a931fe50a4bb42','Ailin Nemui','Merge tag \'1.0.4\' into integrate/1.0.4','NEWS','2907','0','13','0','MODIFY','@@ -1,5 +1,18 @@  v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>   +v1.0.4 2017-07-07  The Irssi team <staff@irssi.org> +	- Fix null pointer dereference when parsing invalid timestamp (GL#10, +	  GL!15). Reported by Brian \'geeknik\' Carpenter. +	- Fix use-after-free condition when removing nicks from the internal +	  nicklist (GL#11, GL!16). Reported by Brian \'geeknik\' Carpenter. +	- Fix incorrect string comparison in DCC file names (#714). +	- Fix regression in Irssi 1.0.3 where it would claim \"Invalid time \'-1\'\" +	  (#716, #722). +	- Fix a bug when using \\n to separate lines with expand_escapes (#723). +	- Retain screen output on improper exit, to better see any error +	  messages (#287, #721). +	- Minor help update (#729). +  v1.0.3 2017-06-06  The Irssi team <staff@irssi.org>  	- Fix out of bounds read when scanning expandos (GL!11).  	- Fix invalid memory access with quoted filenames in DCC '),('irssi','1.0.4','2bc10386610eba0fe5741228f143e89e1acd2a7d','Tristan','Clarified ambiguous autogen.sh error  autogen.sh now instructs the user to install elinks or lynx if needed','autogen.sh','51','4','1','0','MODIFY','@@ -39,6 +39,7 @@ elif type links >/dev/null 2>&1 ; then    links -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt  else    echo \"**Error**: No lynx or elinks present\" +  echo \"Install lynx or elinks, then run autogen.sh again\"    exit 1  fi   '),('irssi','1.0.4','d971c0292082823182f333a412207a9a8f6ad008','LemonBoy','Allow the user to clear the sasl-related fields  There was no easy way for the user to disable the SASL authentication or to clear the username/password once the network was created. Closes #718','network.in','53','0','1','0','MODIFY','@@ -36,6 +36,7 @@      -sasl_mechanism  Specifies the mechanism to use for the SASL authentication.                       At the moment irssi only supports the \'plain\' and the                       \'external\' mechanisms. +                     Use \'\' to disable the authentication.      -sasl_username   Specifies the username to use during the SASL authentication.      -sasl_password   Specifies the password to use during the SASL authentication.   '),('irssi','1.0.4','d971c0292082823182f333a412207a9a8f6ad008','LemonBoy','Allow the user to clear the sasl-related fields  There was no easy way for the user to disable the SASL authentication or to clear the username/password once the network was created. Closes #718','fe-ircnet.c','186','68','3','3','MODIFY','@@ -163,11 +163,11 @@ static void cmd_network_add_modify(const char *data, gboolean add)    	/* the validity of the parameters is checked in sig_server_setup_fill_chatnet */  	value = g_hash_table_lookup(optlist, \"sasl_mechanism\"); -	if (value != NULL && *value != \'\\0\') rec->sasl_mechanism = g_strdup(value); +	if (value != NULL) rec->sasl_mechanism = *value != \'\\0\' ? g_strdup(value) : NULL;  	value = g_hash_table_lookup(optlist, \"sasl_username\"); -	if (value != NULL && *value != \'\\0\') rec->sasl_username = g_strdup(value); +	if (value != NULL) rec->sasl_username = *value != \'\\0\' ? g_strdup(value) : NULL;  	value = g_hash_table_lookup(optlist, \"sasl_password\"); -	if (value != NULL && *value != \'\\0\') rec->sasl_password = g_strdup(value); +	if (value != NULL) rec->sasl_password = *value != \'\\0\' ? g_strdup(value) : NULL;    	ircnet_create(rec);  	printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, IRCTXT_NETWORK_ADDED, name); '),('irssi','1.0.4','d971c0292082823182f333a412207a9a8f6ad008','LemonBoy','Allow the user to clear the sasl-related fields  There was no easy way for the user to disable the SASL authentication or to clear the username/password once the network was created. Closes #718','irc-servers-setup.c','146','52','3','3','MODIFY','@@ -89,6 +89,8 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,    	/* Validate the SASL parameters filled by sig_chatnet_read() or cmd_network_add */  	conn->sasl_mechanism = SASL_MECHANISM_NONE; +	conn->sasl_username = NULL; +	conn->sasl_password = NULL;    	if (ircnet->sasl_mechanism != NULL) {  		if (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"plain\")) { @@ -102,9 +104,7 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,  				g_warning(\"The fields sasl_username and sasl_password are either missing or empty\");  		}  		else if (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"external\")) { -				conn->sasl_mechanism = SASL_MECHANISM_EXTERNAL; -				conn->sasl_username = NULL; -				conn->sasl_password = NULL; +			conn->sasl_mechanism = SASL_MECHANISM_EXTERNAL;  		}  		else  			g_warning(\"Unsupported SASL mechanism \\\"%s\\\" selected\", ircnet->sasl_mechanism); '),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','Don\'t compute log_dir_create_mode in three different places.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.c','441','97','2','3','MODIFY','@@ -33,6 +33,8 @@  #define DEFAULT_LOG_FILE_CREATE_MODE 600    GSList *logs; +int log_file_create_mode; +int log_dir_create_mode;    static const char *log_item_types[] = {  	\"target\", @@ -42,8 +44,6 @@ static const char *log_item_types[] = {  };    static char *log_timestamp; -static int log_file_create_mode; -static int log_dir_create_mode;  static int rotate_tag;    static int log_item_str2type(const char *type) @@ -562,7 +562,6 @@ static void read_settings(void)  	log_timestamp = g_strdup(settings_get_str(\"log_timestamp\"));    	log_file_create_mode = octal2dec(settings_get_int(\"log_create_mode\")); -  	log_dir_create_mode = log_file_create_mode;  	if (log_file_create_mode & 0400) log_dir_create_mode |= 0100;  	if (log_file_create_mode & 0040) log_dir_create_mode |= 0010; '),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','Don\'t compute log_dir_create_mode in three different places.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.h','44','0','2','0','MODIFY','@@ -35,6 +35,8 @@ struct _LOG_REC {  };    extern GSList *logs; +extern int log_file_create_mode; +extern int log_dir_create_mode;    /* Create log record - you still need to call log_update() to actually add it     into log list */ '),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','Don\'t compute log_dir_create_mode in three different places.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','169','37','1','8','MODIFY','@@ -20,6 +20,7 @@    #include \"module.h\"  #include \"rawlog.h\" +#include \"log.h\"  #include \"modules.h\"  #include \"signals.h\"  #include \"commands.h\" @@ -31,8 +32,6 @@    static int rawlog_lines;  static int signal_rawlog; -static int log_file_create_mode; -static int log_dir_create_mode;    RAWLOG_REC *rawlog_create(void)  { @@ -174,12 +173,6 @@ void rawlog_set_size(int lines)  static void read_settings(void)  {  	rawlog_set_size(settings_get_int(\"rawlog_lines\")); -	log_file_create_mode = octal2dec(settings_get_int(\"log_create_mode\")); -        log_dir_create_mode = log_file_create_mode; -        if (log_file_create_mode & 0400) log_dir_create_mode |= 0100; -        if (log_file_create_mode & 0040) log_dir_create_mode |= 0010; -        if (log_file_create_mode & 0004) log_dir_create_mode |= 0001; -  }    static void cmd_rawlog(const char *data, SERVER_REC *server, void *item) '),('irssi','1.0.4','e08e2bd87aceafc2a34d72ca3fd362f2f2ea90eb','Edward Tomasz Napierala','Don\'t compute log_dir_create_mode in three different places.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-log.c','583','148','0','9','MODIFY','@@ -49,8 +49,6 @@ static THEME_REC *log_theme;  static int skip_next_printtext;  static char *log_theme_name;   -static int log_dir_create_mode; -  static char **autolog_ignore_targets;    static char *log_colorizer_strip(const char *str) @@ -676,7 +674,6 @@ static void sig_theme_destroyed(THEME_REC *theme)  static void read_settings(void)  {  	int old_autolog = autolog_level; -	int log_file_create_mode;    	g_free_not_null(autolog_path);  	autolog_path = g_strdup(settings_get_str(\"autolog_path\")); @@ -704,12 +701,6 @@ static void read_settings(void)  	log_theme = log_theme_name == NULL ? NULL :  		theme_load(log_theme_name);   -	log_file_create_mode = octal2dec(settings_get_int(\"log_create_mode\")); -        log_dir_create_mode = log_file_create_mode; -        if (log_file_create_mode & 0400) log_dir_create_mode |= 0100; -        if (log_file_create_mode & 0040) log_dir_create_mode |= 0010; -        if (log_file_create_mode & 0004) log_dir_create_mode |= 0001; -  	if (autolog_ignore_targets != NULL)  		g_strfreev(autolog_ignore_targets);   '),('irssi','1.0.4','42b5e89f6e9fba17111f67441e25db38a737a3bd','Edward Tomasz Napierala','Add missing diagnostics for rawlog open().  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','172','38','3','0','MODIFY','@@ -128,6 +128,9 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)  	path = convert_home(fname);  	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT,  			      log_file_create_mode); +	if (rawlog->handle == -1) { +		g_warning(\"rawlog open() failed: %s\", strerror(errno)); +	}  	g_free(path);    	rawlog_dump(rawlog, rawlog->handle); '),('irssi','1.0.4','08dc6734b90389c357c73544023ec614e43b0860','Edward Tomasz Napierala','When rawlog open fails, there\'s no point in trying to write.  Don\'t.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','173','38','4','2','MODIFY','@@ -128,13 +128,15 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)  	path = convert_home(fname);  	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT,  			      log_file_create_mode); +	g_free(path); +  	if (rawlog->handle == -1) {  		g_warning(\"rawlog open() failed: %s\", strerror(errno)); +		return;  	} -	g_free(path);    	rawlog_dump(rawlog, rawlog->handle); -	rawlog->logging = rawlog->handle != -1; +	rawlog->logging = TRUE;  }    void rawlog_close(RAWLOG_REC *rawlog) '),('irssi','1.0.4','2914498b291ea0ca432a320004aa3d2499e50eb5','Edward Tomasz Napierala','Consistency: use FALSE instead of 0.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','173','38','1','1','MODIFY','@@ -144,7 +144,7 @@ void rawlog_close(RAWLOG_REC *rawlog)  	if (rawlog->logging) {  		write_buffer_flush();  		close(rawlog->handle); -		rawlog->logging = 0; +		rawlog->logging = FALSE;  	}  }   '),('irssi','1.0.4','2907a82b446d9d0a25157aa4ab560b49853f80d2','Edward Tomasz Napierala','Fix vertical alignment in ./configure --help output.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','configure.ac','671','4','1','1','MODIFY','@@ -158,7 +158,7 @@ AC_ARG_ENABLE(true-color,  	want_truecolor=no)    AC_ARG_ENABLE(gregex, -[  --disable-gregex     Build without GRegex (fall back to regex.h)], +[  --disable-gregex        Build without GRegex (fall back to regex.h)],  	if test x$enableval = xno ; then  		want_gregex=no  	else '),('irssi','1.0.4','f468008b25c7218a03cc0b327082d4d69d5481ef','Edward Tomasz Napierala','Make autotools detect Capsicum.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','configure.ac','692','4','22','0','MODIFY','@@ -166,6 +166,15 @@ AC_ARG_ENABLE(gregex,  	fi,  	want_gregex=yes)   +AC_ARG_WITH(capsicum, +[  --with-capsicum            Build with Capsicum support], +	if test x$withval = xno; then +		want_capsicum=no +	else +		want_capsicum=yes +	fi, +	want_capsicum=yes) +  dnl **  dnl ** just some generic stuff...  dnl ** @@ -499,6 +508,18 @@ if test \"$want_perl\" != \"no\"; then  	fi  fi   +dnl ** +dnl ** check for capsicum +dnl ** + +if test \"x$want_capsicum\" = \"xyes\"; then +	AC_CHECK_LIB(c, cap_enter, [ +		AC_DEFINE(HAVE_CAPSICUM,, Build with Capsicum support) +	], [ +		want_capsicum=\"no, cap_enter not found\" +	]) +fi +  dnl ** check what we want to build  AM_CONDITIONAL(BUILD_TEXTUI, test \"$want_textui\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\") @@ -713,6 +734,7 @@ echo  echo \"Building with 64bit DCC support .. : $offt_64bit\"  echo \"Building with true color support.. : $want_truecolor\"  echo \"Building with GRegex ............. : $want_gregex\" +echo \"Building with Capsicum ........... : $want_capsicum\"    echo  echo \"If there are any problems, read the INSTALL file.\" '),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','Implement /cap_enter.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','configure.ac','693','4','2','1','MODIFY','@@ -167,7 +167,7 @@ AC_ARG_ENABLE(gregex,  	want_gregex=yes)    AC_ARG_WITH(capsicum, -[  --with-capsicum            Build with Capsicum support], +[  --with-capsicum         Build with Capsicum support],  	if test x$withval = xno; then  		want_capsicum=no  	else @@ -526,6 +526,7 @@ AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIFUZZER, test \"$want_irssifuzzer\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIPROXY, test \"$want_irssiproxy\" = \"yes\")  AM_CONDITIONAL(HAVE_PERL, test \"$want_perl\" != \"no\") +AM_CONDITIONAL(HAVE_CAPSICUM, test \"x$want_capsicum\" = \"xyes\")  AM_CONDITIONAL(USE_GREGEX, test \"x$want_gregex\" = \"xyes\")    # move LIBS to PROG_LIBS so they\'re not tried to be used when linking eg. perl libraries '),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','Implement /cap_enter.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','Makefile.am','110','0','5','0','MODIFY','@@ -56,6 +56,11 @@ libcore_a_SOURCES = \\  	tls.c \\  	write-buffer.c   +if HAVE_CAPSICUM +libcore_a_SOURCES += \\ +	capsicum.c +endif +  structure_headers = \\  	channel-rec.h \\  	channel-setup-rec.h \\ '),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','Implement /cap_enter.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','20','4','46','0','ADD','@@ -0,0 +1,46 @@ +/* + capsicum.c : Capsicum sandboxing support + +    Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org> + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"signals.h\" +#include \"commands.h\" + +#include <sys/capsicum.h> +#include <string.h> + +static void cmd_cap_enter(void) +{ +	int error; + +	error = cap_enter(); +	if (error != 0) +		g_error(\"cap_enter(2) failed: %s\", strerror(errno)); +} + +void capsicum_init(void) +{ + +	command_bind(\"cap_enter\", NULL, (SIGNAL_FUNC) cmd_cap_enter); +} + +void capsicum_deinit(void) +{ +	command_unbind(\"cap_enter\", (SIGNAL_FUNC) cmd_cap_enter); +} '),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','Implement /cap_enter.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.h','2','0','7','0','ADD','@@ -0,0 +1,7 @@ +#ifndef __CAPSICUM_H +#define __CAPSICUM_H + +void capsicum_init(void); +void capsicum_deinit(void); + +#endif '),('irssi','1.0.4','56c94570b420dea28b253af5f2c91184423acee1','Edward Tomasz Napierala','Implement /cap_enter.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','core.c','224','24','3','0','MODIFY','@@ -29,6 +29,7 @@  #include \"signals.h\"  #include \"settings.h\"  #include \"session.h\" +#include \"capsicum.h\"    #include \"chat-protocols.h\"  #include \"servers.h\" @@ -235,6 +236,7 @@ void core_init(void)  	commands_init();  	nickmatch_cache_init();          session_init(); +	capsicum_init();    	chat_protocols_init();  	chatnets_init(); @@ -292,6 +294,7 @@ void core_deinit(void)  	chatnets_deinit();  	chat_protocols_deinit();   +	capsicum_deinit();          session_deinit();          nickmatch_cache_deinit();  	commands_deinit(); '),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','Add capability mode error/success messages.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','38','7','22','2','MODIFY','@@ -30,17 +30,37 @@ static void cmd_cap_enter(void)  	int error;    	error = cap_enter(); -	if (error != 0) -		g_error(\"cap_enter(2) failed: %s\", strerror(errno)); +	if (error != 0) { +		signal_emit(\"capability mode failed\", 1, strerror(errno)); +	} else { +		signal_emit(\"capability mode enabled\", 0); +	} +} + +static void cmd_cap_getmode(void) +{ +	u_int mode; +	int error; + +	error = cap_getmode(&mode); +	if (error != 0) { +		signal_emit(\"capability mode failed\", 1, strerror(errno)); +	} else if (mode == 0) { +		signal_emit(\"capability mode disabled\", 0); +	} else { +		signal_emit(\"capability mode enabled\", 0); +	}  }    void capsicum_init(void)  {    	command_bind(\"cap_enter\", NULL, (SIGNAL_FUNC) cmd_cap_enter); +	command_bind(\"cap_getmode\", NULL, (SIGNAL_FUNC) cmd_cap_getmode);  }    void capsicum_deinit(void)  {  	command_unbind(\"cap_enter\", (SIGNAL_FUNC) cmd_cap_enter); +	command_unbind(\"cap_getmode\", (SIGNAL_FUNC) cmd_cap_getmode);  } '),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','Add capability mode error/success messages.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','Makefile.am','65','0','5','0','MODIFY','@@ -38,6 +38,11 @@ libfe_common_core_a_SOURCES = \\  	windows-layout.c \\  	fe-windows.c   +if HAVE_CAPSICUM +libfe_common_core_a_SOURCES += \\ +	fe-capsicum.c +endif +  pkginc_fe_common_coredir=$(pkgincludedir)/src/fe-common/core  pkginc_fe_common_core_HEADERS = \\  	command-history.h \\ '),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','Add capability mode error/success messages.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-capsicum.c','30','5','60','0','ADD','@@ -0,0 +1,60 @@ +/* + fe-capsicum.c : irssi + +    Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org> + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"module-formats.h\" +#include \"signals.h\" +#include \"printtext.h\" + +#include \"levels.h\" +#include \"servers.h\" + +static void capability_mode_enabled(void) +{ + +	printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_CAPSICUM_ENABLED); +} + +static void capability_mode_disabled(void) +{ + +	printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_CAPSICUM_DISABLED); +} + +static void capability_mode_failed(gchar *msg) +{ + +	printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_CAPSICUM_FAILED, msg); +} + +void fe_capsicum_init(void) +{ + +	signal_add(\"capability mode enabled\", (SIGNAL_FUNC) capability_mode_enabled); +	signal_add(\"capability mode disabled\", (SIGNAL_FUNC) capability_mode_disabled); +	signal_add(\"capability mode failed\", (SIGNAL_FUNC) capability_mode_failed); +} + +void fe_capsicum_deinit(void) +{ +	signal_remove(\"capability mode enabled\", (SIGNAL_FUNC) capability_mode_enabled); +	signal_remove(\"capability mode disabled\", (SIGNAL_FUNC) capability_mode_disabled); +	signal_remove(\"capability mode failed\", (SIGNAL_FUNC) capability_mode_failed); +} '),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','Add capability mode error/success messages.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-capsicum.h','2','0','7','0','ADD','@@ -0,0 +1,7 @@ +#ifndef __FE_CAPSICUM_H +#define __FE_CAPSICUM_H + +void fe_capsicum_init(void); +void fe_capsicum_deinit(void); + +#endif '),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','Add capability mode error/success messages.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-common-core.c','377','52','3','0','MODIFY','@@ -32,6 +32,7 @@  #include \"special-vars.h\"  #include \"fe-core-commands.h\"  #include \"fe-queries.h\" +#include \"fe-capsicum.h\"  #include \"hilight-text.h\"  #include \"command-history.h\"  #include \"completion.h\" @@ -179,6 +180,7 @@ void fe_common_core_init(void)  	fe_server_init();  	fe_settings_init();  	fe_tls_init(); +	fe_capsicum_init();  	windows_init();  	window_activity_init();  	window_commands_init(); @@ -221,6 +223,7 @@ void fe_common_core_deinit(void)  	fe_server_deinit();  	fe_settings_deinit();  	fe_tls_deinit(); +	fe_capsicum_deinit();  	windows_deinit();  	window_activity_deinit();  	window_commands_deinit(); '),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','Add capability mode error/success messages.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','module-formats.c','244','0','3','0','MODIFY','@@ -290,6 +290,9 @@ FORMAT_REC fecommon_core_formats[] = {  	{ \"completion_header\", \"%#Key        Value                                    Auto\", 0 },  	{ \"completion_line\", \"%#$[10]0 $[!40]1 $2\", 3, { 0, 0, 0 } },  	{ \"completion_footer\", \"\", 0 }, +	{ \"capsicum_enabled\", \"Capability mode enabled\", 0 }, +	{ \"capsicum_disabled\", \"Capability mode not enabled\", 0 }, +	{ \"capsicum_failed\", \"Capability mode failed: $0\", 1, { 0 } },    	/* ---- */  	{ NULL, \"TLS\", 0 }, '),('irssi','1.0.4','d5d45c29b8e00c304a6b6656983cafee84fe6bc8','Edward Tomasz Napierala','Add capability mode error/success messages.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','module-formats.h','243','0','3','0','MODIFY','@@ -255,6 +255,9 @@ enum {  	TXT_COMPLETION_HEADER,          TXT_COMPLETION_LINE,  	TXT_COMPLETION_FOOTER, +	TXT_CAPSICUM_ENABLED, +	TXT_CAPSICUM_DISABLED, +	TXT_CAPSICUM_FAILED,    	TLS_FILL_15,   '),('irssi','1.0.4','3200c381dbcb02e99c7667bd955c90ee859d15a0','Edward Tomasz Napierala','Rename to \"/capability enter\" and \"/capability status\".  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','44','8','13','6','MODIFY','@@ -25,7 +25,12 @@  #include <sys/capsicum.h>  #include <string.h>   -static void cmd_cap_enter(void) +static void cmd_capsicum(const char *data, SERVER_REC *server, void *item) +{ +	command_runsub(\"capsicum\", data, server, item); +} + +static void cmd_capsicum_enter(void)  {  	int error;   @@ -37,7 +42,7 @@ static void cmd_cap_enter(void)  	}  }   -static void cmd_cap_getmode(void) +static void cmd_capsicum_status(void)  {  	u_int mode;  	int error; @@ -55,12 +60,14 @@ static void cmd_cap_getmode(void)  void capsicum_init(void)  {   -	command_bind(\"cap_enter\", NULL, (SIGNAL_FUNC) cmd_cap_enter); -	command_bind(\"cap_getmode\", NULL, (SIGNAL_FUNC) cmd_cap_getmode); +	command_bind(\"capsicum\", NULL, (SIGNAL_FUNC) cmd_capsicum); +	command_bind(\"capsicum enter\", NULL, (SIGNAL_FUNC) cmd_capsicum_enter); +	command_bind(\"capsicum status\", NULL, (SIGNAL_FUNC) cmd_capsicum_status);  }    void capsicum_deinit(void)  { -	command_unbind(\"cap_enter\", (SIGNAL_FUNC) cmd_cap_enter); -	command_unbind(\"cap_getmode\", (SIGNAL_FUNC) cmd_cap_getmode); +	command_unbind(\"capsicum\", (SIGNAL_FUNC) cmd_capsicum); +	command_unbind(\"capsicum enter\", (SIGNAL_FUNC) cmd_capsicum_enter); +	command_unbind(\"capsicum status\", (SIGNAL_FUNC) cmd_capsicum_status);  } '),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with IP addresses.','configure.ac','698','4','6','1','MODIFY','@@ -514,7 +514,12 @@ dnl **    if test \"x$want_capsicum\" = \"xyes\"; then  	AC_CHECK_LIB(c, cap_enter, [ -		AC_DEFINE(HAVE_CAPSICUM,, Build with Capsicum support) +		AC_CHECK_LIB(nv, nvlist_create, [ +			AC_DEFINE(HAVE_CAPSICUM,, Build with Capsicum support) +			LIBS=\"$LIBS -lnv\" +		], [ +			want_capsicum=\"no, nvlist_create not found\" +		])  	], [  		want_capsicum=\"no, cap_enter not found\"  	]) '),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with IP addresses.','capsicum.c','145','26','126','0','MODIFY','@@ -19,21 +19,147 @@  */    #include \"module.h\" +#include \"network.h\"  #include \"signals.h\"  #include \"commands.h\"   +#include <sys/types.h>  #include <sys/capsicum.h> +#include <sys/nv.h> +#include <sys/procdesc.h> +#include <sys/socket.h>  #include <string.h>   +static int symbiontfds[2]; + +gboolean capsicum_enabled(void) +{ +	u_int mode; +	int error; + +	error = cap_getmode(&mode); +	if (error != 0) +		return FALSE; + +	if (mode == 0) +		return FALSE; + +	return TRUE; +} + +int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip) +{ +	nvlist_t *nvl; +	int error, saved_errno, sock; + +	/* Send request to the symbiont. */ +	nvl = nvlist_create(0); +	nvlist_add_binary(nvl, \"ip\", ip, sizeof(*ip)); +	nvlist_add_number(nvl, \"port\", port); +	if (my_ip != NULL) { +		/* nvlist_add_binary(3) can\'t handle NULL values. */ +		nvlist_add_binary(nvl, \"my_ip\", my_ip, sizeof(*my_ip)); +	} +	error = nvlist_send(symbiontfds[1], nvl); +	nvlist_destroy(nvl); +	if (error != 0) { +		g_warning(\"nvlist_send: %s\", strerror(errno)); +		return -1; +	} + +	/* Receive response. */ +	nvl = nvlist_recv(symbiontfds[1], 0); +	if (nvl == NULL) { +		g_warning(\"nvlist_recv: %s\", strerror(errno)); +		return -1; +	} +	if (nvlist_exists_descriptor(nvl, \"sock\")) { +		sock = nvlist_take_descriptor(nvl, \"sock\"); +	} else { +		sock = -1; +	} +	saved_errno = nvlist_get_number(nvl, \"errno\"); +	nvlist_destroy(nvl); +	errno = saved_errno; + +	return sock; +} +  static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)  {  	command_runsub(\"capsicum\", data, server, item);  }   +static int start_symbiont(void) +{ +	pid_t pid; +	nvlist_t *nvl; +	IPADDR *ip, *my_ip; +	int childfd, error, port, saved_errno, sock; + +	error = socketpair(PF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, symbiontfds); +	if (error != 0) { +		g_warning(\"socketpair: %s\", strerror(errno)); +		return 1; +	} + +	pid = pdfork(&childfd, PD_CLOEXEC); +	if (pid < 0) { +		g_warning(\"pdfork: %s\", strerror(errno)); +		return 1; +	} + +	if (pid > 0) { +		close(symbiontfds[0]); +		return 0; +	} + +	/* We\'re the child, running outside the Capsicum sandbox. */ +	setproctitle(\"capsicum symbiont\"); +	close(symbiontfds[1]); +	close(0); +	close(1); +	close(2); +	for (;;) { +		/* Receive parameters from the main irssi process. */ +		nvl = nvlist_recv(symbiontfds[0], 0); +		if (nvl == NULL) +			exit(1); +		ip = nvlist_get_binary(nvl, \"ip\", NULL); +		port = (int)nvlist_get_number(nvl, \"port\"); +		if (nvlist_exists(nvl, \"my_ip\")) +			my_ip = nvlist_get_binary(nvl, \"my_ip\", NULL); +		else +			my_ip = NULL; + +		/* Connect. */ +		sock = net_connect_ip_handle(ip, port, my_ip); +		saved_errno = errno; + +		/* Send back the socket fd. */ +		nvlist_destroy(nvl); +		nvl = nvlist_create(0); + +		if (sock != -1) +			nvlist_move_descriptor(nvl, \"sock\", sock); +		nvlist_add_number(nvl, \"errno\", saved_errno); +		error = nvlist_send(symbiontfds[0], nvl); +		if (error != 0) +			exit(1); +		nvlist_destroy(nvl); +	} +} +  static void cmd_capsicum_enter(void)  {  	int error;   +	error = start_symbiont(); +	if (error != 0) { +		signal_emit(\"capability mode failed\", 1, strerror(errno)); +		return; +	} +  	error = cap_enter();  	if (error != 0) {  		signal_emit(\"capability mode failed\", 1, strerror(errno)); '),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with IP addresses.','capsicum.h','4','0','3','0','MODIFY','@@ -1,6 +1,9 @@  #ifndef __CAPSICUM_H  #define __CAPSICUM_H   +gboolean capsicum_enabled(void); +int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip); +  void capsicum_init(void);  void capsicum_deinit(void);   '),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with IP addresses.','network.c','388','102','28','5','MODIFY','@@ -20,6 +20,9 @@    #include \"module.h\"  #include \"network.h\" +#ifdef HAVE_CAPSICUM +#include \"capsicum.h\" +#endif    #include <sys/un.h>   @@ -144,8 +147,7 @@ GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip)  	return net_connect_ip(ip, port, my_ip);  }   -/* Connect to socket with ip address */ -GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip) +int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip)  {  	union sockaddr_union so;  	int handle, ret, opt = 1; @@ -161,7 +163,7 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)  	handle = socket(ip->family, SOCK_STREAM, 0);    	if (handle == -1) -		return NULL; +		return -1;    	/* set socket options */  	fcntl(handle, F_SETFL, O_NONBLOCK); @@ -176,7 +178,7 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)    			close(handle);  			errno = old_errno; -			return NULL; +			return -1;  		}  	}   @@ -190,9 +192,30 @@ GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)  		int old_errno = errno;  		close(handle);  		errno = old_errno; -		return NULL; +		return -1;  	}   +	return handle; +} + + +/* Connect to socket with ip address */ +GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip) +{ +	int handle = -1; + +#ifdef HAVE_CAPSICUM +	if (capsicum_enabled()) +		handle = capsicum_net_connect_ip(ip, port, my_ip); +	else +		handle = net_connect_ip_handle(ip, port, my_ip); +#else +	handle = net_connect_ip_handle(ip, port, my_ip); +#endif + +	if (handle == -1) +		return (NULL); +  	return g_io_channel_new(handle);  }   '),('irssi','1.0.4','cec68557aa436b4f16505d2095af02f83d154eda','Edward Tomasz Napierala','/connect works - although only with IP addresses.','network.h','36','0','2','0','MODIFY','@@ -36,6 +36,8 @@ GIOChannel *g_io_channel_new(int handle);  /* returns 1 if IPADDRs are the same */  int net_ip_compare(IPADDR *ip1, IPADDR *ip2);   +int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip); +  /* Connect to socket */  GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED;  /* Connect to socket with ip address and SSL*/ '),('irssi','1.0.4','925240155e5c0c20569bcb5fafe4d3047055768a','Edward Tomasz Napierala','Config file support for \"capsicum\" parameter.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','154','28','13','1','MODIFY','@@ -19,9 +19,10 @@  */    #include \"module.h\" +#include \"commands.h\"  #include \"network.h\" +#include \"settings.h\"  #include \"signals.h\" -#include \"commands.h\"    #include <sys/types.h>  #include <sys/capsicum.h> @@ -183,8 +184,17 @@ static void cmd_capsicum_status(void)  	}  }   +void sig_init_finished(void) +{ +	if (settings_get_bool(\"capsicum\")) +		cmd_capsicum_enter(); +} +  void capsicum_init(void)  { +	settings_add_bool(\"misc\", \"capsicum\", FALSE); + +	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);    	command_bind(\"capsicum\", NULL, (SIGNAL_FUNC) cmd_capsicum);  	command_bind(\"capsicum enter\", NULL, (SIGNAL_FUNC) cmd_capsicum_enter); @@ -193,6 +203,8 @@ void capsicum_init(void)    void capsicum_deinit(void)  { +	signal_remove(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished); +  	command_unbind(\"capsicum\", (SIGNAL_FUNC) cmd_capsicum);  	command_unbind(\"capsicum enter\", (SIGNAL_FUNC) cmd_capsicum_enter);  	command_unbind(\"capsicum status\", (SIGNAL_FUNC) cmd_capsicum_status); '),('irssi','1.0.4','f4546be7ecb8a0801fb0d30415586c15d721494a','Edward Tomasz Napierala','Reorder functions.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','154','28','5','5','MODIFY','@@ -86,11 +86,6 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)  	return sock;  }   -static void cmd_capsicum(const char *data, SERVER_REC *server, void *item) -{ -	command_runsub(\"capsicum\", data, server, item); -} -  static int start_symbiont(void)  {  	pid_t pid; @@ -151,6 +146,11 @@ static int start_symbiont(void)  	}  }   +static void cmd_capsicum(const char *data, SERVER_REC *server, void *item) +{ +	command_runsub(\"capsicum\", data, server, item); +} +  static void cmd_capsicum_enter(void)  {  	int error; '),('irssi','1.0.4','509eca76f0755e94b5981f464f9f9a882499180a','Edward Tomasz Napierala','Make DNS work in capability mode.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','222','36','136','37','MODIFY','@@ -31,6 +31,9 @@  #include <sys/socket.h>  #include <string.h>   +#define	OPCODE_CONNECT		1 +#define	OPCODE_GETHOSTBYNAME	2 +  static int symbiontfds[2];    gboolean capsicum_enabled(void) @@ -55,6 +58,7 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)    	/* Send request to the symbiont. */  	nvl = nvlist_create(0); +	nvlist_add_number(nvl, \"opcode\", OPCODE_CONNECT);  	nvlist_add_binary(nvl, \"ip\", ip, sizeof(*ip));  	nvlist_add_number(nvl, \"port\", port);  	if (my_ip != NULL) { @@ -86,12 +90,139 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)  	return sock;  }   -static int start_symbiont(void) +int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)  { -	pid_t pid;  	nvlist_t *nvl; +	IPADDR *received_ip4, *received_ip6; +	int error, ret, saved_errno; + +	/* Send request to the symbiont. */ +	nvl = nvlist_create(0); +	nvlist_add_number(nvl, \"opcode\", OPCODE_GETHOSTBYNAME); +	nvlist_add_string(nvl, \"addr\", addr); +	error = nvlist_send(symbiontfds[1], nvl); +	nvlist_destroy(nvl); +	if (error != 0) { +		g_warning(\"nvlist_send: %s\", strerror(errno)); +		return -1; +	} + +	/* Receive response. */ +	nvl = nvlist_recv(symbiontfds[1], 0); +	if (nvl == NULL) { +		g_warning(\"nvlist_recv: %s\", strerror(errno)); +		return -1; +	} + +	received_ip4 = nvlist_get_binary(nvl, \"ip4\", NULL); +	received_ip6 = nvlist_get_binary(nvl, \"ip6\", NULL); +	memcpy(ip4, received_ip4, sizeof(*ip4)); +	memcpy(ip6, received_ip6, sizeof(*ip6)); + +	ret = nvlist_get_number(nvl, \"ret\"); +	saved_errno = nvlist_get_number(nvl, \"errno\"); +	nvlist_destroy(nvl); +	errno = saved_errno; + +	return ret; +} + +nvlist_t *symbiont_connect(const nvlist_t *request) +{ +	nvlist_t *response;  	IPADDR *ip, *my_ip; -	int childfd, error, port, saved_errno, sock; +	int port, saved_errno, sock; + +	ip = nvlist_get_binary(request, \"ip\", NULL); +	port = (int)nvlist_get_number(request, \"port\"); +	if (nvlist_exists(request, \"my_ip\")) +		my_ip = nvlist_get_binary(request, \"my_ip\", NULL); +	else +		my_ip = NULL; + +	/* Connect. */ +	sock = net_connect_ip_handle(ip, port, my_ip); +	saved_errno = errno; + +	/* Send back the socket fd. */ +	response = nvlist_create(0); + +	if (sock != -1) +		nvlist_move_descriptor(response, \"sock\", sock); +	nvlist_add_number(response, \"errno\", saved_errno); + +	return (response); +} + +nvlist_t *symbiont_gethostbyname(const nvlist_t *request) +{ +	nvlist_t *response; +	IPADDR ip4, ip6; +	const char *addr; +	int ret, saved_errno; + +	addr = nvlist_get_string(request, \"addr\"); + +	/* Connect. */ +	ret = net_gethostbyname(addr, &ip4, &ip6); +	saved_errno = errno; + +	/* Send back the IPs. */ +	response = nvlist_create(0); + +	nvlist_add_number(response, \"ret\", ret); +	nvlist_add_number(response, \"errno\", saved_errno); +	nvlist_add_binary(response, \"ip4\", &ip4, sizeof(ip4)); +	nvlist_add_binary(response, \"ip6\", &ip6, sizeof(ip6)); + +	return (response); +} + +/* + * Child process, running outside the Capsicum sandbox. + */ +_Noreturn static void symbiont(void) +{ +	nvlist_t *request, *response; +	int error, opcode; + +	setproctitle(\"capsicum symbiont\"); +	close(symbiontfds[1]); +	close(0); +	close(1); +	close(2); + +	for (;;) { +		/* Receive parameters from the main irssi process. */ +		request = nvlist_recv(symbiontfds[0], 0); +		if (request == NULL) +			exit(1); + +		opcode = nvlist_get_number(request, \"opcode\"); +		switch (opcode) { +		case OPCODE_CONNECT: +			response = symbiont_connect(request); +			break; +		case OPCODE_GETHOSTBYNAME: +			response = symbiont_gethostbyname(request); +			break; +		default: +			exit(1); +		} + +		/* Send back the response. */ +		error = nvlist_send(symbiontfds[0], response); +		if (error != 0) +			exit(1); +		nvlist_destroy(request); +		nvlist_destroy(response); +	} +} + +static int start_symbiont(void) +{ +	int childfd, error; +	pid_t pid;    	error = socketpair(PF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, symbiontfds);  	if (error != 0) { @@ -110,40 +241,8 @@ static int start_symbiont(void)  		return 0;  	}   -	/* We\'re the child, running outside the Capsicum sandbox. */ -	setproctitle(\"capsicum symbiont\"); -	close(symbiontfds[1]); -	close(0); -	close(1); -	close(2); -	for (;;) { -		/* Receive parameters from the main irssi process. */ -		nvl = nvlist_recv(symbiontfds[0], 0); -		if (nvl == NULL) -			exit(1); -		ip = nvlist_get_binary(nvl, \"ip\", NULL); -		port = (int)nvlist_get_number(nvl, \"port\"); -		if (nvlist_exists(nvl, \"my_ip\")) -			my_ip = nvlist_get_binary(nvl, \"my_ip\", NULL); -		else -			my_ip = NULL; - -		/* Connect. */ -		sock = net_connect_ip_handle(ip, port, my_ip); -		saved_errno = errno; - -		/* Send back the socket fd. */ -		nvlist_destroy(nvl); -		nvl = nvlist_create(0); - -		if (sock != -1) -			nvlist_move_descriptor(nvl, \"sock\", sock); -		nvlist_add_number(nvl, \"errno\", saved_errno); -		error = nvlist_send(symbiontfds[0], nvl); -		if (error != 0) -			exit(1); -		nvlist_destroy(nvl); -	} +	symbiont(); +	/* NOTREACHED */  }    static void cmd_capsicum(const char *data, SERVER_REC *server, void *item) '),('irssi','1.0.4','509eca76f0755e94b5981f464f9f9a882499180a','Edward Tomasz Napierala','Make DNS work in capability mode.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.h','5','0','1','0','MODIFY','@@ -3,6 +3,7 @@    gboolean capsicum_enabled(void);  int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip); +int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);    void capsicum_init(void);  void capsicum_deinit(void); '),('irssi','1.0.4','509eca76f0755e94b5981f464f9f9a882499180a','Edward Tomasz Napierala','Make DNS work in capability mode.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','network.c','390','104','5','0','MODIFY','@@ -406,6 +406,11 @@ int net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)  	struct addrinfo hints, *ai, *ailist;  	int ret, count_v4, count_v6, use_v4, use_v6;   +#ifdef HAVE_CAPSICUM +	if (capsicum_enabled()) +		return (capsicum_net_gethostbyname(addr, ip4, ip6)); +#endif +  	g_return_val_if_fail(addr != NULL, -1);    	memset(ip4, 0, sizeof(IPADDR)); '),('irssi','1.0.4','1f57ceec4c4e7c3d42f341921e36fe4aab612e57','Edward Tomasz Napierala','Prevent the user from calling \"/capsicum enter\" twice.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','228','38','7','0','MODIFY','@@ -252,8 +252,15 @@ static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)    static void cmd_capsicum_enter(void)  { +	u_int mode;  	int error;   +	error = cap_getmode(&mode); +	if (error == 0 && mode != 0) { +		g_warning(\"Already in capability mode\"); +		return; +	} +  	error = start_symbiont();  	if (error != 0) {  		signal_emit(\"capability mode failed\", 1, strerror(errno)); '),('irssi','1.0.4','939371aa1dfdbf11fe98648e1eafc4c95e80bb9e','Edward Tomasz Napierala','Fix warnings.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','228','38','2','2','MODIFY','@@ -93,7 +93,7 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)  int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)  {  	nvlist_t *nvl; -	IPADDR *received_ip4, *received_ip6; +	const IPADDR *received_ip4, *received_ip6;  	int error, ret, saved_errno;    	/* Send request to the symbiont. */ @@ -130,7 +130,7 @@ int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)  nvlist_t *symbiont_connect(const nvlist_t *request)  {  	nvlist_t *response; -	IPADDR *ip, *my_ip; +	const IPADDR *ip, *my_ip;  	int port, saved_errno, sock;    	ip = nvlist_get_binary(request, \"ip\", NULL); '),('irssi','1.0.4','939371aa1dfdbf11fe98648e1eafc4c95e80bb9e','Edward Tomasz Napierala','Fix warnings.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','network.c','390','104','1','1','MODIFY','@@ -147,7 +147,7 @@ GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip)  	return net_connect_ip(ip, port, my_ip);  }   -int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip) +int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip)  {  	union sockaddr_union so;  	int handle, ret, opt = 1; '),('irssi','1.0.4','939371aa1dfdbf11fe98648e1eafc4c95e80bb9e','Edward Tomasz Napierala','Fix warnings.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','network.h','36','0','1','1','MODIFY','@@ -36,7 +36,7 @@ GIOChannel *g_io_channel_new(int handle);  /* returns 1 if IPADDRs are the same */  int net_ip_compare(IPADDR *ip1, IPADDR *ip2);   -int net_connect_ip_handle(IPADDR *ip, int port, IPADDR *my_ip); +int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);    /* Connect to socket */  GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED; '),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','Working /log and /rawlog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','255','45','33','0','MODIFY','@@ -20,6 +20,8 @@    #include \"module.h\"  #include \"commands.h\" +#include \"log.h\" +#include \"misc.h\"  #include \"network.h\"  #include \"settings.h\"  #include \"signals.h\" @@ -34,6 +36,9 @@  #define	OPCODE_CONNECT		1  #define	OPCODE_GETHOSTBYNAME	2   +static char *irclogs_path; +static size_t irclogs_path_len; +static int irclogs_fd;  static int symbiontfds[2];    gboolean capsicum_enabled(void) @@ -127,6 +132,23 @@ int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)  	return ret;  }   +int capsicum_open(const char *path, int flags, int mode) +{ +	int fd; + +	/* +1 is for slash separating irclogs_path and the rest. */ +	if (strlen(path) > irclogs_path_len + 1 && strncmp(path, irclogs_path, irclogs_path_len) == 0) { +		fd = openat(irclogs_fd, path + irclogs_path_len + 1, flags, mode); +	} else { +		fd = open(path, flags, mode); +	} + +	if (fd < 0 && (errno == ENOTCAPABLE || errno == ECAPMODE)) +		g_warning(\"File system access restricted to %s due to capability mode\", irclogs_path); + +	return (fd); +} +  nvlist_t *symbiont_connect(const nvlist_t *request)  {  	nvlist_t *response; @@ -261,6 +283,16 @@ static void cmd_capsicum_enter(void)  		return;  	}   +	irclogs_path = convert_home(settings_get_str(\"capsicum_irclogs_path\")); +	g_mkdir_with_parents(irclogs_path, log_dir_create_mode); +	irclogs_path_len = strlen(irclogs_path); +	irclogs_fd = open(irclogs_path, O_DIRECTORY | O_CLOEXEC); +	if (irclogs_fd < 0) { +		g_warning(\"Unable to open %s: %s\", irclogs_path, strerror(errno)); +		signal_emit(\"capability mode failed\", 1, strerror(errno)); +		return; +	} +  	error = start_symbiont();  	if (error != 0) {  		signal_emit(\"capability mode failed\", 1, strerror(errno)); @@ -299,6 +331,7 @@ void sig_init_finished(void)  void capsicum_init(void)  {  	settings_add_bool(\"misc\", \"capsicum\", FALSE); +	settings_add_str(\"misc\", \"capsicum_irclogs_path\", \"~/irclogs\");    	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);   '),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','Working /log and /rawlog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.h','6','0','1','0','MODIFY','@@ -4,6 +4,7 @@  gboolean capsicum_enabled(void);  int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);  int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6); +int capsicum_open(const char *path, int flags, int mode);    void capsicum_init(void);  void capsicum_deinit(void); '),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','Working /log and /rawlog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.c','448','100','14','1','MODIFY','@@ -26,6 +26,9 @@  #include \"servers.h\"  #include \"log.h\"  #include \"write-buffer.h\" +#ifdef HAVE_CAPSICUM +#include \"capsicum.h\" +#endif    #include \"lib-config/iconfig.h\"  #include \"settings.h\" @@ -73,6 +76,16 @@ static void log_write_timestamp(int handle, const char *format,  	if (text != NULL) write_buffer(handle, text, strlen(text));  }   +static int log_open_wrapper(const char *path, int flags, int mode) +{ +#ifdef HAVE_CAPSICUM +	if (capsicum_enabled()) +		return capsicum_open(path, flags, mode); +#endif + +	return open(path, flags, mode); +} +  static char *log_filename(LOG_REC *log)  {  	char *str, fname[1024]; @@ -119,7 +132,7 @@ int log_start_logging(LOG_REC *log)  	}    	log->handle = log->real_fname == NULL ? -1 : -		open(log->real_fname, O_WRONLY | O_APPEND | O_CREAT, +		log_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,  		     log_file_create_mode);  	if (log->handle == -1) {  		signal_emit(\"log create failed\", 1, log); '),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','Working /log and /rawlog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.h','45','0','2','0','MODIFY','@@ -38,6 +38,8 @@ extern GSList *logs;  extern int log_file_create_mode;  extern int log_dir_create_mode;   +extern int log_dir_create_mode; +  /* Create log record - you still need to call log_update() to actually add it     into log list */  LOG_REC *log_create_rec(const char *fname, int level); '),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','Working /log and /rawlog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','network.c','390','104','0','1','MODIFY','@@ -198,7 +198,6 @@ int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip)  	return handle;  }   -  /* Connect to socket with ip address */  GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)  { '),('irssi','1.0.4','241dd66ac11d54b37c671cd56f1320fe5b83803d','Edward Tomasz Napierala','Working /log and /rawlog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','180','41','15','2','MODIFY','@@ -27,12 +27,25 @@  #include \"misc.h\"  #include \"write-buffer.h\"  #include \"settings.h\" +#ifdef HAVE_CAPSICUM +#include \"capsicum.h\" +#endif    #include \"servers.h\"    static int rawlog_lines;  static int signal_rawlog;   +static int rawlog_open_wrapper(const char *path, int flags, int mode) +{ +#ifdef HAVE_CAPSICUM +	if (capsicum_enabled()) +		return capsicum_open(path, flags, mode); +#endif + +	return open(path, flags, mode); +} +  RAWLOG_REC *rawlog_create(void)  {  	RAWLOG_REC *rec; @@ -126,7 +139,7 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)  		return;    	path = convert_home(fname); -	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT, +	rawlog->handle = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT,  			      log_file_create_mode);  	g_free(path);   @@ -158,7 +171,7 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)          g_free(dir);    	path = convert_home(fname); -	f = open(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode); +	f = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode);  	g_free(path);    	if (f < 0) { '),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','Working autolog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','294','55','47','4','MODIFY','@@ -136,19 +136,62 @@ int capsicum_open(const char *path, int flags, int mode)  {  	int fd;   -	/* +1 is for slash separating irclogs_path and the rest. */ -	if (strlen(path) > irclogs_path_len + 1 && strncmp(path, irclogs_path, irclogs_path_len) == 0) { -		fd = openat(irclogs_fd, path + irclogs_path_len + 1, flags, mode); +	/* +1 is for the slash separating irclogs_path and the rest. */ +	if (strlen(path) > irclogs_path_len + 1 && +	    strncmp(path, irclogs_path, irclogs_path_len) == 0) { +		fd = openat(irclogs_fd, path + irclogs_path_len + 1, +		    flags, mode);  	} else {  		fd = open(path, flags, mode);  	}    	if (fd < 0 && (errno == ENOTCAPABLE || errno == ECAPMODE)) -		g_warning(\"File system access restricted to %s due to capability mode\", irclogs_path); +		g_warning(\"File system access restricted to %s \" +		    \"due to capability mode\", irclogs_path);    	return (fd);  }   +void capsicum_mkdir_with_parents(const char *path, int mode) +{ +	char *component, *copy, *tofree; +	int error, fd, newfd; + +	/* +1 is for the slash separating irclogs_path and the rest. */ +	if (strlen(path) <= irclogs_path_len + 1 || +	    strncmp(path, irclogs_path, irclogs_path_len) != 0) { +		g_warning(\"Cannot create %s: file system access restricted \" +		    \"to %s due to capability mode\", path, irclogs_path); +		return; +	} + +	copy = tofree = g_strdup(path + irclogs_path_len + 1); +	fd = irclogs_fd; +	for (;;) { +		component = strsep(&copy, \"/\"); +		if (component == NULL) +			break; +		error = mkdirat(fd, component, mode); +		if (error != 0 && errno != EEXIST) { +			g_warning(\"cannot create %s: %s\", +			    component, strerror(errno)); +			break; +		} +		newfd = openat(fd, component, O_DIRECTORY); +		if (newfd < 0) { +			g_warning(\"cannot open %s: %s\", +			    component, strerror(errno)); +			break; +		} +		if (fd != irclogs_fd) +			close(fd); +		fd = newfd; +	} +	g_free(tofree); +	if (fd != irclogs_fd) +		close(fd); +} +  nvlist_t *symbiont_connect(const nvlist_t *request)  {  	nvlist_t *response; '),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','Working autolog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.h','7','0','1','0','MODIFY','@@ -5,6 +5,7 @@ gboolean capsicum_enabled(void);  int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);  int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);  int capsicum_open(const char *path, int flags, int mode); +void capsicum_mkdir_with_parents(const char *path, int mode);    void capsicum_init(void);  void capsicum_deinit(void); '),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','Working autolog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.c','452','102','7','0','MODIFY','@@ -127,7 +127,14 @@ int log_start_logging(LOG_REC *log)  		/* path may contain variables (%time, $vars),  		   make sure the directory is created */  		dir = g_path_get_dirname(log->real_fname); +#ifdef HAVE_CAPSICUM +		if (capsicum_enabled()) +			capsicum_mkdir_with_parents(dir, log_dir_create_mode); +		else +			g_mkdir_with_parents(dir, log_dir_create_mode); +#else  		g_mkdir_with_parents(dir, log_dir_create_mode); +#endif  		g_free(dir);  	}   '),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','Working autolog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','184','43','8','1','MODIFY','@@ -167,7 +167,14 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)  	int f;            dir = g_path_get_dirname(fname); -        g_mkdir_with_parents(dir, log_dir_create_mode); +#ifdef HAVE_CAPSICUM +	if (capsicum_enabled()) +		capsicum_mkdir_with_parents(dir, log_dir_create_mode); +	else +		g_mkdir_with_parents(dir, log_dir_create_mode); +#else +	g_mkdir_with_parents(dir, log_dir_create_mode); +#endif          g_free(dir);    	path = convert_home(fname); '),('irssi','1.0.4','e777ae986d64863a444132885b160ab2e9c7458e','Edward Tomasz Napierala','Working autolog.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-log.c','588','150','10','0','MODIFY','@@ -30,6 +30,9 @@  #include \"special-vars.h\"  #include \"settings.h\"  #include \"lib-config/iconfig.h\" +#ifdef HAVE_CAPSICUM +#include \"capsicum.h\" +#endif    #include \"fe-windows.h\"  #include \"window-items.h\" @@ -451,7 +454,14 @@ static void autolog_open(SERVER_REC *server, const char *server_tag,  		log_item_add(log, LOG_ITEM_TARGET, target, server_tag);    		dir = g_path_get_dirname(log->real_fname); +#ifdef HAVE_CAPSICUM +		if (capsicum_enabled()) +			capsicum_mkdir_with_parents(dir, log_dir_create_mode); +		else +			g_mkdir_with_parents(dir, log_dir_create_mode); +#else  		g_mkdir_with_parents(dir, log_dir_create_mode); +#endif  		g_free(dir);    		log->temp = TRUE; '),('irssi','1.0.4','c00d4753aee732b5a815f12dda3c9fced41ef1f5','Edward Tomasz Napierala','Restrict port range available in capability mode.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','310','60','27','3','MODIFY','@@ -40,6 +40,8 @@ static char *irclogs_path;  static size_t irclogs_path_len;  static int irclogs_fd;  static int symbiontfds[2]; +static int port_min; +static int port_max;    gboolean capsicum_enabled(void)  { @@ -90,6 +92,13 @@ int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)  	}  	saved_errno = nvlist_get_number(nvl, \"errno\");  	nvlist_destroy(nvl); + +	if (sock == -1 && (port < port_min || port > port_max)) { +		g_warning(\"Access restricted to ports between %d and %d \" +		    \"due to capability mode\", +		    port_min, port_max); +	} +  	errno = saved_errno;    	return sock; @@ -205,9 +214,19 @@ nvlist_t *symbiont_connect(const nvlist_t *request)  	else  		my_ip = NULL;   -	/* Connect. */ -	sock = net_connect_ip_handle(ip, port, my_ip); -	saved_errno = errno; +	/* +	 * Check if the port is in allowed range.  This is to minimize +	 * the chance of the attacker rooting another system in case of +	 * compromise. +	 */ +	if (port < port_min || port > port_max) { +		sock = -1; +		saved_errno = EPERM; +	} else { +		/* Connect. */ +		sock = net_connect_ip_handle(ip, port, my_ip); +		saved_errno = errno; +	}    	/* Send back the socket fd. */  	response = nvlist_create(0); @@ -326,6 +345,9 @@ static void cmd_capsicum_enter(void)  		return;  	}   +	port_min = settings_get_int(\"capsicum_port_min\"); +	port_max = settings_get_int(\"capsicum_port_max\"); +  	irclogs_path = convert_home(settings_get_str(\"capsicum_irclogs_path\"));  	g_mkdir_with_parents(irclogs_path, log_dir_create_mode);  	irclogs_path_len = strlen(irclogs_path); @@ -375,6 +397,8 @@ void capsicum_init(void)  {  	settings_add_bool(\"misc\", \"capsicum\", FALSE);  	settings_add_str(\"misc\", \"capsicum_irclogs_path\", \"~/irclogs\"); +	settings_add_int(\"misc\", \"capsicum_port_min\", 6667); +	settings_add_int(\"misc\", \"capsicum_port_max\", 6697);    	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);   '),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','Add wrappers to reduce #ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','325','64','17','0','MODIFY','@@ -161,6 +161,14 @@ int capsicum_open(const char *path, int flags, int mode)  	return (fd);  }   +int capsicum_open_wrapper(const char *path, int flags, int mode) +{ +	if (capsicum_enabled()) { +		return capsicum_open(path, flags, mode); +	} +	return open(path, flags, mode); +} +  void capsicum_mkdir_with_parents(const char *path, int mode)  {  	char *component, *copy, *tofree; @@ -201,6 +209,15 @@ void capsicum_mkdir_with_parents(const char *path, int mode)  		close(fd);  }   +void capsicum_mkdir_with_parents_wrapper(const char *path, int mode) +{ +	if (capsicum_enabled()) { +		capsicum_mkdir_with_parents(path, mode); +		return; +	} +	g_mkdir_with_parents(path, mode); +} +  nvlist_t *symbiont_connect(const nvlist_t *request)  {  	nvlist_t *response; '),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','Add wrappers to reduce #ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.h','9','0','11','1','MODIFY','@@ -7,7 +7,17 @@ int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);  int capsicum_open(const char *path, int flags, int mode);  void capsicum_mkdir_with_parents(const char *path, int mode);   +#ifdef HAVE_CAPSICUM +int capsicum_open_wrapper(const char *path, int flags, int mode); +void capsicum_mkdir_with_parents_wrapper(const char *path, int mode); +#else +#define	capsicum_open_wrapper(P, F, M)			\\ +	open(P, F, M) +#define	capsicum_mkdir_with_parents_wrapper(P, M)	\\ +	g_mkdir_with_parents(P, M) +#endif +  void capsicum_init(void);  void capsicum_deinit(void);   -#endif +#endif /* !__CAPSICUM_H */ '),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','Add wrappers to reduce #ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.c','442','97','2','21','MODIFY','@@ -26,9 +26,7 @@  #include \"servers.h\"  #include \"log.h\"  #include \"write-buffer.h\" -#ifdef HAVE_CAPSICUM  #include \"capsicum.h\" -#endif    #include \"lib-config/iconfig.h\"  #include \"settings.h\" @@ -76,16 +74,6 @@ static void log_write_timestamp(int handle, const char *format,  	if (text != NULL) write_buffer(handle, text, strlen(text));  }   -static int log_open_wrapper(const char *path, int flags, int mode) -{ -#ifdef HAVE_CAPSICUM -	if (capsicum_enabled()) -		return capsicum_open(path, flags, mode); -#endif - -	return open(path, flags, mode); -} -  static char *log_filename(LOG_REC *log)  {  	char *str, fname[1024]; @@ -127,19 +115,12 @@ int log_start_logging(LOG_REC *log)  		/* path may contain variables (%time, $vars),  		   make sure the directory is created */  		dir = g_path_get_dirname(log->real_fname); -#ifdef HAVE_CAPSICUM -		if (capsicum_enabled()) -			capsicum_mkdir_with_parents(dir, log_dir_create_mode); -		else -			g_mkdir_with_parents(dir, log_dir_create_mode); -#else -		g_mkdir_with_parents(dir, log_dir_create_mode); -#endif +		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);  		g_free(dir);  	}    	log->handle = log->real_fname == NULL ? -1 : -		log_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT, +		capsicum_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,  		     log_file_create_mode);  	if (log->handle == -1) {  		signal_emit(\"log create failed\", 1, log); '),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','Add wrappers to reduce #ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','176','38','6','23','MODIFY','@@ -27,25 +27,13 @@  #include \"misc.h\"  #include \"write-buffer.h\"  #include \"settings.h\" -#ifdef HAVE_CAPSICUM  #include \"capsicum.h\" -#endif    #include \"servers.h\"    static int rawlog_lines;  static int signal_rawlog;   -static int rawlog_open_wrapper(const char *path, int flags, int mode) -{ -#ifdef HAVE_CAPSICUM -	if (capsicum_enabled()) -		return capsicum_open(path, flags, mode); -#endif - -	return open(path, flags, mode); -} -  RAWLOG_REC *rawlog_create(void)  {  	RAWLOG_REC *rec; @@ -139,8 +127,9 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)  		return;    	path = convert_home(fname); -	rawlog->handle = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT, -			      log_file_create_mode); +	rawlog->handle = capsicum_open_wrapper(path, +					       O_WRONLY | O_APPEND | O_CREAT, +					       log_file_create_mode);  	g_free(path);    	if (rawlog->handle == -1) { @@ -167,18 +156,12 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)  	int f;            dir = g_path_get_dirname(fname); -#ifdef HAVE_CAPSICUM -	if (capsicum_enabled()) -		capsicum_mkdir_with_parents(dir, log_dir_create_mode); -	else -		g_mkdir_with_parents(dir, log_dir_create_mode); -#else -	g_mkdir_with_parents(dir, log_dir_create_mode); -#endif +	capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);          g_free(dir);    	path = convert_home(fname); -	f = rawlog_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode); +	f = capsicum_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT, +				  log_file_create_mode);  	g_free(path);    	if (f < 0) { '),('irssi','1.0.4','12e2c46d6a778f131c1ca6a7134af1cd5e722dbe','Edward Tomasz Napierala','Add wrappers to reduce #ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-log.c','584','148','1','10','MODIFY','@@ -30,9 +30,7 @@  #include \"special-vars.h\"  #include \"settings.h\"  #include \"lib-config/iconfig.h\" -#ifdef HAVE_CAPSICUM  #include \"capsicum.h\" -#endif    #include \"fe-windows.h\"  #include \"window-items.h\" @@ -454,14 +452,7 @@ static void autolog_open(SERVER_REC *server, const char *server_tag,  		log_item_add(log, LOG_ITEM_TARGET, target, server_tag);    		dir = g_path_get_dirname(log->real_fname); -#ifdef HAVE_CAPSICUM -		if (capsicum_enabled()) -			capsicum_mkdir_with_parents(dir, log_dir_create_mode); -		else -			g_mkdir_with_parents(dir, log_dir_create_mode); -#else -		g_mkdir_with_parents(dir, log_dir_create_mode); -#endif +		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);  		g_free(dir);    		log->temp = TRUE; '),('irssi','1.0.4','8c04c2be14fc053bd7b5ff03b8e4ba8cb5023700','Edward Tomasz Napierala','Fix build without Capsicum.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','core.c','224','26','4','0','MODIFY','@@ -236,7 +236,9 @@ void core_init(void)  	commands_init();  	nickmatch_cache_init();          session_init(); +#ifdef HAVE_CAPSICUM  	capsicum_init(); +#endif    	chat_protocols_init();  	chatnets_init(); @@ -294,7 +296,9 @@ void core_deinit(void)  	chatnets_deinit();  	chat_protocols_deinit();   +#ifdef HAVE_CAPSICUM  	capsicum_deinit(); +#endif          session_deinit();          nickmatch_cache_deinit();  	commands_deinit(); '),('irssi','1.0.4','8c04c2be14fc053bd7b5ff03b8e4ba8cb5023700','Edward Tomasz Napierala','Fix build without Capsicum.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-common-core.c','377','54','4','0','MODIFY','@@ -180,7 +180,9 @@ void fe_common_core_init(void)  	fe_server_init();  	fe_settings_init();  	fe_tls_init(); +#ifdef HAVE_CAPSICUM  	fe_capsicum_init(); +#endif  	windows_init();  	window_activity_init();  	window_commands_init(); @@ -223,7 +225,9 @@ void fe_common_core_deinit(void)  	fe_server_deinit();  	fe_settings_deinit();  	fe_tls_deinit(); +#ifdef HAVE_CAPSICUM  	fe_capsicum_deinit(); +#endif  	windows_deinit();  	window_activity_deinit();  	window_commands_deinit(); '),('irssi','1.0.4','7f2697d30744d1f33cf67430aa48013b8f4ae9cd','Edward Tomasz Napierala','Cosmetics.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.h','44','0','0','2','MODIFY','@@ -38,8 +38,6 @@ extern GSList *logs;  extern int log_file_create_mode;  extern int log_dir_create_mode;   -extern int log_dir_create_mode; -  /* Create log record - you still need to call log_update() to actually add it     into log list */  LOG_REC *log_create_rec(const char *fname, int level); '),('irssi','1.0.4','7f2697d30744d1f33cf67430aa48013b8f4ae9cd','Edward Tomasz Napierala','Cosmetics.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','176','38','1','1','MODIFY','@@ -156,7 +156,7 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)  	int f;            dir = g_path_get_dirname(fname); -	capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode); +        capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode);          g_free(dir);    	path = convert_home(fname); '),('irssi','1.0.4','a29eeaa9f2e85630b08fc46b3a2b8749b9719efd','Edward Tomasz Napierala','Fix trailing slash handling for capsicum_irclogs_path.  This is mostly an anti-footshooting measure, but still.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','331','68','10','1','MODIFY','@@ -147,6 +147,7 @@ int capsicum_open(const char *path, int flags, int mode)    	/* +1 is for the slash separating irclogs_path and the rest. */  	if (strlen(path) > irclogs_path_len + 1 && +	    path[irclogs_path_len] == \'/\' &&  	    strncmp(path, irclogs_path, irclogs_path_len) == 0) {  		fd = openat(irclogs_fd, path + irclogs_path_len + 1,  		    flags, mode); @@ -176,6 +177,7 @@ void capsicum_mkdir_with_parents(const char *path, int mode)    	/* +1 is for the slash separating irclogs_path and the rest. */  	if (strlen(path) <= irclogs_path_len + 1 || +	    path[irclogs_path_len] != \'/\' ||  	    strncmp(path, irclogs_path, irclogs_path_len) != 0) {  		g_warning(\"Cannot create %s: file system access restricted \"  		    \"to %s due to capability mode\", path, irclogs_path); @@ -366,8 +368,15 @@ static void cmd_capsicum_enter(void)  	port_max = settings_get_int(\"capsicum_port_max\");    	irclogs_path = convert_home(settings_get_str(\"capsicum_irclogs_path\")); -	g_mkdir_with_parents(irclogs_path, log_dir_create_mode);  	irclogs_path_len = strlen(irclogs_path); + +	/* Strip trailing slashes, if any. */ +	while (irclogs_path_len > 0 && irclogs_path[irclogs_path_len - 1] == \'/\') { +		irclogs_path[irclogs_path_len - 1] = \'\\0\'; +		irclogs_path_len--; +	} + +	g_mkdir_with_parents(irclogs_path, log_dir_create_mode);  	irclogs_fd = open(irclogs_path, O_DIRECTORY | O_CLOEXEC);  	if (irclogs_fd < 0) {  		g_warning(\"Unable to open %s: %s\", irclogs_path, strerror(errno)); '),('irssi','1.0.4','8bb392a3f47d74cccb9e2d7e3633e3e534306968','Edward Tomasz Napierala','Hook up capsicum.h and fe-capsicum.h to autotools.  This hopefully fixes Travis build.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','Makefile.am','111','0','1','0','MODIFY','@@ -74,6 +74,7 @@ structure_headers = \\  pkginc_coredir=$(pkgincludedir)/src/core  pkginc_core_HEADERS = \\  	args.h \\ +	capsicum.h \\  	channels.h \\  	channels-setup.h \\  	commands.h \\ '),('irssi','1.0.4','8bb392a3f47d74cccb9e2d7e3633e3e534306968','Edward Tomasz Napierala','Hook up capsicum.h and fe-capsicum.h to autotools.  This hopefully fixes Travis build.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','Makefile.am','66','0','1','0','MODIFY','@@ -48,6 +48,7 @@ pkginc_fe_common_core_HEADERS = \\  	command-history.h \\  	chat-completion.h \\  	completion.h \\ +	fe-capsicum.h \\  	fe-channels.h \\  	fe-common-core.h \\  	fe-core-commands.h \\ '),('irssi','1.0.4','5551b4fe9504f5d5b4e81a680741cab72bec82e9','Edward Tomasz Napierala','Update copyrights.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','331','68','4','0','MODIFY','@@ -3,6 +3,10 @@        Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org>   +    This software was developed by SRI International and the University of +    Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237 +    (\"CTSRD\"), as part of the DARPA CRASH research programme. +      This program is free software; you can redistribute it and/or modify      it under the terms of the GNU General Public License as published by      the Free Software Foundation; either version 2 of the License, or '),('irssi','1.0.4','5551b4fe9504f5d5b4e81a680741cab72bec82e9','Edward Tomasz Napierala','Update copyrights.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-capsicum.c','30','5','4','0','MODIFY','@@ -3,6 +3,10 @@        Copyright (C) 2017 Edward Tomasz Napierala <trasz@FreeBSD.org>   +    This software was developed by SRI International and the University of +    Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237 +    (\"CTSRD\"), as part of the DARPA CRASH research programme. +      This program is free software; you can redistribute it and/or modify      it under the terms of the GNU General Public License as published by      the Free Software Foundation; either version 2 of the License, or '),('irssi','1.0.4','aeaa420ad330a528391ed149371b55581a808655','Edward Tomasz Napierala','Clean up includes a bit.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','332','68','1','0','MODIFY','@@ -23,6 +23,7 @@  */    #include \"module.h\" +#include \"capsicum.h\"  #include \"commands.h\"  #include \"log.h\"  #include \"misc.h\" '),('irssi','1.0.4','aeaa420ad330a528391ed149371b55581a808655','Edward Tomasz Napierala','Clean up includes a bit.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-capsicum.c','30','5','3','4','MODIFY','@@ -23,12 +23,11 @@  */    #include \"module.h\" +#include \"fe-capsicum.h\" +#include \"levels.h\"  #include \"module-formats.h\" -#include \"signals.h\"  #include \"printtext.h\" - -#include \"levels.h\" -#include \"servers.h\" +#include \"signals.h\"    static void capability_mode_enabled(void)  { '),('irssi','1.0.4','96f4fe10c6081cf441122039c39eb6422eef13e8','Edward Tomasz Napierala','Change the way we load default CA certificates so it works with Capsicum.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','339','69','8','0','MODIFY','@@ -28,6 +28,7 @@  #include \"log.h\"  #include \"misc.h\"  #include \"network.h\" +#include \"network-openssl.h\"  #include \"settings.h\"  #include \"signals.h\"   @@ -361,6 +362,7 @@ static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)  static void cmd_capsicum_enter(void)  {  	u_int mode; +	gboolean inited;  	int error;    	error = cap_getmode(&mode); @@ -369,6 +371,12 @@ static void cmd_capsicum_enter(void)  		return;  	}   +	inited = irssi_ssl_init(); +	if (!inited) { +		signal_emit(\"capability mode failed\", 1, strerror(errno)); +		return; +	} +  	port_min = settings_get_int(\"capsicum_port_min\");  	port_max = settings_get_int(\"capsicum_port_max\");   '),('irssi','1.0.4','96f4fe10c6081cf441122039c39eb6422eef13e8','Edward Tomasz Napierala','Change the way we load default CA certificates so it works with Capsicum.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','network-openssl.c','672','144','20','3','MODIFY','@@ -20,6 +20,7 @@    #include \"module.h\"  #include \"network.h\" +#include \"network-openssl.h\"  #include \"net-sendbuffer.h\"  #include \"misc.h\"  #include \"servers.h\" @@ -58,6 +59,7 @@ typedef struct  } GIOSSLChannel;    static int ssl_inited = FALSE; +static X509_STORE *store = NULL;    static void irssi_ssl_free(GIOChannel *handle)  { @@ -362,8 +364,10 @@ static GIOFuncs irssi_ssl_channel_funcs = {      irssi_ssl_get_flags  };   -static gboolean irssi_ssl_init(void) +gboolean irssi_ssl_init(void)  { +	int success; +  #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)  	if (!OPENSSL_init_ssl(OPENSSL_INIT_SSL_DEFAULT, NULL)) {  		g_error(\"Could not initialize OpenSSL\"); @@ -374,6 +378,20 @@ static gboolean irssi_ssl_init(void)  	SSL_load_error_strings();  	OpenSSL_add_all_algorithms();  #endif +	store = X509_STORE_new(); +	if (store == NULL) { +		g_error(\"Could not initialize OpenSSL: X509_STORE_new() failed\"); +		return FALSE; +	} + +	success = X509_STORE_set_default_paths(store); +	if (success == 0) { +		g_error(\"Could not load default certificates\"); +		X509_STORE_free(store); +		store = NULL; +		return FALSE; +	} +  	ssl_inited = TRUE;    	return TRUE; @@ -492,8 +510,7 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_  		g_free(scapath);  		verify = TRUE;  	} else { -		if (!SSL_CTX_set_default_verify_paths(ctx)) -			g_warning(\"Could not load default certificates\"); +		SSL_CTX_set_cert_store(ctx, store);  	}    	if(!(ssl = SSL_new(ctx))) '),('irssi','1.0.4','96f4fe10c6081cf441122039c39eb6422eef13e8','Edward Tomasz Napierala','Change the way we load default CA certificates so it works with Capsicum.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','network-openssl.h','1','0','6','0','ADD','@@ -0,0 +1,6 @@ +#ifndef __NETWORK_OPENSSL_H +#define __NETWORK_OPENSSL_H + +gboolean irssi_ssl_init(void); + +#endif /* !__NETWORK_OPENSSL_H */ '),('irssi','1.0.4','5db6caee0d17eb125d8c7f3090c325ffbee35920','Edward Tomasz Napierala','Attempt to fix build by adding the forgotten header.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','Makefile.am','112','0','1','0','MODIFY','@@ -95,6 +95,7 @@ pkginc_core_HEADERS = \\  	net-nonblock.h \\  	net-sendbuffer.h \\  	network.h \\ +	network-openssl.h \\  	nick-rec.h \\  	nicklist.h \\  	nickmatch-cache.h \\ '),('irssi','1.0.4','788e47032f9f6b7eea188a1a6e7fc1a19531c1b0','Paul Townsend','Update /CONNECT and /SERVER syntax tags (-ssl -> -tls).','chat-commands.c','384','117','7','7','MODIFY','@@ -149,9 +149,9 @@ static SERVER_CONNECT_REC *get_server_connect(const char *data, int *plus_addr,          return conn;  }   -/* SYNTAX: CONNECT [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>] [-ssl_pass <password>] -                   [-ssl_verify] [-ssl_cafile <cafile>] [-ssl_capath <capath>] -                   [-ssl_ciphers <list>] +/* SYNTAX: CONNECT [-4 | -6] [-tls] [-tls_cert <cert>] [-tls_pkey <pkey>] [-tls_pass <password>] +                   [-tls_verify] [-tls_cafile <cafile>] [-tls_capath <capath>] +                   [-tls_ciphers <list>] [-tls_pinned_cert <fingerprint>] [-tls_pinned_pubkey <fingerprint>]                     [-!] [-noautosendcmd]  		   [-noproxy] [-network <network>] [-host <hostname>]  		   [-rawlog <file>] @@ -250,10 +250,10 @@ static void cmd_server(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  	command_runsub(\"server\", data, server, item);  }   -/* SYNTAX: SERVER CONNECT [-4 | -6] [-ssl] [-ssl_cert <cert>] [-ssl_pkey <pkey>]  -		  [-ssl_pass <password>] [-ssl_verify] [-ssl_cafile <cafile>]  -		  [-ssl_capath <capath>] -		  [-ssl_ciphers <list>] +/* SYNTAX: SERVER CONNECT [-4 | -6] [-tls] [-tls_cert <cert>] [-tls_pkey <pkey>]  +		  [-tls_pass <password>] [-tls_verify] [-tls_cafile <cafile>]  +		  [-tls_capath <capath>] +		  [-tls_ciphers <list>] [-tls_pinned_cert <fingerprint>] [-tls_pinned_pubkey <fingerprint>]  		  [-!] [-noautosendcmd]  		  [-noproxy] [-network <network>] [-host <hostname>]  		  [-rawlog <file>] '),('irssi','1.0.4','947682e5dde85aa5e0277c01d7fb4afc1032ea04','ailin-nemui','Revert \"Merge pull request #452 from LemonBoy/terminfo-cup\"  Fixes #733. The fix outlined in #452 had adverse effects for the following reason. The code removed the restoration path that would go on the code path from kill SIGTSTP. The problem is this: When Irssi is not running in a controlling parent (like a shell), the TSTP will in fact be ignored. In that case, there is no process sending a CONT either and thus the screen state never gets restored. Luckily, the patch in #457 is sufficient to prevent the problem in #450 (which lead to the development of #452). To that end, we do end up with potentially calling terminfo_cont twice but that is better than not calling it at all.  This reverts commit b1ffd5f6472584aa3966746da9728c5afefcc4ce, reversing changes made to 9cb0419435d1ad331c1f55361a003d9682fae9a8.','term-terminfo.c','532','168','7','0','MODIFY','@@ -629,6 +629,13 @@ void term_stop(void)  {  	terminfo_stop(current_term);  	kill(getpid(), SIGTSTP); +	/* this call needs to stay here in case the TSTP was ignored, +	   because then we never see a CONT to call the restoration +	   code. On the other hand we also cannot remove the CONT +	   handler because then nothing would restore the screen when +	   Irssi is killed with TSTP/STOP from external. */ +	terminfo_cont(current_term); +	irssi_redraw();  }    static int input_utf8(const unsigned char *buffer, int size, unichar *result) '),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','Add back some ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.h','9','0','1','9','MODIFY','@@ -5,17 +5,9 @@ gboolean capsicum_enabled(void);  int capsicum_net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);  int capsicum_net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6);  int capsicum_open(const char *path, int flags, int mode); -void capsicum_mkdir_with_parents(const char *path, int mode); - -#ifdef HAVE_CAPSICUM  int capsicum_open_wrapper(const char *path, int flags, int mode); +void capsicum_mkdir_with_parents(const char *path, int mode);  void capsicum_mkdir_with_parents_wrapper(const char *path, int mode); -#else -#define	capsicum_open_wrapper(P, F, M)			\\ -	open(P, F, M) -#define	capsicum_mkdir_with_parents_wrapper(P, M)	\\ -	g_mkdir_with_parents(P, M) -#endif    void capsicum_init(void);  void capsicum_deinit(void); '),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','Add back some ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','core.c','224','26','2','0','MODIFY','@@ -29,7 +29,9 @@  #include \"signals.h\"  #include \"settings.h\"  #include \"session.h\" +#ifdef HAVE_CAPSICUM  #include \"capsicum.h\" +#endif    #include \"chat-protocols.h\"  #include \"servers.h\" '),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','Add back some ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','log.c','446','100','12','0','MODIFY','@@ -26,7 +26,9 @@  #include \"servers.h\"  #include \"log.h\"  #include \"write-buffer.h\" +#ifdef HAVE_CAPSICUM  #include \"capsicum.h\" +#endif    #include \"lib-config/iconfig.h\"  #include \"settings.h\" @@ -115,13 +117,23 @@ int log_start_logging(LOG_REC *log)  		/* path may contain variables (%time, $vars),  		   make sure the directory is created */  		dir = g_path_get_dirname(log->real_fname); +#ifdef HAVE_CAPSICUM  		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode); +#else +		g_mkdir_with_parents(dir, log_dir_create_mode); +#endif  		g_free(dir);  	}   +#ifdef HAVE_CAPSICUM  	log->handle = log->real_fname == NULL ? -1 :  		capsicum_open_wrapper(log->real_fname, O_WRONLY | O_APPEND | O_CREAT,  		     log_file_create_mode); +#else +	log->handle = log->real_fname == NULL ? -1 : +		open(log->real_fname, O_WRONLY | O_APPEND | O_CREAT, +		     log_file_create_mode); +#endif  	if (log->handle == -1) {  		signal_emit(\"log create failed\", 1, log);  		log->failed = TRUE; '),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','Add back some ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','rawlog.c','180','41','16','0','MODIFY','@@ -27,7 +27,9 @@  #include \"misc.h\"  #include \"write-buffer.h\"  #include \"settings.h\" +#ifdef HAVE_CAPSICUM  #include \"capsicum.h\" +#endif    #include \"servers.h\"   @@ -127,9 +129,15 @@ void rawlog_open(RAWLOG_REC *rawlog, const char *fname)  		return;    	path = convert_home(fname); +#ifdef HAVE_CAPSICUM  	rawlog->handle = capsicum_open_wrapper(path,  					       O_WRONLY | O_APPEND | O_CREAT,  					       log_file_create_mode); +#else +	rawlog->handle = open(path, O_WRONLY | O_APPEND | O_CREAT, +			      log_file_create_mode); +#endif +  	g_free(path);    	if (rawlog->handle == -1) { @@ -156,12 +164,20 @@ void rawlog_save(RAWLOG_REC *rawlog, const char *fname)  	int f;            dir = g_path_get_dirname(fname); +#ifdef HAVE_CAPSICUM          capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode); +#else +        g_mkdir_with_parents(dir, log_dir_create_mode); +#endif          g_free(dir);    	path = convert_home(fname); +#ifdef HAVE_CAPSICUM  	f = capsicum_open_wrapper(path, O_WRONLY | O_APPEND | O_CREAT,  				  log_file_create_mode); +#else +	f = open(path, O_WRONLY | O_APPEND | O_CREAT, log_file_create_mode); +#endif  	g_free(path);    	if (f < 0) { '),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','Add back some ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-common-core.c','377','54','2','0','MODIFY','@@ -32,7 +32,9 @@  #include \"special-vars.h\"  #include \"fe-core-commands.h\"  #include \"fe-queries.h\" +#ifdef HAVE_CAPSICUM  #include \"fe-capsicum.h\" +#endif  #include \"hilight-text.h\"  #include \"command-history.h\"  #include \"completion.h\" '),('irssi','1.0.4','0c49a84ffb8d74506a13653183bfa1ef8ffd2554','Edward Tomasz Napierala','Add back some ifdefs.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-log.c','585','149','6','0','MODIFY','@@ -30,7 +30,9 @@  #include \"special-vars.h\"  #include \"settings.h\"  #include \"lib-config/iconfig.h\" +#ifdef HAVE_CAPSICUM  #include \"capsicum.h\" +#endif    #include \"fe-windows.h\"  #include \"window-items.h\" @@ -452,7 +454,11 @@ static void autolog_open(SERVER_REC *server, const char *server_tag,  		log_item_add(log, LOG_ITEM_TARGET, target, server_tag);    		dir = g_path_get_dirname(log->real_fname); +#ifdef HAVE_CAPSICUM  		capsicum_mkdir_with_parents_wrapper(dir, log_dir_create_mode); +#else +		g_mkdir_with_parents(dir, log_dir_create_mode); +#endif  		g_free(dir);    		log->temp = TRUE; '),('irssi','1.0.4','4bcbb41113bf23b1d121ad6fbd7b86473f7fa89d','Edward Tomasz Napierala','Fix indentation; no functional changes.  (Take two.)  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','module-formats.h','240','0','25','25','MODIFY','@@ -12,21 +12,21 @@ enum {  	TXT_DAYCHANGE,  	TXT_TALKING_WITH,  	TXT_REFNUM_TOO_LOW, -        TXT_ERROR_SERVER_STICKY, -        TXT_SET_SERVER_STICKY, +	TXT_ERROR_SERVER_STICKY, +	TXT_SET_SERVER_STICKY,  	TXT_UNSET_SERVER_STICKY, -        TXT_WINDOW_NAME_NOT_UNIQUE, -        TXT_WINDOW_LEVEL, -        TXT_WINDOW_SET_IMMORTAL, -        TXT_WINDOW_UNSET_IMMORTAL, -        TXT_WINDOW_IMMORTAL_ERROR, +	TXT_WINDOW_NAME_NOT_UNIQUE, +	TXT_WINDOW_LEVEL, +	TXT_WINDOW_SET_IMMORTAL, +	TXT_WINDOW_UNSET_IMMORTAL, +	TXT_WINDOW_IMMORTAL_ERROR,  	TXT_WINDOWLIST_HEADER,  	TXT_WINDOWLIST_LINE,  	TXT_WINDOWLIST_FOOTER,  	TXT_WINDOWS_LAYOUT_SAVED,  	TXT_WINDOWS_LAYOUT_RESET, -        TXT_WINDOW_INFO_HEADER, -        TXT_WINDOW_INFO_FOOTER, +	TXT_WINDOW_INFO_HEADER, +	TXT_WINDOW_INFO_FOOTER,  	TXT_WINDOW_INFO_REFNUM,  	TXT_WINDOW_INFO_REFNUM_STICKY,  	TXT_WINDOW_INFO_NAME, @@ -34,22 +34,22 @@ enum {  	TXT_WINDOW_INFO_IMMORTAL,  	TXT_WINDOW_INFO_SIZE,  	TXT_WINDOW_INFO_LEVEL, -        TXT_WINDOW_INFO_SERVER, +	TXT_WINDOW_INFO_SERVER,  	TXT_WINDOW_INFO_SERVER_STICKY, -        TXT_WINDOW_INFO_THEME, +	TXT_WINDOW_INFO_THEME,  	TXT_WINDOW_INFO_BOUND_ITEMS_HEADER,  	TXT_WINDOW_INFO_BOUND_ITEM,  	TXT_WINDOW_INFO_BOUND_ITEMS_FOOTER,  	TXT_WINDOW_INFO_ITEMS_HEADER,  	TXT_WINDOW_INFO_ITEM, -        TXT_WINDOW_INFO_ITEMS_FOOTER, +	TXT_WINDOW_INFO_ITEMS_FOOTER,    	TXT_FILL_2,    	TXT_LOOKING_UP,  	TXT_CONNECTING, - 	TXT_RECONNECTING, -        TXT_CONNECTION_ESTABLISHED, +	TXT_RECONNECTING, +	TXT_CONNECTION_ESTABLISHED,  	TXT_CANT_CONNECT,  	TXT_CONNECTION_LOST,  	TXT_LAG_DISCONNECTED, @@ -100,7 +100,7 @@ enum {  	TXT_CHANSETUP_LINE,  	TXT_CHANSETUP_FOOTER,   -        TXT_FILL_4, +	TXT_FILL_4,    	TXT_OWN_MSG,  	TXT_OWN_MSG_CHANNEL, @@ -162,7 +162,7 @@ enum {    	TXT_MODULE_HEADER,  	TXT_MODULE_LINE, -        TXT_MODULE_FOOTER, +	TXT_MODULE_FOOTER,  	TXT_MODULE_ALREADY_LOADED,  	TXT_MODULE_NOT_LOADED,  	TXT_MODULE_LOAD_ERROR, @@ -183,7 +183,7 @@ enum {  	TXT_NOT_JOINED,  	TXT_CHAN_NOT_FOUND,  	TXT_CHAN_NOT_SYNCED, -        TXT_ILLEGAL_PROTO, +	TXT_ILLEGAL_PROTO,  	TXT_NOT_GOOD_IDEA,  	TXT_INVALID_NUMBER,  	TXT_INVALID_TIME, @@ -232,8 +232,8 @@ enum {    	TXT_FILL_14,   -        TXT_UNKNOWN_CHAT_PROTOCOL, -        TXT_UNKNOWN_CHATNET, +	TXT_UNKNOWN_CHAT_PROTOCOL, +	TXT_UNKNOWN_CHATNET,  	TXT_NOT_TOGGLE,  	TXT_PERL_ERROR,  	TXT_BIND_HEADER, @@ -245,15 +245,15 @@ enum {  	TXT_CONFIG_RELOADED,  	TXT_CONFIG_MODIFIED,  	TXT_GLIB_ERROR, -        TXT_OVERWRITE_CONFIG, -        TXT_SET_TITLE, -        TXT_SET_ITEM, -        TXT_SET_UNKNOWN, +	TXT_OVERWRITE_CONFIG, +	TXT_SET_TITLE, +	TXT_SET_ITEM, +	TXT_SET_UNKNOWN,  	TXT_SET_NOT_BOOLEAN,  	TXT_NO_COMPLETIONS, -        TXT_COMPLETION_REMOVED, +	TXT_COMPLETION_REMOVED,  	TXT_COMPLETION_HEADER, -        TXT_COMPLETION_LINE, +	TXT_COMPLETION_LINE,  	TXT_COMPLETION_FOOTER,    	TLS_FILL_15, '),('irssi','1.0.4','edee0ba587069a860eac43f9219f8ecfa49fe1fa','Edward Tomasz Napierala','Don\'t error out on failure to load default certificate store.  This restores the previous behaviour.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','network-openssl.c','671','145','3','3','MODIFY','@@ -386,10 +386,10 @@ gboolean irssi_ssl_init(void)    	success = X509_STORE_set_default_paths(store);  	if (success == 0) { -		g_error(\"Could not load default certificates\"); +		g_warning(\"Could not load default certificates\");  		X509_STORE_free(store);  		store = NULL; -		return FALSE; +		/* Don\'t return an error; the user might have their own cafile/capath. */  	}    	ssl_inited = TRUE; @@ -509,7 +509,7 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_  		g_free(scafile);  		g_free(scapath);  		verify = TRUE; -	} else { +	} else if (store != NULL) {  		SSL_CTX_set_cert_store(ctx, store);  	}   '),('irssi','1.0.4','245a3fd4c1afb86b38eb17477a42c60c52cef793','Edward Tomasz Napierala','Add docs/capsicum.txt.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','Makefile.am','15','0','1','0','MODIFY','@@ -2,6 +2,7 @@ man_MANS = \\  	irssi.1    doc_DATA = \\ +	capsicum.txt \\  	design.txt \\  	formats.txt \\  	manual.txt \\ '),('irssi','1.0.4','245a3fd4c1afb86b38eb17477a42c60c52cef793','Edward Tomasz Napierala','Add docs/capsicum.txt.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.txt','24','0','30','0','ADD','@@ -0,0 +1,30 @@ +Capsicum is a lightweight OS capability and sandbox framework provided +by FreeBSD.  When built with Capsicum support - which is the default under +FreeBSD - Irssi can enter a Capsicum capability mode (a sandbox), greatly +limiting possible consequences of a potential security hole in Irssi +or the libraries it depends on. + +To make Irssi enter capability mode on startup, add + +capsicum = \"yes\"; + +to your ~/.irssi/config and restart the client.  Alternatively you can +enter it \"by hand\", using the \"/capsicum enter\" command.  From the security +point of view it\'s strongly preferable to use the former method, to avoid +establishing connections without the sandbox protection; the \"/capsicum\" +command is only intended for experimentation, and in cases where you need +to do something that\'s not possible in capability mode - run scripts, +for example - before continuing. + +There is no way to leave the capability mode, apart from exiting Irssi. +When running in capability mode, there are certain restrictions - Irssi +won\'t be able to access any files outside the directory pointed to by +capsicum_irclogs_path (which defaults to ~/irclogs/).  If you change +the path when already in capability mode it won\'t be effective until +you restart Irssi.  Capability mode also makes it impossible to use +the \"/save\" command. + +Currently there is no way to use custom SSL certificates.  As a workaround +you can establish connections and enter the capability mode afterwards +using the \"/capsicum enter\" command. + '),('irssi','1.0.4','7086eae650a616615bc81e688cdfa44d444463e0','LemonBoy','Complete filenames ending with a slash','completion.c','653','185','12','1','MODIFY','@@ -321,6 +321,10 @@ GList *filename_complete(const char *path, const char *default_path)    	g_return_val_if_fail(path != NULL, NULL);   +	if (path[0] == \'\\0\') { +	    return NULL; +	} +  	list = NULL;    	/* get directory part of the path - expand ~/ */ @@ -350,7 +354,14 @@ GList *filename_complete(const char *path, const char *default_path)  		g_free_and_null(dir);  	}   -	basename = g_path_get_basename(path); +	len = strlen(path); +	/* g_path_get_basename() returns the component before the last slash if +	 * the path ends with a directory separator, that\'s not what we want */ +	if (len > 0 && path[len - 1] == G_DIR_SEPARATOR) { +	    basename = g_strdup(\"\"); +	} else { +	    basename = g_path_get_basename(path); +	}  	len = strlen(basename);    	/* add all files in directory to completion list */ '),('irssi','1.0.4','b529e1a9df134bbc5618752abcf19af0110b6868','Edward Tomasz Napierala','Fix /back in Capsicum capability mode.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','fe-core-commands.c','255','53','14','0','MODIFY','@@ -28,6 +28,9 @@  #include \"settings.h\"  #include \"irssi-version.h\"  #include \"servers.h\" +#ifdef HAVE_CAPSICUM +#include \"capsicum.h\" +#endif    #include \"fe-windows.h\"  #include \"printtext.h\" @@ -120,6 +123,9 @@ static void cmd_cat(const char *data)  	GIOChannel *handle;  	GString *buf;  	gsize tpos; +#ifdef HAVE_CAPSICUM +	int fd; +#endif    	if (!cmd_get_params(data, &free_arg, 2, &fname, &fposstr))  		return; @@ -128,7 +134,15 @@ static void cmd_cat(const char *data)  	fpos = atoi(fposstr);          cmd_params_free(free_arg);   +#ifdef HAVE_CAPSICUM +	fd = capsicum_open_wrapper(fname, O_RDONLY, 0); +	if (fd > 0) +		handle = g_io_channel_unix_new(fd); +	else +		handle = NULL; +#else  	handle = g_io_channel_new_file(fname, \"r\", NULL); +#endif  	g_free(fname);    	if (handle == NULL) { '),('irssi','1.0.4','96d5a4669d696d57a511119963ae5c651346e167','LemonBoy','Increment the X509_STORE refcount during the connection  OpenSSL doesn\'t increment the reference count when the store is assigned to a SSL_CTX.','network-openssl.c','672','145','4','0','MODIFY','@@ -510,6 +510,10 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, int port, SERVER_  		g_free(scapath);  		verify = TRUE;  	} else if (store != NULL) { +		/* Make sure to increment the refcount every time the store is +		 * used, that\'s essential not to get it free\'d by OpenSSL when +		 * the SSL_CTX is destroyed. */ +		X509_STORE_up_ref(store);  		SSL_CTX_set_cert_store(ctx, store);  	}   '),('irssi','1.0.4','36d8b974fc42ed8eb1ff88811e09d0910ae61187','LemonBoy','Restore compatibility with old OpenSSL versions  Let\'s implement X509_STORE_up_ref on our own.','network-openssl.c','679','147','13','0','MODIFY','@@ -45,6 +45,19 @@  #define ASN1_STRING_data(x)       ASN1_STRING_get0_data(x)  #endif   +/* OpenSSL 1.1.0 also introduced some useful additions to the api */ +#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined (LIBRESSL_VERSION_NUMBER) +static int X509_STORE_up_ref(X509_STORE *vfy) +{ +    int n; + +    n = CRYPTO_add(&vfy->references, 1, CRYPTO_LOCK_X509_STORE); +    g_assert(n > 1); + +    return (n > 1) ? 1 : 0; +} +#endif +  /* ssl i/o channel object */  typedef struct  { '),('irssi','1.0.4','624ef4a696fc736779c6b7af94c7e376b7033590','Edward Tomasz Napierala','Get rid of the zombies in Capsicum capability mode.  Signed-off-by: Edward Tomasz Napierala <trasz@FreeBSD.org>','capsicum.c','340','69','7','0','MODIFY','@@ -403,6 +403,13 @@ static void cmd_capsicum_enter(void)  		return;  	}   +	/* +	 * XXX: We should use pdwait(2) to wait for children.  Unfortunately +	 *      it\'s not implemented yet.  Thus the workaround, to get rid +	 *      of the zombies at least. +	 */ +	signal(SIGCHLD, SIG_IGN); +  	error = cap_enter();  	if (error != 0) {  		signal_emit(\"capability mode failed\", 1, strerror(errno)); '),('irssi','1.0.4','0468c5d912fc8a89bd552611ef6243bd1c889df7','ailin-nemui','add new function to set the position in bytes  fixes #752','gui-entry.c','799','249','20','0','MODIFY','@@ -936,6 +936,26 @@ void gui_entry_set_pos(GUI_ENTRY_REC *entry, int pos)  	gui_entry_draw(entry);  }   +void gui_entry_set_text_and_pos_bytes(GUI_ENTRY_REC *entry, const char *str, int pos_bytes) +{ +	int pos; +	const char *ptr; + +	g_return_if_fail(entry != NULL); + +	gui_entry_set_text(entry, str); + +	if (entry->utf8) { +		g_utf8_validate(str, pos_bytes, &ptr); +		pos = g_utf8_pointer_to_offset(str, ptr); +	} else if (term_type == TERM_TYPE_BIG5) +		pos = strlen_big5((const unsigned char *)str) - strlen_big5((const unsigned char *)(str + pos_bytes)); +	else +		pos = pos_bytes; + +	gui_entry_set_pos(entry, pos); +} +  void gui_entry_move_pos(GUI_ENTRY_REC *entry, int pos)  {          g_return_if_fail(entry != NULL); '),('irssi','1.0.4','0468c5d912fc8a89bd552611ef6243bd1c889df7','ailin-nemui','add new function to set the position in bytes  fixes #752','gui-entry.h','56','0','1','0','MODIFY','@@ -50,6 +50,7 @@ void gui_entry_set_utf8(GUI_ENTRY_REC *entry, int utf8);  void gui_entry_set_text(GUI_ENTRY_REC *entry, const char *str);  char *gui_entry_get_text(GUI_ENTRY_REC *entry);  char *gui_entry_get_text_and_pos(GUI_ENTRY_REC *entry, int *pos); +void gui_entry_set_text_and_pos_bytes(GUI_ENTRY_REC *entry, const char *str, int pos_bytes);    void gui_entry_insert_text(GUI_ENTRY_REC *entry, const char *str);  void gui_entry_insert_char(GUI_ENTRY_REC *entry, unichar chr); '),('irssi','1.0.4','0468c5d912fc8a89bd552611ef6243bd1c889df7','ailin-nemui','add new function to set the position in bytes  fixes #752','gui-readline.c','1029','208','2','4','MODIFY','@@ -878,8 +878,7 @@ static void key_completion(int erase, int backward)  	g_free(text);    	if (line != NULL) { -		gui_entry_set_text(active_entry, line); -		gui_entry_set_pos(active_entry, pos); +		gui_entry_set_text_and_pos_bytes(active_entry, line, pos);  		g_free(line);  	}  } @@ -909,8 +908,7 @@ static void key_check_replaces(void)  	g_free(text);    	if (line != NULL) { -		gui_entry_set_text(active_entry, line); -		gui_entry_set_pos(active_entry, pos); +		gui_entry_set_text_and_pos_bytes(active_entry, line, pos);  		g_free(line);  	}  } '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 10 +#define IRSSI_ABI_VERSION 11    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','levels.c','132','39','11','10','MODIFY','@@ -21,6 +21,7 @@  #include \"module.h\"  #include \"levels.h\"   +/* the order of these levels must match the bits in levels.h */  static const char *levels[] = {  	\"CRAP\",  	\"MSGS\", @@ -44,9 +45,6 @@ static const char *levels[] = {  	\"CLIENTCRAP\",  	\"CLIENTERRORS\",  	\"HILIGHTS\", - -	\"NOHILIGHT\", -	\"NO_ACT\",  	NULL  };   @@ -63,6 +61,9 @@ int level_get(const char *level)  	if (g_ascii_strcasecmp(level, \"NO_ACT\") == 0)  		return MSGLEVEL_NO_ACT;   +	if (g_ascii_strcasecmp(level, \"HIDDEN\") == 0) +		return MSGLEVEL_HIDDEN; +  	len = strlen(level);  	if (len == 0) return 0;   @@ -138,17 +139,13 @@ char *bits2level(int bits)      	str = g_string_new(NULL); -	if (bits & MSGLEVEL_NEVER) { +	if (bits & MSGLEVEL_NEVER)  		g_string_append(str, \"NEVER \"); -		bits &= ~MSGLEVEL_NEVER; -	}   -	if (bits & MSGLEVEL_NO_ACT) { +	if (bits & MSGLEVEL_NO_ACT)  		g_string_append(str, \"NO_ACT \"); -		bits &= ~MSGLEVEL_NO_ACT; -	}   -	if (bits == MSGLEVEL_ALL) { +	if ((bits & MSGLEVEL_ALL) == MSGLEVEL_ALL) {  		g_string_append(str, \"ALL \");  	} else {  		for (n = 0; levels[n] != NULL; n++) { @@ -156,6 +153,10 @@ char *bits2level(int bits)  				g_string_append_printf(str, \"%s \", levels[n]);  		}  	} + +	if (bits & MSGLEVEL_HIDDEN) +		g_string_append(str, \"HIDDEN \"); +          if (str->len > 0)  		g_string_truncate(str, str->len-1);   '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','levels.h','34','0','3','1','MODIFY','@@ -36,7 +36,9 @@ enum {  	MSGLEVEL_NOHILIGHT    = 0x1000000, /* Don\'t highlight this message */  	MSGLEVEL_NO_ACT       = 0x2000000, /* Don\'t trigger channel activity */  	MSGLEVEL_NEVER        = 0x4000000, /* never ignore / never log */ -	MSGLEVEL_LASTLOG      = 0x8000000 /* never ignore / never log */ +	MSGLEVEL_LASTLOG      = 0x8000000, /* used for /lastlog */ + +	MSGLEVEL_HIDDEN       = 0x10000000 /* Hidden from view */  };    int level_get(const char *level); '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','gui-windows.c','221','51','4','0','MODIFY','@@ -23,6 +23,7 @@  #include \"misc.h\"  #include \"settings.h\"  #include \"special-vars.h\" +#include \"levels.h\"    #include \"term.h\"  #include \"gui-entry.h\" @@ -50,6 +51,7 @@ static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,  					   !settings_get_bool(\"indent_always\"),  					   get_default_indent_func());  	textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\")); +	textbuffer_view_set_hidden_level(gui->view, MSGLEVEL_HIDDEN);  	if (parent->active == window)  		textbuffer_view_set_window(gui->view, parent->screen_win);  	return gui; @@ -204,6 +206,8 @@ void gui_windows_reset_settings(void)  		WINDOW_REC *rec = tmp->data;  		GUI_WINDOW_REC *gui = WINDOW_GUI(rec);   +		textbuffer_view_set_hidden_level(gui->view, MSGLEVEL_HIDDEN); +  		textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));    		textbuffer_view_set_default_indent(gui->view, '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','mainwindows-layout.c','167','38','10','0','MODIFY','@@ -23,6 +23,7 @@  #include \"misc.h\"  #include \"lib-config/iconfig.h\"  #include \"settings.h\" +#include \"levels.h\"    #include \"mainwindows.h\"  #include \"gui-windows.h\" @@ -41,6 +42,12 @@ static void sig_layout_window_save(WINDOW_REC *window, CONFIG_NODE *node)  			iconfig_node_set_int(node, \"parent\", active->refnum);  	}   +	if (gui->view->hidden_level != MSGLEVEL_HIDDEN) { +		char *level = bits2level(gui->view->hidden_level); +		iconfig_node_set_str(node, \"hidelevel\", level); +		g_free(level); +	} +  	if (gui->use_scroll)                  iconfig_node_set_bool(node, \"scroll\", gui->scroll);  } @@ -58,6 +65,9 @@ static void sig_layout_window_restore(WINDOW_REC *window, CONFIG_NODE *node)    	if (config_node_get_bool(node, \"sticky\", FALSE))  		gui_window_set_sticky(window); + +	textbuffer_view_set_hidden_level(gui->view, level2bits(config_node_get_str(node, \"hidelevel\", \"HIDDEN\"), NULL)); +  	if (config_node_get_str(node, \"scroll\", NULL) != NULL) {  		gui->use_scroll = TRUE;  		gui->scroll = config_node_get_bool(node, \"scroll\", TRUE); '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','module-formats.c','49','0','1','0','MODIFY','@@ -50,6 +50,7 @@ FORMAT_REC gui_text_formats[] =  	{ \"window_info_scroll\", \"%#Scroll  : $0\", 1, { 0 } },  	{ \"window_scroll\", \"Window scroll mode is now $0\", 1, { 0 } },  	{ \"window_scroll_unknown\", \"Unknown scroll mode $0, must be ON, OFF or DEFAULT\", 1, { 0 } }, +	{ \"window_hidelevel\", \"Window hidden level is now $0\", 1, { 0 } },    	/* ---- */  	{ NULL, \"Statusbars\", 0 }, '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','module-formats.h','48','0','1','0','MODIFY','@@ -26,6 +26,7 @@ enum {          TXT_WINDOW_INFO_SCROLL,          TXT_WINDOW_SCROLL,          TXT_WINDOW_SCROLL_UNKNOWN, +	TXT_WINDOW_HIDELEVEL,    	TXT_FILL_3,   '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer-commands.c','300','68','21','0','MODIFY','@@ -89,6 +89,25 @@ static void cmd_window_scroll(const char *data)  				   gui->scroll : settings_get_bool(\"scroll\"));  }   +/* SYNTAX: WINDOW HIDELEVEL [<level>] */ +static void cmd_window_hidelevel(const char *data) +{ +	GUI_WINDOW_REC *gui; +	char *level; + +	g_return_if_fail(data != NULL); + +	gui = WINDOW_GUI(active_win); +	textbuffer_view_set_hidden_level(gui->view, +					 combine_level(gui->view->hidden_level, data)); +	textbuffer_view_redraw(gui->view); +	level = gui->view->hidden_level == 0 ? g_strdup(\"NONE\") : +		bits2level(gui->view->hidden_level); +	printformat_window(active_win, MSGLEVEL_CLIENTNOTICE, +			   TXT_WINDOW_HIDELEVEL, level); +	g_free(level); +} +  static void cmd_scrollback(const char *data, SERVER_REC *server,  			   WI_ITEM_REC *item)  { @@ -358,6 +377,7 @@ void textbuffer_commands_init(void)  {  	command_bind(\"clear\", NULL, (SIGNAL_FUNC) cmd_clear);  	command_bind(\"window scroll\", NULL, (SIGNAL_FUNC) cmd_window_scroll); +	command_bind(\"window hidelevel\", NULL, (SIGNAL_FUNC) cmd_window_hidelevel);  	command_bind(\"scrollback\", NULL, (SIGNAL_FUNC) cmd_scrollback);  	command_bind(\"scrollback clear\", NULL, (SIGNAL_FUNC) cmd_scrollback_clear);  	command_bind(\"scrollback levelclear\", NULL, (SIGNAL_FUNC) cmd_scrollback_levelclear); @@ -377,6 +397,7 @@ void textbuffer_commands_deinit(void)  {  	command_unbind(\"clear\", (SIGNAL_FUNC) cmd_clear);  	command_unbind(\"window scroll\", (SIGNAL_FUNC) cmd_window_scroll); +	command_unbind(\"window hidelevel\", (SIGNAL_FUNC) cmd_window_hidelevel);  	command_unbind(\"scrollback\", (SIGNAL_FUNC) cmd_scrollback);  	command_unbind(\"scrollback clear\", (SIGNAL_FUNC) cmd_scrollback_clear);  	command_unbind(\"scrollback levelclear\", (SIGNAL_FUNC) cmd_scrollback_levelclear); '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer-view.c','1073','264','61','6','MODIFY','@@ -41,9 +41,15 @@ static GSList *views;  #define view_is_bottom(view) \\          ((view)->ypos >= -1 && (view)->ypos < (view)->height)   -#define view_get_linecount(view, line) \\ +#define view_get_linecount_hidden(view, line) \\          textbuffer_view_get_line_cache(view, line)->count   +#define view_line_is_hidden(view, line) \\ +	(((line)->info.level & (view)->hidden_level) != 0) + +#define view_get_linecount(view, line) \\ +	(view_line_is_hidden(view, line) ? 0 : view_get_linecount_hidden(view, line)) +  static GSList *textbuffer_get_views(TEXT_BUFFER_REC *buffer)  {  	GSList *tmp, *list; @@ -552,6 +558,9 @@ static void textbuffer_view_init_bottom(TEXT_BUFFER_VIEW_REC *view)  	total = 0;          line = textbuffer_line_last(view->buffer);  	for (; line != NULL; line = line->prev) { +		if (view_line_is_hidden(view, line)) +			continue; +  		linecount = view_get_linecount(view, line);  		if (line == view->bottom_startline) {  			/* keep the old one, make sure that subline is ok */ @@ -614,6 +623,8 @@ TEXT_BUFFER_VIEW_REC *textbuffer_view_create(TEXT_BUFFER_REC *buffer,          view->subline = view->bottom_subline;  	view->bottom = TRUE;   +	view->hidden_level = 0; +  	textbuffer_view_init_ypos(view);    	view->bookmarks = g_hash_table_new((GHashFunc) g_str_hash, @@ -726,8 +737,10 @@ static void view_draw(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,                  return;    	while (line != NULL && lines > 0) { -                linecount = view_line_draw(view, line, subline, ypos, lines); -		ypos += linecount; lines -= linecount; +		if (!view_line_is_hidden(view, line)) { +			linecount = view_line_draw(view, line, subline, ypos, lines); +			ypos += linecount; lines -= linecount; +		}    		subline = 0;                  line = line->next; @@ -768,7 +781,12 @@ static void view_draw_bottom(TEXT_BUFFER_VIEW_REC *view, int lines)          view_draw(view, line, subline, maxline, lines, TRUE);  }   -/* Returns number of lines actually scrolled */ +/* lines: this pointer is scrolled by scrollcount screen lines +   subline: this pointer contains the subline position +   scrollcount: the number of lines to scroll down (negative: up) +   draw_nonclean: whether to redraw the screen now + +   Returns number of lines actually scrolled */  static int view_scroll(TEXT_BUFFER_VIEW_REC *view, LINE_REC **lines,  		       int *subline, int scrollcount, int draw_nonclean)  { @@ -1027,7 +1045,7 @@ static void view_insert_line(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line)  			view->bottom = view_is_bottom(view);  		}   -		if (view->window != NULL) { +		if (view->window != NULL && !view_line_is_hidden(view, line)) {  			ypos = view->ypos+1 - view_get_linecount(view, line);  			if (ypos >= 0)  				subline = 0; @@ -1042,7 +1060,7 @@ static void view_insert_line(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line)  		}  	}   -        if (view->window != NULL) +        if (view->window != NULL && !view_line_is_hidden(view, line))  		term_refresh(view->window);  }   @@ -1122,6 +1140,12 @@ static int view_get_lines_height(TEXT_BUFFER_VIEW_REC *view,  	return height < view->height ? height : view->height;  }   +/* line: line to remove +   linecount: linecount of that line, to be offset when the line was in/below view + +   scroll the window maintaining the startline while removing line +   if startline is removed, make the previous line the new startline +*/  static void view_remove_line_update_startline(TEXT_BUFFER_VIEW_REC *view,  					      LINE_REC *line, int linecount)  { @@ -1318,6 +1342,37 @@ LINE_REC *textbuffer_view_get_bookmark(TEXT_BUFFER_VIEW_REC *view,          return g_hash_table_lookup(view->bookmarks, name);  }   +void textbuffer_view_set_hidden_level(TEXT_BUFFER_VIEW_REC *view, int level) +{ +	g_return_if_fail(view != NULL); + +	if (view->hidden_level != level) { +		if (view->empty_linecount > 0 && view->startline != NULL) { +			int old_height, new_height; +			LINE_REC *hidden_start; + +			hidden_start = view->startline; +			while (hidden_start->prev != NULL && view_line_is_hidden(view, hidden_start->prev)) { +				hidden_start = hidden_start->prev; +			} + +			old_height = view_get_lines_height(view, hidden_start, view->subline, NULL); +			view->hidden_level = level; +			new_height = view_get_lines_height(view, hidden_start, view->subline, NULL); + +			view->empty_linecount -= new_height - old_height; + +			if (view->empty_linecount < 0) +				view->empty_linecount = 0; +			else if (view->empty_linecount > view->height) +				view->empty_linecount = view->height; +		} else { +			view->hidden_level = level; +		} +		textbuffer_view_resize(view, view->width, view->height); +	} +} +  /* Specify window where the changes in view should be drawn,     NULL disables it. */  void textbuffer_view_set_window(TEXT_BUFFER_VIEW_REC *view, '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer-view.h','84','0','24','12','MODIFY','@@ -49,41 +49,51 @@ typedef struct {    struct _TEXT_BUFFER_VIEW_REC {  	TEXT_BUFFER_REC *buffer; -	GSList *siblings; /* other views that use the same buffer */ +	/* other views that use the same buffer */ +	GSList *siblings;            TERM_WINDOW *window;  	int width, height;    	int default_indent;          INDENT_FUNC default_indent_func; -	unsigned int longword_noindent:1; -	unsigned int scroll:1; /* scroll down automatically when at bottom */ -	unsigned int utf8:1; /* use UTF8 in this view */ -	unsigned int break_wide:1; /* Break wide chars in this view */    	TEXT_BUFFER_CACHE_REC *cache; -	int ypos; /* cursor position - visible area is 0..height-1 */ +	/* cursor position - visible area is 0..height-1 */ +	int ypos;   -	LINE_REC *startline; /* line at the top of the screen */ -	int subline; /* number of \"real lines\" to skip from `startline\' */ +	 /* line at the top of the screen */ +	LINE_REC *startline; +	/* number of \"real lines\" to skip from `startline\' */ +	int subline;            /* marks the bottom of the text buffer */  	LINE_REC *bottom_startline;  	int bottom_subline;   +	/* Bookmarks to the lines in the buffer - removed automatically +	   when the line gets removed from buffer */ +        GHashTable *bookmarks; + +	/* these levels should be hidden */ +	int hidden_level;  	/* how many empty lines are in screen. a screenful when started  	   or used /CLEAR */  	int empty_linecount; + +	unsigned int longword_noindent:1; +	/* scroll down automatically when at bottom */ +	unsigned int scroll:1; +	/* use UTF8 in this view */ +	unsigned int utf8:1; +	/* Break wide chars in this view */ +	unsigned int break_wide:1;          /* window is at the bottom of the text buffer */  	unsigned int bottom:1;          /* if !bottom - new text has been printed since we were at bottom */  	unsigned int more_text:1;          /* Window needs a redraw */  	unsigned int dirty:1; - -	/* Bookmarks to the lines in the buffer - removed automatically -	   when the line gets removed from buffer */ -        GHashTable *bookmarks;  };    /* Create new view. */ @@ -143,6 +153,8 @@ void textbuffer_view_set_bookmark_bottom(TEXT_BUFFER_VIEW_REC *view,  /* Return the line for bookmark */  LINE_REC *textbuffer_view_get_bookmark(TEXT_BUFFER_VIEW_REC *view,  				       const char *name); +/* Set hidden level for view */ +void textbuffer_view_set_hidden_level(TEXT_BUFFER_VIEW_REC *view, int level);    /* Specify window where the changes in view should be drawn,     NULL disables it. */ '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer.c','472','140','1','0','MODIFY','@@ -230,6 +230,7 @@ LINE_REC *textbuffer_line_last(TEXT_BUFFER_REC *buffer)  	return buffer->cur_line;  }   +/* returns TRUE if `search\' comes on or after `line\' in the buffer */  int textbuffer_line_exists_after(LINE_REC *line, LINE_REC *search)  {  	while (line != NULL) { '),('irssi','1.0.4','8dfeca57ede1e726de07522a87203ce13676882d','ailin-nemui','hidden lines','textbuffer.h','61','0','1','1','MODIFY','@@ -65,10 +65,10 @@ typedef struct {  	LINE_REC *cur_line;  	TEXT_CHUNK_REC *cur_text;   -	unsigned int last_eol:1;  	int last_fg;  	int last_bg;  	int last_flags; +	unsigned int last_eol:1;  } TEXT_BUFFER_REC;    /* Create new buffer */ '),('irssi','1.0.4','32f33e7bb34598e8603b9f6a931ef063f6bd31f2','Robert Bisewski','improving HOWTO document','startup-HOWTO.html','463','0','5','5','MODIFY','@@ -635,7 +635,7 @@ separated by <code>:</code> from the actual proxy password.</p>    <h2 id=\"statusbar\">12. Statusbar</h2>   -<p><code>/STATUSBAR</code> displays a list of statusbars:</p> +<p><code>/STATUSBAR</code> displays a list of the current statusbars, along with their position and visibility:</p>    <pre><code> Name                           Type   Placement Position Visible   window                         window bottom    0        always @@ -644,9 +644,9 @@ separated by <code>:</code> from the actual proxy password.</p>   topic                          root   top       1        always  </code></pre>   -<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings and itâ€™s items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to itâ€™s default settings, or if the statusbar was created by you, it will be removed.</p> +<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings (type, placement, position, visibility) as well as its items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to its default settings, or if the statusbar was created by you, it will be removed.</p>   -<p>Type can be window or root, meaning if the statusbar should be created for each split window, or just once. Placement can be top or bottom. Position is a number, the higher the value the lower in screen it is. Visible can be always, active or inactive. Active/inactive is useful only with split windows, one split window is active and the rest are inactive. These settings can be changed with:</p> +<p>The statusbar type can be either window or root. If the type is window, then a statusbar will be created for each split window, otherwise it will be created only once. Placement can be top or bottom, which refers to the top or bottom of the screen. Position is a number, the higher the value the lower it will appear in-screen. Visible can be always, active or inactive. Active/inactive is useful only with split windows; one split window is active and the rest are inactive. To adjust these settings, the following commands are available:</p>    <pre><code> /STATUSBAR &lt;name&gt; TYPE window|root   /STATUSBAR &lt;name&gt; PLACEMENT top|bottom @@ -654,10 +654,10 @@ separated by <code>:</code> from the actual proxy password.</p>   /STATUSBAR &lt;name&gt; VISIBLE always|active|inactive  </code></pre>   -<p>When loading a new statusbar scripts, youâ€™ll need to also specify where you want to show it. Statusbar items can be modified with:</p> +<p>Statusbar items can also be added or removed via command. Note that when loading new statusbar scripts that add items, you will need to specify where you want to show the item and how it is aligned. This can be accomplished using the below commands:</p>    <pre><code> /STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt;   /STATUSBAR &lt;name&gt; REMOVE &lt;item&gt;  </code></pre>   -<p>The item name with statusbar scripts is usually same as the scriptâ€™s name. Scriptâ€™s documentation should tell if this isnâ€™t the case. So, to add mail.pl before the window activity item (see the list with <code>/STATUSBAR</code> window), use: <code>/STATUSBAR window ADD -before act mail</code>.</p> +<p>For statusbar scripts, the item name is usually equivalent to the script name. The documentation of the script ought to tell you if this is not the case. For example, to add mail.pl before the window activity item, use: <code>/STATUSBAR window ADD -before act mail</code>.</p> '),('irssi','1.0.4','1f7de4c3bd8cb03af76c14aff71fc535ce9f23de','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 10 +#define IRSSI_ABI_VERSION 11    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.0.4','e1e632d31e1d8efc3370db76ddcc4bda200e4d31','Robert Bisewski','correcting and expanding content of statusbar help text','statusbar.in','34','0','21','12','MODIFY','@@ -5,22 +5,31 @@    %9Parameters:%9   -    ENABLE:       Enables the statusbar. -    DISABLE:      Disabled the statusbar. +    ENABLE:       Adds a statusbar to the list of statusbars. +    DISABLE:      Removes a statusbar from the list.      RESET:        Restores the default statusbar configuration. -    TYPE:         Identifies the type of statusbar. -    PLACEMENT:    Identifies the placement of the statusbar. -    POSITION:     Identifies the position of the statusbar. -    VISIBLE:      Identifies the visibility of the statusbar. -    ADD:          Adds a statusbar into the configuration. -    REMOVE:       Removes a statusbar from the configuration. - -    The name of the statusbar; if no argument is given, the list of statusbars -    will be displayed. +    TYPE:         Refers to the type of statusbar, for each split window +                  or only for the current root screen. +    PLACEMENT:    Refers to the placement of the statusbar, either at the +                  top or the bottom of the screen. +    POSITION:     Refers to the position of the statusbar. Represented as +                  an unsigned integer, with 0 implying the first position. +    VISIBLE:      Refers to the visibility of the statusbar or item. If set +                  to always it is visible on all screens, otherwise if set +                  to inactive or active then it is only visible on inactive +                  or active screens, respectively. +    ADD:          Adds an item to the specified statusbar. It can be set to +                  appear before/after another item and left/right aligned +                  to a specified position on the screen. +    REMOVE:       Removes an item from the specified statusbar. + +    Where name refers to the name of the statusbar; if no argument is +    given, the entire list of statusbars will be displayed.    %9Description:%9   -    Modified the attributes of the statusbar. +    Allows adjustment of the attributes and items of a statusbar, as well +    as where it is located and whether or not it is currently visible.    %9Examples:%9   '),('irssi','1.0.4','0883ff8d320be47336e05aa38cf11427bd79b3af','Robert Bisewski','reverting changes to startup HOWTO','startup-HOWTO.html','463','0','5','5','MODIFY','@@ -635,7 +635,7 @@ separated by <code>:</code> from the actual proxy password.</p>    <h2 id=\"statusbar\">12. Statusbar</h2>   -<p><code>/STATUSBAR</code> displays a list of the current statusbars, along with their position and visibility:</p> +<p><code>/STATUSBAR</code> displays a list of statusbars:</p>    <pre><code> Name                           Type   Placement Position Visible   window                         window bottom    0        always @@ -644,9 +644,9 @@ separated by <code>:</code> from the actual proxy password.</p>   topic                          root   top       1        always  </code></pre>   -<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings (type, placement, position, visibility) as well as its items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to its default settings, or if the statusbar was created by you, it will be removed.</p> +<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings and itâ€™s items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to itâ€™s default settings, or if the statusbar was created by you, it will be removed.</p>   -<p>The statusbar type can be either window or root. If the type is window, then a statusbar will be created for each split window, otherwise it will be created only once. Placement can be top or bottom, which refers to the top or bottom of the screen. Position is a number, the higher the value the lower it will appear in-screen. Visible can be always, active or inactive. Active/inactive is useful only with split windows; one split window is active and the rest are inactive. To adjust these settings, the following commands are available:</p> +<p>Type can be window or root, meaning if the statusbar should be created for each split window, or just once. Placement can be top or bottom. Position is a number, the higher the value the lower in screen it is. Visible can be always, active or inactive. Active/inactive is useful only with split windows, one split window is active and the rest are inactive. These settings can be changed with:</p>    <pre><code> /STATUSBAR &lt;name&gt; TYPE window|root   /STATUSBAR &lt;name&gt; PLACEMENT top|bottom @@ -654,10 +654,10 @@ separated by <code>:</code> from the actual proxy password.</p>   /STATUSBAR &lt;name&gt; VISIBLE always|active|inactive  </code></pre>   -<p>Statusbar items can also be added or removed via command. Note that when loading new statusbar scripts that add items, you will need to specify where you want to show the item and how it is aligned. This can be accomplished using the below commands:</p> +<p>When loading a new statusbar scripts, youâ€™ll need to also specify where you want to show it. Statusbar items can be modified with:</p>    <pre><code> /STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt;   /STATUSBAR &lt;name&gt; REMOVE &lt;item&gt;  </code></pre>   -<p>For statusbar scripts, the item name is usually equivalent to the script name. The documentation of the script ought to tell you if this is not the case. For example, to add mail.pl before the window activity item, use: <code>/STATUSBAR window ADD -before act mail</code>.</p> +<p>The item name with statusbar scripts is usually same as the scriptâ€™s name. Scriptâ€™s documentation should tell if this isnâ€™t the case. So, to add mail.pl before the window activity item (see the list with <code>/STATUSBAR</code> window), use: <code>/STATUSBAR window ADD -before act mail</code>.</p> '),('irssi','1.0.4','84bfea52af8776e13d754e2ee20387f07556fc90','Robert Bisewski','adjusting text content as per the pull-request discussion','statusbar.in','36','0','10','8','MODIFY','@@ -6,15 +6,17 @@  %9Parameters:%9        ENABLE:       Adds a statusbar to the list of statusbars. -    DISABLE:      Removes a statusbar from the list. +    DISABLE:      Removes a statusbar from the list. Note that for +                  built-in statusbars they can be enabled again should the +                  user wish to add back the default statusbars.      RESET:        Restores the default statusbar configuration. -    TYPE:         Refers to the type of statusbar, for each split window -                  or only for the current root screen. -    PLACEMENT:    Refers to the placement of the statusbar, either at the -                  top or the bottom of the screen. -    POSITION:     Refers to the position of the statusbar. Represented as -                  an unsigned integer, with 0 implying the first position. -    VISIBLE:      Refers to the visibility of the statusbar or item. If set +    TYPE:         Sets the type of statusbar, for each split window or only +                  for the current root screen. +    PLACEMENT:    Sets the placement of the statusbar, either at the top or +                  the bottom of the screen. +    POSITION:     Sets the position of the statusbar. Represented as a +                  number, with 0 implying the first position. +    VISIBLE:      Sets the visibility of the statusbar or item. If set to                    to always it is visible on all screens, otherwise if set                    to inactive or active then it is only visible on inactive                    or active screens, respectively. '),('irssi','1.0.4','4b42eca7c57fdd3d5ded8d5b1d4c75d01fc28569','Robert Bisewski','minor word correction','statusbar.in','36','0','2','2','MODIFY','@@ -17,8 +17,8 @@      POSITION:     Sets the position of the statusbar. Represented as a                    number, with 0 implying the first position.      VISIBLE:      Sets the visibility of the statusbar or item. If set to -                  to always it is visible on all screens, otherwise if set -                  to inactive or active then it is only visible on inactive +                  always it is visible on all screens, otherwise if set to +                  inactive or active then it is only visible on inactive                    or active screens, respectively.      ADD:          Adds an item to the specified statusbar. It can be set to                    appear before/after another item and left/right aligned '),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list  this allows access to the global history even when a using /window history named or /set window_history on, and you want to recall something from one of the other windows\' histories.  usage (default): ctrl+up/down','command-history.c','307','85','137','24','MODIFY','@@ -30,10 +30,93 @@  #include \"command-history.h\"    /* command history */ +static GList *history_entries;  static HISTORY_REC *global_history;  static int window_history;  static GSList *histories;   +static HISTORY_ENTRY_REC *history_entry_new(HISTORY_REC *history, const char *text) +{ +	HISTORY_ENTRY_REC *entry; + +	entry = g_new0(HISTORY_ENTRY_REC, 1); +	entry->text = g_strdup(text); +	entry->history = history; +	entry->time = time(NULL); + +	return entry; +} + +static void history_entry_destroy(HISTORY_ENTRY_REC *entry) +{ +	g_free((char *)entry->text); +	g_free(entry); +} + +GList *command_history_list_last(HISTORY_REC *history) +{ +	GList *link; + +	link = g_list_last(history_entries); +	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) { +		link = link->prev; +	} + +	return link; +} + +GList *command_history_list_first(HISTORY_REC *history) +{ +	GList *link; + +	link = history_entries; +	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) { +		link = link->next; +	} + +	return link; +} + +GList *command_history_list_prev(HISTORY_REC *history, GList *pos) +{ +	GList *link; + +	link = pos != NULL ? pos->prev : NULL; +	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) { +		link = link->prev; +	} + +	return link; +} + +GList *command_history_list_next(HISTORY_REC *history, GList *pos) +{ +	GList *link; + +	link = pos != NULL ? pos->next : NULL; +	while (link != NULL && history != NULL && ((HISTORY_ENTRY_REC *)link->data)->history != history) { +		link = link->next; +	} + +	return link; +} + +static void command_history_clear_pos_for_unlink_func(HISTORY_REC *history, GList* link) +{ +	if (history->pos == link) { +		history->pos = command_history_list_next(history, link); +		history->redo = 1; +	} +} + +static void history_list_delete_link_and_destroy(GList *link) +{ +	g_slist_foreach(histories, +		       (GFunc) command_history_clear_pos_for_unlink_func, link); +	history_entry_destroy(link->data); +	history_entries = g_list_delete_link(history_entries, link); +} +  void command_history_add(HISTORY_REC *history, const char *text)  {  	GList *link; @@ -41,21 +124,19 @@ void command_history_add(HISTORY_REC *history, const char *text)  	g_return_if_fail(history != NULL);  	g_return_if_fail(text != NULL);   -	link = g_list_last(history->list); -	if (link != NULL && g_strcmp0(link->data, text) == 0) -	  return; /* same as previous entry */ +	link = command_history_list_last(history); +	if (link != NULL && g_strcmp0(((HISTORY_ENTRY_REC *)link->data)->text, text) == 0) +		return; /* same as previous entry */    	if (settings_get_int(\"max_command_history\") < 1 ||  	    history->lines < settings_get_int(\"max_command_history\"))  		history->lines++;  	else { -		link = history->list; -		g_free(link->data); -		history->list = g_list_remove_link(history->list, link); -		g_list_free_1(link); +		link = command_history_list_first(history); +		history_list_delete_link_and_destroy(link);  	}   -	history->list = g_list_append(history->list, g_strdup(text)); +	history_entries = g_list_append(history_entries, history_entry_new(history, text));  }    HISTORY_REC *command_history_find(HISTORY_REC *history) @@ -104,32 +185,44 @@ HISTORY_REC *command_history_current(WINDOW_REC *window)  	return global_history;  }   -const char *command_history_prev(WINDOW_REC *window, const char *text) +static const char *command_history_prev_int(WINDOW_REC *window, const char *text, gboolean global)  {  	HISTORY_REC *history;  	GList *pos;    	history = command_history_current(window);  	pos = history->pos; +	history->redo = 0;    	if (pos != NULL) {  		/* don\'t go past the first entry (no wrap around) */ -		if (history->pos->prev != NULL) -			history->pos = history->pos->prev; +		GList *prev = command_history_list_prev(global ? NULL : history, history->pos); +		if (prev != NULL) +			history->pos = prev;  	} else { -		history->pos = g_list_last(history->list); +		history->pos = command_history_list_last(global ? NULL : history);  	}    	if (*text != \'\\0\' && -	    (pos == NULL || g_strcmp0(pos->data, text) != 0)) { +	    (pos == NULL || g_strcmp0(((HISTORY_ENTRY_REC *)pos->data)->text, text) != 0)) {  		/* save the old entry to history */  		command_history_add(history, text);  	}   -	return history->pos == NULL ? text : history->pos->data; +	return history->pos == NULL ? text : ((HISTORY_ENTRY_REC *)history->pos->data)->text;  }   -const char *command_history_next(WINDOW_REC *window, const char *text) +const char *command_history_prev(WINDOW_REC *window, const char *text) +{ +	return command_history_prev_int(window, text, FALSE); +} + +const char *command_global_history_prev(WINDOW_REC *window, const char *text) +{ +	return command_history_prev_int(window, text, TRUE); +} + +static const char *command_history_next_int(WINDOW_REC *window, const char *text, gboolean global)  {  	HISTORY_REC *history;  	GList *pos; @@ -137,15 +230,26 @@ const char *command_history_next(WINDOW_REC *window, const char *text)  	history = command_history_current(window);  	pos = history->pos;   -	if (pos != NULL) -		history->pos = history->pos->next; +	if (!(history->redo) && pos != NULL) +		history->pos = command_history_list_next(global ? NULL : history, history->pos); +	history->redo = 0;    	if (*text != \'\\0\' && -	    (pos == NULL || g_strcmp0(pos->data, text) != 0)) { +	    (pos == NULL || g_strcmp0(((HISTORY_ENTRY_REC *)pos->data)->text, text) != 0)) {  		/* save the old entry to history */  		command_history_add(history, text);  	} -	return history->pos == NULL ? \"\" : history->pos->data; +	return history->pos == NULL ? \"\" : ((HISTORY_ENTRY_REC *)history->pos->data)->text; +} + +const char *command_history_next(WINDOW_REC *window, const char *text) +{ +	return command_history_next_int(window, text, FALSE); +} + +const char *command_global_history_next(WINDOW_REC *window, const char *text) +{ +	return command_history_next_int(window, text, TRUE);  }    void command_history_clear_pos_func(HISTORY_REC *history, gpointer user_data) @@ -175,12 +279,17 @@ HISTORY_REC *command_history_create(const char *name)    void command_history_clear(HISTORY_REC *history)  { +	GList *link, *next; +  	g_return_if_fail(history != NULL);    	command_history_clear_pos_func(history, NULL); -	g_list_foreach(history->list, (GFunc) g_free, NULL); -	g_list_free(history->list); -	history->list = NULL; +	link = command_history_list_first(history); +	while (link != NULL) { +		next = command_history_list_next(history, link); +		history_list_delete_link_and_destroy(link); +		link = next; +	}  	history->lines = 0;  }   @@ -264,8 +373,8 @@ static char *special_history_func(const char *text, void *item, int *free_ret)  	ret = NULL;    	history = command_history_current(window); -	for (tmp = history->list; tmp != NULL; tmp = tmp->next) { -		const char *line = tmp->data; +	for (tmp = command_history_list_first(history); tmp != NULL; tmp = command_history_list_next(history, tmp)) { +		const char *line = ((HISTORY_ENTRY_REC *)tmp->data)->text;    		if (match_wildcards(findtext, line)) {  			*free_ret = TRUE; @@ -289,6 +398,8 @@ void command_history_init(void)    	special_history_func_set(special_history_func);   +	history_entries = NULL; +  	global_history = command_history_create(NULL);    	read_settings(); @@ -308,4 +419,6 @@ void command_history_deinit(void)  	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);    	command_history_destroy(global_history); + +	g_list_free_full(history_entries, (GDestroyNotify) history_entry_destroy);  } '),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list  this allows access to the global history even when a using /window history named or /set window_history on, and you want to recall something from one of the other windows\' histories.  usage (default): ctrl+up/down','command-history.h','33','0','15','1','MODIFY','@@ -6,12 +6,19 @@  typedef struct {  	char *name;   -	GList *list, *pos; +	GList *pos;  	int lines;    	int refcount; +	int redo:1;  } HISTORY_REC;   +typedef struct { +	const char *text; +	HISTORY_REC *history; +	time_t time; +} HISTORY_ENTRY_REC; +  HISTORY_REC *command_history_find(HISTORY_REC *history);  HISTORY_REC *command_history_find_name(const char *name);   @@ -22,8 +29,15 @@ void command_history_deinit(void);    void command_history_add(HISTORY_REC *history, const char *text);   +GList *command_history_list_last(HISTORY_REC *history); +GList *command_history_list_first(HISTORY_REC *history); +GList *command_history_list_prev(HISTORY_REC *history, GList *pos); +GList *command_history_list_next(HISTORY_REC *history, GList *pos); +  const char *command_history_prev(WINDOW_REC *window, const char *text);  const char *command_history_next(WINDOW_REC *window, const char *text); +const char *command_global_history_prev(WINDOW_REC *window, const char *text); +const char *command_global_history_next(WINDOW_REC *window, const char *text);    void command_history_clear_pos(WINDOW_REC *window);   '),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list  this allows access to the global history even when a using /window history named or /set window_history on, and you want to recall something from one of the other windows\' histories.  usage (default): ctrl+up/down','gui-readline.c','1053','210','28','0','MODIFY','@@ -530,6 +530,28 @@ static void key_forward_history(void)          g_free(line);  }   +static void key_backward_global_history(void) +{ +	const char *text; +	char *line; + +	line = gui_entry_get_text(active_entry); +	text = command_global_history_prev(active_win, line); +	gui_entry_set_text(active_entry, text); +	g_free(line); +} + +static void key_forward_global_history(void) +{ +	const char *text; +	char *line; + +	line = gui_entry_get_text(active_entry); +	text = command_global_history_next(active_win, line); +	gui_entry_set_text(active_entry, text); +	g_free(line); +} +  static void key_beginning_of_line(void)  {          gui_entry_set_pos(active_entry, 0); @@ -1176,6 +1198,8 @@ void gui_readline_init(void)  	key_bind(\"key\", NULL, \"meta2-5C\", \"cright\", (SIGNAL_FUNC) key_combo);  	key_bind(\"key\", NULL, \"meta2-1;5D\", \"cleft\", (SIGNAL_FUNC) key_combo);  	key_bind(\"key\", NULL, \"meta2-1;5C\", \"cright\", (SIGNAL_FUNC) key_combo); +	key_bind(\"key\", NULL, \"meta2-1;5A\", \"cup\", (SIGNAL_FUNC) key_combo); +	key_bind(\"key\", NULL, \"meta2-1;5B\", \"cdown\", (SIGNAL_FUNC) key_combo);    	key_bind(\"key\", NULL, \"meta2-1;3A\", \"mup\", (SIGNAL_FUNC) key_combo);  	key_bind(\"key\", NULL, \"meta2-1;3B\", \"mdown\", (SIGNAL_FUNC) key_combo); @@ -1217,6 +1241,8 @@ void gui_readline_init(void)          /* history */  	key_bind(\"backward_history\", \"Go back one line in the history\", \"up\", NULL, (SIGNAL_FUNC) key_backward_history);  	key_bind(\"forward_history\", \"Go forward one line in the history\", \"down\", NULL, (SIGNAL_FUNC) key_forward_history); +	key_bind(\"backward_global_history\", \"Go back one line in the global history\", \"cup\", NULL, (SIGNAL_FUNC) key_backward_global_history); +	key_bind(\"forward_global_history\", \"Go forward one line in the global history\", \"cdown\", NULL, (SIGNAL_FUNC) key_forward_global_history);            /* line editing */  	key_bind(\"backspace\", \"Delete the previous character\", \"backspace\", NULL, (SIGNAL_FUNC) key_backspace); @@ -1310,6 +1336,8 @@ void gui_readline_deinit(void)    	key_unbind(\"backward_history\", (SIGNAL_FUNC) key_backward_history);  	key_unbind(\"forward_history\", (SIGNAL_FUNC) key_forward_history); +	key_unbind(\"backward_global_history\", (SIGNAL_FUNC) key_backward_global_history); +	key_unbind(\"forward_global_history\", (SIGNAL_FUNC) key_forward_global_history);    	key_unbind(\"backspace\", (SIGNAL_FUNC) key_backspace);  	key_unbind(\"delete_character\", (SIGNAL_FUNC) key_delete_character); '),('irssi','1.0.4','1fd285dccfd43b740e88f7f4e168132387d39843','ailin-nemui','refactor history to use history_entries list  this allows access to the global history even when a using /window history named or /set window_history on, and you want to recall something from one of the other windows\' histories.  usage (default): ctrl+up/down','Window.xs','248','2','3','2','MODIFY','@@ -252,8 +252,9 @@ PREINIT:  	GList *tmp;  PPCODE:  	rec = command_history_current(window); -	for (tmp = rec->list; tmp != NULL; tmp = tmp->next) -		XPUSHs(sv_2mortal(new_pv(tmp->data))); +	for (tmp = command_history_list_first(rec); tmp != NULL; tmp = command_history_list_next(rec, tmp)) +		XPUSHs(sv_2mortal(new_pv(((HISTORY_ENTRY_REC *)tmp->data)->text))); +    #*******************************  MODULE = Irssi::UI::Window  PACKAGE = Irssi::Windowitem  PREFIX = window_item_ '),('irssi','1.0.4','16d68a86ca75b73c53aa81fe6d3d36361cb35b99','ailin-nemui','add two XSFuncs to manipulate command history entries  it is possible to use Irssi::UI::Window::get_history_entries to save the history entries, load_history_entries to load entries into the command history and delete_history_entries to remove history entries (for example to remove history selectively)','command-history.c','351','96','55','0','MODIFY','@@ -168,6 +168,61 @@ HISTORY_REC *command_history_find_name(const char *name)  	return NULL;  }   +static int history_entry_after_time_sort(const HISTORY_ENTRY_REC *a, const HISTORY_ENTRY_REC *b) +{ +	return a->time == b->time ? 1 : a->time - b->time; +} + +void command_history_load_entry(time_t history_time, HISTORY_REC *history, const char *text) +{ +	HISTORY_ENTRY_REC *entry; + +	g_return_if_fail(history != NULL); +	g_return_if_fail(text != NULL); + +	entry = g_new0(HISTORY_ENTRY_REC, 1); +	entry->text = g_strdup(text); +	entry->history = history; +	entry->time = history_time; + +	history->lines++; + +	history_entries = g_list_insert_sorted(history_entries, entry, (GCompareFunc)history_entry_after_time_sort); +} + +static int history_entry_find_func(const HISTORY_ENTRY_REC *data, const HISTORY_ENTRY_REC *user_data) +{ +	if ((user_data->time == -1 || (data->time == user_data->time)) && +	    (user_data->history == NULL || (data->history == user_data->history)) && +	    g_strcmp0(data->text, user_data->text) == 0) { +		return 0; +	} else { +		return -1; +	} +} + +gboolean command_history_delete_entry(time_t history_time, HISTORY_REC *history, const char *text) +{ +	GList *link; +	HISTORY_ENTRY_REC entry; + +	g_return_val_if_fail(history != NULL, FALSE); +	g_return_val_if_fail(text != NULL, FALSE); + +	entry.text = text; +	entry.history = history; +	entry.time = history_time; + +	link = g_list_find_custom(history_entries, &entry, (GCompareFunc)history_entry_find_func); +	if (link != NULL) { +		((HISTORY_ENTRY_REC *)link->data)->history->lines--; +		history_list_delete_link_and_destroy(link); +		return TRUE; +	} else { +		return FALSE; +	} +} +  HISTORY_REC *command_history_current(WINDOW_REC *window)  {  	HISTORY_REC *rec; '),('irssi','1.0.4','16d68a86ca75b73c53aa81fe6d3d36361cb35b99','ailin-nemui','add two XSFuncs to manipulate command history entries  it is possible to use Irssi::UI::Window::get_history_entries to save the history entries, load_history_entries to load entries into the command history and delete_history_entries to remove history entries (for example to remove history selectively)','command-history.h','35','0','2','0','MODIFY','@@ -28,6 +28,8 @@ void command_history_init(void);  void command_history_deinit(void);    void command_history_add(HISTORY_REC *history, const char *text); +void command_history_load_entry(time_t time, HISTORY_REC *history, const char *text); +gboolean command_history_delete_entry(time_t history_time, HISTORY_REC *history, const char *text);    GList *command_history_list_last(HISTORY_REC *history);  GList *command_history_list_first(HISTORY_REC *history); '),('irssi','1.0.4','16d68a86ca75b73c53aa81fe6d3d36361cb35b99','ailin-nemui','add two XSFuncs to manipulate command history entries  it is possible to use Irssi::UI::Window::get_history_entries to save the history entries, load_history_entries to load entries into the command history and delete_history_entries to remove history entries (for example to remove history selectively)','Window.xs','377','35','139','0','MODIFY','@@ -255,6 +255,145 @@ PPCODE:  	for (tmp = command_history_list_first(rec); tmp != NULL; tmp = command_history_list_next(rec, tmp))  		XPUSHs(sv_2mortal(new_pv(((HISTORY_ENTRY_REC *)tmp->data)->text)));   +void +window_get_history_entries(window) +	Irssi::UI::Window window +PREINIT: +	HISTORY_REC *rec; +	HISTORY_ENTRY_REC *ent; +	WINDOW_REC *win; +	GList *tmp; +	GSList *stmp; +	HV *hv; +PPCODE: +	rec = window == NULL ? NULL : command_history_current(window); +	for (tmp = command_history_list_first(rec); tmp != NULL; tmp = command_history_list_next(rec, tmp)) { +		hv = (HV*)sv_2mortal((SV*)newHV()); +		ent = tmp->data; +		hv_store(hv, \"text\", 4, newSVpv(ent->text, 0), 0); +		hv_store(hv, \"time\", 4, newSViv(ent->time), 0); +		if (ent->history == command_history_current(NULL)) { +			hv_store(hv, \"history\", 7, newSV(0), 0); +			hv_store(hv, \"window\", 6, newSV(0), 0); +		} else { +			if (ent->history->name == NULL) { +				hv_store(hv, \"history\", 7, newSV(0), 0); +				for (stmp = windows; stmp != NULL; stmp = stmp->next) { +					win = stmp->data; +					if (win->history == ent->history) { +						hv_store(hv, \"window\", 6, newSViv(win->refnum), 0); +						break; +					} +				} +			} else { +				hv_store(hv, \"history\", 7, new_pv(ent->history->name), 0); +				hv_store(hv, \"window\", 6, newSV(0), 0); +			} +		} +		XPUSHs(sv_2mortal(newRV_inc((SV*)hv))); +	} + +void +window_load_history_entries(window, ...) +	Irssi::UI::Window window +PREINIT: +	HV *hv; +	SV **sv; +	HISTORY_REC *history; +	WINDOW_REC *tmp; +	const char *text; +	long hist_time; +	int i; +PPCODE: +	for (i = 1; i < items; i++) { +		if (!is_hvref(ST(i))) { +			croak(\"Usage: Irssi::UI::Window::load_history_entries(window, hash...)\"); +		} +		hv = hvref(ST(i)); +		if (hv != NULL) { +			tmp = NULL; +			text = NULL; +			hist_time = time(NULL); +			history = command_history_current(NULL); + +			sv = hv_fetch(hv, \"text\", 4, 0); +			if (sv != NULL) text = SvPV_nolen(*sv); +			sv = hv_fetch(hv, \"time\", 4, 0); +			if (sv != NULL && SvOK(*sv)) hist_time = SvIV(*sv); + +			if (window != NULL) { +				history = command_history_current(window); +			} else { +				sv = hv_fetch(hv, \"history\", 7, 0); +				if (sv != NULL && SvOK(*sv)) { +					history = command_history_find_name(SvPV_nolen(*sv)); +				} + +				sv = hv_fetch(hv, \"window\", 6, 0); +				if (sv != NULL && SvOK(*sv)) { +					tmp = window_find_refnum(SvIV(*sv)); +					if (tmp != NULL) { +						history = tmp->history; +					} +				} +			} + +			if (text != NULL && history != NULL) { +				command_history_load_entry(hist_time, history, text); +			} +		} +	} + +void +window_delete_history_entries(window, ...) +	Irssi::UI::Window window +PREINIT: +	HV *hv; +	SV **sv; +	HISTORY_REC *history; +	WINDOW_REC *tmp; +	const char *text; +	long hist_time; +	int i; +PPCODE: +	for (i = 1; i < items; i++) { +		if (!is_hvref(ST(i))) { +			croak(\"Usage: Irssi::UI::Window::delete_history_entries(window, hash...)\"); +		} +		hv = hvref(ST(i)); +		if (hv != NULL) { +			tmp = NULL; +			text = NULL; +			hist_time = -1; +			history = command_history_current(NULL); + +			sv = hv_fetch(hv, \"text\", 4, 0); +			if (sv != NULL) text = SvPV_nolen(*sv); +			sv = hv_fetch(hv, \"time\", 4, 0); +			if (sv != NULL && SvOK(*sv)) hist_time = SvIV(*sv); + +			if (window != NULL) { +				history = command_history_current(window); +			} else { +				sv = hv_fetch(hv, \"history\", 7, 0); +				if (sv != NULL && SvOK(*sv)) { +					history = command_history_find_name(SvPV_nolen(*sv)); +				} + +				sv = hv_fetch(hv, \"window\", 6, 0); +				if (sv != NULL && SvOK(*sv)) { +					tmp = window_find_refnum(SvIV(*sv)); +					if (tmp != NULL) { +						history = tmp->history; +					} +				} +			} + +			if (text != NULL && history != NULL) { +				XPUSHs(boolSV(command_history_delete_entry(hist_time, history, text))); +			} +		} +	}    #*******************************  MODULE = Irssi::UI::Window  PACKAGE = Irssi::Windowitem  PREFIX = window_item_ '),('irssi','1.0.4','deac66f33c0fb1d6914d15ce63bde3f030a9c06d','ailin-nemui','add a key binding to erase history entries  it is possible to delete the current history entry using the erase_history_entry key binding','command-history.c','364','100','17','0','MODIFY','@@ -307,6 +307,23 @@ const char *command_global_history_next(WINDOW_REC *window, const char *text)  	return command_history_next_int(window, text, TRUE);  }   +const char *command_history_delete_current(WINDOW_REC *window, const char *text) +{ +	HISTORY_REC *history; +	GList *pos; + +	history = command_history_current(window); +	pos = history->pos; + +	if (pos != NULL && g_strcmp0(((HISTORY_ENTRY_REC *)pos->data)->text, text) == 0) { +		((HISTORY_ENTRY_REC *)pos->data)->history->lines--; +		history_list_delete_link_and_destroy(pos); +	} + +	history->redo = 0; +	return history->pos == NULL ? \"\" : ((HISTORY_ENTRY_REC *)history->pos->data)->text; +} +  void command_history_clear_pos_func(HISTORY_REC *history, gpointer user_data)  {  	history->pos = NULL; '),('irssi','1.0.4','deac66f33c0fb1d6914d15ce63bde3f030a9c06d','ailin-nemui','add a key binding to erase history entries  it is possible to delete the current history entry using the erase_history_entry key binding','command-history.h','36','0','1','0','MODIFY','@@ -40,6 +40,7 @@ const char *command_history_prev(WINDOW_REC *window, const char *text);  const char *command_history_next(WINDOW_REC *window, const char *text);  const char *command_global_history_prev(WINDOW_REC *window, const char *text);  const char *command_global_history_next(WINDOW_REC *window, const char *text); +const char *command_history_delete_current(WINDOW_REC *window, const char *text);    void command_history_clear_pos(WINDOW_REC *window);   '),('irssi','1.0.4','deac66f33c0fb1d6914d15ce63bde3f030a9c06d','ailin-nemui','add a key binding to erase history entries  it is possible to delete the current history entry using the erase_history_entry key binding','gui-readline.c','1064','211','13','0','MODIFY','@@ -552,6 +552,17 @@ static void key_forward_global_history(void)  	g_free(line);  }   +static void key_erase_history_entry(void) +{ +	const char *text; +	char *line; + +	line = gui_entry_get_text(active_entry); +	text = command_history_delete_current(active_win, line); +	gui_entry_set_text(active_entry, text); +	g_free(line); +} +  static void key_beginning_of_line(void)  {          gui_entry_set_pos(active_entry, 0); @@ -1243,6 +1254,7 @@ void gui_readline_init(void)  	key_bind(\"forward_history\", \"Go forward one line in the history\", \"down\", NULL, (SIGNAL_FUNC) key_forward_history);  	key_bind(\"backward_global_history\", \"Go back one line in the global history\", \"cup\", NULL, (SIGNAL_FUNC) key_backward_global_history);  	key_bind(\"forward_global_history\", \"Go forward one line in the global history\", \"cdown\", NULL, (SIGNAL_FUNC) key_forward_global_history); +	key_bind(\"erase_history_entry\", \"Erase the currently active entry from the history\", NULL, NULL, (SIGNAL_FUNC) key_erase_history_entry);            /* line editing */  	key_bind(\"backspace\", \"Delete the previous character\", \"backspace\", NULL, (SIGNAL_FUNC) key_backspace); @@ -1338,6 +1350,7 @@ void gui_readline_deinit(void)  	key_unbind(\"forward_history\", (SIGNAL_FUNC) key_forward_history);  	key_unbind(\"backward_global_history\", (SIGNAL_FUNC) key_backward_global_history);  	key_unbind(\"forward_global_history\", (SIGNAL_FUNC) key_forward_global_history); +	key_unbind(\"erase_history_entry\", (SIGNAL_FUNC) key_erase_history_entry);    	key_unbind(\"backspace\", (SIGNAL_FUNC) key_backspace);  	key_unbind(\"delete_character\", (SIGNAL_FUNC) key_delete_character); '),('irssi','1.0.4','5da0b73a12b3b319a2c7d6b18657ec13d52b6476','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 11 +#define IRSSI_ABI_VERSION 12    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.0.4','40ae8f5fa67cb7ec529f9fea5816fb8804c9bba8','Edward Tomasz Napierala','Limit capsicum rights to stdio.  This requires FreeBSD fix (https://reviews.freebsd.org/D12622) to work properly.','capsicum.c','347','70','8','0','MODIFY','@@ -37,6 +37,7 @@  #include <sys/nv.h>  #include <sys/procdesc.h>  #include <sys/socket.h> +#include <capsicum_helpers.h>  #include <string.h>    #define	OPCODE_CONNECT		1 @@ -410,6 +411,13 @@ static void cmd_capsicum_enter(void)  	 */  	signal(SIGCHLD, SIG_IGN);   +	error = caph_limit_stdio(); +	if (error != 0) { +		g_warning(\"caph_limit_stdio(3) failed: %s\", strerror(errno)); +		signal_emit(\"capability mode failed\", 1, strerror(errno)); +		return; +	} +  	error = cap_enter();  	if (error != 0) {  		signal_emit(\"capability mode failed\", 1, strerror(errno)); '),('irssi','1.0.4','00c80cb6fcca40cfc421fe3fc181115ac4907191','ailin-nemui','fix out of bounds read in compress_colors  Reported by Hanno BÃ¶ck.  Fixes GL#12','themes.c','1125','277','6','1','MODIFY','@@ -587,7 +587,7 @@ static char *theme_format_compress_colors(THEME_REC *theme, const char *format)  			/* a normal character */  			g_string_append_c(str, *format);  			format++; -		} else { +		} else if (format[1] != \'\\0\') {  			/* %format */  			format++;  			if (IS_OLD_FORMAT(*format, last_fg, last_bg)) { @@ -614,6 +614,11 @@ static char *theme_format_compress_colors(THEME_REC *theme, const char *format)  					last_bg = \'\\0\';  			}  			format++; +		} else { +			/* % at end of string */ +			format++; +			g_string_append_c(str, \'%\'); +			g_string_append_c(str, \'%\');  		}  	}   '),('irssi','1.0.4','49ace3251b79a9e97c6e4d0bc640f9143dc71b90','ailin-nemui','fix uaf in chanquery module  the chanquery needs to be removed in any case if a channel rec is destroyed, regardless of any state  Fixes GL#13','channels-query.c','342','69','3','3','MODIFY','@@ -125,15 +125,15 @@ static void query_remove_all(IRC_CHANNEL_REC *channel)  		rec->queries[n] = g_slist_remove(rec->queries[n], channel);  	rec->current_queries = g_slist_remove(rec->current_queries, channel);   -	query_check(channel->server); +	if (!channel->server->disconnected) +		query_check(channel->server);  }    static void sig_channel_destroyed(IRC_CHANNEL_REC *channel)  {  	g_return_if_fail(channel != NULL);   -	if (IS_IRC_CHANNEL(channel) && !channel->server->disconnected && -	    !channel->synced) +	if (IS_IRC_CHANNEL(channel))  		query_remove_all(channel);  }   '),('irssi','1.0.4','2edd816e7db13b4ac0b20df9bf7fe55ee7718215','Joseph Bisch','Fix segfault in query_remove_all  It is possible for rec to be NULL in query_remove_all, resulting in a segfault. So return without doing anything if rec is NULL.','channels-query.c','343','70','1','0','MODIFY','@@ -119,6 +119,7 @@ static void query_remove_all(IRC_CHANNEL_REC *channel)  	int n;    	rec = channel->server->chanqueries; +	if (rec == NULL) return;    	/* remove channel from query lists */  	for (n = 0; n < CHANNEL_QUERIES; n++) '),('irssi','1.0.4','4ccff71f678f79da71713a29d8528812379bb584','Will Storey','Set host to an empty string on error  While investigating #317, I noticed that it was possible we would access an uninitialized buffer due to failing to check the return value of net_ip2host(). This is done in several places. To make such uses safe, set the host buffer to an empty string on error. It is possible callers could be improved by handling the error in each spot, but this gives us some safety.','network.c','394','104','10','1','MODIFY','@@ -489,7 +489,16 @@ int net_gethostbyaddr(IPADDR *ip, char **name)    int net_ip2host(IPADDR *ip, char *host)  { -	return inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN) ? 0 : -1; +	if (inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN)) { +		return 0; +	} + +	// For callers that do not check our return value and pass in an +	// uninitialized buffer assuming it will be set, ensure the buffer is a valid +	// string. Ideally callers should check what we return and handle +	// appropriately, but this at least gives us safety. +	host[0] = \'\\0\'; +	return -1;  }    int net_host2ip(const char *host, IPADDR *ip) '),('irssi','1.0.4','cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d','Will Storey','Delete unused function net_ip_compare()','network.c','382','101','0','12','MODIFY','@@ -60,18 +60,6 @@ IPADDR ip4_any = {  #endif  };   -int net_ip_compare(IPADDR *ip1, IPADDR *ip2) -{ -	if (ip1->family != ip2->family) -		return 0; - -	if (ip1->family == AF_INET6) -		return memcmp(&ip1->ip, &ip2->ip, sizeof(ip1->ip)) == 0; - -	return memcmp(&ip1->ip, &ip2->ip, 4) == 0; -} - -  static void sin_set_ip(union sockaddr_union *so, const IPADDR *ip)  {  	if (ip == NULL) { '),('irssi','1.0.4','cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d','Will Storey','Delete unused function net_ip_compare()','network.h','35','0','0','3','MODIFY','@@ -33,9 +33,6 @@ extern IPADDR ip4_any;    GIOChannel *g_io_channel_new(int handle);   -/* returns 1 if IPADDRs are the same */ -int net_ip_compare(IPADDR *ip1, IPADDR *ip2); -  int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);    /* Connect to socket */ '),('irssi','1.0.4','3b3939b146bb2f80182d572a2afc08ba405037a1','Will Storey','Delete commented out CYGWIN define','network.c','382','101','0','3','MODIFY','@@ -48,9 +48,6 @@ GIOChannel *g_io_channel_new(int handle)  	return chan;  }   -/* Cygwin need this, don\'t know others.. */ -/*#define BLOCKING_SOCKETS 1*/ -  IPADDR ip4_any = {  	AF_INET,  #if defined(IN6ADDR_ANY_INIT) '),('irssi','1.0.4','b8b90c76d4ea87d7e50c2a34fbc36ab732e3e89e','Will Storey','Delete unused function net_connect()','network.c','357','94','0','34','MODIFY','@@ -98,40 +98,6 @@ static int sin_get_port(union sockaddr_union *so)  		     so->sin.sin_port);  }   -/* Connect to socket */ -GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) -{ -	IPADDR ip4, ip6, *ip; - -	g_return_val_if_fail(addr != NULL, NULL); - -	if (net_gethostbyname(addr, &ip4, &ip6) == -1) -		return NULL; - -	if (my_ip == NULL) { -                /* prefer IPv4 addresses */ -		ip = ip4.family != 0 ? &ip4 : &ip6; -	} else if (IPADDR_IS_V6(my_ip)) { -                /* my_ip is IPv6 address, use it if possible */ -		if (ip6.family != 0) -			ip = &ip6; -		else { -			my_ip = NULL; -                        ip = &ip4; -		} -	} else { -                /* my_ip is IPv4 address, use it if possible */ -		if (ip4.family != 0) -			ip = &ip4; -		else { -			my_ip = NULL; -                        ip = &ip6; -		} -	} - -	return net_connect_ip(ip, port, my_ip); -} -  int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip)  {  	union sockaddr_union so; '),('irssi','1.0.4','b8b90c76d4ea87d7e50c2a34fbc36ab732e3e89e','Will Storey','Delete unused function net_connect()','network.h','34','0','0','2','MODIFY','@@ -35,8 +35,6 @@ GIOChannel *g_io_channel_new(int handle);    int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);   -/* Connect to socket */ -GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip) G_GNUC_DEPRECATED;  /* Connect to socket with ip address and SSL*/  GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server);  /* Start TLS */ '),('irssi','1.0.4','174adee9dd91c23615f79b979b3b3c5f72ad1240','Will Storey','Always initialize the host string  This also removes a wordy comment','network.c','391','104','1','9','MODIFY','@@ -489,16 +489,8 @@ int net_gethostbyaddr(IPADDR *ip, char **name)    int net_ip2host(IPADDR *ip, char *host)  { -	if (inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN)) { -		return 0; -	} - -	// For callers that do not check our return value and pass in an -	// uninitialized buffer assuming it will be set, ensure the buffer is a valid -	// string. Ideally callers should check what we return and handle -	// appropriately, but this at least gives us safety.  	host[0] = \'\\0\'; -	return -1; +	return inet_ntop(ip->family, &ip->ip, host, MAX_IP_LEN) ? 0 : -1;  }    int net_host2ip(const char *host, IPADDR *ip) '),('irssi','1.0.4','17b195021dc35b95b24c1cce6f2e891e0e6b85ec','Edward Tomasz Napierala','Bump default capsicum_port_max to 9999.  This is needed for servers like ssl.efnet.org, which, per default config, listen on 9999.','capsicum.c','347','70','1','1','MODIFY','@@ -452,7 +452,7 @@ void capsicum_init(void)  	settings_add_bool(\"misc\", \"capsicum\", FALSE);  	settings_add_str(\"misc\", \"capsicum_irclogs_path\", \"~/irclogs\");  	settings_add_int(\"misc\", \"capsicum_port_min\", 6667); -	settings_add_int(\"misc\", \"capsicum_port_max\", 6697); +	settings_add_int(\"misc\", \"capsicum_port_max\", 9999);    	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished);   '),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','Add alternate_nick as a network-specific property.','network.in','54','0','1','0','MODIFY','@@ -11,6 +11,7 @@      REMOVE:          Removes a network from your configuration.        -nick:           Specifies the nickname to use. +    -alternate_nick  Specifies the alternate nickname to use.      -user:           Specifies the user identity to use.      -realname:       Specifies the real name to use.      -host:           Specifies the hostname to use. '),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','Add alternate_nick as a network-specific property.','chatnet-rec.h','10','0','1','0','MODIFY','@@ -4,6 +4,7 @@ int chat_type; /* chat_protocol_lookup(xx) */  char *name;    char *nick; +char *alternate_nick;  char *username;  char *realname;   '),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','Add alternate_nick as a network-specific property.','fe-ircnet.c','191','72','8','3','MODIFY','@@ -48,6 +48,8 @@ static void cmd_network_list(void)  		g_string_truncate(str, 0);  		if (rec->nick != NULL)  			g_string_append_printf(str, \"nick: %s, \", rec->nick); +		if (rec->alternate_nick != NULL) +			g_string_append_printf(str, \"alternate_nick: %s, \", rec->alternate_nick);  		if (rec->username != NULL)  			g_string_append_printf(str, \"username: %s, \", rec->username);  		if (rec->realname != NULL) @@ -114,6 +116,7 @@ static void cmd_network_add_modify(const char *data, gboolean add)  		rec->name = g_strdup(name);  	} else {  		if (g_hash_table_lookup(optlist, \"nick\")) g_free_and_null(rec->nick); +		if (g_hash_table_lookup(optlist, \"alternate_nick\")) g_free_and_null(rec->alternate_nick);  		if (g_hash_table_lookup(optlist, \"user\")) g_free_and_null(rec->username);  		if (g_hash_table_lookup(optlist, \"realname\")) g_free_and_null(rec->realname);  		if (g_hash_table_lookup(optlist, \"host\")) { @@ -145,6 +148,8 @@ static void cmd_network_add_modify(const char *data, gboolean add)    	value = g_hash_table_lookup(optlist, \"nick\");  	if (value != NULL && *value != \'\\0\') rec->nick = g_strdup(value); +	value = g_hash_table_lookup(optlist, \"alternate_nick\"); +	if (value != NULL && *value != \'\\0\') rec->alternate_nick = g_strdup(value);  	value = g_hash_table_lookup(optlist, \"user\");  	if (value != NULL && *value != \'\\0\') rec->username = g_strdup(value);  	value = g_hash_table_lookup(optlist, \"realname\"); @@ -175,7 +180,7 @@ static void cmd_network_add_modify(const char *data, gboolean add)  	cmd_params_free(free_arg);  }   -/* SYNTAX: NETWORK ADD|MODIFY [-nick <nick>] [-user <user>] [-realname <name>] +/* SYNTAX: NETWORK ADD|MODIFY [-nick <nick>] [-alternate_nick <nick>] [-user <user>] [-realname <name>]                                [-host <host>] [-usermode <mode>] [-autosendcmd <cmd>]                                [-querychans <count>] [-whois <count>] [-msgs <count>]                                [-kicks <count>] [-modes <count>] [-cmdspeed <ms>] @@ -228,9 +233,9 @@ void fe_ircnet_init(void)  	command_bind(\"network remove\", NULL, (SIGNAL_FUNC) cmd_network_remove);    	command_set_options(\"network add\", \"-kicks -msgs -modes -whois -cmdspeed \" -			    \"-cmdmax -nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\"); +			    \"-cmdmax -nick -alternate_nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\");  	command_set_options(\"network modify\", \"-kicks -msgs -modes -whois -cmdspeed \" -			    \"-cmdmax -nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\"); +			    \"-cmdmax -nick -alternate_nick -user -realname -host -autosendcmd -querychans -usermode -sasl_mechanism -sasl_username -sasl_password\");  }    void fe_ircnet_deinit(void) '),('irssi','1.0.4','87955b69cb82314becf1aa9f66c707705f517d0f','Paul Townsend','Add alternate_nick as a network-specific property.','irc-servers-setup.c','153','53','8','1','MODIFY','@@ -69,7 +69,14 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,  		return;  	g_return_if_fail(IS_IRCNET(ircnet));   -	if (ircnet->nick != NULL) g_free_and_null(conn->alternate_nick); +	if (ircnet->nick != NULL) { +		g_free_and_null(conn->nick); +		conn->nick = g_strdup(ircnet->nick); +	} +	if (ircnet->alternate_nick != NULL) { +		g_free_and_null(conn->alternate_nick); +		conn->alternate_nick = g_strdup(ircnet->alternate_nick); +	}  	if (ircnet->usermode != NULL) {  		g_free_and_null(conn->usermode);  		conn->usermode = g_strdup(ircnet->usermode); '),('irssi','1.0.4','1e66cbd62e231f8ae47589cf4f1c0c6c62bb7ca8','Edward Tomasz Napierala','Improve Capsicum stdio limits to fix terminal state on exit.','capsicum.c','368','76','35','3','MODIFY','@@ -360,6 +360,38 @@ static void cmd_capsicum(const char *data, SERVER_REC *server, void *item)  	command_runsub(\"capsicum\", data, server, item);  }   +/* + * The main difference between this and caph_limit_stdio(3) is that this + * one permits TIOCSETAW, which is requred for restoring the terminal state + * on exit. + */ +static int +limit_stdio_fd(int fd) +{ +	cap_rights_t rights; +	unsigned long cmds[] = { TIOCGETA, TIOCGWINSZ, TIOCSETAW, FIODTYPE }; + +	cap_rights_init(&rights, CAP_READ, CAP_WRITE, CAP_EVENT, CAP_FCNTL, +	    CAP_FSTAT, CAP_IOCTL, CAP_SEEK); + +	if (cap_rights_limit(fd, &rights) < 0) { +		g_warning(\"cap_rights_limit(3) failed: %s\", strerror(errno)); +		return (-1); +	} + +	if (cap_ioctls_limit(fd, cmds, nitems(cmds)) < 0) { +		g_warning(\"cap_ioctls_limit(3) failed: %s\", strerror(errno)); +		return (-1); +	} + +	if (cap_fcntls_limit(fd, CAP_FCNTL_GETFL) < 0) { +		g_warning(\"cap_fcntls_limit(3) failed: %s\", strerror(errno)); +		return (-1); +	} + +	return (0); +} +  static void cmd_capsicum_enter(void)  {  	u_int mode; @@ -411,9 +443,9 @@ static void cmd_capsicum_enter(void)  	 */  	signal(SIGCHLD, SIG_IGN);   -	error = caph_limit_stdio(); -	if (error != 0) { -		g_warning(\"caph_limit_stdio(3) failed: %s\", strerror(errno)); +	if (limit_stdio_fd(STDIN_FILENO) != 0 || +	    limit_stdio_fd(STDOUT_FILENO) != 0 || +	    limit_stdio_fd(STDERR_FILENO) != 0) {  		signal_emit(\"capability mode failed\", 1, strerror(errno));  		return;  	} '),('irssi','1.0.4','5c0b4aeb0572827877654b65bb05fb7b37a3117a','Edward Tomasz Napierala','Sort Capsicum headers.','capsicum.c','369','76','3','2','MODIFY','@@ -32,13 +32,14 @@  #include \"settings.h\"  #include \"signals.h\"   -#include <sys/types.h> +#include <sys/param.h>  #include <sys/capsicum.h> +#include <sys/filio.h>  #include <sys/nv.h>  #include <sys/procdesc.h>  #include <sys/socket.h> -#include <capsicum_helpers.h>  #include <string.h> +#include <termios.h>    #define	OPCODE_CONNECT		1  #define	OPCODE_GETHOSTBYNAME	2 '),('irssi','1.0.4','9895e7b28a3767bbe4430cbffd3662b4ef92b37f','Edward Tomasz Napierala','Silence down a warning that would appear on \"/away\" in Capability mode.','capsicum.c','371','77','4','0','MODIFY','@@ -183,6 +183,10 @@ void capsicum_mkdir_with_parents(const char *path, int mode)  	char *component, *copy, *tofree;  	int error, fd, newfd;   +	/* The directory already exists, nothing to do. */ +	if (strcmp(path, irclogs_path) == 0) +		return; +  	/* +1 is for the slash separating irclogs_path and the rest. */  	if (strlen(path) <= irclogs_path_len + 1 ||  	    path[irclogs_path_len] != \'/\' || '),('irssi','1.0.4','711b2d7df7da4a3010214909ed1b260c55f6befa','Edward Tomasz Napierala','Document that one needs to change the awaylog_file path for \"/away\" to work with Capsicum.','capsicum.txt','25','0','1','0','MODIFY','@@ -7,6 +7,7 @@ or the libraries it depends on.  To make Irssi enter capability mode on startup, add    capsicum = \"yes\"; +awaylog_file = \"~/irclogs/away.log\";    to your ~/.irssi/config and restart the client.  Alternatively you can  enter it \"by hand\", using the \"/capsicum enter\" command.  From the security '),('irssi','1.0.4','da59fd7c2dd0641f623db2c67a244ddca3013d65','Will Storey','Revert \"Delete unused function net_ip_compare()\"  This reverts commit cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d.','network.c','365','97','12','0','MODIFY','@@ -57,6 +57,18 @@ IPADDR ip4_any = {  #endif  };   +int net_ip_compare(IPADDR *ip1, IPADDR *ip2) +{ +	if (ip1->family != ip2->family) +		return 0; + +	if (ip1->family == AF_INET6) +		return memcmp(&ip1->ip, &ip2->ip, sizeof(ip1->ip)) == 0; + +	return memcmp(&ip1->ip, &ip2->ip, 4) == 0; +} + +  static void sin_set_ip(union sockaddr_union *so, const IPADDR *ip)  {  	if (ip == NULL) { '),('irssi','1.0.4','da59fd7c2dd0641f623db2c67a244ddca3013d65','Will Storey','Revert \"Delete unused function net_ip_compare()\"  This reverts commit cb5f3cba1f2b5dbad67bcc107f3fe4a1875cc52d.','network.h','35','0','3','0','MODIFY','@@ -33,6 +33,9 @@ extern IPADDR ip4_any;    GIOChannel *g_io_channel_new(int handle);   +/* returns 1 if IPADDRs are the same */ +int net_ip_compare(IPADDR *ip1, IPADDR *ip2); +  int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);    /* Connect to socket with ip address and SSL*/ '),('irssi','1.0.4','233be9f580290ff3efa66e6256e46303b01781da','Will Storey','Mark net_ip_compare() deprecated','network.h','35','0','3','2','MODIFY','@@ -33,8 +33,9 @@ extern IPADDR ip4_any;    GIOChannel *g_io_channel_new(int handle);   -/* returns 1 if IPADDRs are the same */ -int net_ip_compare(IPADDR *ip1, IPADDR *ip2); +/* Returns 1 if IPADDRs are the same. */ +/* Deprecated since it is unused. It will be deleted in a later release. */ +int net_ip_compare(IPADDR *ip1, IPADDR *ip2) G_GNUC_DEPRECATED;    int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);   '),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','Changes based on comments in pull #771.','chatnet-rec.h','9','0','0','1','MODIFY','@@ -4,7 +4,6 @@ int chat_type; /* chat_protocol_lookup(xx) */  char *name;    char *nick; -char *alternate_nick;  char *username;  char *realname;   '),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','Changes based on comments in pull #771.','irc-chatnets.c','89','27','7','0','MODIFY','@@ -43,6 +43,9 @@ static void sig_chatnet_read(IRC_CHATNET_REC *rec, CONFIG_NODE *node)  	value = config_node_get_str(node, \"usermode\", NULL);  	rec->usermode = (value != NULL && *value != \'\\0\') ? g_strdup(value) : NULL;   +	value = config_node_get_str(node, \"alternate_nick\", NULL); +	rec->alternate_nick = (value != NULL && *value != \'\\0\') ? g_strdup(value) : NULL; +  	rec->max_cmds_at_once = config_node_get_int(node, \"cmdmax\", 0);  	rec->cmd_queue_speed = config_node_get_int(node, \"cmdspeed\", 0);  	rec->max_query_chans = config_node_get_int(node, \"max_query_chans\", 0); @@ -65,6 +68,9 @@ static void sig_chatnet_saved(IRC_CHATNET_REC *rec, CONFIG_NODE *node)  	if (rec->usermode != NULL)  		iconfig_node_set_str(node, \"usermode\", rec->usermode);   +	if (rec->alternate_nick != NULL) +		iconfig_node_set_str(node, \"alternate_nick\", rec->alternate_nick); +  	if (rec->max_cmds_at_once > 0)  		iconfig_node_set_int(node, \"cmdmax\", rec->max_cmds_at_once);  	if (rec->cmd_queue_speed > 0) @@ -93,6 +99,7 @@ static void sig_chatnet_destroyed(IRC_CHATNET_REC *rec)  {  	if (IS_IRC_CHATNET(rec)) {  		g_free(rec->usermode); +		g_free(rec->alternate_nick);  		g_free(rec->sasl_mechanism);  		g_free(rec->sasl_username);  		g_free(rec->sasl_password); '),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','Changes based on comments in pull #771.','irc-chatnets.h','17','0','1','0','MODIFY','@@ -18,6 +18,7 @@ struct _IRC_CHATNET_REC {  #include \"chatnet-rec.h\"    	char *usermode; +	char *alternate_nick;    	char *sasl_mechanism;  	char *sasl_username; '),('irssi','1.0.4','7b94015f8f3a7f9f9348a57243632a98cb5e2a56','Paul Townsend','Changes based on comments in pull #771.','irc-servers-setup.c','149','52','0','4','MODIFY','@@ -69,10 +69,6 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,  		return;  	g_return_if_fail(IS_IRCNET(ircnet));   -	if (ircnet->nick != NULL) { -		g_free_and_null(conn->nick); -		conn->nick = g_strdup(ircnet->nick); -	}  	if (ircnet->alternate_nick != NULL) {  		g_free_and_null(conn->alternate_nick);  		conn->alternate_nick = g_strdup(ircnet->alternate_nick); '),('irssi','1.0.4','45dfe2ba3889c5dc23a9bea3214f158cc651a043','LemonBoy','Prevent a OOB read when parsing IRCNet ! channels  Make sure the string has enough data. Fixes #16','channel-events.c','271','67','1','1','MODIFY','@@ -37,7 +37,7 @@ static void check_join_failure(IRC_SERVER_REC *server, const char *channel)  		channel++; /* server didn\'t understand !channels */    	chanrec = channel_find(SERVER(server), channel); -	if (chanrec == NULL && channel[0] == \'!\') { +	if (chanrec == NULL && channel[0] == \'!\' && strlen(channel) > 6) {  		/* it probably replied with the full !channel name,  		   find the channel with the short name.. */  		chan2 = g_strdup_printf(\"!%s\", channel+6); '),('irssi','1.0.4','9f0dc4766c7aa80e34aa2cde94323fb49971abdf','ailin-nemui','fix dcc issue','dcc-chat.c','620','143','21','0','MODIFY','@@ -66,6 +66,13 @@ CHAT_DCC_REC *dcc_chat_create(IRC_SERVER_REC *server,          dcc->id = dcc_chat_get_new_id(nick);    	dcc_init_rec(DCC(dcc), server, chat, nick, arg); +	if (dcc->module_data == NULL) { +		/* failed to successfully init; TODO: change init_rec API */ +		g_free(dcc->id); +		g_free(dcc); +		return NULL; +	} +          return dcc;  }   @@ -471,6 +478,7 @@ static void cmd_dcc_chat(const char *data, IRC_SERVER_REC *server)  			/* We are accepting a passive DCC CHAT. */  			dcc_chat_passive(dcc);  		} +		cmd_params_free(free_arg);  		return;  	}   @@ -485,6 +493,11 @@ static void cmd_dcc_chat(const char *data, IRC_SERVER_REC *server)  		cmd_param_error(CMDERR_NOT_CONNECTED);    	dcc = dcc_chat_create(server, NULL, nick, \"chat\"); +	if (dcc == NULL) { +		cmd_params_free(free_arg); +		g_warn_if_reached(); +		return; +	}    	if (g_hash_table_lookup(optlist, \"passive\") == NULL) {  		/* Standard DCC CHAT... let\'s listen for incoming connections */ @@ -627,6 +640,9 @@ static void ctcp_msg_dcc_chat(IRC_SERVER_REC *server, const char *data,  	}  	passive = paramcount == 4 && g_strcmp0(params[2], \"0\") == 0;   +	if (nick == NULL) +		nick = \"\"; +  	dcc = DCC_CHAT(dcc_find_request(DCC_CHAT_TYPE, nick, NULL));  	if (dcc != NULL) {  		if (dcc_is_listening(dcc)) { @@ -658,6 +674,11 @@ static void ctcp_msg_dcc_chat(IRC_SERVER_REC *server, const char *data,  	}    	dcc = dcc_chat_create(server, chat, nick, params[0]); +	if (dcc == NULL) { +		g_strfreev(params); +		g_warn_if_reached(); +		return; +	}  	dcc->target = g_strdup(target);  	dcc->port = atoi(params[2]);   '),('irssi','1.0.4','9f0dc4766c7aa80e34aa2cde94323fb49971abdf','ailin-nemui','fix dcc issue','dcc-get.c','440','98','15','2','MODIFY','@@ -43,6 +43,12 @@ GET_DCC_REC *dcc_get_create(IRC_SERVER_REC *server, CHAT_DCC_REC *chat,  	dcc->fhandle = -1;    	dcc_init_rec(DCC(dcc), server, chat, nick, arg); +	if (dcc->module_data == NULL) { +		/* failed to successfully init; TODO: change API */ +		g_free(dcc); +		return NULL; +	} +          return dcc;  }   @@ -430,9 +436,10 @@ static void ctcp_msg_dcc_send(IRC_SERVER_REC *server, const char *data,  	int p_id = -1;  	int passive = FALSE;   -	if (addr == NULL) { +	if (addr == NULL)  		addr = \"\"; -	} +	if (nick == NULL) +		nick = \"\";    	/* SEND <file name> <address> <port> <size> [...] */  	/* SEND <file name> <address> 0 <size> <id> (DCC SEND passive protocol) */ @@ -512,6 +519,12 @@ static void ctcp_msg_dcc_send(IRC_SERVER_REC *server, const char *data,  		dcc_destroy(DCC(dcc)); /* remove the old DCC */    	dcc = dcc_get_create(server, chat, nick, fname); +	if (dcc == NULL) { +		g_free(address); +		g_free(fname); +		g_warn_if_reached(); +		return; +	}  	dcc->target = g_strdup(target);    	if (passive && port == 0) '),('irssi','1.0.4','9f0dc4766c7aa80e34aa2cde94323fb49971abdf','ailin-nemui','fix dcc issue','dcc-send.c','352','75','10','0','MODIFY','@@ -237,6 +237,12 @@ static SEND_DCC_REC *dcc_send_create(IRC_SERVER_REC *server,  	dcc->queue = -1;    	dcc_init_rec(DCC(dcc), server, chat, nick, arg); +	if (dcc->module_data == NULL) { +		/* failed to successfully init; TODO: change API */ +		g_free(dcc); +		return NULL; +	} +          return dcc;  }   @@ -417,6 +423,10 @@ static int dcc_send_one_file(int queue, const char *target, const char *fname,    	dcc = dcc_send_create(server, chat, target, str);  	g_free(str); +	if (dcc == NULL) { +		g_warn_if_reached(); +		return FALSE; +	}    	dcc->handle = handle;  	dcc->port = port; '),('irssi','1.0.4','73d7b9d7753d35c63f24defe6d26c7c06ffa3cce','Joseph Bisch','Don\'t proceed with cmd_msg if there was an error splitting msg  There may be cases (such as if target or server->nick is very long) where the split_message function returns NULL, indicating an error. To avoid a potential segfault, we now check to see if splitmsgs is NULL.','chat-commands.c','385','117','4','1','MODIFY','@@ -404,7 +404,10 @@ static void cmd_msg(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  		else  			splitmsgs = singlemsg;   -		while ((m = splitmsgs[n++])) { +		/* splitmsgs may be NULL if there was an error */ +		g_warn_if_fail(splitmsgs != NULL); + +		while (splitmsgs && (m = splitmsgs[n++])) {  			signal_emit(\"server sendmsg\", 4, server, target, m,  				    GINT_TO_POINTER(target_type));  			signal_emit(target_type == SEND_TARGET_CHANNEL ? '),('irssi','1.0.4','beb2beba3b4802c6969a5595197e25e7a5483fa3','Joseph Bisch','Revert \"Don\'t proceed with cmd_msg if there was an error splitting msg\"  This reverts commit bd83852d646de28f2e0fe01efe7c9236aa4074d4.','chat-commands.c','384','117','1','4','MODIFY','@@ -404,10 +404,7 @@ static void cmd_msg(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  		else  			splitmsgs = singlemsg;   -		/* splitmsgs may be NULL if there was an error */ -		g_warn_if_fail(splitmsgs != NULL); - -		while (splitmsgs && (m = splitmsgs[n++])) { +		while ((m = splitmsgs[n++])) {  			signal_emit(\"server sendmsg\", 4, server, target, m,  				    GINT_TO_POINTER(target_type));  			signal_emit(target_type == SEND_TARGET_CHANNEL ? '),('irssi','1.0.4','0840eaec7bf56740029aae614e393f8cf76f6946','Joseph Bisch','Make split functions return an array with NULL instead of NULL  This avoids undefined behavior in functions that call these split functions and expect an array back instead of just a NULL pointer.','recode.c','229','62','6','1','MODIFY','@@ -198,7 +198,12 @@ char **recode_split(const SERVER_REC *server, const char *str,  	int n = 0;  	char **ret;   -	g_return_val_if_fail(str != NULL, NULL); +	g_warn_if_fail(str != NULL); +	if (str == NULL) { +		ret = g_new(char *, 1); +		ret[0] = NULL; +		return ret; +	}    	if (settings_get_bool(\"recode\")) {  		to = find_conversion(server, target); '),('irssi','1.0.4','0840eaec7bf56740029aae614e393f8cf76f6946','Joseph Bisch','Make split functions return an array with NULL instead of NULL  This avoids undefined behavior in functions that call these split functions and expect an array back instead of just a NULL pointer.','irc-servers.c','780','195','4','1','MODIFY','@@ -116,11 +116,14 @@ static char **split_line(const SERVER_REC *server, const char *line,  	 * the code much simpler.  It\'s worth it.  	 */  	len -= strlen(recoded_start) + strlen(recoded_end); +	g_warn_if_fail(len > 0);  	if (len <= 0) {  		/* There is no room for anything. */  		g_free(recoded_start);  		g_free(recoded_end); -		return NULL; +		lines = g_new(char *, 1); +		lines[0] = NULL; +		return lines;  	}    	lines = recode_split(server, line, target, len, onspace); '),('irssi','1.0.5','956bc592a94d5f4cce03f5762f1976d98de637ef','Will Storey','Fix a typo in the readme  Also uppercase Irssi in a couple places, and escape an argument not shown due to looking like an HTML tag','README.md','99','0','4','4','MODIFY','@@ -28,7 +28,7 @@ think of currently:     queries when msgs/notices are received or when you send a msg, closing     queries when it\'s been idle for some time, etc.   - - **Multiserver friendy** - I think Irssi has clearly the best support + - **Multiserver friendly** - I think Irssi has clearly the best support     for handling multiple server connections. You can have as many as you     want in as many ircnets as you want. Having several connections in one     server works too, for example when you hit the (ircnet\'s) 10 @@ -84,7 +84,7 @@ think of currently:     search command that jumps around in scrollback in GUI-style is still     missing from Irssi, but there\'s something that\'s almost as good as it.     /LASTLOG always shows timestamps when the line was printed, even if you -   didn\'t have timestamps on. Now doing /SB GOTO <timestamp> jumps +   didn\'t have timestamps on. Now doing /SB GOTO \\<timestamp\\> jumps     directly to the position in scrollback you wanted. Great feature when     you want to browse a bit of the discussion what happened when someone     said your name (as seen in awaylog) or topic was changed (/last @@ -96,9 +96,9 @@ think of currently:      - `startup-HOWTO.txt` - new users should read this      - `manual.txt` - manual I started writing but didn\'t get it very far :)      - `perl.txt` - Perl scripting help -    - `formats.txt` - How to use colors, etc. with irssi +    - `formats.txt` - How to use colors, etc. with Irssi      - `faq.txt` - Frequently Asked Questions -    - `special_vars.txt` - some predefined $variables you can use with irssi +    - `special_vars.txt` - some predefined $variables you can use with Irssi    ## Bugs / Suggestions   '),('irssi','1.0.5','816df6d153e937734bdac258ad6bf43173361451','ailin-nemui','Merge tag \'1.0.5\' into integrate/1.0.5','NEWS','2923','0','18','0','MODIFY','@@ -1,5 +1,23 @@  v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>   +v1.0.5 2017-10-23  The Irssi team <staff@irssi.org> +	- Fix missing -sasl_method \'\' in /NETWORK (#718, #719). +	- Fix incorrect restoration of term state when hitting SUSP +          inside screen (#737, #733). +	- Fix out of bounds read when compressing colour +          sequences. Found by Hanno BÃ¶ck (GL#12, GL!18). +	- Fix use after free condition during a race condition when +          waiting on channel sync during a rejoin (GL#13, GL!19). +	- Fix null pointer dereference when parsing certain malformed +          CTCP DCC messages (GL#14, GL!20). +	- Fix crash due to null pointer dereference when failing to +          split messages due to overlong nick or target (GL#15, GL!21). +	- Fix out of bounds read when trying to skip a safe channel ID +          without verifying that the ID is long enough (GL#16, GL!22). +	- Fix return of random memory when inet_ntop failed (#769). +	- Minor statusbar help update. By Robert Bisewski (#758, +          #763). +  v1.0.4 2017-07-07  The Irssi team <staff@irssi.org>  	- Fix null pointer dereference when parsing invalid timestamp (GL#10,  	  GL!15). Reported by Brian \'geeknik\' Carpenter. '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','.gitignore','54','0','1','0','MODIFY','@@ -33,6 +33,7 @@ docs/help/in/Makefile.am    src/fe-text/irssi  src/fe-fuzz/irssi-fuzz +src/fe-fuzz/irc/core/event-get-params-fuzz    src/fe-common/irc/irc-modules.c  src/irc/irc.c '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','configure.ac','700','4','2','0','MODIFY','@@ -648,6 +648,8 @@ src/fe-common/irc/Makefile  src/fe-common/irc/dcc/Makefile  src/fe-common/irc/notifylist/Makefile  src/fe-fuzz/Makefile +src/fe-fuzz/irc/Makefile +src/fe-fuzz/irc/core/Makefile  src/fe-none/Makefile  src/fe-text/Makefile  src/lib-config/Makefile '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','Makefile.am','19','0','2','0','MODIFY','@@ -1,3 +1,5 @@ +SUBDIRS = irc +  bin_PROGRAMS = irssi-fuzz    # Force link with CXX for libfuzzer support '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = core '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','Makefile.am','39','0','46','0','ADD','@@ -0,0 +1,46 @@ +bin_PROGRAMS = event-get-params-fuzz + +# Force link with CXX for libfuzzer support +CCLD=$(CXX) $(CXXFLAGS) + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core/ \\ +	-I$(top_srcdir)/src/irc/core/ \\ +	-I$(top_srcdir)/src/fe-common/core/ \\ +	$(GLIB_CFLAGS) + +AM_DEPENDENCIES = \\ +	../../../core/libcore.a \\ +	../../../lib-config/libirssi_config.a \\ +	../../../irc/libirc.a \\ +	../../../irc/core/libirc_core.a \\ +	../../../irc/dcc/libirc_dcc.a \\ +	../../../irc/flood/libirc_flood.a \\ +	../../../irc/notifylist/libirc_notifylist.a \\ +	../../../fe-common/core/libfe_common_core.a \\ +	../../../fe-common/irc/libfe_common_irc.a \\ +	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\ +	../../../fe-common/irc/notifylist/libfe_irc_notifylist a + +LDADD = \\ +	../../../irc/libirc.a \\ +	../../../irc/core/libirc_core.a \\ +	../../../irc/dcc/libirc_dcc.a \\ +	../../../irc/flood/libirc_flood.a \\ +	../../../irc/notifylist/libirc_notifylist.a \\ +	../../../fe-common/core/libfe_common_core.a \\ +	../../../fe-common/irc/libfe_common_irc.a \\ +	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\ +	../../../fe-common/irc/notifylist/libfe_irc_notifylist.a \\ +	../../../core/libcore.a \\ +	../../../lib-config/libirssi_config.a \\ +	@PROG_LIBS@ \\ +	$(FUZZER_LIBS) + +event_get_params_fuzz_SOURCES = \\ +        event-get-params.c \\ +	$(top_srcdir)/src/fe-text/module-formats.c + +noinst_HEADERS = \\ +	$(top_srcdir)/src/fe-text/module-formats.h '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','event-get-params.c','61','11','86','0','ADD','@@ -0,0 +1,86 @@ +/* + event-get-params.c : irssi + +    Copyright (C) 2017 Joseph Bisch + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"modules-load.h\" +#include \"levels.h\" +#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text +#include \"themes.h\" +#include \"core.h\" +#include \"fe-common-core.h\" +#include \"args.h\" +#include \"printtext.h\" +#include \"irc.h\" + +#include <stddef.h> +#include <stdint.h> +#include <stdlib.h> +#include <string.h> + +int LLVMFuzzerInitialize(int *argc, char ***argv) { +	core_register_options(); +	fe_common_core_register_options(); +	/* no args */ +	args_execute(0, NULL); +	core_preinit((*argv)[0]); +	core_init(); +	fe_common_core_init(); +	theme_register(gui_text_formats); +	module_register(\"core\", \"fe-fuzz\"); +	return 0; +} + +int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { +	if (size < 1) { +		return 0; +	} +	uint8_t count = *data; +	char *copy = (char *)malloc(sizeof(char)*(size-1+1)); +	memcpy(copy, data+1, size-1); +	copy[size-1] = \'\\0\'; + +	char *output0; +	char *output1; +	char *output2; +	char *output3; +	char *params; +	if (count % 8 == 0) { +		params = event_get_params(copy, 1 | PARAM_FLAG_GETREST, &output0); +	} else if (count % 8 == 1) { +		params = event_get_params(copy, 2 | PARAM_FLAG_GETREST, &output0, &output1); +	} else if (count % 8 == 2) { +		params = event_get_params(copy, 3 | PARAM_FLAG_GETREST, &output0, &output1, &output2); +	} else if (count % 8 == 3) { +		params = event_get_params(copy, 4 | PARAM_FLAG_GETREST, &output0, &output1, &output2, &output3); +	} else if (count % 8 == 4) { +		params = event_get_params(copy, 1, &output0); +	} else if (count % 8 == 5) { +		params = event_get_params(copy, 2, &output0, &output1); +	} else if (count % 8 == 6) { +		params = event_get_params(copy, 3, &output0, &output1, &output2); +	} else if (count % 8 == 7) { +		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3); +	} else { +		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3); +	} +	g_free(params); +	free(copy); +	return 0; +} '),('irssi','1.0.5','87550541e745627cc78507ce573d68b8453959c9','ailin-nemui','fix key length checker to actually do some work','autogen.sh','44','1','1','15','MODIFY','@@ -29,20 +29,6 @@ cat docs/help/in/Makefile.am.gen|sed \"s/@HELPFILES@/$files/g\"|sed \'s/?/\\\\?/g\'|tr  files=`echo $files|sed \'s/\\.in//g\'`  cat docs/help/Makefile.am.gen|sed \"s/@HELPFILES@/$files/g\"|sed \'s/?/\\\\?/g\'|tr \'!?\' \'\\t\\n\' > docs/help/Makefile.am   -# .html -> .txt with lynx or elinks -echo \"Documentation: html -> txt...\" -if type lynx >/dev/null 2>&1 ; then -  LC_ALL=en_IE.utf8 lynx -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt -elif type elinks >/dev/null 2>&1 ; then -  elinks -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt -elif type links >/dev/null 2>&1 ; then -  links -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt -else -  echo \"**Error**: No lynx or elinks present\" -  echo \"Install lynx or elinks, then run autogen.sh again\" -  exit 1 -fi -  if test x$NOCONFIGURE = x && test -z \"$*\"; then    echo \"**Warning**: I am going to run \\`configure\' with no arguments.\"    echo \"If you wish to pass any to it, please specify them on the\" @@ -65,4 +51,4 @@ else  fi    # make sure perl hashes have correct length -find src/perl -name *.c -o -name *.xs | xargs grep -n hv_store | perl -ne \'if (/\"(\\w+)\",\\s*(\\d+)/) { print unless $2 == length $1 }\' +find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\' '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','.gitignore','52','0','0','1','MODIFY','@@ -11,7 +11,6 @@ config.status  configure  default-config.h  default-theme.h -faq.txt  irssi-config  irssi-config.h  irssi-config.h.in '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','Makefile.am','16','0','2','1','MODIFY','@@ -11,7 +11,8 @@ doc_DATA = \\  	perl.txt \\  	signals.txt \\  	special_vars.txt \\ -	startup-HOWTO.html +	startup-HOWTO.html \\ +	startup-HOWTO.txt    EXTRA_DIST = $(doc_DATA) $(man_MANS)   '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','faq.html','42','0','3','1','MODIFY','@@ -1,4 +1,6 @@ +<base href=\'https://irssi.org/documentation/faq/\'>  <h1>Frequently Asked Questions</h1> +  <h3 id=\"q-why-doesnt-irssi-display-colors-even-when-ircii-etc-displays-them\">Q: Why doesnâ€™t irssi display colors even when ircii etc. displays them?</h3>    <p>A: They force ANSI colors even if terminal doesnâ€™t support them. By default, irssi uses colors only if terminfo/termcap so says. The correct way to fix this would be to change your TERM environment to a value where colors work, like xterm-color or color_xterm (eg. <code>TERM=xterm-color irssi</code>). If this doesnâ€™t help, then use the evil way of <code>/SET term_force_colors ON</code>.</p> @@ -77,4 +79,4 @@    <h3 id=\"q-how-to-pronounce-irssi\">Q: How to pronounce Irssi?</h3>   -<p>A: Check <a href=\"https://irssi.org/assets/irssi.wav\">here</a></p> +<p>A: Check <a href=\"/assets/irssi.wav\">here</a></p> \\ No newline at end of file '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','faq.txt','99','0','124','0','ADD','@@ -0,0 +1,124 @@ +   Frequently Asked Questions + +Q: Why doesnâ€™t irssi display colors even when ircii etc. displays them? +A: They force ANSI colors even if terminal doesnâ€™t support them. By default, +   irssi uses colors only if terminfo/termcap so says. The correct way to fix this +   would be to change your TERM environment to a value where colors work, like +   xterm-color or color_xterm (eg. TERM=xterm-color irssi). If this doesnâ€™t help, +   then use the evil way of /SET term_force_colors ON. + +Q: How do I easily write text to channel that starts with â€˜/â€™ character? +A: / /text + +Q: Why doesnâ€™t irssi update my realname (or whatever) after I change it with / +   SET realname and reconnect with /RECONNECT or /SERVER? +A: Irssi is trying to be too smart. This will be fixed in future, but for now +   you should use /DISCONNECT and /CONNECT. + +Q: I connected to some server which isnâ€™t responding but now irssi tries to +   connect back to it all the time! How can I stop it? +A: Two ways. The â€œgood wayâ€ to do it is with /DISCONNECT. Check the server tags +   first with /SERVER without giving it any parameters, reconnections are those +   that have tag starting with â€œreconâ€ text. So most probably youâ€™re going to do / +   DISCONNECT recon-1. The other way is to remove all the reconnections with / +   RMRECONNS, easier but may remove some connections you actually wanted to +   reconnect (if you used multiple servers..). + +Q: How do I add seconds to timestamp? +A: /FORMAT timestamp {timestamp %%H:%%M:%%S} - and remember to add the trailing +   space :) + +Q: Why does irssi say â€œIrssi: Channel not fully synchronized yet, try again +   after a whileâ€ when I try to use /BAN etc? +A: Possibly a bug in irssi, or ircd youâ€™re using does something that irssi +   didnâ€™t really notice. The new code should make this happen far less often than +   before, but one known reason for this is when irssi doesnâ€™t notice that you +   were unable to join some channel. Currently however I donâ€™t know of any such +   events irssi doesnâ€™t know about. + +   Anyway, if this does happen, do /RAWLOG SAVE ~/rawlog soon after joining to +   channel, and either try to figure out yourself why irssi didnâ€™t get reply to +   WHO request, or open a Github issue with the full log included. Note that the +   rawlog is by default only 200 lines and it may not be enough to show all needed +   information, so you might want to do /SET rawlog_lines 1000 or so. + +   MODE +b still works fine though. + +Q: Whereâ€™s the GUI version? +A: There was one on [1]irssi-import/xirssi but it has not been maintained for a +   long time. + +Q: How do I autorejoin channels after being kicked? +A: Thatâ€™s evil and you shouldnâ€™t do it. If you get kicked, you should stay out, +   at least until the channel forgot you existed :) Most channels Iâ€™ve joined just +   ban you if you autorejoin after kick. If youâ€™re joined to channels who kick +   people for fun, try changing channels or something. + +   Anyway, if you REALLY want to do that, and you understand that youâ€™re doing +   evilness, you can use the autorejoin.pl script that comes with irssi. Youâ€™ll +   still need to specify the channels you wish to rejoin with /SET +   autorejoin_channels #chan1 #chan2 ... + +Q: How do I announce that Iâ€™m away/back in all channels Iâ€™ve joined? Or how do +   I change my nick when setting myself away/back? +A: Thatâ€™s even worse than autorejoin. Who could possibly care every time you +   come and go? Many channels will kick you for using this, and I for example have +   added several ignores so Iâ€™d never need to see these messages. Learn to use / +   AWAY command properly and tell its existence to people who donâ€™t know about it. +   /WII yournick shows your away reason much better for people who actually want +   to know if youâ€™re there or not. + +Q: Why does irssi autojoin on invite by default? +A: The setting is /SET join_auto_chans_on_invite - itâ€™s not the same as regular +   autojoin-on-invite, which irssi doesnâ€™t even have. The only channels that are +   joined on invite, are the ones youâ€™ve added to config with /CHANNEL ADD -auto. +   This is very useful with +i channels when you need to first send an invite +   request to bot, or if you get accidentally kicked from channel, the kicker can +   invite you back immediately. + +   I donâ€™t see any bad side effects with this feature, so itâ€™s ON by default. I +   guess someone could start kicking/inviting you all the time but server +   connection shouldnâ€™t drop because of that, and you shouldnâ€™t join channels +   whose operators are that evil. + +Q: How to make UTF-8 support work with irssi? +A: Make sure your terminal supports UTF-8 (for example, xterm -u8). If you use +   screen, you may have to do screen -U. And in Irssi do /SET term_charset utf-8. +   (for 0.8.9 and older: /SET term_type utf-8) + +Q: Will there be /DETACH-like feature? +A: [2]tmux, [3]screen and [4]dtach can be used to do it just fine. + +Q: How do I run scripts automatically at startup? +A: Put them into ~/.irssi/scripts/autorun/ directory. Or better would be if you +   placed them in ~/.irssi/scripts/ and created symlinks to autorun directory (eg. +   cd ~/.irssi/scripts/autorun/ ; ln -s ../script.pl .) + +Q: How do I execute commands automatically at startup? +A: Put them into ~/.irssi/startup file, each command on its own line. The +   preceding slash (/) is not necessary. + +Q: How do I easily edit existing topic? +A: /TOPIC <tab> + +Q: How can I have /WHOIS replies to active window? +A: You can disable the status window, or do /WINDOW LEVEL -CRAP in it which +   would also make several other messages show up in active window. You can also +   use a [5]script. + +Q: How do I add the active network to the statusbar +A: Modify the window-line in statusbar section in config file to window = \"{sb +   $winref:$tag/$T{sbmode $M}}\"; + +Q: How to pronounce Irssi? +A: Check [6]here + + +   References: + +   [1] https://github.com/irssi-import/xirssi +   [2] http://tmux.github.io/ +   [3] http://www.gnu.org/software/screen/screen.html +   [4] http://dtach.sf.net/ +   [5] http://dgl.cx/irssi/hack-whois-in-current-window.pl +   [6] https://irssi.org/assets/irssi.wav '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','startup-HOWTO.html','475','0','267','243','MODIFY','@@ -1,4 +1,6 @@ -                    <h1>Startup How-To</h1> +<base href=\'https://irssi.org/documentation/startup/\'> +<h1>Startup How-To</h1> +  <h3 id=\"to-new-irssi-users-not-to-new-irc-users-\">To new Irssi users (not to new IRC users ..)</h3>    <p>Copyright (c) 2000-2002 by Timo Sirainen, release under <a href=\"http://www.gnu.org/licenses/fdl.html\">GNU FDL</a> 1.1 license.</p> @@ -6,11 +8,7 @@  <p>Index with some FAQ questions that are answered in the chapter:</p>    <ol> -  <li><a href=\"#for-all-the-ircii-people\">For all the ircII people</a> -    <ul> -      <li>This window management is just weird, I want it exactly like ircII</li> -    </ul> -  </li> +  <li><a href=\"#first-steps\">First steps</a></li>    <li><a href=\"#basic-user-interface-usage\">Basic user interface usage</a>      <ul>        <li>Split windows work in weird way</li> @@ -50,7 +48,11 @@      </ul>    </li>    <li><a href=\"#proxies-and-irc-bouncers\">Proxies and IRC bouncers</a></li> -  <li><a href=\"#irssis-settings\">Irssiâ€™s settings</a></li> +  <li><a href=\"#irssis-settings\">Irssiâ€™s settings</a> +    <ul> +      <li><a href=\"#for-all-the-ircii-people\">For all the ircII people</a></li> +    </ul> +  </li>    <li><a href=\"#statusbar\">Statusbar</a>      <ul>        <li>I loaded a statusbar script but itâ€™s not visible anywhere!</li> @@ -58,169 +60,176 @@    </li>  </ol>   -<h2 id=\"for-all-the-ircii-people\">1. For all the ircII people</h2> +<h2 id=\"first-steps\">1. First steps</h2>   -<p>These settings should give you pretty good defaults (the ones I use):</p> +<p>IRC Networks are made of servers, and servers have channels. The default config has a few predefined networks, to list them:</p>   -<p>If colors donâ€™t work, and you know youâ€™re not going to use some weird non-VT compatible terminal (you most probably arenâ€™t), just say:</p> +<div><div><pre><code>/NETWORK LIST +</code></pre></div></div>   -<pre><code> /SET term_force_colors ON -</code></pre> +<p>And to connect to one of those networks and join a channel:</p>   -<p>I donâ€™t like automatic query windows, I donâ€™t like status window, I do like msgs window where all messages go:</p> +<div><div><pre><code>/CONNECT Freenode +/JOIN #irssi +</code></pre></div></div>   -<pre><code> /SET autocreate_own_query OFF - /SET autocreate_query_level DCCMSGS - /SET use_status_window OFF - /SET use_msgs_window ON -</code></pre> +<p>To add more networks:</p>   -<p>Disable automatic window closing when <code>/PART</code>ing channel or <code>/UNQUERY</code>ing query:</p> +<div><div><pre><code>/NETWORK ADD ExampleNet +</code></pre></div></div>   -<pre><code> /SET autoclose_windows OFF - /SET reuse_unused_windows ON -</code></pre> +<p>Then add some servers (with -auto to automatically connect):</p>   -<p>Hereâ€™s the settings that make irssi work exactly like ircII in window management (send me a note if you can think of more):</p> +<div><div><pre><code>/SERVER ADD -auto -network ExampleNet irc.example.net +</code></pre></div></div>   -<pre><code> /SET autocreate_own_query OFF - /SET autocreate_query_level NONE - /SET use_status_window OFF - /SET use_msgs_window OFF - /SET reuse_unused_windows ON - /SET windows_auto_renumber OFF +<p>Automatically join to channels after connected to server:</p>   - /SET autostick_split_windows OFF - /SET autoclose_windows OFF - /SET print_active_channel ON -</code></pre> +<div><div><pre><code>/CHANNEL ADD -auto #lounge ExampleNet +</code></pre></div></div>   -<p>And example how to add servers:</p> +<p>To modify existing networks (or servers, or channels) just ADD again using the same name as before. This configures a network to identify with nickserv and wait for 2 seconds before joining channels:</p>   -<p>(OFTC network, identify with nickserv and wait for 2 seconds before joining channels)</p> +<div><div><pre><code>/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" ExampleNet +</code></pre></div></div>   -<pre><code> /NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC -</code></pre> +<p>If you have irssi 0.8.18 or higher and the irc network supports it, you can use SASL instead of nickserv, which is more reliable:</p>   -<p>(NOTE: use /IRCNET with 0.8.9 and older)</p> +<div><div><pre><code>/NETWORK ADD -sasl_username yourname -sasl_password yourpassword -sasl_mechanism PLAIN Freenode +</code></pre></div></div>   -<p>Then add some servers to different networks (network is already set up for them), irc.kpnqwest.fi is used by default for IRCNet but if it fails, irc.funet.fi is tried next:</p> +<p>These commands have many more options, see their help for details:</p>   -<pre><code> /SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 - /SERVER ADD -network IRCnet irc.funet.fi 6667 - /SERVER ADD -auto -network efnet efnet.cs.hut.fi 6667 -</code></pre> +<div><div><pre><code>/HELP NETWORK +/HELP SERVER +/HELP CHANNEL +/HELP +</code></pre></div></div>   -<p>Automatically join to channels after connected to server, send op request to bot after joined to efnet/#irssi:</p> +<p>If you want lines containing your nick to hilight:</p>   -<pre><code> /CHANNEL ADD -auto #irssi IRCnet - /CHANNEL ADD -auto -bots *!*bot@host.org -botcmd \"/^msg $0 op pass\" #irssi efnet -</code></pre> +<div><div><pre><code>/HILIGHT nick +</code></pre></div></div>   -<p>If you want lines containing your nick to hilight:</p> +<p>Or, for irssi 0.8.18 or higher:</p> + +<div><div><pre><code>/SET hilight_nick_matches_everywhere ON +</code></pre></div></div> + +<p>To get beeps on private messages or highlights:</p> + +<div><div><pre><code>/SET beep_msg_level MSGS HILIGHT DCCMSGS +</code></pre></div></div>   -<pre><code> /HILIGHT nick -</code></pre> +<p>No other irssi settings are needed (donâ€™t enable bell_beeps), but there may be settings to change in your terminal multiplexer (screen/tmux), your terminal, or your desktop environment.</p>    <h2 id=\"basic-user-interface-usage\">2. Basic user interface usage</h2>    <p>Windows can be scrolled up/down with PgUp and PgDown keys. If they donâ€™t work for you, use Meta-p and Meta-n keys. For jumping to beginning or end of the buffer, use <code>/SB HOME</code> and <code>/SB END</code> commands.</p>   -<p>By default, irssi uses â€œhidden windowsâ€ for everything. Hidden window is created every time you <code>/JOIN</code> a channel or <code>/QUERY</code> someone. Thereâ€™s several ways you can change between these windows:</p> +<p>By default, irssi uses â€œhidden windowsâ€ for everything. Hidden windows are created every time you <code>/JOIN</code> a channel or <code>/QUERY</code> someone. Thereâ€™s several ways you can change between these windows:</p>   -<pre><code> Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10 - Meta-q .. Meta-o          - Jump directly between windows 11-19 - /WINDOW &lt;number&gt;          - Jump to any window with specified number - Ctrl-P, Ctrl-N            - Jump to previous / next window -</code></pre> +<div><div><pre><code>Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10 +Meta-q .. Meta-o          - Jump directly between windows 11-19 +/WINDOW &lt;number&gt;          - Jump to any window with specified number +Ctrl-P, Ctrl-N            - Jump to previous / next window +</code></pre></div></div>   -<p>Clearly the easiest way is to use Meta-number keys. And what is the Meta key? ESC key always works as Meta, but thereâ€™s also easier ways. ALT could work as Meta, or if you have Windows keyboard, left Windows key might work as Meta. If they donâ€™t work directly, youâ€™ll need to set a few X resources (NOTE: these work with both xterm and rxvt):</p> +<p>Clearly the easiest way is to use Meta-number keys. Meta usually means the ALT key, but if that doesnâ€™t work, you can use ESC.</p>   -<pre><code> XTerm*eightBitInput:   false +<p>Mac OS X users with ALT key issues might prefer using <a href=\"https://www.iterm2.com/\">iTerm2</a> instead of the default terminal emulator.</p> + +<h3 id=\"alt-key-as-meta-for-xtermrxvt-users\">Alt key as meta, for xterm/rxvt users</h3> + +<p>If you use xterm or rxvt, you may need to set a few X resources:</p> + +<div><div><pre><code> XTerm*eightBitInput:   false   XTerm*metaSendsEscape: true -</code></pre> +</code></pre></div></div>    <p>With rxvt, you can also specify which key acts as Meta key. So if you want to use ALT instead of Windows key for it, use:</p>   -<pre><code> rxvt*modifier: alt -</code></pre> +<div><div><pre><code> rxvt*modifier: alt +</code></pre></div></div>    <p>You could do this by changing the X key mappings:</p>   -<pre><code> xmodmap -e \"keysym Alt_L = Meta_L Alt_L\" -</code></pre> +<div><div><pre><code> xmodmap -e \"keysym Alt_L = Meta_L Alt_L\" +</code></pre></div></div>    <p>And how exactly do you set these X resources? For Debian, thereâ€™s <code>/etc/X11/Xresources/xterm</code> file where you can put them and itâ€™s read automatically when X starts. <code>~/.Xresources</code> and <code>~/.Xdefaults</code> files might also work. If you canâ€™t get anything else to work, just copy and paste those lines to <code>~/.Xresources</code> and directly call <code>xrdb -merge ~/.Xresources</code> in some xterm. The resources affect only the new xterms you start, not existing ones.</p>   -<p>Many windows SSH clients also donâ€™t allow usage of ALT. One excellent client that does allow is putty, you can download it from <a href=\"http://www.chiark.greenend.org.uk/~sgtatham/putty/\"> http://www.chiark.greenend.org.uk/~sgtatham/putty/</a>.</p> +<h3 id=\"split-windows-and-window-items\">Split windows and window items</h3> + +<p><em>Note: <a href=\"http://quadpoint.org/articles/irssisplit/\">this guide</a> might be a better introduction to window splits</em></p>    <p>Irssi also supports split windows, theyâ€™ve had some problems in past but I think they should work pretty well now :) Hereâ€™s some commands related to them:</p>   -<pre><code> /WINDOW NEW                    - Create new split window - /WINDOW NEW HIDE               - Create new hidden window - /WINDOW CLOSE                  - Close split or hidden window +<div><div><pre><code>/WINDOW NEW                    - Create new split window +/WINDOW NEW HIDE               - Create new hidden window +/WINDOW CLOSE                  - Close split or hidden window   - /WINDOW HIDE [&lt;number&gt;|&lt;name&gt;] - Make the split window hidden window - /WINDOW SHOW &lt;number&gt;|&lt;name&gt;   - Make the hidden window a split window +/WINDOW HIDE [&lt;number&gt;|&lt;name&gt;] - Make the split window hidden window +/WINDOW SHOW &lt;number&gt;|&lt;name&gt;   - Make the hidden window a split window   - /WINDOW SHRINK [&lt;lines&gt;]       - Shrink the split window - /WINDOW GROW [&lt;lines&gt;]         - Grow the split window - /WINDOW BALANCE                - Balance the sizes of all split windows -</code></pre> +/WINDOW SHRINK [&lt;lines&gt;]       - Shrink the split window +/WINDOW GROW [&lt;lines&gt;]         - Grow the split window +/WINDOW BALANCE                - Balance the sizes of all split windows +</code></pre></div></div>    <p>By default, irssi uses â€œsticky windowingâ€ for split windows. This means that windows created inside one split window cannot be moved to another split window without some effort. For example you could have following window layout:</p>   -<pre><code> Split window 1: win#1 - Status window, win#2 - Messages window +<div><div><pre><code> Split window 1: win#1 - Status window, win#2 - Messages window   Split window 2: win#3 - IRCnet/#channel1, win#4 - IRCnet/#channel2   Split window 3: win#5 - efnet/#channel1, win#6 - efnet/#channel2 -</code></pre> +</code></pre></div></div>    <p>When you are in win#1 and press ALT-6, irssi jumps to split window #3 and moves the efnet/#channel2 the active window.</p>    <p>With non-sticky windowing the windows donâ€™t have any relationship with split windows, pressing ALT-6 in win#1 moves win#6 to split window 1 and sets it active, except if win#6 was already visible in some other split window irssi just changes to that split window. This it the way windows work with ircii, if you prefer it you can set it with</p>   -<pre><code> /SET autostick_split_windows OFF -</code></pre> +<div><div><pre><code>/SET autostick_split_windows OFF +</code></pre></div></div>    <p>Each window can have multiple channels, queries and other â€œwindow itemsâ€ inside them. If you donâ€™t like windows at all, you disable automatic creating of them with</p>   -<pre><code> /SET autocreate_windows OFF -</code></pre> +<div><div><pre><code>/SET autocreate_windows OFF +</code></pre></div></div>    <p>And if you keep all channels in one window, you most probably want the channel name printed in each line:</p>   -<pre><code> /SET print_active_channel ON -</code></pre> +<div><div><pre><code>/SET print_active_channel ON +</code></pre></div></div>    <p>If you want to group only some channels or queries in one window, use</p>   -<pre><code> /JOIN -window #channel - /QUERY -window nick -</code></pre> +<div><div><pre><code>/JOIN -window #channel +/QUERY -window nick +</code></pre></div></div>    <h2 id=\"server-and-channel-automation\">3. Server and channel automation</h2>    <p>Irssiâ€™s multiple IRC network support is IMHO very good - at least compared to other clients :) Even if youâ€™re only in one IRC network you should group all your servers to be in the same IRC network as this helps with reconnecting if your primary server breaks and is probably useful in some other ways too :) For information how to actually use irssi correctly with multiple servers see the chapter 6.</p>   -<p>First you need to have your IRC network set, use <code>/NETWORK</code> command to see if itâ€™s already there. If it isnâ€™t, use <code>/NETWORK ADD yournetwork</code>. If you want to execute some commands automatically when youâ€™re connected to some network, use <code>-autosendcmd</code> option. (NOTE: use /IRCNET with 0.8.9 and older.) Hereâ€™s some examples:</p> +<p>First you need to have your IRC network set, use <code>/NETWORK</code> command to see if itâ€™s already there. If it isnâ€™t, use <code>/NETWORK ADD yournetwork</code>. If you want to execute some commands automatically when youâ€™re connected to some network, use <code>-autosendcmd</code> option. Hereâ€™s some examples:</p>   -<pre><code> /NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet - /NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC -</code></pre> +<div><div><pre><code>/NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet +/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC +</code></pre></div></div>    <p>After that you need to add your servers. For example:</p>   -<pre><code> /SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 - /SERVER ADD -auto -network worknet irc.mycompany.com 6667 password -</code></pre> +<div><div><pre><code>/SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 +/SERVER ADD -auto -network worknet irc.mycompany.com 6667 password +</code></pre></div></div>    <p>The <code>-auto</code> option specifies that this server is automatically connected at startup. You donâ€™t need to make more than one server with <code>-auto</code> option to one IRC network, other servers are automatically connected in same network if the <code>-auto</code> server fails.</p>    <p>And finally channels:</p>   -<pre><code> /CHANNEL ADD -auto -bots *!*bot@host.org -botcmd \"/^msg $0 op pass\" #irssi efnet - /CHANNEL ADD -auto #secret IRCnet password -</code></pre> +<div><div><pre><code>/CHANNEL ADD -auto -bots *!*user@host -botcmd \"/^msg $0 op pass\" #irssi efnet +/CHANNEL ADD -auto #secret IRCnet password +</code></pre></div></div>    <p><code>-bots</code> and <code>-botcmd</code> should be the only ones needing a bit of explaining. Theyâ€™re used to send commands automatically to bot when channel is joined, usually to get ops automatically. You can specify multiple bot masks with <code>-bots</code> option separated with spaces (and remember to quote the string then). The $0 in <code>-botcmd</code> specifies the first found bot in the list. If you donâ€™t need the bot masks (ie. the bot is always with the same nick, like chanserv) you can give only the <code>-botcmd</code> option and the command is always sent.</p>   @@ -228,9 +237,9 @@    <p>First connect to all the servers, join the channels and create the queries you want. If you want to move the windows or channels around use commands:</p>   -<pre><code> /WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere - /WINDOW ITEM MOVE &lt;number&gt;|&lt;name&gt; - move channel/query to another window -</code></pre> +<div><div><pre><code>/WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere +/WINDOW ITEM MOVE &lt;number&gt;|&lt;name&gt; - move channel/query to another window +</code></pre></div></div>    <p>When everything looks the way you like, use <code>/LAYOUT SAVE</code> command (and <code>/SAVE</code>, if you donâ€™t have autosaving enabled) and when you start irssi next time, irssi remembers the positions of the channels, queries and everything. This â€œrememberingâ€ doesnâ€™t mean that simply using <code>/LAYOUT SAVE</code> would automatically make irssi reconnect to all servers and join all channels, youâ€™ll need the <code>/SERVER ADD -auto</code> and <code>/CHANNEL ADD -auto</code> commands to do that.</p>   @@ -240,32 +249,32 @@    <p>By default, all the â€œextra messagesâ€ go to status window. This means pretty much all messages that donâ€™t clearly belong to some channel or query. Some people like it, some donâ€™t. If you want to remove it, use</p>   -<pre><code> /SET use_status_window OFF -</code></pre> +<div><div><pre><code>/SET use_status_window OFF +</code></pre></div></div>    <p>This doesnâ€™t have any effect until you restart irssi. If you want to remove it immediately, just <code>/WINDOW CLOSE</code> it.</p>    <p>Another common window is â€œmessages windowâ€, where all private messages go. By default itâ€™s disabled and query windows are created instead. To make all private messages go to msgs window, say:</p>   -<pre><code> /SET use_msgs_window ON - /SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to +<div><div><pre><code>/SET use_msgs_window ON +/SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to   				      dcc chats either, say NONE) -</code></pre> +</code></pre></div></div>    <p>use_msgs_window either doesnâ€™t have any effect until restarting irssi. To create it immediately say:</p>   -<pre><code> /WINDOW NEW HIDE     - create the window - /WINDOW NAME (msgs)  - name it to \"(msgs)\" - /WINDOW LEVEL MSGS   - make all private messages go to this window - /WINDOW MOVE 1       - move it to first window -</code></pre> +<div><div><pre><code>/WINDOW NEW HIDE     - create the window +/WINDOW NAME (msgs)  - name it to \"(msgs)\" +/WINDOW LEVEL MSGS   - make all private messages go to this window +/WINDOW MOVE 1       - move it to first window +</code></pre></div></div>    <p>Note that neither use_msgs_window nor use_status_window have any effect at all if <code>/LAYOUT SAVE</code> has been used.</p>    <p>This brings us to message levels.. What are they? All messages that irssi prints have one or more â€œmessage levelsâ€. Most common are PUBLIC for public messages in channels, MSGS for private messages and CRAP for all sorts of messages with no real classification. You can get a whole list of levels with</p>   -<pre><code> /HELP levels -</code></pre> +<div><div><pre><code>/HELP levels +</code></pre></div></div>    <p>Status window has message level <code>ALL -MSGS</code>, meaning that all messages, except private messages, without more specific place go to status window. The <code>-MSGS</code> is there so it doesnâ€™t conflict with messages window.</p>   @@ -273,15 +282,15 @@    <p>ircii and several other clients support multiple servers by placing the connection into some window. IRSSI DOES NOT. There is no required relationship between window and server. You can connect to 10 servers and manage them all in just one window, or join channel in each one of them to one single window if you really want to. That being said, hereâ€™s how you do connect to new server without closing the old connection:</p>   -<pre><code> /CONNECT irc.server.org -</code></pre> +<div><div><pre><code>/CONNECT irc.server.org +</code></pre></div></div>    <p>Instead of the <code>/SERVER</code> which disconnects the existing connection. To see list of all active connections, use <code>/SERVER</code> without any parameters. You should see a list of something like:</p>   -<pre><code> -!- IRCNet: irc.song.fi:6667 (IRCNet) +<div><div><pre><code> -!- IRCNet: irc.song.fi:6667 (IRCNet)   -!- OFTC: irc.oftc.net:6667 (OFTC)   -!- RECON-1: 192.168.0.1:6667 () (02:59 left before reconnecting) -</code></pre> +</code></pre></div></div>    <p>Here you see that weâ€™re connected to IRCNet and OFTC networks. The IRCNet at the beginning is called the â€œserver tagâ€ while the (IRCnet) at the end shows the IRC network. Server tag specifies unique tag to refer to the server, usually itâ€™s the same as the IRC network. When the IRC network isnâ€™t known itâ€™s some part of the server name. When thereâ€™s multiple connections to same IRC network or server, irssi adds a number after the tag so there could be network, network2, network3 etc.</p>   @@ -289,63 +298,63 @@    <p>To disconnect one of the servers, or to stop irssi from reconnecting, use</p>   -<pre><code> /DISCONNECT network   - disconnect server with tag \"network\" - /DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server - /RMRECONNS           - stop all server reconnections +<div><div><pre><code>/DISCONNECT network   - disconnect server with tag \"network\" +/DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server +/RMRECONNS           - stop all server reconnections   - /RECONNECT recon-1   - immediately try reconnecting back to RECON-1 - /RECONNECT ALL       - immediately try reconnecting back to all +/RECONNECT recon-1   - immediately try reconnecting back to RECON-1 +/RECONNECT ALL       - immediately try reconnecting back to all   		       servers in reconnection queue -</code></pre> +</code></pre></div></div>    <p>Now that youâ€™re connected to all your servers, youâ€™ll have to know how to specify which one of them you want to use. One way is to have an empty window, like status or msgs window. In it, you can specify which server to set active with</p>   -<pre><code> /WINDOW SERVER tag    - set server \"tag\" active - Ctrl-X                - set the next server in list active -</code></pre> +<div><div><pre><code>/WINDOW SERVER tag    - set server \"tag\" active +Ctrl-X                - set the next server in list active +</code></pre></div></div>    <p>When the server is active, you can use it normally. When thereâ€™s multiple connected servers, irssi adds [servertag] prefix to all messages in non-channel/query messages so youâ€™ll know where it came from.</p>    <p>Several commands also accept <code>-servertag</code> option to specify which server it should use:</p>   -<pre><code> /MSG -tag nick message - /JOIN -tag #channel - /QUERY -tag nick -</code></pre> +<div><div><pre><code>/MSG -tag nick message +/JOIN -tag #channel +/QUERY -tag nick +</code></pre></div></div>    <p><code>/MSG</code> tab completion also automatically adds the <code>-tag</code> option when nick isnâ€™t in active server.</p>    <p>Windowâ€™s server can be made sticky. When sticky, it will never automatically change to anything else, and if server gets disconnected, the window wonâ€™t have any active server. When the server gets connected again, it is automatically set active in the window. To set the windowâ€™s server sticky use</p>   -<pre><code> /WINDOW SERVER -sticky tag -</code></pre> +<div><div><pre><code>/WINDOW SERVER -sticky tag +</code></pre></div></div>    <p>This is useful if you wish to have multiple status or msgs windows, one for each server. Hereâ€™s how to do them (repeat for each server)</p>   -<pre><code> /WINDOW NEW HIDE - /WINDOW NAME (status) - /WINDOW LEVEL ALL -MSGS - /WINDOW SERVER -sticky network +<div><div><pre><code>/WINDOW NEW HIDE +/WINDOW NAME (status) +/WINDOW LEVEL ALL -MSGS +/WINDOW SERVER -sticky network   - /WINDOW NEW HIDE - /WINDOW NAME (msgs) - /WINDOW LEVEL MSGS - /WINDOW SERVER -sticky network -</code></pre> +/WINDOW NEW HIDE +/WINDOW NAME (msgs) +/WINDOW LEVEL MSGS +/WINDOW SERVER -sticky network +</code></pre></div></div>    <h2 id=\"lastlog-and-jumping-around-in-scrollback\">7. /LASTLOG and jumping around in scrollback</h2>    <p><code>/LASTLOG</code> command can be used for searching texts in scrollback buffer. Simplest usages are</p>   -<pre><code> /LASTLOG word     - print all lines with \"word\" in them - /LASTLOG word 10  - print last 10 occurances of \"word\" - /LASTLOG -topics  - print all topic changes -</code></pre> +<div><div><pre><code>/LASTLOG word     - print all lines with \"word\" in them +/LASTLOG word 10  - print last 10 occurances of \"word\" +/LASTLOG -topics  - print all topic changes +</code></pre></div></div>    <p>If thereâ€™s more than 1000 lines to be printed, irssi thinks that you probably made some mistake and wonâ€™t print them without <code>-force</code> option. If you want to save the full lastlog to file, use</p>   -<pre><code> /LASTLOG -file ~/irc.log -</code></pre> +<div><div><pre><code>/LASTLOG -file ~/irc.log +</code></pre></div></div>    <p>With <code>-file</code> option you donâ€™t need <code>-force</code> even if thereâ€™s more than 1000 lines. <code>/LASTLOG</code> has a lot of other options too, see <code>/HELP lastlog</code> for details.</p>   @@ -355,29 +364,29 @@    <p>Irssi can automatically log important messages when youâ€™re set away (<code>/AWAY reason</code>). When you set yourself unaway (<code>/AWAY</code>), the new messages in away log are printed to screen. You can configure it with:</p>   -<pre><code> /SET awaylog_level MSGS HILIGHT     - Specifies what messages to log - /SET awaylog_file ~/.irssi/away.log - Specifies the file to use -</code></pre> +<div><div><pre><code>/SET awaylog_level MSGS HILIGHT     - Specifies what messages to log +/SET awaylog_file ~/.irssi/away.log - Specifies the file to use +</code></pre></div></div>    <p>Easiest way to start logging with Irssi is to use autologging. With it Irssi logs all channels and private messages to specified directory. You can turn it on with</p>   -<pre><code> /SET autolog ON -</code></pre> +<div><div><pre><code>/SET autolog ON +</code></pre></div></div>    <p>By default it logs pretty much everything execept CTCPS or CRAP (<code>/WHOIS</code> requests, etc). You can specify the logging level yourself with</p>   -<pre><code> /SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default) -</code></pre> +<div><div><pre><code>/SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default) +</code></pre></div></div>    <p>By default irssi logs to ~/irclogs/<servertag>/<target>.log. You can change this with</target></servertag></p>   -<pre><code> /SET autolog_path ~/irclogs/$tag/$0.log (this is the default) -</code></pre> +<div><div><pre><code>/SET autolog_path ~/irclogs/$tag/$0.log (this is the default) +</code></pre></div></div>    <p>The path is automatically created if it doesnâ€™t exist. $0 specifies the target (channel/nick). You can make irssi automatically rotate the logs by adding date/time formats to the file name. The formats are in â€œman strftimeâ€ format. For example</p>   -<pre><code> /SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log -</code></pre> +<div><div><pre><code>/SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log +</code></pre></div></div>    <p>For logging only some specific channels or nicks, see <code>/HELP log</code></p>   @@ -387,16 +396,16 @@    <p><code>/HELP bind</code> tells pretty much everything there is to know about keyboard bindings. However, thereâ€™s the problem of how to bind some non-standard keys. They might differ a bit with each terminal, so youâ€™ll need to find out what exactly the keypress produces. Easiest way to check that would be to see what it prints in <code>cat</code>. Hereâ€™s an example for pressing F1 key:</p>   -<pre><code> [cras@hurina] ~% cat +<div><div><pre><code> [user@host] ~% cat   ^[OP -</code></pre> +</code></pre></div></div>    <p>So in irssi you would use <code>/BIND ^[OP /ECHO F1 pressed</code>. If you use multiple terminals which have different bindings for the key, it would be better to use eg.:</p>   -<pre><code> /BIND ^[OP key F1 - /BIND ^[11~ key F1 - /BIND F1 /ECHO F1 pressed. -</code></pre> +<div><div><pre><code>/BIND ^[OP key F1 +/BIND ^[11~ key F1 +/BIND F1 /ECHO F1 pressed. +</code></pre></div></div>    <h2 id=\"proxies-and-irc-bouncers\">10. Proxies and IRC bouncers</h2>   @@ -404,20 +413,20 @@    <p>Hereâ€™s an example: You have your bouncer (lets say, BNC or BNC-like) listening in irc.bouncer.org port 5000. You want to use it to connect to servers irc.dalnet and irc.efnet.org. First youâ€™d need to setup the bouncer:</p>   -<pre><code> /SET use_proxy ON - /SET proxy_address irc.bouncer.org - /SET proxy_port 5000 +<div><div><pre><code>/SET use_proxy ON +/SET proxy_address irc.bouncer.org +/SET proxy_port 5000   - /SET proxy_password YOUR_BNC_PASSWORD_HERE - /SET -clear proxy_string - /SET proxy_string_after conn %s %d -</code></pre> +/SET proxy_password YOUR_BNC_PASSWORD_HERE +/SET -clear proxy_string +/SET proxy_string_after conn %s %d +</code></pre></div></div>    <p>Then youâ€™ll need to add the server connections. These are done exactly as if youâ€™d want to connect directly to them. Nothing special about them:</p>   -<pre><code> /SERVER ADD -auto -network dalnet irc.dal.net - /SERVER ADD -auto -network efnet irc.efnet.org -</code></pre> +<div><div><pre><code>/SERVER ADD -auto -network dalnet irc.dal.net +/SERVER ADD -auto -network efnet irc.efnet.org +</code></pre></div></div>    <p>With the proxy <code>/SET</code>s however, irssi now connects to those servers through your BNC. All server connections are made through them so you can just forget that your bouncer even exists.</p>   @@ -427,36 +436,36 @@    <p>All proxies have these settings in common:</p>   -<pre><code> /SET use_proxy ON - /SET proxy_address &lt;Proxy host address&gt; - /SET proxy_port &lt;Proxy port&gt; -</code></pre> +<div><div><pre><code>/SET use_proxy ON +/SET proxy_address &lt;Proxy host address&gt; +/SET proxy_port &lt;Proxy port&gt; +</code></pre></div></div>    <p><strong>HTTP proxy</strong></p>    <p>Use these settings with HTTP proxies:</p>   -<pre><code> /SET -clear proxy_password - /EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n -</code></pre> +<div><div><pre><code>/SET -clear proxy_password +/EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n +</code></pre></div></div>    <p><strong>BNC</strong></p>   -<pre><code> /SET proxy_password your_pass - /SET -clear proxy_string - /SET proxy_string_after conn %s %d -</code></pre> +<div><div><pre><code>/SET proxy_password your_pass +/SET -clear proxy_string +/SET proxy_string_after conn %s %d +</code></pre></div></div>    <p><strong>dircproxy</strong></p>    <p>dircproxy separates the server connections by passwords. So, if you for example have network connection with password ircpass and OFTC connection with oftcpass, you would do something like this:</p>   -<pre><code> /SET -clear proxy_password - /SET -clear proxy_string +<div><div><pre><code>/SET -clear proxy_password +/SET -clear proxy_string   - /SERVER ADD -auto -network IRCnet fake.network 6667 ircpass - /SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass -</code></pre> +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass +</code></pre></div></div>    <p>The server name and port you give isnâ€™t used anywhere, so you can put anything you want in there.</p>   @@ -464,19 +473,17 @@    <p>psyBNC has internal support for multiple servers. However, it could be a bit annoying to use, and some people just use different users for connecting to different servers. You can manage this in a bit same way as with dircproxy, by creating fake connections:</p>   -<pre><code> /SET -clear proxy_password - /SET -clear proxy_string +<div><div><pre><code>/SET -clear proxy_password +/SET -clear proxy_string   - /NETWORK ADD -user networkuser IRCnet - /SERVER ADD -auto -network IRCnet fake.network 6667 ircpass - /NETWORK ADD -user oftcuser OFTC - /SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass -</code></pre> +/NETWORK ADD -user networkuser IRCnet +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/NETWORK ADD -user oftcuser OFTC +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass +</code></pre></div></div>    <p>So, youâ€™ll specify the usernames with <code>/NETWORK ADD</code> command, and the userâ€™s password with <code>/SERVER ADD</code>.</p>   -<p>(NOTE: use /IRCNET with 0.8.9 and older.)</p> -  <p><strong>Irssi proxy</strong></p>    <p>Irssi contains itâ€™s own proxy which you can build giving <code>\\--with-proxy</code> option to configure. Youâ€™ll still need to run irssi in a screen to use it though.</p> @@ -487,65 +494,52 @@    <p>Usage in proxy side:</p>   -<pre><code> /LOAD proxy - /SET irssiproxy_password &lt;password&gt; - /SET irssiproxy_ports &lt;network&gt;=&lt;port&gt; ... (eg. IRCnet=2777 efnet=2778) -</code></pre> +<div><div><pre><code>/LOAD proxy +/SET irssiproxy_password &lt;password&gt; +/SET irssiproxy_ports &lt;network&gt;=&lt;port&gt; ... (eg. IRCnet=2777 efnet=2778) +</code></pre></div></div>    <p><strong>NOTE</strong>: you <strong>MUST</strong> add all the servers you are using to server and network lists with <code>/SERVER ADD</code> and <code>/NETWORK ADD</code>. ..Except if you really donâ€™t want to for some reason, and you only use one server connection, you may simply set:</p>   -<pre><code> /SET irssiproxy_ports *=2777 -</code></pre> - -<p>The special network name <code>?</code> allows the client to select the -network dynamically on connect (see below):</p> - -<pre> -/SET irssiproxy_ports ?=2777 -</pre> +<div><div><pre><code>/SET irssiproxy_ports *=2777 +</code></pre></div></div>    <p>Usage in client side:</p>    <p>Just connect to the irssi proxy like it is a normal server with password specified in <code>/SET irssiproxy_password</code>. For example:</p>   -<pre><code> /SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret - /SERVER ADD -network efnet my.irssi-proxy.org 2778 secret -</code></pre> - -<p>Or, if you used <code>?</code> in <code>irssiproxy_ports</code>:</p> - -<pre> -/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 IRCnet:secret -/SERVER ADD -network efnet my.irssi-proxy.org 2777 efnet:secret -</pre> - -<p>I.e. the network to connect to is specified as part of the password, -separated by <code>:</code> from the actual proxy password.</p> +<div><div><pre><code>/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret +/SERVER ADD -network efnet my.irssi-proxy.org 2778 secret +</code></pre></div></div>    <p>Irssi proxy works fine with other IRC clients as well.</p>    <p><strong>SOCKS</strong></p>   -<p>Irssi can be compiled with socks support (<code>\\--with-socks</code> option to configure), but I donâ€™t really know how it works, if at all. <code>/SET proxy</code> settings donâ€™t have anything to do with socks however.</p> +<p>Irssi can be compiled with socks support (<code>\\--with-socks</code> option to configure), which requires â€œdanteâ€ and routes all connections through the proxy specified in the system-wide /etc/socks.conf. This method is known to have issues in Mac OS X.</p> + +<p>Note that <code>/SET proxy</code> settings donâ€™t have anything to do with socks.</p> + +<p>Using <a href=\"https://github.com/rofl0r/proxychains-ng\">proxychains-ng</a> is recommended over recompiling irssi.</p>    <p><strong>Others</strong></p>    <p>IRC bouncers usually work like IRC servers, and want a password. You can give it with:</p>   -<pre><code> /SET proxy_password &lt;password&gt; -</code></pre> +<div><div><pre><code>/SET proxy_password &lt;password&gt; +</code></pre></div></div>    <p>Irssiâ€™s defaults for connect strings are</p>   -<pre><code> /SET proxy_string CONNECT %s %d - /SET proxy_string_after -</code></pre> +<div><div><pre><code>/SET proxy_string CONNECT %s %d +/SET proxy_string_after +</code></pre></div></div>    <p>The proxy_string is sent before NICK/USER commands, the proxy_string_after is sent after them. %s and %d can be used with both of them.</p>    <h2 id=\"irssis-settings\">11. Irssiâ€™s settings</h2>   -<p>You probably donâ€™t like Irssiâ€™s default settings. I donâ€™t like them. But Iâ€™m still convinced that theyâ€™re pretty good defaults. Hereâ€™s some of them you might want to change (the default value is shown): Also check the <a href=\"/documentation/settings/\">Settings Documentation</a></p> +<p>Hereâ€™s some settings you might want to change (the default value is shown): Also check the <a href=\"/documentation/settings/\">Settings Documentation</a></p>    <p><strong>Queries</strong></p>   @@ -633,31 +627,61 @@ separated by <code>:</code> from the actual proxy password.</p>    <dd>Completion character to use.</dd>  </dl>   +<h3 id=\"for-all-the-ircii-people\">For all the ircII people</h3> + +<p>I donâ€™t like automatic query windows, I donâ€™t like status window, I do like msgs window where all messages go:</p> + +<div><div><pre><code>/SET autocreate_own_query OFF +/SET autocreate_query_level DCCMSGS +/SET use_status_window OFF +/SET use_msgs_window ON +</code></pre></div></div> + +<p>Disable automatic window closing when <code>/PART</code>ing channel or <code>/UNQUERY</code>ing query:</p> + +<div><div><pre><code>/SET autoclose_windows OFF +/SET reuse_unused_windows ON +</code></pre></div></div> + +<p>Hereâ€™s the settings that make irssi work exactly like ircII in window management (send me a note if you can think of more):</p> + +<div><div><pre><code>/SET autocreate_own_query OFF +/SET autocreate_query_level NONE +/SET use_status_window OFF +/SET use_msgs_window OFF +/SET reuse_unused_windows ON +/SET windows_auto_renumber OFF + +/SET autostick_split_windows OFF +/SET autoclose_windows OFF +/SET print_active_channel ON +</code></pre></div></div> +  <h2 id=\"statusbar\">12. Statusbar</h2>   -<p><code>/STATUSBAR</code> displays a list of statusbars:</p> +<p><code>/STATUSBAR</code> displays a list of the current statusbars, along with their position and visibility:</p>   -<pre><code> Name                           Type   Placement Position Visible +<div><div><pre><code> Name                           Type   Placement Position Visible   window                         window bottom    0        always   window_inact                   window bottom    1        inactive   prompt                         root   bottom    100      always   topic                          root   top       1        always -</code></pre> +</code></pre></div></div>   -<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings and itâ€™s items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to itâ€™s default settings, or if the statusbar was created by you, it will be removed.</p> +<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings (type, placement, position, visibility) as well as its items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to its default settings, or if the statusbar was created by you, it will be removed.</p>   -<p>Type can be window or root, meaning if the statusbar should be created for each split window, or just once. Placement can be top or bottom. Position is a number, the higher the value the lower in screen it is. Visible can be always, active or inactive. Active/inactive is useful only with split windows, one split window is active and the rest are inactive. These settings can be changed with:</p> +<p>The statusbar type can be either window or root. If the type is window, then a statusbar will be created for each split window, otherwise it will be created only once. Placement can be top or bottom, which refers to the top or bottom of the screen. Position is a number, the higher the value the lower it will appear in-screen. Visible can be always, active or inactive. Active/inactive is useful only with split windows; one split window is active and the rest are inactive. To adjust these settings, the following commands are available:</p>   -<pre><code> /STATUSBAR &lt;name&gt; TYPE window|root - /STATUSBAR &lt;name&gt; PLACEMENT top|bottom - /STATUSBAR &lt;name&gt; POSITION &lt;num&gt; - /STATUSBAR &lt;name&gt; VISIBLE always|active|inactive -</code></pre> +<div><div><pre><code>/STATUSBAR &lt;name&gt; TYPE window|root +/STATUSBAR &lt;name&gt; PLACEMENT top|bottom +/STATUSBAR &lt;name&gt; POSITION &lt;num&gt; +/STATUSBAR &lt;name&gt; VISIBLE always|active|inactive +</code></pre></div></div>   -<p>When loading a new statusbar scripts, youâ€™ll need to also specify where you want to show it. Statusbar items can be modified with:</p> +<p>Statusbar items can also be added or removed via command. Note that when loading new statusbar scripts that add items, you will need to specify where you want to show the item and how it is aligned. This can be accomplished using the below commands:</p>   -<pre><code> /STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt; - /STATUSBAR &lt;name&gt; REMOVE &lt;item&gt; -</code></pre> +<div><div><pre><code>/STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt; +/STATUSBAR &lt;name&gt; REMOVE &lt;item&gt; +</code></pre></div></div>   -<p>The item name with statusbar scripts is usually same as the scriptâ€™s name. Scriptâ€™s documentation should tell if this isnâ€™t the case. So, to add mail.pl before the window activity item (see the list with <code>/STATUSBAR</code> window), use: <code>/STATUSBAR window ADD -before act mail</code>.</p> +<p>For statusbar scripts, the item name is usually equivalent to the script name. The documentation of the script ought to tell you if this is not the case. For example, to add mail.pl before the window activity item, use: <code>/STATUSBAR window ADD -before act mail</code>.</p> \\ No newline at end of file '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','startup-HOWTO.txt','582','0','797','0','ADD','@@ -0,0 +1,797 @@ +Startup How-To + +To new Irssi users (not to new IRC users ..) + +Copyright (c) 2000-2002 by Timo Sirainen, release under [1]GNU FDL 1.1 license. + +Index with some FAQ questions that are answered in the chapter: + + 1. First steps + 2. Basic user interface usage +      â–¡ Split windows work in weird way +      â–¡ How can I easily switch between windows? +      â–¡ But alt-1 etc. donâ€™t work! + 3. Server and channel automation +      â–¡ How do I automatically connect to servers at startup? +      â–¡ How do I automatically join to channels at startup? +      â–¡ How do I automatically send commands to server at connect? + 4. Setting up windows and automatically restoring them at startup + 5. Status and msgs windows & message levels +      â–¡ I want /WHOIS to print reply to current window +      â–¡ I want all messages to go to one window, not create new windows + 6. How support for multiple servers works in irssi +      â–¡ I connected to some server that doesnâ€™t respond and now irssi keeps +        trying to reconnect to it again and again, how can I stop it?? +      â–¡ I want to have own status and/or msgs window for each servers + 7. /LASTLOG and jumping around in scrollback +      â–¡ How can I save all texts in a window to file? + 8. Logging + 9. Changing keyboard bindings +      â–¡ How do I make F1 key do something? +10. Proxies and IRC bouncers +11. Irssiâ€™s settings +      â–¡ For all the ircII people +12. Statusbar +      â–¡ I loaded a statusbar script but itâ€™s not visible anywhere! + +1. First steps + +IRC Networks are made of servers, and servers have channels. The default config +has a few predefined networks, to list them: + +/NETWORK LIST + +And to connect to one of those networks and join a channel: + +/CONNECT Freenode +/JOIN #irssi + +To add more networks: + +/NETWORK ADD ExampleNet + +Then add some servers (with -auto to automatically connect): + +/SERVER ADD -auto -network ExampleNet irc.example.net + +Automatically join to channels after connected to server: + +/CHANNEL ADD -auto #lounge ExampleNet + +To modify existing networks (or servers, or channels) just ADD again using the +same name as before. This configures a network to identify with nickserv and +wait for 2 seconds before joining channels: + +/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" ExampleNet + +If you have irssi 0.8.18 or higher and the irc network supports it, you can use +SASL instead of nickserv, which is more reliable: + +/NETWORK ADD -sasl_username yourname -sasl_password yourpassword -sasl_mechanism PLAIN Freenode + +These commands have many more options, see their help for details: + +/HELP NETWORK +/HELP SERVER +/HELP CHANNEL +/HELP + +If you want lines containing your nick to hilight: + +/HILIGHT nick + +Or, for irssi 0.8.18 or higher: + +/SET hilight_nick_matches_everywhere ON + +To get beeps on private messages or highlights: + +/SET beep_msg_level MSGS HILIGHT DCCMSGS + +No other irssi settings are needed (donâ€™t enable bell_beeps), but there may be +settings to change in your terminal multiplexer (screen/tmux), your terminal, +or your desktop environment. + +2. Basic user interface usage + +Windows can be scrolled up/down with PgUp and PgDown keys. If they donâ€™t work +for you, use Meta-p and Meta-n keys. For jumping to beginning or end of the +buffer, use /SB HOME and /SB END commands. + +By default, irssi uses â€œhidden windowsâ€ for everything. Hidden windows are +created every time you /JOIN a channel or /QUERY someone. Thereâ€™s several ways +you can change between these windows: + +Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10 +Meta-q .. Meta-o          - Jump directly between windows 11-19 +/WINDOW <number>          - Jump to any window with specified number +Ctrl-P, Ctrl-N            - Jump to previous / next window + +Clearly the easiest way is to use Meta-number keys. Meta usually means the ALT +key, but if that doesnâ€™t work, you can use ESC. + +Mac OS X users with ALT key issues might prefer using [2]iTerm2 instead of the +default terminal emulator. + +Alt key as meta, for xterm/rxvt users + +If you use xterm or rxvt, you may need to set a few X resources: + + XTerm*eightBitInput:   false + XTerm*metaSendsEscape: true + +With rxvt, you can also specify which key acts as Meta key. So if you want to +use ALT instead of Windows key for it, use: + + rxvt*modifier: alt + +You could do this by changing the X key mappings: + + xmodmap -e \"keysym Alt_L = Meta_L Alt_L\" + +And how exactly do you set these X resources? For Debian, thereâ€™s /etc/X11/ +Xresources/xterm file where you can put them and itâ€™s read automatically when X +starts. ~/.Xresources and ~/.Xdefaults files might also work. If you canâ€™t get +anything else to work, just copy and paste those lines to ~/.Xresources and +directly call xrdb -merge ~/.Xresources in some xterm. The resources affect +only the new xterms you start, not existing ones. + +Split windows and window items + +Note: [3]this guide might be a better introduction to window splits + +Irssi also supports split windows, theyâ€™ve had some problems in past but I +think they should work pretty well now :) Hereâ€™s some commands related to them: + +/WINDOW NEW                    - Create new split window +/WINDOW NEW HIDE               - Create new hidden window +/WINDOW CLOSE                  - Close split or hidden window + +/WINDOW HIDE [<number>|<name>] - Make the split window hidden window +/WINDOW SHOW <number>|<name>   - Make the hidden window a split window + +/WINDOW SHRINK [<lines>]       - Shrink the split window +/WINDOW GROW [<lines>]         - Grow the split window +/WINDOW BALANCE                - Balance the sizes of all split windows + +By default, irssi uses â€œsticky windowingâ€ for split windows. This means that +windows created inside one split window cannot be moved to another split window +without some effort. For example you could have following window layout: + + Split window 1: win#1 - Status window, win#2 - Messages window + Split window 2: win#3 - IRCnet/#channel1, win#4 - IRCnet/#channel2 + Split window 3: win#5 - efnet/#channel1, win#6 - efnet/#channel2 + +When you are in win#1 and press ALT-6, irssi jumps to split window #3 and moves +the efnet/#channel2 the active window. + +With non-sticky windowing the windows donâ€™t have any relationship with split +windows, pressing ALT-6 in win#1 moves win#6 to split window 1 and sets it +active, except if win#6 was already visible in some other split window irssi +just changes to that split window. This it the way windows work with ircii, if +you prefer it you can set it with + +/SET autostick_split_windows OFF + +Each window can have multiple channels, queries and other â€œwindow itemsâ€ inside +them. If you donâ€™t like windows at all, you disable automatic creating of them +with + +/SET autocreate_windows OFF + +And if you keep all channels in one window, you most probably want the channel +name printed in each line: + +/SET print_active_channel ON + +If you want to group only some channels or queries in one window, use + +/JOIN -window #channel +/QUERY -window nick + +3. Server and channel automation + +Irssiâ€™s multiple IRC network support is IMHO very good - at least compared to +other clients :) Even if youâ€™re only in one IRC network you should group all +your servers to be in the same IRC network as this helps with reconnecting if +your primary server breaks and is probably useful in some other ways too :) For +information how to actually use irssi correctly with multiple servers see the +chapter 6. + +First you need to have your IRC network set, use /NETWORK command to see if +itâ€™s already there. If it isnâ€™t, use /NETWORK ADD yournetwork. If you want to +execute some commands automatically when youâ€™re connected to some network, use +-autosendcmd option. Hereâ€™s some examples: + +/NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet +/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC + +After that you need to add your servers. For example: + +/SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 +/SERVER ADD -auto -network worknet irc.mycompany.com 6667 password + +The -auto option specifies that this server is automatically connected at +startup. You donâ€™t need to make more than one server with -auto option to one +IRC network, other servers are automatically connected in same network if the +-auto server fails. + +And finally channels: + +/CHANNEL ADD -auto -bots *!*user@host -botcmd \"/^msg $0 op pass\" #irssi efnet +/CHANNEL ADD -auto #secret IRCnet password + +-bots and -botcmd should be the only ones needing a bit of explaining. Theyâ€™re +used to send commands automatically to bot when channel is joined, usually to +get ops automatically. You can specify multiple bot masks with -bots option +separated with spaces (and remember to quote the string then). The $0 in +-botcmd specifies the first found bot in the list. If you donâ€™t need the bot +masks (ie. the bot is always with the same nick, like chanserv) you can give +only the -botcmd option and the command is always sent. + +4. Setting up windows and automatically restoring them at startup + +First connect to all the servers, join the channels and create the queries you +want. If you want to move the windows or channels around use commands: + +/WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere +/WINDOW ITEM MOVE <number>|<name> - move channel/query to another window + +When everything looks the way you like, use /LAYOUT SAVE command (and /SAVE, if +you donâ€™t have autosaving enabled) and when you start irssi next time, irssi +remembers the positions of the channels, queries and everything. This +â€œrememberingâ€ doesnâ€™t mean that simply using /LAYOUT SAVE would automatically +make irssi reconnect to all servers and join all channels, youâ€™ll need the / +SERVER ADD -auto and /CHANNEL ADD -auto commands to do that. + +If you want to change the layout, you just rearrange the layout like you want +it and use /LAYOUT SAVE again. If you want to remove the layout for some +reason, use /LAYOUT RESET. + +5. Status and msgs windows & message levels + +By default, all the â€œextra messagesâ€ go to status window. This means pretty +much all messages that donâ€™t clearly belong to some channel or query. Some +people like it, some donâ€™t. If you want to remove it, use + +/SET use_status_window OFF + +This doesnâ€™t have any effect until you restart irssi. If you want to remove it +immediately, just /WINDOW CLOSE it. + +Another common window is â€œmessages windowâ€, where all private messages go. By +default itâ€™s disabled and query windows are created instead. To make all +private messages go to msgs window, say: + +/SET use_msgs_window ON +/SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to +                                      dcc chats either, say NONE) + +use_msgs_window either doesnâ€™t have any effect until restarting irssi. To +create it immediately say: + +/WINDOW NEW HIDE     - create the window +/WINDOW NAME (msgs)  - name it to \"(msgs)\" +/WINDOW LEVEL MSGS   - make all private messages go to this window +/WINDOW MOVE 1       - move it to first window + +Note that neither use_msgs_window nor use_status_window have any effect at all +if /LAYOUT SAVE has been used. + +This brings us to message levels.. What are they? All messages that irssi +prints have one or more â€œmessage levelsâ€. Most common are PUBLIC for public +messages in channels, MSGS for private messages and CRAP for all sorts of +messages with no real classification. You can get a whole list of levels with + +/HELP levels + +Status window has message level ALL -MSGS, meaning that all messages, except +private messages, without more specific place go to status window. The -MSGS is +there so it doesnâ€™t conflict with messages window. + +6. How support for multiple servers works in irssi + +ircii and several other clients support multiple servers by placing the +connection into some window. IRSSI DOES NOT. There is no required relationship +between window and server. You can connect to 10 servers and manage them all in +just one window, or join channel in each one of them to one single window if +you really want to. That being said, hereâ€™s how you do connect to new server +without closing the old connection: + +/CONNECT irc.server.org + +Instead of the /SERVER which disconnects the existing connection. To see list +of all active connections, use /SERVER without any parameters. You should see a +list of something like: + + -!- IRCNet: irc.song.fi:6667 (IRCNet) + -!- OFTC: irc.oftc.net:6667 (OFTC) + -!- RECON-1: 192.168.0.1:6667 () (02:59 left before reconnecting) + +Here you see that weâ€™re connected to IRCNet and OFTC networks. The IRCNet at +the beginning is called the â€œserver tagâ€ while the (IRCnet) at the end shows +the IRC network. Server tag specifies unique tag to refer to the server, +usually itâ€™s the same as the IRC network. When the IRC network isnâ€™t known itâ€™s +some part of the server name. When thereâ€™s multiple connections to same IRC +network or server, irssi adds a number after the tag so there could be network, +network2, network3 etc. + +Server tags beginning with RECON- mean server reconnections. Above we see that +connection to server at 192.168.0.1 wasnâ€™t successful and irssi will try to +connect it again in 3 minutes. + +To disconnect one of the servers, or to stop irssi from reconnecting, use + +/DISCONNECT network   - disconnect server with tag \"network\" +/DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server +/RMRECONNS           - stop all server reconnections + +/RECONNECT recon-1   - immediately try reconnecting back to RECON-1 +/RECONNECT ALL       - immediately try reconnecting back to all +                       servers in reconnection queue + +Now that youâ€™re connected to all your servers, youâ€™ll have to know how to +specify which one of them you want to use. One way is to have an empty window, +like status or msgs window. In it, you can specify which server to set active +with + +/WINDOW SERVER tag    - set server \"tag\" active +Ctrl-X                - set the next server in list active + +When the server is active, you can use it normally. When thereâ€™s multiple +connected servers, irssi adds [servertag] prefix to all messages in non-channel +/query messages so youâ€™ll know where it came from. + +Several commands also accept -servertag option to specify which server it +should use: + +/MSG -tag nick message +/JOIN -tag #channel +/QUERY -tag nick + +/MSG tab completion also automatically adds the -tag option when nick isnâ€™t in +active server. + +Windowâ€™s server can be made sticky. When sticky, it will never automatically +change to anything else, and if server gets disconnected, the window wonâ€™t have +any active server. When the server gets connected again, it is automatically +set active in the window. To set the windowâ€™s server sticky use + +/WINDOW SERVER -sticky tag + +This is useful if you wish to have multiple status or msgs windows, one for +each server. Hereâ€™s how to do them (repeat for each server) + +/WINDOW NEW HIDE +/WINDOW NAME (status) +/WINDOW LEVEL ALL -MSGS +/WINDOW SERVER -sticky network + +/WINDOW NEW HIDE +/WINDOW NAME (msgs) +/WINDOW LEVEL MSGS +/WINDOW SERVER -sticky network + +7. /LASTLOG and jumping around in scrollback + +/LASTLOG command can be used for searching texts in scrollback buffer. Simplest +usages are + +/LASTLOG word     - print all lines with \"word\" in them +/LASTLOG word 10  - print last 10 occurances of \"word\" +/LASTLOG -topics  - print all topic changes + +If thereâ€™s more than 1000 lines to be printed, irssi thinks that you probably +made some mistake and wonâ€™t print them without -force option. If you want to +save the full lastlog to file, use + +/LASTLOG -file ~/irc.log + +With -file option you donâ€™t need -force even if thereâ€™s more than 1000 lines. / +LASTLOG has a lot of other options too, see /HELP lastlog for details. + +Once youâ€™ve found the lines you were interested in, you might want to check the +discussion around them. Irssi has /SCROLLBACK (or alias /SB) command for +jumping around in scrollback buffer. Since /LASTLOG prints the timestamp when +the message was originally printed, you can use /SB GOTO hh:mm to jump directly +there. To get back to the bottom of scrollback, use /SB END command. + +8. Logging + +Irssi can automatically log important messages when youâ€™re set away (/AWAY +reason). When you set yourself unaway (/AWAY), the new messages in away log are +printed to screen. You can configure it with: + +/SET awaylog_level MSGS HILIGHT     - Specifies what messages to log +/SET awaylog_file ~/.irssi/away.log - Specifies the file to use + +Easiest way to start logging with Irssi is to use autologging. With it Irssi +logs all channels and private messages to specified directory. You can turn it +on with + +/SET autolog ON + +By default it logs pretty much everything execept CTCPS or CRAP (/WHOIS +requests, etc). You can specify the logging level yourself with + +/SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default) + +By default irssi logs to ~/irclogs//.log. You can change this with + +/SET autolog_path ~/irclogs/$tag/$0.log (this is the default) + +The path is automatically created if it doesnâ€™t exist. $0 specifies the target +(channel/nick). You can make irssi automatically rotate the logs by adding date +/time formats to the file name. The formats are in â€œman strftimeâ€ format. For +example + +/SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log + +For logging only some specific channels or nicks, see /HELP log + +9. Changing keyboard bindings + +You can change any keyboard binding that terminal lets irssi know about. It +doesnâ€™t let irssi know everything, so for example shift-backspace canâ€™t be +bound unless you modify xterm resources somehow. + +/HELP bind tells pretty much everything there is to know about keyboard +bindings. However, thereâ€™s the problem of how to bind some non-standard keys. +They might differ a bit with each terminal, so youâ€™ll need to find out what +exactly the keypress produces. Easiest way to check that would be to see what +it prints in cat. Hereâ€™s an example for pressing F1 key: + + [user@host] ~% cat + ^[OP + +So in irssi you would use /BIND ^[OP /ECHO F1 pressed. If you use multiple +terminals which have different bindings for the key, it would be better to use +eg.: + +/BIND ^[OP key F1 +/BIND ^[11~ key F1 +/BIND F1 /ECHO F1 pressed. + +10. Proxies and IRC bouncers + +Irssi supports connecting to IRC servers via a proxy. All server connections +are then made through it, and if youâ€™ve set up everything properly, you donâ€™t +need to do any /QUOTE SERVER commands manually. + +Hereâ€™s an example: You have your bouncer (lets say, BNC or BNC-like) listening +in irc.bouncer.org port 5000. You want to use it to connect to servers +irc.dalnet and irc.efnet.org. First youâ€™d need to setup the bouncer: + +/SET use_proxy ON +/SET proxy_address irc.bouncer.org +/SET proxy_port 5000 + +/SET proxy_password YOUR_BNC_PASSWORD_HERE +/SET -clear proxy_string +/SET proxy_string_after conn %s %d + +Then youâ€™ll need to add the server connections. These are done exactly as if +youâ€™d want to connect directly to them. Nothing special about them: + +/SERVER ADD -auto -network dalnet irc.dal.net +/SERVER ADD -auto -network efnet irc.efnet.org + +With the proxy /SETs however, irssi now connects to those servers through your +BNC. All server connections are made through them so you can just forget that +your bouncer even exists. + +If you donâ€™t want to use the proxy for some reason, thereâ€™s -noproxy option +which you can give to /SERVER and /SERVER ADD commands. + +Proxy specific settings: + +All proxies have these settings in common: + +/SET use_proxy ON +/SET proxy_address <Proxy host address> +/SET proxy_port <Proxy port> + +HTTP proxy + +Use these settings with HTTP proxies: + +/SET -clear proxy_password +/EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n + +BNC + +/SET proxy_password your_pass +/SET -clear proxy_string +/SET proxy_string_after conn %s %d + +dircproxy + +dircproxy separates the server connections by passwords. So, if you for example +have network connection with password ircpass and OFTC connection with +oftcpass, you would do something like this: + +/SET -clear proxy_password +/SET -clear proxy_string + +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass + +The server name and port you give isnâ€™t used anywhere, so you can put anything +you want in there. + +psyBNC + +psyBNC has internal support for multiple servers. However, it could be a bit +annoying to use, and some people just use different users for connecting to +different servers. You can manage this in a bit same way as with dircproxy, by +creating fake connections: + +/SET -clear proxy_password +/SET -clear proxy_string + +/NETWORK ADD -user networkuser IRCnet +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/NETWORK ADD -user oftcuser OFTC +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass + +So, youâ€™ll specify the usernames with /NETWORK ADD command, and the userâ€™s +password with /SERVER ADD. + +Irssi proxy + +Irssi contains itâ€™s own proxy which you can build giving \\--with-proxy option +to configure. Youâ€™ll still need to run irssi in a screen to use it though. + +Irssi proxy is a bit different than most proxies, normally proxies create a new +connection to IRC server when you connect to it, but irssi proxy shares your +existing IRC connection(s) to multiple clients. And even more clearly: You can +use only one IRC server connection to IRC with as many clients as you want. Can +anyone figure out even more easier ways to say this, so I wouldnâ€™t need to try +to explain this thing for minutes every time? :) + +Irssi proxy supports sharing multiple server connections in different ports, +like you can share network in port 2777 and efnet in port 2778. + +Usage in proxy side: + +/LOAD proxy +/SET irssiproxy_password <password> +/SET irssiproxy_ports <network>=<port> ... (eg. IRCnet=2777 efnet=2778) + +NOTE: you MUST add all the servers you are using to server and network lists +with /SERVER ADD and /NETWORK ADD. ..Except if you really donâ€™t want to for +some reason, and you only use one server connection, you may simply set: + +/SET irssiproxy_ports *=2777 + +Usage in client side: + +Just connect to the irssi proxy like it is a normal server with password +specified in /SET irssiproxy_password. For example: + +/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret +/SERVER ADD -network efnet my.irssi-proxy.org 2778 secret + +Irssi proxy works fine with other IRC clients as well. + +SOCKS + +Irssi can be compiled with socks support (\\--with-socks option to configure), +which requires â€œdanteâ€ and routes all connections through the proxy specified +in the system-wide /etc/socks.conf. This method is known to have issues in Mac +OS X. + +Note that /SET proxy settings donâ€™t have anything to do with socks. + +Using [4]proxychains-ng is recommended over recompiling irssi. + +Others + +IRC bouncers usually work like IRC servers, and want a password. You can give +it with: + +/SET proxy_password <password> + +Irssiâ€™s defaults for connect strings are + +/SET proxy_string CONNECT %s %d +/SET proxy_string_after + +The proxy_string is sent before NICK/USER commands, the proxy_string_after is +sent after them. %s and %d can be used with both of them. + +11. Irssiâ€™s settings + +Hereâ€™s some settings you might want to change (the default value is shown): +Also check the [5]Settings Documentation + +Queries + +/SET autocreate_own_query ON +    Should new query window be created when you send message to someone (with / +    MSG). +/SET autocreate_query_level MSGS +    New query window should be created when receiving messages with this level. +    MSGS, DCCMSGS and NOTICES levels work currently. You can disable this with +    /SET -clear autocreate_query_level. +/SET autoclose_query 0 +    Query windows can be automatically closed after certain time of inactivity. +    Queries with unread messages arenâ€™t closed and active window is neither +    never closed. The value is given in seconds. + +Windows + +/SET use_msgs_window OFF +    Create messages window at startup. All private messages go to this window. +    This only makes sense if youâ€™ve disabled automatic query windows. Message +    window can also be created manually with /WINDOW LEVEL MSGS, /WINDOW NAME +    (msgs). +/SET use_status_window ON +    Create status window at startup. All messages that donâ€™t really have better +    place go here, like all /WHOIS replies etc. Status window can also be +    created manually with /WINDOW LEVEL ALL -MSGS, /WINDOW NAME (status). +/SET autocreate_windows ON +    Should we create new windows for new window items or just place everything +    in one window +/SET autoclose_windows ON +    Should window be automatically closed when the last item in them is removed +    (ie. /PART, /UNQUERY). +/SET reuse_unused_windows OFF +    When finding where to place new window item (channel, query) Irssi first +    tries to use already existing empty windows. If this is set ON, new window +    will always be created for all window items. This setting is ignored if +    autoclose_windows is set ON. +/SET window_auto_change OFF +    Should Irssi automatically change to automatically created windows - +    usually queries when someone sends you a message. To prevent accidentally +    sending text meant to some other channel/nick, Irssi clears the input +    buffer when changing the window. The text is still in scrollback buffer, +    you can get it back with pressing arrow up key. +/SET print_active_channel OFF +    When you keep more than one channel in same window, Irssi prints the +    messages coming to active channel as <nick> text and other channels as +    <nick:channel> text. If this setting is set ON, the messages to active +    channels are also printed in the latter way. +/SET window_history OFF +    Should command history be kept separate for each window. + +User information + +/SET nick +    Your nick name +/SET alternate_nick +    Your alternate nick. +/SET user_name +    Your username, if you have ident enabled this doesnâ€™t affect anything +/SET real_name +    Your real name. + +Server information + +/SET skip_motd OFF +    Should we hide serverâ€™s MOTD (Message Of The Day). +/SET server_reconnect_time 300 +    Seconds to wait before connecting to same server again. Donâ€™t set this too +    low since it usually doesnâ€™t help at all - if the host is down, the few +    extra minutes of waiting wonâ€™t hurt much. +/SET lag_max_before_disconnect 300 +    Maximum server lag in seconds before disconnecting and trying to reconnect. +    This happens mostly only when network breaks between you and IRC server. + +Appearance + +/SET timestamps ON +    Show timestamps before each message. +/SET hide_text_style OFF +    Hide all bolds, underlines, MIRC colors, etc. +/SET show_nickmode ON +    Show the nickâ€™s mode before nick in channels, ie. ops have <@nick>, voices +    <+nick> and others < nick> +/SET show_nickmode_empty ON +    If the nick doesnâ€™t have a mode, use one space. ie. ON: < nick>, OFF: +    <nick> +/SET show_quit_once OFF +    Show quit message only once in some of the channel windows the nick was in +    instead of in all windows. +/SET lag_min_show 100 +    Show the server lag in status bar if itâ€™s bigger than this, the unit is 1/ +    100 of seconds (ie. the default value of 100 = 1 second). +/SET indent 10 +    When lines are longer than screen width they have to be split to multiple +    lines. This specifies how much space to put at the beginning of the line +    before the text begins. This can be overridden in text formats with %| +    format. +/SET activity_hide_targets +    If you donâ€™t want to see window activity in some certain channels or +    queries, list them here. For example #boringchannel =bot1 =bot2. If any +    highlighted text or message for you appears in that window, this setting is +    ignored and the activity is shown. + +Nick completion + +/SET completion_auto OFF +    Automatically complete the nick if line begins with start of nick and the +    completion character. Learn to use the tab-completion instead, itâ€™s a lot +    better ;) +/SET completion_char : +    Completion character to use. + +For all the ircII people + +I donâ€™t like automatic query windows, I donâ€™t like status window, I do like +msgs window where all messages go: + +/SET autocreate_own_query OFF +/SET autocreate_query_level DCCMSGS +/SET use_status_window OFF +/SET use_msgs_window ON + +Disable automatic window closing when /PARTing channel or /UNQUERYing query: + +/SET autoclose_windows OFF +/SET reuse_unused_windows ON + +Hereâ€™s the settings that make irssi work exactly like ircII in window +management (send me a note if you can think of more): + +/SET autocreate_own_query OFF +/SET autocreate_query_level NONE +/SET use_status_window OFF +/SET use_msgs_window OFF +/SET reuse_unused_windows ON +/SET windows_auto_renumber OFF + +/SET autostick_split_windows OFF +/SET autoclose_windows OFF +/SET print_active_channel ON + +12. Statusbar + +/STATUSBAR displays a list of the current statusbars, along with their position +and visibility: + + Name                           Type   Placement Position Visible + window                         window bottom    0        always + window_inact                   window bottom    1        inactive + prompt                         root   bottom    100      always + topic                          root   top       1        always + +/STATUSBAR <name> prints the statusbar settings (type, placement, position, +visibility) as well as its items. /STATUSBAR <name> ENABLE|DISABLE enables/ +disables the statusbar. /STATUSBAR <name> RESET resets the statusbar to its +default settings, or if the statusbar was created by you, it will be removed. + +The statusbar type can be either window or root. If the type is window, then a +statusbar will be created for each split window, otherwise it will be created +only once. Placement can be top or bottom, which refers to the top or bottom of +the screen. Position is a number, the higher the value the lower it will appear +in-screen. Visible can be always, active or inactive. Active/inactive is useful +only with split windows; one split window is active and the rest are inactive. +To adjust these settings, the following commands are available: + +/STATUSBAR <name> TYPE window|root +/STATUSBAR <name> PLACEMENT top|bottom +/STATUSBAR <name> POSITION <num> +/STATUSBAR <name> VISIBLE always|active|inactive + +Statusbar items can also be added or removed via command. Note that when +loading new statusbar scripts that add items, you will need to specify where +you want to show the item and how it is aligned. This can be accomplished using +the below commands: + +/STATUSBAR <name> ADD [-before | -after <item>] [-priority #] [-alignment left|right] <item> +/STATUSBAR <name> REMOVE <item> + +For statusbar scripts, the item name is usually equivalent to the script name. +The documentation of the script ought to tell you if this is not the case. For +example, to add mail.pl before the window activity item, use: /STATUSBAR window +ADD -before act mail. + + +References: + +[1] http://www.gnu.org/licenses/fdl.html +[2] https://www.iterm2.com/ +[3] http://quadpoint.org/articles/irssisplit/ +[4] https://github.com/rofl0r/proxychains-ng +[5] https://irssi.org/documentation/settings/ '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','syncdocs.sh','79','7','101','0','ADD','@@ -0,0 +1,101 @@ +#!/bin/sh -e +# Run this to download FAQ and startup-HOWTO from irssi.org + +PKG_NAME=\"Irssi\" + +site=https://irssi.org + +faq=$site/documentation/faq/ +howto=$site/documentation/startup/ + +# remove everything until H1 and optionally 2 DIVs before the +# FOOTER. May need to be adjusted as the source pages change +pageclean_regex=\'s{.*(?=<h1)}{}s; +s{\\s*(</div>\\s*)?(</div>\\s*)?<footer.*}{}s; +s{(<.*?)\\sclass=\"(?:highlighter-rouge|highlight)\"(.*?>)}{\\1\\2}g;\' + +srcdir=`dirname \"$0\"` +test -z \"$srcdir\" && srcdir=. + +if test ! -f \"$srcdir\"/configure.ac; then +    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" +    echo \" top-level $PKG_NAME directory\" +    exit 1 +fi + +# detect downloader app +downloader=false + +if type curl >/dev/null 2>&1 ; then +    downloader=\"curl -Ssf\" +elif type wget >/dev/null 2>&1 ; then +    downloader=\"wget -nv -O-\" +else +    echo \"**Error**: No wget or curl present\" +    echo \"Install wget or curl, then run syncdocs.sh again\" +fi + +# detect html converter app +converter=false +if [ \"$1\" = \"-any\" ]; then +    any=true +else +    any=false +fi + +if type w3m >/dev/null 2>&1 ; then +    converter=\"w3m -o display_link_number=1 -dump -T text/html\" +    any=true +elif type lynx >/dev/null 2>&1 ; then +    converter=\"lynx -dump -stdin -force_html\" +elif type elinks >/dev/null 2>&1 ; then +    converter=\"elinks -dump -force-html\" +else +    echo \"**Error**: Neither w3m, nor lynx or elinks present\" +    echo \"Install w3m, then run syncdocs.sh again\" +    exit 1 +fi + +if ! $any ; then +    echo \"**Error**: w3m not present\" +    echo \"If you want to use lynx or elinks, run syncdocs.sh -any\" +    exit 1 +fi + +check_download() { +    if test \"$1\" -ne 0 || test ! -e \"$2\" || test \"$(wc -l \"$2\" | awk \'{print $1}\')\" -le 1 ; then +	rm -f \"$2\" +	echo \"... download failed ( $1 )\" +	exit 2 +    fi +} + +download_it() { +    echo \"Downloading $1 from $2 ...\" +    ret=0 +    $downloader \"$2\" > \"$3\".tmp || ret=$? +    check_download \"$ret\" \"$3\".tmp +    perl -i -0777 -p -e \"$pageclean_regex\" \"$3\".tmp +    perl -i -0777 -p -e \'s{\\A}{\'\"<base href=\'$2\'>\"\'\\n}\' \"$3\".tmp +    perl -i -0777 -p -e \'s{<a href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\".*?\">\\[email&#160;protected\\]</a>}{user\\@host}g\' \"$3\".tmp +    mv \"$3\".tmp \"$3\" +} + +download_it \"FAQ\" \"$faq\" \"$srcdir\"/docs/faq.html +download_it \"Startup How-To\" \"$howto\" \"$srcdir\"/docs/startup-HOWTO.html + +# .html -> .txt with lynx or elinks +echo \"Documentation: html -> txt...\" + +cat \"$srcdir\"/docs/faq.html \\ +    | LC_ALL=en_IE.utf8 $converter \\ +    | perl -pe \' +	s/^ *//; +	if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } +	elsif (/^([QA]):/) { $state = $1 } +	elsif ($_ ne \"\\n\") { $_ = \"   $_\"; }; +\' > docs/faq.txt + +cat \"$srcdir\"/docs/startup-HOWTO.html \\ +    | perl -pe \"s/\\\\bhref=([\\\"\\\'])#.*?\\\\1//\" \\ +    | LC_ALL=en_IE.utf8 $converter > \"$srcdir\"/docs/startup-HOWTO.txt '),('irssi','1.0.5','9a3c0bce48d3f172d5638ecb37967528812129b1','ailin-nemui','add a script to sync scripts as well','syncscripts.sh','30','1','38','0','ADD','@@ -0,0 +1,38 @@ +#!/bin/sh -e +# Run this script to sync dual lived scripts from scripts.irssi.org to scripts/ + +PKG_NAME=\"Irssi\" + +scriptbase=https://scripts.irssi.org/scripts + +srcdir=`dirname \"$0\"` +test -z \"$srcdir\" && srcdir=. + +if test ! -f \"$srcdir\"/configure.ac; then +    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" +    echo \" top-level $PKG_NAME directory\" +    exit 1 +fi + +dl2=\'curl -Ssf\' + +dl_it() { +    echo \"$1\" +    $dl2 -o \"$srcdir/scripts/$1\" \"$scriptbase/$1\" +} + +for script in \\ +    autoop.pl \\ +    autorejoin.pl \\ +    buf.pl \\ +    dns.pl \\ +    kills.pl \\ +    mail.pl \\ +    mlock.pl \\ +    quitmsg.pl \\ +    scriptassist.pl \\ +    usercount.pl \\ +    ; +do +    dl_it $script +done '),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','Strip : from <trailing> parameters  This is to fix #601. The function used to extract the mode string assumed that \":\" would only occur in a particular spot. This lead to the possibility that \":\" could be treated as part of things like nicknames or mode arguments, where it should have been stripped as part of protocol escaping.','fe-events.c','376','58','1','1','MODIFY','@@ -224,7 +224,7 @@ static void event_nick(IRC_SERVER_REC *server, const char *data,  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick, const char *addr)  { -	char *params, *channel, *mode; +	char *params = NULL, *channel = NULL, *mode = NULL;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','Strip : from <trailing> parameters  This is to fix #601. The function used to extract the mode string assumed that \":\" would only occur in a particular spot. This lead to the possibility that \":\" could be treated as part of things like nicknames or mode arguments, where it should have been stripped as part of protocol escaping.','irc.c','316','74','30','2','MODIFY','@@ -40,6 +40,8 @@ static int signal_server_incoming;  #  define MAX_SOCKET_READS 5  #endif   +static void strip_params_colon(char *const); +  /* The core of the irc_send_cmd* functions. If `raw\' is TRUE, the `cmd\'     won\'t be checked at all if it\'s 512 bytes or not, or if it contains     line feeds or not. Use with extreme caution! */ @@ -269,8 +271,9 @@ char *event_get_params(const char *data, int count, ...)  	while (count-- > 0) {  		str = (char **) va_arg(args, char **);  		if (count == 0 && rest) { -			/* put the rest to last parameter */ -			tmp = *datad == \':\' ? datad+1 : datad; +			/* Put the rest into the last parameter. */ +			strip_params_colon(datad); +			tmp = datad;  		} else {  			tmp = event_get_param(&datad);  		} @@ -281,6 +284,31 @@ char *event_get_params(const char *data, int count, ...)  	return duprec;  }   +/* Given a string containing <params>, strip any colon prefixing <trailing>. */ +static void strip_params_colon(char *const params) +{ +	if (!params) { +		return; +	} + +	char *s = params; +	while (*s != \'\\0\') { +		if (*s == \':\') { +			memmove(s, s+1, strlen(s+1)+1); +			return; +		} + +		s = strchr(s, \' \'); +		if (!s) { +			return; +		} + +		while (*s == \' \') { +			s++; +		} +	} +} +  static void irc_server_event(IRC_SERVER_REC *server, const char *line,  			     const char *nick, const char *address)  { '),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','Strip : from <trailing> parameters  This is to fix #601. The function used to extract the mode string assumed that \":\" would only occur in a particular spot. This lead to the possibility that \":\" could be treated as part of things like nicknames or mode arguments, where it should have been stripped as part of protocol escaping.','modes.c','700','195','2','2','MODIFY','@@ -480,8 +480,8 @@ static void event_user_mode(IRC_SERVER_REC *server, const char *data)  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick)  { -	IRC_CHANNEL_REC *chanrec; -	char *params, *channel, *mode; +	IRC_CHANNEL_REC *chanrec = NULL; +	char *params = NULL, *channel = NULL, *mode = NULL;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','22','0','7','14','MODIFY','@@ -7,33 +7,26 @@ CLEANFILES = default-config.h default-theme.h  @MAINTAINER_MODE_TRUE@.PHONY: irssi-version.h    default-config.h: $(srcdir)/irssi.conf -	$(srcdir)/file2header.sh $(srcdir)/irssi.conf default_config > default-config.h +	$(srcdir)/utils/file2header.sh $(srcdir)/irssi.conf default_config > default-config.h   -default-theme.h: $(srcdir)/default.theme -	$(srcdir)/file2header.sh $(srcdir)/default.theme default_theme > default-theme.h +default-theme.h: $(srcdir)/themes/default.theme +	$(srcdir)/utils/file2header.sh $(srcdir)/themes/default.theme default_theme > default-theme.h    irssi-version.h: -	VERSION=\"$(VERSION)\" $(srcdir)/irssi-version.sh $(srcdir) | \\ -		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/irssi-version.sh $(srcdir) >$@ +	VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) | \\ +		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) >$@   -SUBDIRS = src docs scripts +SUBDIRS = src docs scripts themes utils    confdir = $(sysconfdir)  conf_DATA = irssi.conf   -themedir = $(datadir)/irssi/themes -theme_DATA = default.theme colorless.theme -  pkginclude_HEADERS = irssi-config.h irssi-version.h    EXTRA_DIST = \\  	ChangeLog \\  	autogen.sh \\  	README.md \\ -	file2header.sh \\  	$(conf_DATA) \\ -	$(theme_DATA) \\  	irssi-config.in \\ -	irssi-icon.png \\ -	irssi-version.sh \\ -	syntax.pl +	irssi-icon.png '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','autogen.sh','45','1','16','11','MODIFY','@@ -3,21 +3,24 @@    PKG_NAME=\"Irssi\"   -srcdir=`dirname $0` +srcdir=`dirname \"$0\"`  test -z \"$srcdir\" && srcdir=. +mydir=`pwd`   -if test ! -f $srcdir/configure.ac; then -    echo -n \"**Error**: Directory \\`$srcdir\\\' does not look like the\" +if test ! -f \"$srcdir\"/configure.ac; then +    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\"      echo \" top-level $PKG_NAME directory\"      exit 1  fi   +cd \"$srcdir\" +  # create help files  echo \"Creating help files...\" -perl syntax.pl +perl utils/syntax.pl    echo \"Creating ChangeLog...\" -git log > $srcdir/ChangeLog +git log > ChangeLog  if test \"$?\" -ne 0; then      echo \"**Error**: ${PKG_NAME} Autogen must be run in a git clone, cannot proceed.\"      exit 1 @@ -38,17 +41,19 @@ fi    rm -f aclocal.m4  echo \"Running autoreconf ...\" -autoreconf -i || exit 1 +autoreconf -i || exit $? + +# make sure perl hashes have correct length +find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\' + +cd \"$mydir\"    conf_flags=\"--enable-maintainer-mode\"    if test x$NOCONFIGURE = x; then -  echo Running $srcdir/configure $conf_flags \"$@\" ... -  $srcdir/configure $conf_flags \"$@\" \\ +  echo Running \"$srcdir\"/configure $conf_flags \"$@\" ... +  \"$srcdir\"/configure $conf_flags \"$@\" \\    && echo Now type \\`make\\\' to compile $PKG_NAME || exit 1  else    echo Skipping configure process.  fi - -# make sure perl hashes have correct length -find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\' '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','configure.ac','700','4','2','0','MODIFY','@@ -661,6 +661,8 @@ scripts/examples/Makefile  docs/Makefile  docs/help/Makefile  docs/help/in/Makefile +utils/Makefile +themes/Makefile  irssi-config  ])   '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','4','0','5','0','ADD','@@ -0,0 +1,5 @@ +themedir = $(datadir)/irssi/themes +theme_DATA = default.theme colorless.theme + +EXTRA_DIST = \\ +	$(theme_DATA) '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','colorless.theme','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','default.theme','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','4','0','4','0','ADD','@@ -0,0 +1,4 @@ +EXTRA_DIST = \\ +	file2header.sh \\ +	irssi-version.sh \\ +	syntax.pl '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','file2header.sh','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','irssi-version.sh','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syncdocs.sh','80','7','2','1','RENAME','@@ -16,6 +16,7 @@ s{(<.*?)\\sclass=\"(?:highlighter-rouge|highlight)\"(.*?>)}{\\1\\2}g;\'    srcdir=`dirname \"$0\"`  test -z \"$srcdir\" && srcdir=. +srcdir=\"$srcdir\"/..    if test ! -f \"$srcdir\"/configure.ac; then      echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" @@ -94,7 +95,7 @@ cat \"$srcdir\"/docs/faq.html \\  	if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; }  	elsif (/^([QA]):/) { $state = $1 }  	elsif ($_ ne \"\\n\") { $_ = \"   $_\"; }; -\' > docs/faq.txt +\' > \"$srcdir\"/docs/faq.txt    cat \"$srcdir\"/docs/startup-HOWTO.html \\      | perl -pe \"s/\\\\bhref=([\\\"\\\'])#.*?\\\\1//\" \\ '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syncscripts.sh','31','1','1','0','RENAME','@@ -7,6 +7,7 @@ scriptbase=https://scripts.irssi.org/scripts    srcdir=`dirname \"$0\"`  test -z \"$srcdir\" && srcdir=. +srcdir=\"$srcdir\"/..    if test ! -f \"$srcdir\"/configure.ac; then      echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syntax.pl','None','None','0','0','RENAME',''),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','autorejoin.pl','67','0','32','17','MODIFY','@@ -1,6 +1,9 @@ -# automatically rejoin to channel after kick +# automatically rejoin to channel after kicked  # delayed rejoin: Lam 28.10.2001 (lam@lac.pl)   +# /SET autorejoin_channels #channel1 #channel2 ... +# /SET autorejoin_delay 5 +  # NOTE: I personally don\'t like this feature, in most channels I\'m in it  # will just result as ban. You\'ve probably misunderstood the idea of /KICK  # if you kick/get kicked all the time \"just for fun\" ... @@ -9,31 +12,22 @@ use Irssi;  use Irssi::Irc;  use strict;  use vars qw($VERSION %IRSSI); -$VERSION = \"1.0.0\"; +$VERSION = \"1.1.0\";  %IRSSI = (  	authors => \"Timo \'cras\' Sirainen, Leszek Matok\",  	contact => \"lam\\@lac.pl\",  	name => \"autorejoin\", -	description => \"Automatically rejoin to channel after being kick, after a (short) user-defined delay\", +	description => \"Automatically rejoin to channel after being kicked, after a (short) user-defined delay\",  	license => \"GPLv2\",  	changed => \"10.3.2002 14:00\"  );   - -# How many seconds to wait before the rejoin? -# TODO: make this a /setting -my $delay = 5; - -my @tags; -my $acttag = 0; -  sub rejoin {  	my ( $data ) = @_; -	my ( $tag, $servtag, $channel, $pass ) = split( / +/, $data ); +	my ( $servtag, $channel, $pass ) = @{$data};    	my $server = Irssi::server_find_tag( $servtag );  	$server->send_raw( \"JOIN $channel $pass\" ) if ( $server ); -	Irssi::timeout_remove( $tags[$tag] );  }    sub event_rejoin_kick { @@ -48,10 +42,31 @@ sub event_rejoin_kick {  	my $rejoinchan = $chanrec->{ name } if ( $chanrec );  	my $servtag = $server->{ tag };   -	Irssi::print \"Rejoining $rejoinchan in $delay seconds.\"; -	$tags[$acttag] = Irssi::timeout_add( $delay * 1000, \"rejoin\", \"$acttag $servtag $rejoinchan $password\" ); -	$acttag++; -	$acttag = 0 if ( $acttag > 60 ); +	# check if we want to autorejoin this channel +	my $chans = Irssi::settings_get_str( \'autorejoin_channels\' ); + +	if ( $chans ) { +		my $found = 0; +		foreach my $chan ( split( /[ ,]/, $chans ) ) { +			if ( lc( $chan ) eq lc( $channel ) ) { +				$found = 1; +				last; +			} +		} +		return unless $found; +	} + +	my @args = ($servtag, $rejoinchan, $password); +	my $delay = Irssi::settings_get_int( \"autorejoin_delay\" ); + +	if ($delay) { +		Irssi::print \"Rejoining $rejoinchan in $delay seconds.\"; +		Irssi::timeout_add_once( $delay * 1000, \"rejoin\", \\@args ); +	} else { +		rejoin( \\@args ); +	}  }   +Irssi::settings_add_int(\'misc\', \'autorejoin_delay\', 5); +Irssi::settings_add_str(\'misc\', \'autorejoin_channels\', \'\');  Irssi::signal_add( \'event kick\', \'event_rejoin_kick\' ); '),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','mail.pl','389','0','1','0','MODIFY','@@ -6,6 +6,7 @@ $VERSION = \"2.92\";      contact     => \"tss\\@iki.fi, matti\\@hiljanen.com, joost\\@carnique.nl, bart\\@dreamflow.nl\",      name        => \"mail\",      description => \"Fully customizable mail counter statusbar item with multiple mailbox and multiple Maildir support\", +    sbitems     => \"mail\",      license     => \"Public Domain\",      url         => \"http://irssi.org, http://scripts.irssi.de\",  ); '),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','usercount.pl','150','9','1','0','MODIFY','@@ -7,6 +7,7 @@ $VERSION = \"1.19\";      contact     => \'dgl@dgl.cx, tss@iki.fi, georg@boerde.de\',      name        => \'usercount\',      description => \'Adds a usercount for a channel as a statusbar item\', +    sbitems     => \'usercount\',      license     => \'GNU GPLv2 or later\',      url         => \'http://irssi.dgl.cx/\',      changes     => \'Only show halfops if server supports them\', '),('irssi','1.0.5','96c7f68b3579ae5f83b635d946dc705d6322a16c','ailin-nemui','clean up file path after move','Makefile.am','156','0','1','1','MODIFY','@@ -59,7 +59,7 @@ perl-signals-list.h: $(top_srcdir)/docs/signals.txt $(srcdir)/get-signals.pl  	cat $(top_srcdir)/docs/signals.txt | $(perlpath) $(srcdir)/get-signals.pl > perl-signals-list.h    irssi-core.pl.h: irssi-core.pl -	$(top_srcdir)/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code > irssi-core.pl.h +	$(top_srcdir)/utils/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code > irssi-core.pl.h    common_sources = \\  	common/Irssi.xs \\ '),('irssi','1.0.5','7e619ed990503faf45fc1ae1e28a3a6062dc7532','ailin-nemui','Update README.md','README.md','51','0','62','98','MODIFY','@@ -1,109 +1,73 @@ -# Irssi +# [Irssi](https://irssi.org/)    [![Build Status](https://travis-ci.org/irssi/irssi.svg?branch=master)](https://travis-ci.org/irssi/irssi)    Irssi is a modular chat client that is most commonly known for its  text mode user interface, but 80% of the code isn\'t text mode -specific. We have a working but currently unmaintained GTK2 frontend -called xirssi. Irssi comes with IRC support built in, and there are +specific. Irssi comes with IRC support built in, and there are  third party [ICB](https://github.com/jperkin/irssi-icb),  [SILC](http://www.silcnet.org/),  [XMPP](http://cybione.org/~irssi-xmpp/) (Jabber), -[PSYC](https://github.com/electric-blue/irssyc) and +[PSYC](http://about.psyc.eu/Irssyc) and  [Quassel](https://github.com/phhusson/quassel-irssi) protocol modules  available.   -## Installation - -See the `INSTALL` file. - -## Features - -So what\'s so great about Irssi? Here\'s a list of some features I can -think of currently: - - - **Optional automation** - There\'s lots of things Irssi does for you -   automatically that some people like and others just hate. Things like: -   nick completion, creating new window for newly joined channel, creating -   queries when msgs/notices are received or when you send a msg, closing -   queries when it\'s been idle for some time, etc. - - - **Multiserver friendly** - I think Irssi has clearly the best support -   for handling multiple server connections. You can have as many as you -   want in as many ircnets as you want. Having several connections in one -   server works too, for example when you hit the (ircnet\'s) 10 -   channels/connection limit you can just create another connection and -   you hardly notice it. If connection to server is lost, Irssi tries to -   connect back until it\'s successful. Also channels you were joined -   before disconnection are restored, even if they\'re \"temporarily -   unavailable\" because of netsplits, Irssi keeps rejoining back to them. -   Also worth noticing - there\'s not that stupid \"server is bound to this -   window, if this window gets closed the connection closes\" thing that -   ircII based clients have. - - - **Channel automation** - You can specify what channels to join to -   immediately after connected to some server or IRC network. After joined -   to channel, Irssi can automatically request ops for you (or do -   anything, actually) from channel\'s bots. - - - **Window content saving** - Say /LAYOUT SAVE when you\'ve put all the -   channels and queries to their correct place, and after restarting -   Irssi, the channels will be joined back into windows where they were -   saved. - - - **Tab completing anything** - You can complete lots of things with tab: -   nicks, commands, command -options, file names, settings, text format -   names, channels and server names. There\'s also an excellent /msg -   completion that works transparently with multiple IRC networks. -   Completing channel nicks is also pretty intelligent, it first goes -   through the people who have talked to you recently, then the people who -   have talked to anyone recently and only then it fallbacks to rest of -   the nicks. You can also complete a set of words you\'ve specified, for -   example homepage<tab> changes it to your actual home page URL. - - - **Excellent logging** - You can log any way you want and as easily or -   hard as you want. With autologging Irssi logs everything to specified -   directory, one file per channel/nick. ircII style /WINDOW LOG ON is -   also supported. There\'s also the \"hard way\" of logging - /LOG command -   which lets you specify exactly what you wish to log and where. Log -   rotating is supported with all the different logging methods, you can -   specify how often you want it to rotate and what kind of time stamp to -   use. - - - **Excellent ignoring** - You can most probably ignore anything any way -   you want. Nick masks, words, regular expressions. You can add -   exceptions to ignores. You can ignore other people\'s replies in -   channels to nicks you have ignored. You can also specify that the -   specific ignores work only in specific channel(s). - - - **Lastlog and scrollback handling** - /LASTLOG command has some new -   features: -new option checks only lines that came since you last did -   /LASTLOG command, -away option checks new lines since you last went -   away. Regular expression matches work also, of course. Going to some -   wanted place at scrollback has always been hard with non-GUI clients. A -   search command that jumps around in scrollback in GUI-style is still -   missing from Irssi, but there\'s something that\'s almost as good as it. -   /LASTLOG always shows timestamps when the line was printed, even if you -   didn\'t have timestamps on. Now doing /SB GOTO \\<timestamp\\> jumps -   directly to the position in scrollback you wanted. Great feature when -   you want to browse a bit of the discussion what happened when someone -   said your name (as seen in awaylog) or topic was changed (/last -   -topics) - -## Files - - - The `docs/` directory contains several documents: -    - `startup-HOWTO.txt` - new users should read this -    - `manual.txt` - manual I started writing but didn\'t get it very far :) -    - `perl.txt` - Perl scripting help -    - `formats.txt` - How to use colors, etc. with Irssi -    - `faq.txt` - Frequently Asked Questions -    - `special_vars.txt` - some predefined $variables you can use with Irssi - -## Bugs / Suggestions - -See the `TODO` file, http://bugs.irssi.org and the GitHub issues if it is -already listed in there; if not, open an issue on GitHub or send a mail to -[staff@irssi.org](mailto:staff@irssi.org). - -You can also contact the Irssi developers in #irssi on freenode. +![irssi](https://user-images.githubusercontent.com/5665186/32180643-cf127f60-bd92-11e7-8aa2-882313ce1d8e.png) + +## [Download information](https://irssi.org/download/) + +#### Development source installation + +``` +git clone https://github.com/irssi/irssi +cd irssi +./autogen.sh +make && sudo make install +``` + +#### Release source installation + +* Download [release](https://github.com/irssi/irssi/releases) +* [Verify](https://irssi.org/download/#release-sources) signature +``` +tar xJf irssi-*.tar.xz +cd irssi-* +./configure +make && sudo make install +``` + +### Requirements + +- [glib-2.28](https://wiki.gnome.org/Projects/GLib) or greater +- [openssl](https://www.openssl.org/) +- [perl-5.6](https://www.perl.org/) or greater (for perl support) +- terminfo or ncurses (for text frontend) + +#### See the [INSTALL](INSTALL) file for details + +## [Documentation](https://irssi.org/documentation/) + +* [Frequently Asked Questions](https://irssi.org/documentation/faq) +* [Startup How-To](https://irssi.org/documentation/startup) +* Check the built-in `/HELP`, it has all the details on command syntax + +## [Themes](https://irssi-import.github.io/themes/) + +## [Scripts](http://scripts.irssi.org/) + +## [Modules](https://irssi.org/modules/) + +## [Security information](https://irssi.org/security/) + +Please report security issues to staff@irssi.org. Thanks! + +## [Bugs](https://github.com/irssi/irssi/issues) / Suggestions / [Contributing](https://irssi.org/development/) + +Check the GitHub issues if it is already listed in there; if not, open +an issue on GitHub or send a mail to [staff@irssi.org](mailto:staff@irssi.org). + +Irssi is always looking for developers. Feel free to submit patches through +GitHub pull requests. + +You can also contact the Irssi developers in +[#irssi](https://irssi.org/support/irc/) on freenode. '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','settings.c','693','161','10','0','MODIFY','@@ -39,6 +39,7 @@ static GString *last_errors;  static GSList *last_invalid_modules;  static int fe_initialized;  static int config_changed; /* FIXME: remove after .98 (unless needed again) */ +static int user_settings_changed;    static GHashTable *settings;  static int timeout_tag; @@ -464,6 +465,11 @@ SETTINGS_REC *settings_get_record(const char *key)  	return g_hash_table_lookup(settings, key);  }   +static void sig_init_userinfo_changed(gpointer changedp) +{ +	user_settings_changed = GPOINTER_TO_INT(changedp); +} +  static void sig_init_finished(void)  {  	fe_initialized = TRUE; @@ -479,6 +485,8 @@ static void sig_init_finished(void)  			  \"updated, please /SAVE\");  		signal_emit(\"setup changed\", 0);  	} + +	signal_emit(\"settings userinfo changed\", 1, GINT_TO_POINTER(user_settings_changed));  }    static void settings_clean_invalid_module(const char *module) @@ -875,6 +883,7 @@ void settings_init(void)  	timeout_tag = g_timeout_add(SETTINGS_AUTOSAVE_TIMEOUT,  				    (GSourceFunc) sig_autosave, NULL);  	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished); +	signal_add(\"irssi init userinfo changed\", (SIGNAL_FUNC) sig_init_userinfo_changed);  	signal_add(\"gui exit\", (SIGNAL_FUNC) sig_autosave);  }   @@ -887,6 +896,7 @@ void settings_deinit(void)  {          g_source_remove(timeout_tag);  	signal_remove(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished); +	signal_remove(\"irssi init userinfo changed\", (SIGNAL_FUNC) sig_init_userinfo_changed);  	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_autosave);    	g_slist_foreach(last_invalid_modules, (GFunc) g_free, NULL); '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','Makefile.am','67','0','1','0','MODIFY','@@ -55,6 +55,7 @@ pkginc_fe_common_core_HEADERS = \\  	fe-exec.h \\  	fe-messages.h \\  	fe-queries.h \\ +	fe-settings.h \\  	fe-tls.h \\  	formats.h \\  	hilight-text.h \\ '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','fe-settings.c','328','91','6','1','MODIFY','@@ -26,7 +26,7 @@  #include \"misc.h\"  #include \"lib-config/iconfig.h\"  #include \"settings.h\" - +#include \"fe-settings.h\"  #include \"levels.h\"  #include \"printtext.h\"  #include \"keyboard.h\" @@ -41,6 +41,11 @@ static void set_print(SETTINGS_REC *rec)  	g_free(value);  }   +void fe_settings_set_print(const char *key) +{ +	set_print(settings_get_record(key)); +} +  static void set_print_pattern(const char *pattern)  {  	GSList *sets, *tmp; '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','fe-settings.h','1','0','6','0','ADD','@@ -0,0 +1,6 @@ +#ifndef __FE_CHANNELS_H +#define __FE_CHANNELS_H + +void fe_settings_set_print(const char *key); + +#endif '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','irssi.c','224','30','25','24','MODIFY','@@ -31,6 +31,7 @@    #include \"printtext.h\"  #include \"fe-common-core.h\" +#include \"fe-settings.h\"  #include \"themes.h\"    #include \"term.h\" @@ -79,25 +80,8 @@ static int dirty, full_redraw;  static GMainLoop *main_loop;  int quitting;   -static const char *banner_text = -	\" ___           _\\n\" -	\"|_ _|_ _ _____(_)\\n\" - 	\" | || \'_(_-<_-< |\\n\" -	\"|___|_| /__/__/_|\\n\" -	\"Irssi v\" PACKAGE_VERSION \" - http://www.irssi.org\"; - -static const char *firsttimer_text = -	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n\" -	\"Hi there! If this is your first time using Irssi, you\\n\" -	\"might want to go to our website and read the startup\\n\" -	\"documentation to get you going.\\n\\n\" -	\"Our community and staff are available to assist you or\\n\" -	\"to answer any questions you may have.\\n\\n\" -	\"Use the /HELP command to get detailed information about\\n\" -	\"the available commands.\\n\" -	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\"; -  static int display_firsttimer = FALSE; +static int user_settings_changed = 0;      static void sig_exit(void) @@ -105,6 +89,11 @@ static void sig_exit(void)          quitting = TRUE;  }   +static void sig_settings_userinfo_changed(gpointer changedp) +{ +	user_settings_changed = GPOINTER_TO_INT(changedp); +} +  /* redraw irssi\'s screen.. */  void irssi_redraw(void)  { @@ -161,6 +150,7 @@ static void textui_init(void)  	fe_common_irc_init();    	theme_register(gui_text_formats); +	signal_add(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);  	signal_add_last(\"gui exit\", (SIGNAL_FUNC) sig_exit);  }   @@ -199,14 +189,24 @@ static void textui_finish_init(void)  	statusbar_redraw(NULL, TRUE);    	if (servers == NULL && lookup_servers == NULL) { -		printtext(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, -			  \"%s\", banner_text); +		printformat(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, TXT_IRSSI_BANNER);  	}    	if (display_firsttimer) { -		printtext(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, -			  \"%s\", firsttimer_text); +		printformat(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, TXT_WELCOME_FIRSTTIME);  	} + +	/* see irc-servers-setup.c:init_userinfo */ +	if (user_settings_changed) +		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_WELCOME_INIT_SETTINGS); +	if (user_settings_changed & (1<<0)) +		fe_settings_set_print(\"real_name\"); +	if (user_settings_changed & (1<<1)) +		fe_settings_set_print(\"user_name\"); +	if (user_settings_changed & (1<<2)) +		fe_settings_set_print(\"nick\"); +	if (user_settings_changed & (1<<3)) +		fe_settings_set_print(\"hostname\");  }    static void textui_deinit(void) @@ -223,6 +223,7 @@ static void textui_deinit(void)  #endif            dirty_check(); /* one last time to print any quit messages */ +	signal_remove(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);  	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_exit);    	lastlog_deinit(); @@ -249,6 +250,7 @@ static void textui_deinit(void)  	core_deinit();  }   +  static void check_files(void)  {  	struct stat statbuf; @@ -259,12 +261,11 @@ static void check_files(void)  	}  }   -  int main(int argc, char **argv)  {  	static int version = 0;  	static GOptionEntry options[] = { -		{ \"version\", \'v\', 0, G_OPTION_ARG_NONE, &version, \"Display irssi version\", NULL }, +		{ \"version\", \'v\', 0, G_OPTION_ARG_NONE, &version, \"Display Irssi version\", NULL },  		{ NULL }  	};  	int loglev; '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','module-formats.c','66','0','21','0','MODIFY','@@ -78,5 +78,26 @@ FORMAT_REC gui_text_formats[] =  	{ \"paste_warning\", \"Pasting $0 lines to $1. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.\", 2, { 1, 0 } },  	{ \"paste_prompt\", \"Hit Ctrl-K to paste, Ctrl-C to abort?\", 0 },   +	/* ---- */ +	{ NULL, \"Welcome\", 0 }, + +	{ \"irssi_banner\", +	  \" ___           _%:\" +	  \"|_ _|_ _ _____(_)%:\" +	  \" | || \'_(_-<_-< |%:\" +	  \"|___|_| /__/__/_|%:\" +	  \"Irssi v$J - http://www.irssi.org\", 0 }, +	{ \"welcome_firsttime\", +	  \"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n\" +	  \"Hi there! If this is your first time using Irssi, you%:\" +	  \"might want to go to our website and read the startup%:\" +	  \"documentation to get you going.%:%:\" +	  \"Our community and staff are available to assist you or%:\" +	  \"to answer any questions you may have.%:%:\" +	  \"Use the /HELP command to get detailed information about%:\" +	  \"the available commands.%:\" +	  \"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\", 0 }, +	{ \"welcome_init_settings\", \"The following settings were initialized\", 0 }, +  	{ NULL, NULL, 0 }  }; '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','module-formats.h','51','0','6','0','MODIFY','@@ -52,6 +52,12 @@ enum {  	TXT_PASTE_WARNING,  	TXT_PASTE_PROMPT,   +	TXT_FILL_5, /* Welcome */ + +	TXT_IRSSI_BANNER, +	TXT_WELCOME_FIRSTTIME, +	TXT_WELCOME_INIT_SETTINGS, +  	TXT_COUNT  };   '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','irc-servers-setup.c','157','52','10','1','MODIFY','@@ -116,14 +116,17 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,    static void init_userinfo(void)  { +	int changed;  	const char *set, *nick, *user_name, *str;   +	changed = 0;  	/* check if nick/username/realname wasn\'t read from setup.. */          set = settings_get_str(\"real_name\");  	if (set == NULL || *set == \'\\0\') {  		str = g_getenv(\"IRCNAME\");  		settings_set_str(\"real_name\",  				 str != NULL ? str : g_get_real_name()); +		changed |= 1<<0;  	}    	/* username */ @@ -134,6 +137,7 @@ static void init_userinfo(void)  				 str != NULL ? str : g_get_user_name());    		user_name = settings_get_str(\"user_name\"); +		changed |= 1<<1;  	}    	/* nick */ @@ -143,15 +147,20 @@ static void init_userinfo(void)  		settings_set_str(\"nick\", str != NULL ? str : user_name);    		nick = settings_get_str(\"nick\"); +		changed |= 1<<2;  	}    	/* host name */          set = settings_get_str(\"hostname\");  	if (set == NULL || *set == \'\\0\') {  		str = g_getenv(\"IRCHOST\"); -		if (str != NULL) +		if (str != NULL) {  			settings_set_str(\"hostname\", str); +			changed |= 1<<3; +		}  	} + +	signal_emit(\"irssi init userinfo changed\", 1, GINT_TO_POINTER(changed));  }    static void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node) '),('irssi','1.0.5','4d6822b1c43d876856a5df07ce69fb4e67c3591a','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 11 +#define IRSSI_ABI_VERSION 12    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.0.5','56013367983b61d8ee4d2e905767ce50b25ffb82','LemonBoy','Turn the style guide into a clang-format file','.clang-format','35','0','37','0','ADD','@@ -0,0 +1,37 @@ +# IndentPPDirectives: None +# SpaceInParentheses: false +AlignAfterOpenBracket: Align +AlignConsecutiveAssignments: false +AlignConsecutiveDeclarations: false +AlignOperands: true +AlignTrailingComments: true +AllowAllParametersOfDeclarationOnNextLine: true +AllowShortBlocksOnASingleLine: false +AllowShortCaseLabelsOnASingleLine: false +AllowShortFunctionsOnASingleLine: Empty +AllowShortIfStatementsOnASingleLine: false +AllowShortLoopsOnASingleLine: false +AlwaysBreakAfterReturnType: None +AlwaysBreakBeforeMultilineStrings: true +BinPackArguments: true +BinPackParameters: true +BreakBeforeBinaryOperators: None +BreakBeforeBraces: Attach +BreakBeforeTernaryOperators: true +ColumnLimit: 100 +IndentCaseLabels: true +IndentWidth: 8 +IndentWrappedFunctionNames: true +KeepEmptyLinesAtTheStartOfBlocks: false +Language: Cpp +MaxEmptyLinesToKeep: 1 +PointerAlignment: Right +SortIncludes: true +SpaceAfterCStyleCast: false +SpaceBeforeAssignmentOperators: true +SpaceBeforeParens: ControlStatements +SpaceInEmptyParentheses: false +SpacesInCStyleCastParentheses: false +SpacesInSquareBrackets: false +TabWidth: 8 +UseTab: ForIndentation '),('irssi','1.0.5','60c31219a278330498e695e4d7fca05ea69962e4','Jari Matilainen','Allow selection of what kind of activity targets to ignore  Initialize tagtarget on declaration  move code around for better flow, extra checks for uninitialized values  remove unnecessary item->type checks  don\'t strdup sign  add braces around if statements, use strcmp0 with single characters and remove g_str_has_prefix  refactoring  changed g_ascii_strcasecmp to g_strcmp0  Add networktag/ shorthand  fixed memory leaks  changed from #@= to ::channels, ::queries and ::dccqueries  check for empty string and continue; if found  fixed bug with empty string check  Clean up code','fe-common-core.c','389','62','31','14','MODIFY','@@ -461,26 +461,43 @@ void fe_common_core_finish_init(void)    gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)  { +	int channel_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"CHANNEL\"); +	int query_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"QUERY\"); +	char **tmp; +  	g_return_val_if_fail(array != NULL, FALSE); +	g_return_val_if_fail(dest != NULL, FALSE); +	g_return_val_if_fail(dest->window != NULL, FALSE); +	g_return_val_if_fail(dest->target != NULL, FALSE);   -	if (strarray_find(array, \"*\") != -1) -		return TRUE; +	WI_ITEM_REC *item = window_item_find_window(dest->window, dest->server, dest->target); +	if (item == NULL) { +		return FALSE; +	}   -	if (strarray_find(array, dest->target) != -1) -		return TRUE; +	int server_tag_len = dest->server_tag ? strlen(dest->server_tag) : 0; +	for (tmp = array; *tmp != NULL; tmp++) { +		char *str = *tmp; +		if (*str == \'\\0\') { +			continue; +		}   -	if (dest->server_tag != NULL) { -		char *tagtarget = g_strdup_printf(\"%s/%s\", dest->server_tag, \"*\"); -		int ret = strarray_find(array, tagtarget); -		g_free(tagtarget); -		if (ret != -1) -			return TRUE; +		if (server_tag_len && !g_ascii_strncasecmp(str, dest->server_tag, server_tag_len) && str[server_tag_len] == \'/\') { +			str += server_tag_len + 1; +		}   -		tagtarget = g_strdup_printf(\"%s/%s\", dest->server_tag, dest->target); -		ret = strarray_find(array, tagtarget); -		g_free(tagtarget); -		if (ret != -1) +		if (!g_strcmp0(str, \"\") || !g_strcmp0(str, \"::all\")) {  			return TRUE; +		} else if (!g_ascii_strcasecmp(str, dest->target)) { +			return TRUE; +		} else if (item->type == query_type && +			!g_strcmp0(str, (dest->target[0] == \'=\') ? \"::dccqueries\" : \"::queries\")) { +			return TRUE; +		} else if (item->type == channel_type && +			!g_strcmp0(str, \"::channels\")) { +			return TRUE; +		}  	} +  	return FALSE;  } '),('irssi','1.0.5','f9d69597ef1e204640d5ce104061717aca0d213a','Joseph Bisch','Remove unnecessary malloc cast in fe-fuzz  We compile this as C code, so the cast is unnecessary.','event-get-params.c','61','11','1','1','MODIFY','@@ -52,7 +52,7 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		return 0;  	}  	uint8_t count = *data; -	char *copy = (char *)malloc(sizeof(char)*(size-1+1)); +	char *copy = malloc(sizeof(char)*(size-1+1));  	memcpy(copy, data+1, size-1);  	copy[size-1] = \'\\0\';   '),('irssi','1.0.5','f4b89044f075038d29089435f7620a068507d80e','Joseph Bisch','Fix malloc parameter in fe-fuzz  It is fairly safe to assume that sizeof(char) will always be 1 anyway and replace the size calculation with a comment explaining the calculation.','event-get-params.c','61','11','2','1','MODIFY','@@ -52,7 +52,8 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		return 0;  	}  	uint8_t count = *data; -	char *copy = malloc(sizeof(char)*(size-1+1)); +	/* malloc(size) instead of size+1, because we already used one byte of data */ +	char *copy = malloc(size);  	memcpy(copy, data+1, size-1);  	copy[size-1] = \'\\0\';   '),('irssi','1.0.5','532527ffa6a5eaccdbf607a2dc3d0e6ef884fce9','Joseph Bisch','Use gchar and g_strndup in fe-fuzz','event-get-params.c','59','11','2','4','MODIFY','@@ -53,9 +53,7 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  	}  	uint8_t count = *data;  	/* malloc(size) instead of size+1, because we already used one byte of data */ -	char *copy = malloc(size); -	memcpy(copy, data+1, size-1); -	copy[size-1] = \'\\0\'; +	gchar *copy = g_strndup((const gchar *)data+1, size-1);    	char *output0;  	char *output1; @@ -82,6 +80,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);  	}  	g_free(params); -	free(copy); +	g_free(copy);  	return 0;  } '),('irssi','1.0.5','66b2c9bc91a3b6e34ba59491c95747db75d21c6b','LemonBoy','Keep a copy of the strings coming from the config  The \"HILIGHT_REC\" structure used to keep a pointer to the \"servertag\" string, owned by the \"CONFIG_NODE\", causing a double-free.','hilight-text.c','543','156','5','2','MODIFY','@@ -106,6 +106,7 @@ static void hilight_destroy(HILIGHT_REC *rec)  	if (rec->channels != NULL) g_strfreev(rec->channels);  	g_free_not_null(rec->color);  	g_free_not_null(rec->act_color); +	g_free_not_null(rec->servertag);  	g_free(rec->text);  	g_free(rec);  } @@ -424,7 +425,7 @@ static void read_hilight_config(void)  	CONFIG_NODE *node;  	HILIGHT_REC *rec;  	GSList *tmp; -	char *text, *color; +	char *text, *color, *servertag;    	hilights_destroy_all();   @@ -467,7 +468,9 @@ static void read_hilight_config(void)  		rec->nickmask = config_node_get_bool(node, \"mask\", FALSE);  		rec->fullword = config_node_get_bool(node, \"fullword\", FALSE);  		rec->regexp = config_node_get_bool(node, \"regexp\", FALSE); -		rec->servertag = config_node_get_str(node, \"servertag\", NULL); +		servertag = config_node_get_str(node, \"servertag\", NULL); +		rec->servertag = servertag == NULL || *servertag == \'\\0\' ? NULL : +			g_strdup(servertag);  		hilight_init_rec(rec);    		node = iconfig_node_section(node, \"channels\", -1); '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','settings.c','693','161','3','3','MODIFY','@@ -39,7 +39,7 @@ static GString *last_errors;  static GSList *last_invalid_modules;  static int fe_initialized;  static int config_changed; /* FIXME: remove after .98 (unless needed again) */ -static int user_settings_changed; +static unsigned int user_settings_changed;    static GHashTable *settings;  static int timeout_tag; @@ -467,7 +467,7 @@ SETTINGS_REC *settings_get_record(const char *key)    static void sig_init_userinfo_changed(gpointer changedp)  { -	user_settings_changed = GPOINTER_TO_INT(changedp); +	user_settings_changed |= GPOINTER_TO_UINT(changedp);  }    static void sig_init_finished(void) @@ -486,7 +486,7 @@ static void sig_init_finished(void)  		signal_emit(\"setup changed\", 0);  	}   -	signal_emit(\"settings userinfo changed\", 1, GINT_TO_POINTER(user_settings_changed)); +	signal_emit(\"settings userinfo changed\", 1, GUINT_TO_POINTER(user_settings_changed));  }    static void settings_clean_invalid_module(const char *module) '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','settings.h','73','0','7','0','MODIFY','@@ -30,6 +30,13 @@ typedef struct {  	char **choices;  } SETTINGS_REC;   +enum { +	USER_SETTINGS_REAL_NAME = 0x1, +	USER_SETTINGS_USER_NAME = 0x2, +	USER_SETTINGS_NICK	= 0x4, +	USER_SETTINGS_HOSTNAME	= 0x8, +}; +  /* macros for handling the default Irssi configuration */  #define iconfig_get_str(a, b, c) config_get_str(mainconfig, a, b, c)  #define iconfig_get_int(a, b, c) config_get_int(mainconfig, a, b, c) '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','irssi.c','224','30','7','8','MODIFY','@@ -81,7 +81,7 @@ static GMainLoop *main_loop;  int quitting;    static int display_firsttimer = FALSE; -static int user_settings_changed = 0; +static unsigned int user_settings_changed = 0;      static void sig_exit(void) @@ -91,7 +91,7 @@ static void sig_exit(void)    static void sig_settings_userinfo_changed(gpointer changedp)  { -	user_settings_changed = GPOINTER_TO_INT(changedp); +	user_settings_changed = GPOINTER_TO_UINT(changedp);  }    /* redraw irssi\'s screen.. */ @@ -199,13 +199,13 @@ static void textui_finish_init(void)  	/* see irc-servers-setup.c:init_userinfo */  	if (user_settings_changed)  		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_WELCOME_INIT_SETTINGS); -	if (user_settings_changed & (1<<0)) +	if (user_settings_changed & USER_SETTINGS_REAL_NAME)  		fe_settings_set_print(\"real_name\"); -	if (user_settings_changed & (1<<1)) +	if (user_settings_changed & USER_SETTINGS_USER_NAME)  		fe_settings_set_print(\"user_name\"); -	if (user_settings_changed & (1<<2)) +	if (user_settings_changed & USER_SETTINGS_NICK)  		fe_settings_set_print(\"nick\"); -	if (user_settings_changed & (1<<3)) +	if (user_settings_changed & USER_SETTINGS_HOSTNAME)  		fe_settings_set_print(\"hostname\");  }   @@ -222,7 +222,7 @@ static void textui_deinit(void)          fe_perl_deinit();  #endif   -        dirty_check(); /* one last time to print any quit messages */ +	dirty_check(); /* one last time to print any quit messages */  	signal_remove(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);  	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_exit);   @@ -250,7 +250,6 @@ static void textui_deinit(void)  	core_deinit();  }   -  static void check_files(void)  {  	struct stat statbuf; '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','irc-servers-setup.c','157','52','6','6','MODIFY','@@ -116,7 +116,7 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,    static void init_userinfo(void)  { -	int changed; +	unsigned int changed;  	const char *set, *nick, *user_name, *str;    	changed = 0; @@ -126,7 +126,7 @@ static void init_userinfo(void)  		str = g_getenv(\"IRCNAME\");  		settings_set_str(\"real_name\",  				 str != NULL ? str : g_get_real_name()); -		changed |= 1<<0; +		changed |= USER_SETTINGS_REAL_NAME;  	}    	/* username */ @@ -137,7 +137,7 @@ static void init_userinfo(void)  				 str != NULL ? str : g_get_user_name());    		user_name = settings_get_str(\"user_name\"); -		changed |= 1<<1; +		changed |= USER_SETTINGS_USER_NAME;  	}    	/* nick */ @@ -147,7 +147,7 @@ static void init_userinfo(void)  		settings_set_str(\"nick\", str != NULL ? str : user_name);    		nick = settings_get_str(\"nick\"); -		changed |= 1<<2; +		changed |= USER_SETTINGS_NICK;  	}    	/* host name */ @@ -156,11 +156,11 @@ static void init_userinfo(void)  		str = g_getenv(\"IRCHOST\");  		if (str != NULL) {  			settings_set_str(\"hostname\", str); -			changed |= 1<<3; +			changed |= USER_SETTINGS_HOSTNAME;  		}  	}   -	signal_emit(\"irssi init userinfo changed\", 1, GINT_TO_POINTER(changed)); +	signal_emit(\"irssi init userinfo changed\", 1, GUINT_TO_POINTER(changed));  }    static void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node) '),('irssi','1.0.5','596fa6b51ed2ab6be80041684ad805f7b22256ac','LemonBoy','Take into account Nei\'s suggestions','.clang-format','36','0','6','5','MODIFY','@@ -1,4 +1,4 @@ -# IndentPPDirectives: None +# IndentPPDirectives: AfterHash  # SpaceInParentheses: false  AlignAfterOpenBracket: Align  AlignConsecutiveAssignments: false @@ -12,22 +12,23 @@ AllowShortFunctionsOnASingleLine: Empty  AllowShortIfStatementsOnASingleLine: false  AllowShortLoopsOnASingleLine: false  AlwaysBreakAfterReturnType: None -AlwaysBreakBeforeMultilineStrings: true +AlwaysBreakBeforeMultilineStrings: false  BinPackArguments: true  BinPackParameters: true  BreakBeforeBinaryOperators: None -BreakBeforeBraces: Attach -BreakBeforeTernaryOperators: true +BreakBeforeBraces: Linux +BreakBeforeTernaryOperators: false  ColumnLimit: 100  IndentCaseLabels: true  IndentWidth: 8  IndentWrappedFunctionNames: true  KeepEmptyLinesAtTheStartOfBlocks: false  Language: Cpp +Cpp11BracedListStyle: false  MaxEmptyLinesToKeep: 1  PointerAlignment: Right  SortIncludes: true -SpaceAfterCStyleCast: false +SpaceAfterCStyleCast: true  SpaceBeforeAssignmentOperators: true  SpaceBeforeParens: ControlStatements  SpaceInEmptyParentheses: false '),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','Prevent a UAF error during the execution of some commands  Some arguments were free\'d first and then printed, leading to gibberish being output to screen or a crash.  Found by Joseph Bisch. Closes: !GL17','fe-channels.c','520','131','1','1','MODIFY','@@ -278,9 +278,9 @@ static void cmd_channel_add_modify(const char *data, gboolean add)  	rec = channel_setup_find(channel, chatnet);  	if (rec == NULL) {  		if (add == FALSE) { -			cmd_params_free(free_arg);  			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,  				TXT_CHANSETUP_NOT_FOUND, channel, chatnet); +			cmd_params_free(free_arg);  			return;  		}   '),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','Prevent a UAF error during the execution of some commands  Some arguments were free\'d first and then printed, leading to gibberish being output to screen or a crash.  Found by Joseph Bisch. Closes: !GL17','fe-server.c','382','113','1','1','MODIFY','@@ -136,9 +136,9 @@ static void cmd_server_add_modify(const char *data, gboolean add)    	if (rec == NULL) {  		if (add == FALSE) { -			cmd_params_free(free_arg);  			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,  				TXT_SETUPSERVER_NOT_FOUND, addr, port); +			cmd_params_free(free_arg);  			return;  		}   '),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','Prevent a UAF error during the execution of some commands  Some arguments were free\'d first and then printed, leading to gibberish being output to screen or a crash.  Found by Joseph Bisch. Closes: !GL17','fe-ircnet.c','191','72','1','1','MODIFY','@@ -106,9 +106,9 @@ static void cmd_network_add_modify(const char *data, gboolean add)  	rec = ircnet_find(name);  	if (rec == NULL) {  		if (add == FALSE) { -			cmd_params_free(free_arg);  			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,  				IRCTXT_NETWORK_NOT_FOUND, name); +			cmd_params_free(free_arg);  			return;  		}   '),('irssi','1.0.5','3acc72f842a021ffcff8809c1f245ca614f68598','ailin-nemui','reset colour at comma, like mIRC  Fixes #742 and #740','formats.c','1129','356','3','6','MODIFY','@@ -1072,7 +1072,8 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  	fg = fg_ret == NULL ? -1 : *fg_ret;  	bg = bg_ret == NULL ? -1 : *bg_ret;   -	if (!i_isdigit(**str) && **str != \',\') { +	if (!i_isdigit(**str)) { +		/* turn off color */  		fg = -1;  		bg = -1;  	} else { @@ -1085,11 +1086,8 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  				(*str)++;  			}  		} -		if (**str == \',\') { +		if ((*str)[0] == \',\' && i_isdigit((*str)[1])) {  			/* background color */ -			if (!i_isdigit((*str)[1])) -				bg = -1; -			else {  				(*str)++;  				bg = **str-\'0\';  				(*str)++; @@ -1097,7 +1095,6 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  					bg = bg*10 + (**str-\'0\');  					(*str)++;  				} -			}  		}  	}   '),('irssi','1.0.5','ba3c5801a4bb175fe1e0d0fd273ae15318dd2b03','ailin-nemui','Update .clang-format  do not indent case deeper','.clang-format','36','0','1','1','MODIFY','@@ -19,7 +19,7 @@ BreakBeforeBinaryOperators: None  BreakBeforeBraces: Linux  BreakBeforeTernaryOperators: false  ColumnLimit: 100 -IndentCaseLabels: true +IndentCaseLabels: false  IndentWidth: 8  IndentWrappedFunctionNames: true  KeepEmptyLinesAtTheStartOfBlocks: false '),('irssi','1.0.5','47400d405a0680bfe4d69ce8b06ecbfd09931999','ailin-nemui','Update formats.c  remove now useless check for ,','formats.c','1127','355','11','12','MODIFY','@@ -1078,23 +1078,22 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  		bg = -1;  	} else {  		/* foreground color */ -		if (**str != \',\') { -			fg = **str-\'0\'; +		fg = **str-\'0\'; +		(*str)++; +		if (i_isdigit(**str)) { +			fg = fg*10 + (**str-\'0\');  			(*str)++; -			if (i_isdigit(**str)) { -				fg = fg*10 + (**str-\'0\'); -				(*str)++; -			}  		} +  		if ((*str)[0] == \',\' && i_isdigit((*str)[1])) {  			/* background color */ +			(*str)++; +			bg = **str-\'0\'; +			(*str)++; +			if (i_isdigit(**str)) { +				bg = bg*10 + (**str-\'0\');  				(*str)++; -				bg = **str-\'0\'; -				(*str)++; -				if (i_isdigit(**str)) { -					bg = bg*10 + (**str-\'0\'); -					(*str)++; -				} +			}  		}  	}   '),('irssi','1.0.5','1a49787ef25103d1a393c81e35fb949322fe0523','Will Storey','Revert initializing pointers to NULL  To maintain C89 compatibility','fe-events.c','376','58','1','1','MODIFY','@@ -224,7 +224,7 @@ static void event_nick(IRC_SERVER_REC *server, const char *data,  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick, const char *addr)  { -	char *params = NULL, *channel = NULL, *mode = NULL; +	char *params, *channel, *mode;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','1a49787ef25103d1a393c81e35fb949322fe0523','Will Storey','Revert initializing pointers to NULL  To maintain C89 compatibility','modes.c','700','195','2','2','MODIFY','@@ -480,8 +480,8 @@ static void event_user_mode(IRC_SERVER_REC *server, const char *data)  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick)  { -	IRC_CHANNEL_REC *chanrec = NULL; -	char *params = NULL, *channel = NULL, *mode = NULL; +	IRC_CHANNEL_REC *chanrec; +	char *params, *channel, *mode;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','b2ca8c04778866bd07cf1b612adf0df55f45b78e','ailin-nemui','check for declaration-after-statement on travis','.travis.yml','48','0','1','1','MODIFY','@@ -31,7 +31,7 @@ before_install:    install:      - ./configure --with-proxy --with-bot --with-perl=module --prefix=$HOME/irssi-build -    - make CFLAGS=\"-Wall -Werror\" +    - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"      - make install    before_script: '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','ignore.h','30','0','3','3','MODIFY','@@ -27,14 +27,14 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  		 const char *channel, const char *text, int level);    enum { -	IGNORE_FIND_PATTERN = 0x01, // Match the pattern -	IGNORE_FIND_NOACT   = 0x02, // Exclude the targets with NOACT level +	IGNORE_FIND_PATTERN = 0x01, /* Match the pattern */ +	IGNORE_FIND_NOACT   = 0x02, /* Exclude the targets with NOACT level */  };    IGNORE_REC *ignore_find_full (const char *servertag, const char *mask, const char *pattern,                  char **channels, const int flags);   -// Convenience wrappers around ignore_find_full, for compatibility purpose +/* Convenience wrappers around ignore_find_full, for compatibility purpose */    IGNORE_REC *ignore_find(const char *servertag, const char *mask, char **channels);  IGNORE_REC *ignore_find_noact(const char *servertag, const char *mask, char **channels, int noact); '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','network-openssl.c','679','147','10','10','MODIFY','@@ -600,7 +600,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	tls_rec_set_certificate_fingerprint(tls, cert_fingerprint_hex);  	tls_rec_set_certificate_fingerprint_algorithm(tls, \"SHA256\");   -	// Show algorithm. +	/* Show algorithm. */  	switch (EVP_PKEY_id(pubkey)) {  		case EVP_PKEY_RSA:  			tls_rec_set_public_key_algorithm(tls, \"RSA\"); @@ -624,7 +624,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	tls_rec_set_public_key_size(tls, EVP_PKEY_bits(pubkey));  	tls_rec_set_public_key_fingerprint_algorithm(tls, \"SHA256\");   -	// Read the NotBefore timestamp. +	/* Read the NotBefore timestamp. */  	bio = BIO_new(BIO_s_mem());  	ASN1_TIME_print(bio, X509_get_notBefore(cert));  	length = BIO_read(bio, buffer, sizeof(buffer)); @@ -632,7 +632,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	BIO_free(bio);  	tls_rec_set_not_before(tls, buffer);   -	// Read the NotAfter timestamp. +	/* Read the NotAfter timestamp. */  	bio = BIO_new(BIO_s_mem());  	ASN1_TIME_print(bio, X509_get_notAfter(cert));  	length = BIO_read(bio, buffer, sizeof(buffer)); @@ -670,7 +670,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  	for (i = 0; i < sk_X509_num(chain); i++) {  		cert_rec = tls_cert_create_rec();   -		// Subject. +		/* Subject. */  		name = X509_get_subject_name(sk_X509_value(chain, i));    		for (j = 0; j < X509_NAME_entry_count(name); j++) { @@ -689,7 +689,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  			tls_cert_rec_append_subject_entry(cert_rec, tls_cert_entry_rec);  		}   -		// Issuer. +		/* Issuer. */  		name = X509_get_issuer_name(sk_X509_value(chain, i));    		for (j = 0; j < X509_NAME_entry_count(name); j++) { @@ -718,10 +718,10 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  	g_return_if_fail(ssl != NULL);    #ifdef SSL_get_server_tmp_key -	// Show ephemeral key information. +	/* Show ephemeral key information. */  	EVP_PKEY *ephemeral_key = NULL;   -	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 +	/* OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 */  #ifndef OPENSSL_NO_EC  	EC_KEY *ec_key = NULL;  #endif @@ -759,7 +759,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)    		EVP_PKEY_free(ephemeral_key);  	} -#endif // SSL_get_server_tmp_key. +#endif /* SSL_get_server_tmp_key. */  }    GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server) @@ -866,7 +866,7 @@ int irssi_ssl_handshake(GIOChannel *handle)  	set_peer_cert_chain_info(tls, chan->ssl);  	set_server_temporary_key_info(tls, chan->ssl);   -	// Emit the TLS rec. +	/* Emit the TLS rec. */  	signal_emit(\"tls handshake finished\", 2, chan->server, tls);    	ret = 1; @@ -893,7 +893,7 @@ int irssi_ssl_handshake(GIOChannel *handle)  		ret = irssi_ssl_verify(chan->ssl, chan->ctx, chan->server->connrec->address, chan->port, cert, chan->server, tls);    		if (! ret) { -			// irssi_ssl_verify emits a warning itself. +			/* irssi_ssl_verify emits a warning itself. */  			goto done;  		}  	} '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','irssi.c','33','2','1','1','MODIFY','@@ -21,7 +21,7 @@  #include \"module.h\"  #include \"modules-load.h\"  #include \"levels.h\" -#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text +#include \"../fe-text/module-formats.h\" /* need to explicitly grab from fe-text */  #include \"themes.h\"  #include \"core.h\"  #include \"fe-common-core.h\" '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','statusbar-items.c','391','99','2','2','MODIFY','@@ -369,8 +369,8 @@ static void item_lag(SBAR_ITEM_REC *item, int get_size_only)  	last_lag_unknown = lag_unknown;    	if (lag_unknown) { -		// \"??)\" in C becomes \']\' -		// See: https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C +		/* \"??)\" in C becomes \']\' +		   See: https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C */  		g_snprintf(str, sizeof(str), \"%d (?\"\"?)\", lag / 100);  	} else {  		if (lag % 100 == 0) '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','sasl.c','199','35','3','3','MODIFY','@@ -30,16 +30,16 @@   * Based on IRCv3 SASL Extension Specification:   * http://ircv3.net/specs/extensions/sasl-3.1.html   */ -#define AUTHENTICATE_CHUNK_SIZE 400 // bytes +#define AUTHENTICATE_CHUNK_SIZE 400 /* bytes */    /*   * Maximum size to allow the buffer to grow to before the next fragment comes in. Note that   * due to the way fragmentation works, the maximum message size will actually be:   * floor(AUTHENTICATE_MAX_SIZE / AUTHENTICATE_CHUNK_SIZE) + AUTHENTICATE_CHUNK_SIZE - 1   */ -#define AUTHENTICATE_MAX_SIZE 8192 // bytes +#define AUTHENTICATE_MAX_SIZE 8192 /* bytes */   -#define SASL_TIMEOUT (20 * 1000) // ms +#define SASL_TIMEOUT (20 * 1000) /* ms */    static gboolean sasl_timeout(IRC_SERVER_REC *server)  { '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','network-openssl.c','679','147','9','9','MODIFY','@@ -583,9 +583,6 @@ static void set_cipher_info(TLS_REC *tls, SSL *ssl)    static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_fingerprint, size_t cert_fingerprint_size, unsigned char *public_key_fingerprint, size_t public_key_fingerprint_size)  { -	g_return_if_fail(tls != NULL); -	g_return_if_fail(cert != NULL); -  	EVP_PKEY *pubkey = NULL;  	char *cert_fingerprint_hex = NULL;  	char *public_key_fingerprint_hex = NULL; @@ -594,6 +591,9 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	char buffer[128];  	size_t length;   +	g_return_if_fail(tls != NULL); +	g_return_if_fail(cert != NULL); +  	pubkey = X509_get_pubkey(cert);    	cert_fingerprint_hex = binary_to_hex(cert_fingerprint, cert_fingerprint_size); @@ -647,9 +647,6 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger    static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  { -	g_return_if_fail(tls != NULL); -	g_return_if_fail(ssl != NULL); -  	int nid;  	char *key = NULL;  	char *value = NULL; @@ -662,6 +659,9 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  	TLS_CERT_ENTRY_REC *tls_cert_entry_rec = NULL;  	ASN1_STRING *data = NULL;   +	g_return_if_fail(tls != NULL); +	g_return_if_fail(ssl != NULL); +  	chain = SSL_get_peer_cert_chain(ssl);    	if (chain == NULL) @@ -714,9 +714,6 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)    static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  { -	g_return_if_fail(tls != NULL); -	g_return_if_fail(ssl != NULL); -  #ifdef SSL_get_server_tmp_key  	/* Show ephemeral key information. */  	EVP_PKEY *ephemeral_key = NULL; @@ -729,6 +726,9 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  	char *cname = NULL;  	int nid;   +	g_return_if_fail(tls != NULL); +	g_return_if_fail(ssl != NULL); +  	if (SSL_get_server_tmp_key(ssl, &ephemeral_key)) {  		switch (EVP_PKEY_id(ephemeral_key)) {  			case EVP_PKEY_DH: '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','fe-windows.c','623','184','3','1','MODIFY','@@ -563,8 +563,10 @@ GSList *windows_get_sorted(void)  	begin = windows_seq_begin();    	while (iter != begin) { +		WINDOW_REC *rec; +  		iter = g_sequence_iter_prev(iter); -		WINDOW_REC *rec = g_sequence_get(iter); +		rec = g_sequence_get(iter);    		sorted = g_slist_prepend(sorted, rec);  	} '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','Expando.xs','147','21','2','1','MODIFY','@@ -74,6 +74,7 @@ static char *perl_expando_event(PerlExpando *rec, SERVER_REC *server,    	ret = NULL;  	if (SvTRUE(ERRSV)) { +		char *error;  		PERL_SCRIPT_REC *script = rec->script;    		(void) POPs; @@ -85,7 +86,7 @@ static char *perl_expando_event(PerlExpando *rec, SERVER_REC *server,  			script_unregister_expandos(script);  		/* rec has been freed now */   -		char *error = g_strdup(SvPV_nolen(ERRSV)); +		error = g_strdup(SvPV_nolen(ERRSV));  		signal_emit(\"script error\", 2, script, error);  		g_free(error);  	} else if (retcount > 0) { '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','Statusbar.xs','136','17','2','2','MODIFY','@@ -67,7 +67,7 @@ static void perl_statusbar_event(char *function, SBAR_ITEM_REC *item,    	if (SvTRUE(ERRSV)) {                  PERL_SCRIPT_REC *script; -                char *package; +                char *package, *error;                    package = perl_function_get_package(function);                  script = perl_script_find_package(package); @@ -78,7 +78,7 @@ static void perl_statusbar_event(char *function, SBAR_ITEM_REC *item,  			script_unregister_statusbars(script);  		}   -		char *error = g_strdup(SvPV_nolen(ERRSV)); +		error = g_strdup(SvPV_nolen(ERRSV));  		signal_emit(\"script error\", 2, script, error);  		g_free(error);  	} else { '),('irssi','1.0.5','b0637ad6ea8784d3b2be829ca40f9dddf0c049fc','Will Storey','Update NULL comparison style and be C89 compatible','irc.c','317','74','5','3','MODIFY','@@ -287,11 +287,13 @@ char *event_get_params(const char *data, int count, ...)  /* Given a string containing <params>, strip any colon prefixing <trailing>. */  static void strip_params_colon(char *const params)  { -	if (!params) { +	char *s; + +	if (params == NULL) {  		return;  	}   -	char *s = params; +	s = params;  	while (*s != \'\\0\') {  		if (*s == \':\') {  			memmove(s, s+1, strlen(s+1)+1); @@ -299,7 +301,7 @@ static void strip_params_colon(char *const params)  		}    		s = strchr(s, \' \'); -		if (!s) { +		if (s == NULL) {  			return;  		}   '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','.gitignore','54','0','3','0','MODIFY','@@ -49,6 +49,9 @@ src/perl/*/Makefile.old  src/fe-fuzz/crash-*  src/fe-fuzz/oom-*   +tests/irc/core/test-irc +tests/irc/core/test-irc.trs +  *.a  *.bs  *.la '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','.travis.yml','50','0','3','1','MODIFY','@@ -49,5 +49,7 @@ before_script:      - echo ^quit >> irssi-test/startup      - irssi-build/bin/irssi --home irssi-test      - cat irc.log.* +    - cd $TRAVIS_BUILD_DIR   -script: true +script: +    - make check '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','22','0','1','1','MODIFY','@@ -16,7 +16,7 @@ irssi-version.h:  	VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) | \\  		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) >$@   -SUBDIRS = src docs scripts themes utils +SUBDIRS = src tests docs scripts themes utils    confdir = $(sysconfdir)  conf_DATA = irssi.conf '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','configure.ac','703','4','3','0','MODIFY','@@ -658,6 +658,9 @@ src/perl/ui/Makefile.PL  src/perl/textui/Makefile.PL  scripts/Makefile  scripts/examples/Makefile +tests/Makefile +tests/irc/Makefile +tests/irc/core/Makefile  docs/Makefile  docs/help/Makefile  docs/help/in/Makefile '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = irc '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = core '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','31','0','36','0','ADD','@@ -0,0 +1,36 @@ +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core \\ +	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\ +	$(GLIB_CFLAGS) + +TESTS = test-irc +check_PROGRAMS = test-irc + +test_irc_CPPFLAGS = \\ +	-I$(top_srcdir)/src/irc/core \\ +	$(AM_CPPFLAGS) + +test_irc_DEPENDENCIES = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a + +test_irc_LDADD = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a \\ +	@GLIB_LIBS@ \\ +	@OPENSSL_LIBS@ + +test_irc_SOURCES = \\ +	test-irc.c \\ +	../../../src/irc/core/irc-cap.c \\ +	../../../src/irc/core/irc-nicklist.c \\ +	../../../src/irc/core/irc-queries.c \\ +	../../../src/irc/core/irc-servers-reconnect.c \\ +	../../../src/irc/core/irc-servers-setup.c \\ +	../../../src/irc/core/irc-servers.c \\ +	../../../src/irc/core/irc.c \\ +	../../../src/irc/core/mode-lists.c \\ +	../../../src/irc/core/modes.c \\ +	../../../src/irc/core/servers-idle.c \\ +	../../../src/irc/core/servers-redirect.c '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','test-irc.c','189','5','230','0','ADD','@@ -0,0 +1,230 @@ +/* + test-irc.c : irssi + +    Copyright (C) 2017 Will Storey + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include <glib.h> +#include <irc.h> +#include <string.h> + +static void test_event_get_param(void); +static void test_event_get_params(void); + +int main(int argc, char **argv) +{ +	g_test_init(&argc, &argv, NULL); + +	g_test_add_func(\"/test/event_get_param\", test_event_get_param); +	g_test_add_func(\"/test/event_get_params\", test_event_get_params); + +	return g_test_run(); +} + +static void test_event_get_param(void) +{ +	struct test_case { +		char const *const description; +		char const *const input; +		char const *const input_after; +		char const *const output; +	}; + +	struct test_case const tests[] = { +		{ +			.description = \"Zero parameters\", +			.input       = \"\", +			.input_after = \"\", +			.output      = \"\", +		}, +		{ +			.description = \"One parameter\", +			.input       = \"#test\", +			.input_after = \"\", +			.output      = \"#test\", +		}, +		{ +			.description = \"One parameter, trailing space\", +			.input       = \"#test \", +			.input_after = \"\", +			.output      = \"#test\", +		}, +		{ +			.description = \"One parameter, more trailing space\", +			.input       = \"#test  \", +			.input_after = \" \", +			.output      = \"#test\", +		}, +		{ +			.description = \"Two parameters\", +			.input       = \"#test +o\", +			.input_after = \"+o\", +			.output      = \"#test\", +		}, +		{ +			.description = \"Two parameters continued\", +			.input       = \"+o\", +			.input_after = \"\", +			.output      = \"+o\", +		}, +		{ +			.description = \"Two parameters with trailing space\", +			.input       = \"#test +o \", +			.input_after = \"+o \", +			.output      = \"#test\", +		}, +		{ +			.description = \"Two parameters with trailing space continued\", +			.input       = \"+o \", +			.input_after = \"\", +			.output      = \"+o\", +		}, +		{ +			.description = \"Two parameters with inline and trailing space\", +			.input       = \"#test  +o \", +			.input_after = \" +o \", +			.output      = \"#test\", +		}, +		/* TODO: It seems not ideal that the caller has to deal with inline space. +		 */ +		{ +			.description = \"Two parameters with inline and trailing space continued\", +			.input       = \" +o \", +			.input_after = \"+o \", +			.output      = \"\", +		}, +	}; + +	char *buf = g_malloc0(1024); + +	int i = 0; +	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { +		struct test_case const test = tests[i]; + +		memcpy(buf, test.input, strlen(test.input)+1); +		char *input = buf; + +		char *const output = event_get_param(&input); + +		g_assert_cmpstr(input, ==, test.input_after); +		g_assert_cmpstr(output, ==, test.output); +	} + +	g_free(buf); +} + +static void test_event_get_params(void) +{ +	struct test_case { +		char const *const description; +		char const *const input; +		char const *const output0; +		char const *const output1; +	}; + +	struct test_case const tests[] = { +		{ +			.description = \"Only a channel\", +			.input       = \"#test\", +			.output0     = \"#test\", +			.output1     = \"\", +		}, +		{ +			.description = \"Only a channel with trailing space\", +			.input       = \"#test \", +			.output0     = \"#test\", +			.output1     = \"\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with one parameter after channel name\", +			.input       = \"#test +i\", +			.output0     = \"#test\", +			.output1     = \"+i\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with two parameters after channel name\", +			.input       = \"#test +o tester\", +			.output0     = \"#test\", +			.output1     = \"+o tester\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with three parameters afer channel name\", +			.input       = \"#test +ov tester tester2\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\", +			.input       = \"#test  +ov  tester  tester2 \", +			.output0     = \"#test\", +			.output1     = \" +ov  tester  tester2 \", +		}, +		{ +			.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\", +			.input       = \"#test :+i\", +			.output0     = \"#test\", +			.output1     = \"+i\", +		}, +		{ +			.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\", +			.input       = \"#test :+o tester\", +			.output0     = \"#test\", +			.output1     = \"+o tester\", +		}, +		{ +			.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\", +			.input       = \"#test :+ov tester tester2\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2\", +		}, +		{ +			.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\", +			.input       = \"#test +o :tester\", +			.output0     = \"#test\", +			.output1     = \"+o tester\", +		}, +		{ +			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\", +			.input       = \"#test +ov tester :tester2\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2\", +		}, +		{ +			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\", +			.input       = \"#test +ov tester :tester2 hi:there\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2 hi:there\", +		}, +	}; + +	int i = 0; +	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { +		struct test_case const test = tests[i]; + +		char *output0 = NULL; +		char *output1 = NULL; +		char *const params = event_get_params(test.input, 2 | PARAM_FLAG_GETREST, +				&output0, &output1); + +		/* params happens to always point at the first output */ +		g_assert_cmpstr(params, ==, test.output0); +		g_assert_cmpstr(output0, ==, test.output0); +		g_assert_cmpstr(output1, ==, test.output1); + +		g_free(params); +	} +} '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','configure.ac','704','4','2','0','MODIFY','@@ -295,6 +295,8 @@ fi    LIBS=\"$LIBS $GLIB_LIBS\"   +GLIB_TESTS +  dnl **  dnl ** OpenSSL checks  dnl ** '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','glibtests.m4','27','0','28','0','ADD','@@ -0,0 +1,28 @@ +dnl GLIB_TESTS +dnl + +AC_DEFUN([GLIB_TESTS], +[ +  AC_ARG_ENABLE(installed-tests, +                AS_HELP_STRING([--enable-installed-tests], +                               [Enable installation of some test cases]), +                [case ${enableval} in +                  yes) ENABLE_INSTALLED_TESTS=\"1\"  ;; +                  no)  ENABLE_INSTALLED_TESTS=\"\" ;; +                  *) AC_MSG_ERROR([bad value ${enableval} for --enable-installed-tests]) ;; +                 esac]) +  AM_CONDITIONAL([ENABLE_INSTALLED_TESTS], test \"$ENABLE_INSTALLED_TESTS\" = \"1\") +  AC_ARG_ENABLE(always-build-tests, +                AS_HELP_STRING([--enable-always-build-tests], +                               [Enable always building tests during \'make all\']), +                [case ${enableval} in +                  yes) ENABLE_ALWAYS_BUILD_TESTS=\"1\"  ;; +                  no)  ENABLE_ALWAYS_BUILD_TESTS=\"\" ;; +                  *) AC_MSG_ERROR([bad value ${enableval} for --enable-always-build-tests]) ;; +                 esac]) +  AM_CONDITIONAL([ENABLE_ALWAYS_BUILD_TESTS], test \"$ENABLE_ALWAYS_BUILD_TESTS\" = \"1\") +  if test \"$ENABLE_INSTALLED_TESTS\" = \"1\"; then +    AC_SUBST(installed_test_metadir, [${datadir}/installed-tests/]AC_PACKAGE_NAME) +    AC_SUBST(installed_testdir, [${libexecdir}/installed-tests/]AC_PACKAGE_NAME) +  fi +]) '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','Makefile.am','31','0','3','2','MODIFY','@@ -1,11 +1,12 @@ +include $(top_srcdir)/utils/glib-tap.mk +  AM_CPPFLAGS = \\  	-I$(top_srcdir)/src \\  	-I$(top_srcdir)/src/core \\  	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\  	$(GLIB_CFLAGS)   -TESTS = test-irc -check_PROGRAMS = test-irc +test_programs = test-irc    test_irc_CPPFLAGS = \\  	-I$(top_srcdir)/src/irc/core \\ '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','test-irc.c','190','5','1','0','MODIFY','@@ -32,6 +32,7 @@ int main(int argc, char **argv)  	g_test_add_func(\"/test/event_get_param\", test_event_get_param);  	g_test_add_func(\"/test/event_get_params\", test_event_get_params);   +	g_test_set_nonfatal_assertions();  	return g_test_run();  }   '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','Makefile.am','6','0','3','1','MODIFY','@@ -1,4 +1,6 @@  EXTRA_DIST = \\  	file2header.sh \\  	irssi-version.sh \\ -	syntax.pl +	syntax.pl \\ +	tap-driver.sh \\ +	tap-test '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','glib-tap.mk','86','0','134','0','ADD','@@ -0,0 +1,134 @@ +# GLIB - Library of useful C routines + +TESTS_ENVIRONMENT= \\ +	G_TEST_SRCDIR=\"$(abs_srcdir)\" 		\\ +	G_TEST_BUILDDIR=\"$(abs_builddir)\" 	\\ +	G_DEBUG=gc-friendly 			\\ +	MALLOC_CHECK_=2 			\\ +	MALLOC_PERTURB_=$$(($${RANDOM:-256} % 256)) +LOG_DRIVER = env AM_TAP_AWK=\'$(AWK)\' $(SHELL) $(top_srcdir)/utils/tap-driver.sh +LOG_COMPILER = $(top_srcdir)/utils/tap-test + +NULL = + +# initialize variables for unconditional += appending +BUILT_SOURCES = +BUILT_EXTRA_DIST = +CLEANFILES = *.log *.trs +DISTCLEANFILES = +MAINTAINERCLEANFILES = +EXTRA_DIST = +TESTS = + +installed_test_LTLIBRARIES = +installed_test_PROGRAMS = +installed_test_SCRIPTS = +nobase_installed_test_DATA = + +noinst_LTLIBRARIES = +noinst_PROGRAMS = +noinst_SCRIPTS = +noinst_DATA = + +check_LTLIBRARIES = +check_PROGRAMS = +check_SCRIPTS = +check_DATA = + +# We support a fairly large range of possible variables.  It is expected that all types of files in a test suite +# will belong in exactly one of the following variables. +# +# First, we support the usual automake suffixes, but in lowercase, with the customary meaning: +# +#   test_programs, test_scripts, test_data, test_ltlibraries +# +# The above are used to list files that are involved in both uninstalled and installed testing.  The +# test_programs and test_scripts are taken to be actual testcases and will be run as part of the test suite. +# Note that _data is always used with the nobase_ automake variable name to ensure that installed test data is +# installed in the same way as it appears in the package layout. +# +# In order to mark a particular file as being only for one type of testing, use \'installed\' or \'uninstalled\', +# like so: +# +#   installed_test_programs, uninstalled_test_programs +#   installed_test_scripts, uninstalled_test_scripts +#   installed_test_data, uninstalled_test_data +#   installed_test_ltlibraries, uninstalled_test_ltlibraries +# +# Additionally, we support \'extra\' infixes for programs and scripts.  This is used for support programs/scripts +# that should not themselves be run as testcases (but exist to be used from other testcases): +# +#   test_extra_programs, installed_test_extra_programs, uninstalled_test_extra_programs +#   test_extra_scripts, installed_test_extra_scripts, uninstalled_test_extra_scripts +# +# Additionally, for _scripts and _data, we support the customary dist_ prefix so that the named script or data +# file automatically end up in the tarball. +# +#   dist_test_scripts, dist_test_data, dist_test_extra_scripts +#   dist_installed_test_scripts, dist_installed_test_data, dist_installed_test_extra_scripts +#   dist_uninstalled_test_scripts, dist_uninstalled_test_data, dist_uninstalled_test_extra_scripts +# +# Note that no file is automatically disted unless it appears in one of the dist_ variables.  This follows the +# standard automake convention of not disting programs scripts or data by default. +# +# test_programs, test_scripts, uninstalled_test_programs and uninstalled_test_scripts (as well as their disted +# variants) will be run as part of the in-tree \'make check\'.  These are all assumed to be runnable under +# gtester.  That\'s a bit strange for scripts, but it\'s possible. + +TESTS += $(test_programs) $(test_scripts) $(uninstalled_test_programs) $(uninstalled_test_scripts) \\ +         $(dist_test_scripts) $(dist_uninstalled_test_scripts) + +# Note: build even the installed-only targets during \'make check\' to ensure that they still work. +# We need to do a bit of trickery here and manage disting via EXTRA_DIST instead of using dist_ prefixes to +# prevent automake from mistreating gmake functions like $(wildcard ...) and $(addprefix ...) as if they were +# filenames, including removing duplicate instances of the opening part before the space, eg. \'$(addprefix\'. +all_test_programs     = $(test_programs) $(uninstalled_test_programs) $(installed_test_programs) \\ +                        $(test_extra_programs) $(uninstalled_test_extra_programs) $(installed_test_extra_programs) +all_test_scripts      = $(test_scripts) $(uninstalled_test_scripts) $(installed_test_scripts) \\ +                        $(test_extra_scripts) $(uninstalled_test_extra_scripts) $(installed_test_extra_scripts) +all_dist_test_scripts = $(dist_test_scripts) $(dist_uninstalled_test_scripts) $(dist_installed_test_scripts) \\ +                        $(dist_test_extra_scripts) $(dist_uninstalled_test_extra_scripts) $(dist_installed_test_extra_scripts) +all_test_scripts     += $(all_dist_test_scripts) +EXTRA_DIST           += $(all_dist_test_scripts) +all_test_data         = $(test_data) $(uninstalled_test_data) $(installed_test_data) +all_dist_test_data    = $(dist_test_data) $(dist_uninstalled_test_data) $(dist_installed_test_data) +all_test_data        += $(all_dist_test_data) +EXTRA_DIST           += $(all_dist_test_data) +all_test_ltlibs       = $(test_ltlibraries) $(uninstalled_test_ltlibraries) $(installed_test_ltlibraries) + +if ENABLE_ALWAYS_BUILD_TESTS +noinst_LTLIBRARIES += $(all_test_ltlibs) +noinst_PROGRAMS += $(all_test_programs) +noinst_SCRIPTS += $(all_test_scripts) +noinst_DATA += $(all_test_data) +else +check_LTLIBRARIES += $(all_test_ltlibs) +check_PROGRAMS += $(all_test_programs) +check_SCRIPTS += $(all_test_scripts) +check_DATA += $(all_test_data) +endif + +if ENABLE_INSTALLED_TESTS +installed_test_PROGRAMS += $(test_programs) $(installed_test_programs) \\ +                          $(test_extra_programs) $(installed_test_extra_programs) +installed_test_SCRIPTS += $(test_scripts) $(installed_test_scripts) \\ +                          $(test_extra_scripts) $(test_installed_extra_scripts) +installed_test_SCRIPTS += $(dist_test_scripts) $(dist_test_extra_scripts) \\ +                          $(dist_installed_test_scripts) $(dist_installed_test_extra_scripts) +nobase_installed_test_DATA += $(test_data) $(installed_test_data) +nobase_installed_test_DATA += $(dist_test_data) $(dist_installed_test_data) +installed_test_LTLIBRARIES += $(test_ltlibraries) $(installed_test_ltlibraries) +installed_testcases = $(test_programs) $(installed_test_programs) \\ +                      $(test_scripts) $(installed_test_scripts) \\ +                      $(dist_test_scripts) $(dist_installed_test_scripts) + +installed_test_meta_DATA = $(installed_testcases:=.test) + +%.test: %$(EXEEXT) Makefile +	$(AM_V_GEN) (echo \'[Test]\' > $@.tmp; \\ +	echo \'Type=session\' >> $@.tmp; \\ +	echo \'Exec=$(installed_testdir)/$<\' >> $@.tmp; \\ +	mv $@.tmp $@) + +CLEANFILES += $(installed_test_meta_DATA) +endif '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','tap-driver.sh','452','2','652','0','ADD','@@ -0,0 +1,652 @@ +#! /bin/sh +# Copyright (C) 2011-2013 Free Software Foundation, Inc. +# +# This program is free software; you can redistribute it and/or modify +# it under the terms of the GNU General Public License as published by +# the Free Software Foundation; either version 2, or (at your option) +# any later version. +# +# This program is distributed in the hope that it will be useful, +# but WITHOUT ANY WARRANTY; without even the implied warranty of +# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +# GNU General Public License for more details. +# +# You should have received a copy of the GNU General Public License +# along with this program.  If not, see <http://www.gnu.org/licenses/>. + +# As a special exception to the GNU General Public License, if you +# distribute this file as part of a program that contains a +# configuration script generated by Autoconf, you may include it under +# the same distribution terms that you use for the rest of that program. + +# This file is maintained in Automake, please report +# bugs to <bug-automake@gnu.org> or send patches to +# <automake-patches@gnu.org>. + +scriptversion=2011-12-27.17; # UTC + +# Make unconditional expansion of undefined variables an error.  This +# helps a lot in preventing typo-related bugs. +set -u + +me=tap-driver.sh + +fatal () +{ +  echo \"$me: fatal: $*\" >&2 +  exit 1 +} + +usage_error () +{ +  echo \"$me: $*\" >&2 +  print_usage >&2 +  exit 2 +} + +print_usage () +{ +  cat <<END +Usage: +  tap-driver.sh --test-name=NAME --log-file=PATH --trs-file=PATH +                [--expect-failure={yes|no}] [--color-tests={yes|no}] +                [--enable-hard-errors={yes|no}] [--ignore-exit] +                [--diagnostic-string=STRING] [--merge|--no-merge] +                [--comments|--no-comments] [--] TEST-COMMAND +The \\`--test-name\', \\`--log-file\' and \\`--trs-file\' options are mandatory. +END +} + +# TODO: better error handling in option parsing (in particular, ensure +# TODO: $log_file, $trs_file and $test_name are defined). +test_name= # Used for reporting. +log_file=  # Where to save the result and output of the test script. +trs_file=  # Where to save the metadata of the test run. +expect_failure=0 +color_tests=0 +merge=0 +ignore_exit=0 +comments=0 +diag_string=\'#\' +while test $# -gt 0; do +  case $1 in +  --help) print_usage; exit $?;; +  --version) echo \"$me $scriptversion\"; exit $?;; +  --test-name) test_name=$2; shift;; +  --log-file) log_file=$2; shift;; +  --trs-file) trs_file=$2; shift;; +  --color-tests) color_tests=$2; shift;; +  --expect-failure) expect_failure=$2; shift;; +  --enable-hard-errors) shift;; # No-op. +  --merge) merge=1;; +  --no-merge) merge=0;; +  --ignore-exit) ignore_exit=1;; +  --comments) comments=1;; +  --no-comments) comments=0;; +  --diagnostic-string) diag_string=$2; shift;; +  --) shift; break;; +  -*) usage_error \"invalid option: \'$1\'\";; +  esac +  shift +done + +test $# -gt 0 || usage_error \"missing test command\" + +case $expect_failure in +  yes) expect_failure=1;; +    *) expect_failure=0;; +esac + +if test $color_tests = yes; then +  init_colors=\' +    color_map[\"red\"]=\"[0;31m\" # Red. +    color_map[\"grn\"]=\"[0;32m\" # Green. +    color_map[\"lgn\"]=\"[1;32m\" # Light green. +    color_map[\"blu\"]=\"[1;34m\" # Blue. +    color_map[\"mgn\"]=\"[0;35m\" # Magenta. +    color_map[\"std\"]=\"[m\"     # No color. +    color_for_result[\"ERROR\"] = \"mgn\" +    color_for_result[\"PASS\"]  = \"grn\" +    color_for_result[\"XPASS\"] = \"red\" +    color_for_result[\"FAIL\"]  = \"red\" +    color_for_result[\"XFAIL\"] = \"lgn\" +    color_for_result[\"SKIP\"]  = \"blu\"\' +else +  init_colors=\'\' +fi + +# :; is there to work around a bug in bash 3.2 (and earlier) which +# does not always set \'$?\' properly on redirection failure. +# See the Autoconf manual for more details. +:;{ +  ( +    # Ignore common signals (in this subshell only!), to avoid potential +    # problems with Korn shells.  Some Korn shells are known to propagate +    # to themselves signals that have killed a child process they were +    # waiting for; this is done at least for SIGINT (and usually only for +    # it, in truth).  Without the `trap\' below, such a behaviour could +    # cause a premature exit in the current subshell, e.g., in case the +    # test command it runs gets terminated by a SIGINT.  Thus, the awk +    # script we are piping into would never seen the exit status it +    # expects on its last input line (which is displayed below by the +    # last `echo $?\' statement), and would thus die reporting an internal +    # error. +    # For more information, see the Autoconf manual and the threads: +    # <http://lists.gnu.org/archive/html/bug-autoconf/2011-09/msg00004.html> +    # <http://mail.opensolaris.org/pipermail/ksh93-integration-discuss/2009-February/004121.html> +    trap : 1 3 2 13 15 +    if test $merge -gt 0; then +      exec 2>&1 +    else +      exec 2>&3 +    fi +    \"$@\" +    echo $? +  ) | LC_ALL=C ${AM_TAP_AWK-awk} \\ +        -v me=\"$me\" \\ +        -v test_script_name=\"$test_name\" \\ +        -v log_file=\"$log_file\" \\ +        -v trs_file=\"$trs_file\" \\ +        -v expect_failure=\"$expect_failure\" \\ +        -v merge=\"$merge\" \\ +        -v ignore_exit=\"$ignore_exit\" \\ +        -v comments=\"$comments\" \\ +        -v diag_string=\"$diag_string\" \\ +\' +# FIXME: the usages of \"cat >&3\" below could be optimized when using +# FIXME: GNU awk, and/on on systems that supports /dev/fd/. + +# Implementation note: in what follows, `result_obj` will be an +# associative array that (partly) simulates a TAP result object +# from the `TAP::Parser` perl module. + +## ----------- ## +##  FUNCTIONS  ## +## ----------- ## + +function fatal(msg) +{ +  print me \": \" msg | \"cat >&2\" +  exit 1 +} + +function abort(where) +{ +  fatal(\"internal error \" where) +} + +# Convert a boolean to a \"yes\"/\"no\" string. +function yn(bool) +{ +  return bool ? \"yes\" : \"no\"; +} + +function add_test_result(result) +{ +  if (!test_results_index) +    test_results_index = 0 +  test_results_list[test_results_index] = result +  test_results_index += 1 +  test_results_seen[result] = 1; +} + +# Whether the test script should be re-run by \"make recheck\". +function must_recheck() +{ +  for (k in test_results_seen) +    if (k != \"XFAIL\" && k != \"PASS\" && k != \"SKIP\") +      return 1 +  return 0 +} + +# Whether the content of the log file associated to this test should +# be copied into the \"global\" test-suite.log. +function copy_in_global_log() +{ +  for (k in test_results_seen) +    if (k != \"PASS\") +      return 1 +  return 0 +} + +# FIXME: this can certainly be improved ... +function get_global_test_result() +{ +    if (\"ERROR\" in test_results_seen) +      return \"ERROR\" +    if (\"FAIL\" in test_results_seen || \"XPASS\" in test_results_seen) +      return \"FAIL\" +    all_skipped = 1 +    for (k in test_results_seen) +      if (k != \"SKIP\") +        all_skipped = 0 +    if (all_skipped) +      return \"SKIP\" +    return \"PASS\"; +} + +function stringify_result_obj(result_obj) +{ +  if (result_obj[\"is_unplanned\"] || result_obj[\"number\"] != testno) +    return \"ERROR\" + +  if (plan_seen == LATE_PLAN) +    return \"ERROR\" + +  if (result_obj[\"directive\"] == \"TODO\") +    return result_obj[\"is_ok\"] ? \"XPASS\" : \"XFAIL\" + +  if (result_obj[\"directive\"] == \"SKIP\") +    return result_obj[\"is_ok\"] ? \"SKIP\" : COOKED_FAIL; + +  if (length(result_obj[\"directive\"])) +      abort(\"in function stringify_result_obj()\") + +  return result_obj[\"is_ok\"] ? COOKED_PASS : COOKED_FAIL +} + +function decorate_result(result) +{ +  color_name = color_for_result[result] +  if (color_name) +    return color_map[color_name] \"\" result \"\" color_map[\"std\"] +  # If we are not using colorized output, or if we do not know how +  # to colorize the given result, we should return it unchanged. +  return result +} + +function report(result, details) +{ +  if (result ~ /^(X?(PASS|FAIL)|SKIP|ERROR)/) +    { +      msg = \": \" test_script_name +      add_test_result(result) +    } +  else if (result == \"#\") +    { +      msg = \" \" test_script_name \":\" +    } +  else +    { +      abort(\"in function report()\") +    } +  if (length(details)) +    msg = msg \" \" details +  # Output on console might be colorized. +  print decorate_result(result) msg +  # Log the result in the log file too, to help debugging (this is +  # especially true when said result is a TAP error or \"Bail out!\"). +  print result msg | \"cat >&3\"; +} + +function testsuite_error(error_message) +{ +  report(\"ERROR\", \"- \" error_message) +} + +function handle_tap_result() +{ +  details = result_obj[\"number\"]; +  if (length(result_obj[\"description\"])) +    details = details \" \" result_obj[\"description\"] + +  if (plan_seen == LATE_PLAN) +    { +      details = details \" # AFTER LATE PLAN\"; +    } +  else if (result_obj[\"is_unplanned\"]) +    { +       details = details \" # UNPLANNED\"; +    } +  else if (result_obj[\"number\"] != testno) +    { +       details = sprintf(\"%s # OUT-OF-ORDER (expecting %d)\", +                         details, testno); +    } +  else if (result_obj[\"directive\"]) +    { +      details = details \" # \" result_obj[\"directive\"]; +      if (length(result_obj[\"explanation\"])) +        details = details \" \" result_obj[\"explanation\"] +    } + +  report(stringify_result_obj(result_obj), details) +} + +# `skip_reason` should be empty whenever planned > 0. +function handle_tap_plan(planned, skip_reason) +{ +  planned += 0 # Avoid getting confused if, say, `planned` is \"00\" +  if (length(skip_reason) && planned > 0) +    abort(\"in function handle_tap_plan()\") +  if (plan_seen) +    { +      # Error, only one plan per stream is acceptable. +      testsuite_error(\"multiple test plans\") +      return; +    } +  planned_tests = planned +  # The TAP plan can come before or after *all* the TAP results; we speak +  # respectively of an \"early\" or a \"late\" plan.  If we see the plan line +  # after at least one TAP result has been seen, assume we have a late +  # plan; in this case, any further test result seen after the plan will +  # be flagged as an error. +  plan_seen = (testno >= 1 ? LATE_PLAN : EARLY_PLAN) +  # If testno > 0, we have an error (\"too many tests run\") that will be +  # automatically dealt with later, so do not worry about it here.  If +  # $plan_seen is true, we have an error due to a repeated plan, and that +  # has already been dealt with above.  Otherwise, we have a valid \"plan +  # with SKIP\" specification, and should report it as a particular kind +  # of SKIP result. +  if (planned == 0 && testno == 0) +    { +      if (length(skip_reason)) +        skip_reason = \"- \"  skip_reason; +      report(\"SKIP\", skip_reason); +    } +} + +function extract_tap_comment(line) +{ +  if (index(line, diag_string) == 1) +    { +      # Strip leading `diag_string` from `line`. +      line = substr(line, length(diag_string) + 1) +      # And strip any leading and trailing whitespace left. +      sub(\"^[ \\t]*\", \"\", line) +      sub(\"[ \\t]*$\", \"\", line) +      # Return what is left (if any). +      return line; +    } +  return \"\"; +} + +# When this function is called, we know that line is a TAP result line, +# so that it matches the (perl) RE \"^(not )?ok\\b\". +function setup_result_obj(line) +{ +  # Get the result, and remove it from the line. +  result_obj[\"is_ok\"] = (substr(line, 1, 2) == \"ok\" ? 1 : 0) +  sub(\"^(not )?ok[ \\t]*\", \"\", line) + +  # If the result has an explicit number, get it and strip it; otherwise, +  # automatically assing the next progresive number to it. +  if (line ~ /^[0-9]+$/ || line ~ /^[0-9]+[^a-zA-Z0-9_]/) +    { +      match(line, \"^[0-9]+\") +      # The final `+ 0` is to normalize numbers with leading zeros. +      result_obj[\"number\"] = substr(line, 1, RLENGTH) + 0 +      line = substr(line, RLENGTH + 1) +    } +  else +    { +      result_obj[\"number\"] = testno +    } + +  if (plan_seen == LATE_PLAN) +    # No further test results are acceptable after a \"late\" TAP plan +    # has been seen. +    result_obj[\"is_unplanned\"] = 1 +  else if (plan_seen && testno > planned_tests) +    result_obj[\"is_unplanned\"] = 1 +  else +    result_obj[\"is_unplanned\"] = 0 + +  # Strip trailing and leading whitespace. +  sub(\"^[ \\t]*\", \"\", line) +  sub(\"[ \\t]*$\", \"\", line) + +  # This will have to be corrected if we have a \"TODO\"/\"SKIP\" directive. +  result_obj[\"description\"] = line +  result_obj[\"directive\"] = \"\" +  result_obj[\"explanation\"] = \"\" + +  if (index(line, \"#\") == 0) +    return # No possible directive, nothing more to do. + +  # Directives are case-insensitive. +  rx = \"[ \\t]*#[ \\t]*([tT][oO][dD][oO]|[sS][kK][iI][pP])[ \\t]*\" + +  # See whether we have the directive, and if yes, where. +  pos = match(line, rx \"$\") +  if (!pos) +    pos = match(line, rx \"[^a-zA-Z0-9_]\") + +  # If there was no TAP directive, we have nothing more to do. +  if (!pos) +    return + +  # Let`s now see if the TAP directive has been escaped.  For example: +  #  escaped:     ok \\# SKIP +  #  not escaped: ok \\\\# SKIP +  #  escaped:     ok \\\\\\\\\\# SKIP +  #  not escaped: ok \\ # SKIP +  if (substr(line, pos, 1) == \"#\") +    { +      bslash_count = 0 +      for (i = pos; i > 1 && substr(line, i - 1, 1) == \"\\\\\"; i--) +        bslash_count += 1 +      if (bslash_count % 2) +        return # Directive was escaped. +    } + +  # Strip the directive and its explanation (if any) from the test +  # description. +  result_obj[\"description\"] = substr(line, 1, pos - 1) +  # Now remove the test description from the line, that has been dealt +  # with already. +  line = substr(line, pos) +  # Strip the directive, and save its value (normalized to upper case). +  sub(\"^[ \\t]*#[ \\t]*\", \"\", line) +  result_obj[\"directive\"] = toupper(substr(line, 1, 4)) +  line = substr(line, 5) +  # Now get the explanation for the directive (if any), with leading +  # and trailing whitespace removed. +  sub(\"^[ \\t]*\", \"\", line) +  sub(\"[ \\t]*$\", \"\", line) +  result_obj[\"explanation\"] = line +} + +function get_test_exit_message(status) +{ +  if (status == 0) +    return \"\" +  if (status !~ /^[1-9][0-9]*$/) +    abort(\"getting exit status\") +  if (status < 127) +    exit_details = \"\" +  else if (status == 127) +    exit_details = \" (command not found?)\" +  else if (status >= 128 && status <= 255) +    exit_details = sprintf(\" (terminated by signal %d?)\", status - 128) +  else if (status > 256 && status <= 384) +    # We used to report an \"abnormal termination\" here, but some Korn +    # shells, when a child process die due to signal number n, can leave +    # in $? an exit status of 256+n instead of the more standard 128+n. +    # Apparently, both behaviours are allowed by POSIX (2008), so be +    # prepared to handle them both.  See also Austing Group report ID +    # 0000051 <http://www.austingroupbugs.net/view.php?id=51> +    exit_details = sprintf(\" (terminated by signal %d?)\", status - 256) +  else +    # Never seen in practice. +    exit_details = \" (abnormal termination)\" +  return sprintf(\"exited with status %d%s\", status, exit_details) +} + +function write_test_results() +{ +  print \":global-test-result: \" get_global_test_result() > trs_file +  print \":recheck: \"  yn(must_recheck()) > trs_file +  print \":copy-in-global-log: \" yn(copy_in_global_log()) > trs_file +  for (i = 0; i < test_results_index; i += 1) +    print \":test-result: \" test_results_list[i] > trs_file +  close(trs_file); +} + +BEGIN { + +## ------- ## +##  SETUP  ## +## ------- ## + +\'\"$init_colors\"\' + +# Properly initialized once the TAP plan is seen. +planned_tests = 0 + +COOKED_PASS = expect_failure ? \"XPASS\": \"PASS\"; +COOKED_FAIL = expect_failure ? \"XFAIL\": \"FAIL\"; + +# Enumeration-like constants to remember which kind of plan (if any) +# has been seen.  It is important that NO_PLAN evaluates \"false\" as +# a boolean. +NO_PLAN = 0 +EARLY_PLAN = 1 +LATE_PLAN = 2 + +testno = 0     # Number of test results seen so far. +bailed_out = 0 # Whether a \"Bail out!\" directive has been seen. + +# Whether the TAP plan has been seen or not, and if yes, which kind +# it is (\"early\" is seen before any test result, \"late\" otherwise). +plan_seen = NO_PLAN + +## --------- ## +##  PARSING  ## +## --------- ## + +is_first_read = 1 + +while (1) +  { +    # Involutions required so that we are able to read the exit status +    # from the last input line. +    st = getline +    if (st < 0) # I/O error. +      fatal(\"I/O error while reading from input stream\") +    else if (st == 0) # End-of-input +      { +        if (is_first_read) +          abort(\"in input loop: only one input line\") +        break +      } +    if (is_first_read) +      { +        is_first_read = 0 +        nextline = $0 +        continue +      } +    else +      { +        curline = nextline +        nextline = $0 +        $0 = curline +      } +    # Copy any input line verbatim into the log file. +    print | \"cat >&3\" +    # Parsing of TAP input should stop after a \"Bail out!\" directive. +    if (bailed_out) +      continue + +    # TAP test result. +    if ($0 ~ /^(not )?ok$/ || $0 ~ /^(not )?ok[^a-zA-Z0-9_]/) +      { +        testno += 1 +        setup_result_obj($0) +        handle_tap_result() +      } +    # TAP plan (normal or \"SKIP\" without explanation). +    else if ($0 ~ /^1\\.\\.[0-9]+[ \\t]*$/) +      { +        # The next two lines will put the number of planned tests in $0. +        sub(\"^1\\\\.\\\\.\", \"\") +        sub(\"[^0-9]*$\", \"\") +        handle_tap_plan($0, \"\") +        continue +      } +    # TAP \"SKIP\" plan, with an explanation. +    else if ($0 ~ /^1\\.\\.0+[ \\t]*#/) +      { +        # The next lines will put the skip explanation in $0, stripping +        # any leading and trailing whitespace.  This is a little more +        # tricky in truth, since we want to also strip a potential leading +        # \"SKIP\" string from the message. +        sub(\"^[^#]*#[ \\t]*(SKIP[: \\t][ \\t]*)?\", \"\") +        sub(\"[ \\t]*$\", \"\"); +        handle_tap_plan(0, $0) +      } +    # \"Bail out!\" magic. +    # Older versions of prove and TAP::Harness (e.g., 3.17) did not +    # recognize a \"Bail out!\" directive when preceded by leading +    # whitespace, but more modern versions (e.g., 3.23) do.  So we +    # emulate the latter, \"more modern\" behaviour. +    else if ($0 ~ /^[ \\t]*Bail out!/) +      { +        bailed_out = 1 +        # Get the bailout message (if any), with leading and trailing +        # whitespace stripped.  The message remains stored in `$0`. +        sub(\"^[ \\t]*Bail out![ \\t]*\", \"\"); +        sub(\"[ \\t]*$\", \"\"); +        # Format the error message for the +        bailout_message = \"Bail out!\" +        if (length($0)) +          bailout_message = bailout_message \" \" $0 +        testsuite_error(bailout_message) +      } +    # Maybe we have too look for dianogtic comments too. +    else if (comments != 0) +      { +        comment = extract_tap_comment($0); +        if (length(comment)) +          report(\"#\", comment); +      } +  } + +## -------- ## +##  FINISH  ## +## -------- ## + +# A \"Bail out!\" directive should cause us to ignore any following TAP +# error, as well as a non-zero exit status from the TAP producer. +if (!bailed_out) +  { +    if (!plan_seen) +      { +        testsuite_error(\"missing test plan\") +      } +    else if (planned_tests != testno) +      { +        bad_amount = testno > planned_tests ? \"many\" : \"few\" +        testsuite_error(sprintf(\"too %s tests run (expected %d, got %d)\", +                                bad_amount, planned_tests, testno)) +      } +    if (!ignore_exit) +      { +        # Fetch exit status from the last line. +        exit_message = get_test_exit_message(nextline) +        if (exit_message) +          testsuite_error(exit_message) +      } +  } + +write_test_results() + +exit 0 + +} # End of \"BEGIN\" block. +\' + +# TODO: document that we consume the file descriptor 3 :-( +} 3>\"$log_file\" + +test $? -eq 0 || fatal \"I/O or internal error\" + +# Local Variables: +# mode: shell-script +# sh-indentation: 2 +# eval: (add-hook \'write-file-hooks \'time-stamp) +# time-stamp-start: \"scriptversion=\" +# time-stamp-format: \"%:y-%02m-%02d.%02H\" +# time-stamp-time-zone: \"UTC\" +# time-stamp-end: \"; # UTC\" +# End: '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','tap-test','2','0','5','0','ADD','@@ -0,0 +1,5 @@ +#! /bin/sh + +# run a GTest in tap mode. The test binary is passed as $1 + +$1 -k --tap '),('irssi','1.0.5','43d06369bf8e5c5e470dc2b00656ddcdb9ee0480','ailin-nemui','move fixtures to outer scope','Makefile.am','22','0','4','12','MODIFY','@@ -1,5 +1,7 @@  include $(top_srcdir)/utils/glib-tap.mk   +PACKAGE_STRING=irc/core +  AM_CPPFLAGS = \\  	-I$(top_srcdir)/src \\  	-I$(top_srcdir)/src/core \\ @@ -17,21 +19,11 @@ test_irc_DEPENDENCIES = \\  	../../../src/lib-config/libirssi_config.a    test_irc_LDADD = \\ +	../../../src/irc/core/libirc_core.a \\  	../../../src/core/libcore.a \\  	../../../src/lib-config/libirssi_config.a \\  	@GLIB_LIBS@ \\  	@OPENSSL_LIBS@    test_irc_SOURCES = \\ -	test-irc.c \\ -	../../../src/irc/core/irc-cap.c \\ -	../../../src/irc/core/irc-nicklist.c \\ -	../../../src/irc/core/irc-queries.c \\ -	../../../src/irc/core/irc-servers-reconnect.c \\ -	../../../src/irc/core/irc-servers-setup.c \\ -	../../../src/irc/core/irc-servers.c \\ -	../../../src/irc/core/irc.c \\ -	../../../src/irc/core/mode-lists.c \\ -	../../../src/irc/core/modes.c \\ -	../../../src/irc/core/servers-idle.c \\ -	../../../src/irc/core/servers-redirect.c +	test-irc.c '),('irssi','1.0.5','43d06369bf8e5c5e470dc2b00656ddcdb9ee0480','ailin-nemui','move fixtures to outer scope','test-irc.c','191','5','190','190','MODIFY','@@ -22,210 +22,210 @@  #include <irc.h>  #include <string.h>   -static void test_event_get_param(void); -static void test_event_get_params(void); +typedef struct { +	char const *const description; +	char const *const input; +	char const *const input_after; +	char const *const output; +} event_get_param_test_case; + +event_get_param_test_case const event_get_param_fixtures[] = { +	{ +		.description = \"Zero parameters\", +		.input       = \"\", +		.input_after = \"\", +		.output      = \"\", +	}, +	{ +		.description = \"One parameter\", +		.input       = \"#test\", +		.input_after = \"\", +		.output      = \"#test\", +	}, +	{ +		.description = \"One parameter, trailing space\", +		.input       = \"#test \", +		.input_after = \"\", +		.output      = \"#test\", +	}, +	{ +		.description = \"One parameter, more trailing space\", +		.input       = \"#test  \", +		.input_after = \" \", +		.output      = \"#test\", +	}, +	{ +		.description = \"Two parameters\", +		.input       = \"#test +o\", +		.input_after = \"+o\", +		.output      = \"#test\", +	}, +	{ +		.description = \"Two parameters continued\", +		.input       = \"+o\", +		.input_after = \"\", +		.output      = \"+o\", +	}, +	{ +		.description = \"Two parameters with trailing space\", +		.input       = \"#test +o \", +		.input_after = \"+o \", +		.output      = \"#test\", +	}, +	{ +		.description = \"Two parameters with trailing space continued\", +		.input       = \"+o \", +		.input_after = \"\", +		.output      = \"+o\", +	}, +	{ +		.description = \"Two parameters with inline and trailing space\", +		.input       = \"#test  +o \", +		.input_after = \" +o \", +		.output      = \"#test\", +	}, +	/* TODO: It seems not ideal that the caller has to deal with inline space. +	 */ +	{ +		.description = \"Two parameters with inline and trailing space continued\", +		.input       = \" +o \", +		.input_after = \"+o \", +		.output      = \"\", +	}, +}; + +static void test_event_get_param(const event_get_param_test_case *test); + +typedef struct { +	char const *const description; +	char const *const input; +	char const *const output0; +	char const *const output1; +} event_get_params_test_case; + +event_get_params_test_case const event_get_params_fixtures[] = { +	{ +		.description = \"Only a channel\", +		.input       = \"#test\", +		.output0     = \"#test\", +		.output1     = \"\", +	}, +	{ +		.description = \"Only a channel with trailing space\", +		.input       = \"#test \", +		.output0     = \"#test\", +		.output1     = \"\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with one parameter after channel name\", +		.input       = \"#test +i\", +		.output0     = \"#test\", +		.output1     = \"+i\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with two parameters after channel name\", +		.input       = \"#test +o tester\", +		.output0     = \"#test\", +		.output1     = \"+o tester\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with three parameters afer channel name\", +		.input       = \"#test +ov tester tester2\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\", +		.input       = \"#test  +ov  tester  tester2 \", +		.output0     = \"#test\", +		.output1     = \" +ov  tester  tester2 \", +	}, +	{ +		.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\", +		.input       = \"#test :+i\", +		.output0     = \"#test\", +		.output1     = \"+i\", +	}, +	{ +		.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\", +		.input       = \"#test :+o tester\", +		.output0     = \"#test\", +		.output1     = \"+o tester\", +	}, +	{ +		.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\", +		.input       = \"#test :+ov tester tester2\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2\", +	}, +	{ +		.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\", +		.input       = \"#test +o :tester\", +		.output0     = \"#test\", +		.output1     = \"+o tester\", +	}, +	{ +		.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\", +		.input       = \"#test +ov tester :tester2\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2\", +	}, +	{ +		.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\", +		.input       = \"#test +ov tester :tester2 hi:there\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2 hi:there\", +	}, +}; + +static void test_event_get_params(const event_get_params_test_case *test);    int main(int argc, char **argv)  { +	int i; +  	g_test_init(&argc, &argv, NULL);   -	g_test_add_func(\"/test/event_get_param\", test_event_get_param); -	g_test_add_func(\"/test/event_get_params\", test_event_get_params); +	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) { +		char *name = g_strdup_printf(\"/test/event_get_params/%d\", i); +		g_test_add_data_func(name, &event_get_params_fixtures[i], (GTestDataFunc)test_event_get_params); +		g_free(name); +	} +	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) { +		char *name = g_strdup_printf(\"/test/event_get_param/%d\", i); +		g_test_add_data_func(name, &event_get_param_fixtures[i], (GTestDataFunc)test_event_get_param); +		g_free(name); +	}    	g_test_set_nonfatal_assertions();  	return g_test_run();  }   -static void test_event_get_param(void) +static void test_event_get_param(const event_get_param_test_case *test)  { -	struct test_case { -		char const *const description; -		char const *const input; -		char const *const input_after; -		char const *const output; -	}; - -	struct test_case const tests[] = { -		{ -			.description = \"Zero parameters\", -			.input       = \"\", -			.input_after = \"\", -			.output      = \"\", -		}, -		{ -			.description = \"One parameter\", -			.input       = \"#test\", -			.input_after = \"\", -			.output      = \"#test\", -		}, -		{ -			.description = \"One parameter, trailing space\", -			.input       = \"#test \", -			.input_after = \"\", -			.output      = \"#test\", -		}, -		{ -			.description = \"One parameter, more trailing space\", -			.input       = \"#test  \", -			.input_after = \" \", -			.output      = \"#test\", -		}, -		{ -			.description = \"Two parameters\", -			.input       = \"#test +o\", -			.input_after = \"+o\", -			.output      = \"#test\", -		}, -		{ -			.description = \"Two parameters continued\", -			.input       = \"+o\", -			.input_after = \"\", -			.output      = \"+o\", -		}, -		{ -			.description = \"Two parameters with trailing space\", -			.input       = \"#test +o \", -			.input_after = \"+o \", -			.output      = \"#test\", -		}, -		{ -			.description = \"Two parameters with trailing space continued\", -			.input       = \"+o \", -			.input_after = \"\", -			.output      = \"+o\", -		}, -		{ -			.description = \"Two parameters with inline and trailing space\", -			.input       = \"#test  +o \", -			.input_after = \" +o \", -			.output      = \"#test\", -		}, -		/* TODO: It seems not ideal that the caller has to deal with inline space. -		 */ -		{ -			.description = \"Two parameters with inline and trailing space continued\", -			.input       = \" +o \", -			.input_after = \"+o \", -			.output      = \"\", -		}, -	}; - -	char *buf = g_malloc0(1024); - -	int i = 0; -	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { -		struct test_case const test = tests[i]; - -		memcpy(buf, test.input, strlen(test.input)+1); -		char *input = buf; - -		char *const output = event_get_param(&input); - -		g_assert_cmpstr(input, ==, test.input_after); -		g_assert_cmpstr(output, ==, test.output); -	} +	char *buf, *input, *output; + +	input = buf = g_strdup(test->input); +	output = event_get_param(&input); + +	g_assert_cmpstr(input, ==, test->input_after); +	g_assert_cmpstr(output, ==, test->output);    	g_free(buf);  }   -static void test_event_get_params(void) +static void test_event_get_params(const event_get_params_test_case *test)  { -	struct test_case { -		char const *const description; -		char const *const input; -		char const *const output0; -		char const *const output1; -	}; - -	struct test_case const tests[] = { -		{ -			.description = \"Only a channel\", -			.input       = \"#test\", -			.output0     = \"#test\", -			.output1     = \"\", -		}, -		{ -			.description = \"Only a channel with trailing space\", -			.input       = \"#test \", -			.output0     = \"#test\", -			.output1     = \"\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with one parameter after channel name\", -			.input       = \"#test +i\", -			.output0     = \"#test\", -			.output1     = \"+i\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with two parameters after channel name\", -			.input       = \"#test +o tester\", -			.output0     = \"#test\", -			.output1     = \"+o tester\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with three parameters afer channel name\", -			.input       = \"#test +ov tester tester2\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\", -			.input       = \"#test  +ov  tester  tester2 \", -			.output0     = \"#test\", -			.output1     = \" +ov  tester  tester2 \", -		}, -		{ -			.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\", -			.input       = \"#test :+i\", -			.output0     = \"#test\", -			.output1     = \"+i\", -		}, -		{ -			.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\", -			.input       = \"#test :+o tester\", -			.output0     = \"#test\", -			.output1     = \"+o tester\", -		}, -		{ -			.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\", -			.input       = \"#test :+ov tester tester2\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2\", -		}, -		{ -			.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\", -			.input       = \"#test +o :tester\", -			.output0     = \"#test\", -			.output1     = \"+o tester\", -		}, -		{ -			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\", -			.input       = \"#test +ov tester :tester2\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2\", -		}, -		{ -			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\", -			.input       = \"#test +ov tester :tester2 hi:there\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2 hi:there\", -		}, -	}; - -	int i = 0; -	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { -		struct test_case const test = tests[i]; - -		char *output0 = NULL; -		char *output1 = NULL; -		char *const params = event_get_params(test.input, 2 | PARAM_FLAG_GETREST, -				&output0, &output1); - -		/* params happens to always point at the first output */ -		g_assert_cmpstr(params, ==, test.output0); -		g_assert_cmpstr(output0, ==, test.output0); -		g_assert_cmpstr(output1, ==, test.output1); - -		g_free(params); -	} +	char *output0, *output1, *params; +	output0 = NULL; +	output1 = NULL; +	params = event_get_params(test->input, 2 | PARAM_FLAG_GETREST, +			&output0, &output1); + +	/* params happens to always point at the first output */ +	g_assert_cmpstr(params, ==, test->output0); +	g_assert_cmpstr(output0, ==, test->output0); +	g_assert_cmpstr(output1, ==, test->output1); + +	g_free(params);  } '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','configure.ac','706','4','2','0','MODIFY','@@ -661,6 +661,8 @@ src/perl/textui/Makefile.PL  scripts/Makefile  scripts/examples/Makefile  tests/Makefile +tests/fe-common/Makefile +tests/fe-common/core/Makefile  tests/irc/Makefile  tests/irc/core/Makefile  docs/Makefile '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','1','0','1','1','MODIFY','@@ -1 +1 @@ -SUBDIRS = irc +SUBDIRS = fe-common irc '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = core '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','21','0','28','0','ADD','@@ -0,0 +1,28 @@ +include $(top_srcdir)/utils/glib-tap.mk + +PACKAGE_STRING=fe-common/core + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core \\ +	$(GLIB_CFLAGS) + +test_programs = test-formats + +test_formats_CPPFLAGS = \\ +	-I$(top_srcdir)/src/fe-common/core \\ +	$(AM_CPPFLAGS) + +test_formats_DEPENDENCIES = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a + +test_formats_LDADD = \\ +	../../../src/fe-common/core/libfe_common_core.a \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a \\ +	@GLIB_LIBS@ \\ +	@OPENSSL_LIBS@ + +test_formats_SOURCES = \\ +	test-formats.c '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','test-formats.c','37','4','50','0','ADD','@@ -0,0 +1,50 @@ +#include \"common.h\" +#include \"formats.h\" + +#define MAX_LENGTH 5 + +typedef struct { +	char const *const description; +	char const *const input; +	int const result[ MAX_LENGTH ]; +} format_real_length_test_case; + +static void test_format_real_length(const format_real_length_test_case *test); + +format_real_length_test_case const format_real_length_fixtures[] = { +	{ +		.description = \"\", +		.input = \"%4%w \", +		.result = { 0, 5, 5, -1 }, +	}, +}; + +int main(int argc, char **argv) +{ +	int i; + +	g_test_init(&argc, &argv, NULL); + +	for (i = 0; i < G_N_ELEMENTS(format_real_length_fixtures); i++) { +		char *name = g_strdup_printf(\"/test/format_real_length/%d\", i); +		g_test_add_data_func(name, &format_real_length_fixtures[i], (GTestDataFunc)test_format_real_length); +		g_free(name); +	} + +	g_test_set_nonfatal_assertions(); +	return g_test_run(); +} + +static void test_format_real_length(const format_real_length_test_case *test) +{ +	int j, len; + +	g_test_message(\"Testing format %s\", test->input); + +	for (j = 0; test->result[j] != -1; j++) { +		len = format_real_length(test->input, j); +		g_assert_cmpint(len, ==, test->result[j]); +	} + +	return; +} '),('irssi','1.0.5','d6458304d7dba0644fb4b682e09baf0acebdbb97','ailin-nemui','mess with travis','.travis.yml','58','0','16','7','MODIFY','@@ -12,8 +12,13 @@ perl:      # - \"5.18-shrplib\"      - \"system-perl\"  env: -    - CC=clang -    - CC=gcc +    - CC=clang UNITTESTS=false +    - CC=gcc   UNITTESTS=false +    - CC=clang UNITTESTS=true +matrix: +    exclude: +        - env: CC=clang UNITTESTS=true +          perl: \"system-perl\"    addons:      apt: @@ -31,11 +36,12 @@ before_install:    install:      - ./configure --with-proxy --with-bot --with-perl=module --prefix=$HOME/irssi-build +      $( $UNITTESTS && echo --enable-always-build-tests )      - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"      - make install    before_script: -    - cd +    - pushd ~      - mkdir irssi-test      - echo echo automated irssi launch test > irssi-test/startup;        echo ^set settings_autosave off >> irssi-test/startup; @@ -47,9 +53,12 @@ before_script:      - echo load perl >> irssi-test/startup      - echo load proxy >> irssi-test/startup      - echo ^quit >> irssi-test/startup -    - irssi-build/bin/irssi --home irssi-test -    - cat irc.log.* -    - cd $TRAVIS_BUILD_DIR    script: -    - make check +    - irssi-build/bin/irssi --home irssi-test +    - popd +    - if $UNITTESTS; then make -C tests -sk check; fi + +after_script: +    - cat ~/irc.log.*; +      find -name test-suite.log -exec cat {} + '),('irssi','1.0.5','eb9e2ed6fdacc3fa262b4907de51dea3f12be5fe','ailin-nemui','Update test-irc.c  Fix wrong array (missing an s)','test-irc.c','191','5','1','1','MODIFY','@@ -186,7 +186,7 @@ int main(int argc, char **argv)    	g_test_init(&argc, &argv, NULL);   -	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) { +	for (i = 0; i < G_N_ELEMENTS(event_get_params_fixtures); i++) {  		char *name = g_strdup_printf(\"/test/event_get_params/%d\", i);  		g_test_add_data_func(name, &event_get_params_fixtures[i], (GTestDataFunc)test_event_get_params);  		g_free(name); '),('irssi','1.0.5','8b34871ea67c420b045ead9e317b67a247c02aae','ailin-nemui','make travis pass despite failures','.travis.yml','60','0','2','0','MODIFY','@@ -19,6 +19,8 @@ matrix:      exclude:          - env: CC=clang UNITTESTS=true            perl: \"system-perl\" +    allow_failures: +        - env: CC=clang UNITTESTS=true    addons:      apt: '),('irssi','1.0.5','58557d18c49c11cd4a4de44c5a9e7c00f2d8f880','ailin-nemui','add separator in travis.yml','.travis.yml','60','0','2','2','MODIFY','@@ -62,5 +62,5 @@ script:      - if $UNITTESTS; then make -C tests -sk check; fi    after_script: -    - cat ~/irc.log.*; -      find -name test-suite.log -exec cat {} + +    - cat ~/irc.log.* +    - find -name test-suite.log -exec cat {} + '),('irssi','1.0.5','ef07b3c60c80a828f529a2075246185d7d0b5b25','Joseph Bisch','Remove redundant if case','event-get-params.c','57','10','0','2','MODIFY','@@ -74,8 +74,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		params = event_get_params(copy, 2, &output0, &output1);  	} else if (count % 8 == 6) {  		params = event_get_params(copy, 3, &output0, &output1, &output2); -	} else if (count % 8 == 7) { -		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);  	} else {  		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);  	} '),('irssi','1.0.5','15705432e1fb88d9f784cb3fc12c89f8f9164043','Joseph Bisch','Remove outdated comment','event-get-params.c','57','10','0','1','MODIFY','@@ -52,7 +52,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		return 0;  	}  	uint8_t count = *data; -	/* malloc(size) instead of size+1, because we already used one byte of data */  	gchar *copy = g_strndup((const gchar *)data+1, size-1);    	char *output0; '),('irssi','1.0.5','54d453623d879ea83d0818a80bd14151192953ec','ailin-nemui','do not record topic change time when sender is blank','channel-events.c','275','68','7','1','MODIFY','@@ -138,7 +138,13 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,  	g_free_not_null(chanrec->topic_by);  	chanrec->topic_by = g_strdup(setby);   -	chanrec->topic_time = settime; +	if (chanrec->topic_by == NULL) { +		/* ensure invariant topic_time > 0 <=> topic_by != NULL. +		   this could be triggered by a topic command without sender */ +		chanrec->topic_time = 0; +	} else { +		chanrec->topic_time = settime; +	}    	signal_emit(\"channel topic changed\", 1, chanrec);  } '),('irssi','1.0.5','7a83c63701b7395ee6cc606905314318eef77971','ailin-nemui','check if \\\\c is complete in eval','misc.c','781','258','5','2','MODIFY','@@ -703,8 +703,11 @@ int expand_escape(const char **data)  		*data += 2;  		return strtol(digit, NULL, 16);  	case \'c\': -                /* control character (\\cA = ^A) */ -                (*data)++; +		/* check for end of string */ +		if ((*data)[1] == \'\\0\') +			return 0; +		/* control character (\\cA = ^A) */ +		(*data)++;  		return i_toupper(**data) - 64;  	case \'0\': case \'1\': case \'2\': case \'3\':  	case \'4\': case \'5\': case \'6\': case \'7\': '),('irssi','1.0.5','2361d4b1e5d38701f35146219ceddd318ac4e645','ailin-nemui','rewrite completion code and check for direct match of separator','completion.c','658','185','12','6','MODIFY','@@ -187,12 +187,18 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  			char *old;    			old = linestart; -			linestart = *linestart == \'\\0\' ? -				g_strdup(word) : -				g_strdup_printf(\"%s%c%s\", -						/* do not accidentally duplicate the word separator */ -						line == wordstart - 1 ? \"\" : linestart, -						old_wordstart[-1], word); +			/* we want to move word into linestart */ +			if (*linestart == \'\\0\') { +				linestart = g_strdup(word); +			} else { +				GString *str = g_string_new(linestart); +				if (old_wordstart[-1] != str->str[str->len - 1]) { +					/* do not accidentally duplicate the word separator */ +					g_string_append_c(str, old_wordstart[-1]); +				} +				g_string_append(str, word); +				linestart = g_string_free(str, FALSE); +			}  			g_free(old);    			g_free(word); '),('irssi','1.0.5','cc17837a9b326ec9100a35981348fa0f5d6316fa','ailin-nemui','disable variable arguments code','special-vars.c','541','162','4','0','MODIFY','@@ -384,6 +384,7 @@ char *parse_special(char **cmd, SERVER_REC *server, void *item,  	}    	nest_free = FALSE; nest_value = NULL; +#if 0 /* this code is disabled due to security issues until it is fixed */  	if (**cmd == \'(\' && (*cmd)[1] != \'\\0\') {  		/* subvariable */  		int toplevel = nested_orig_cmd == NULL; @@ -412,6 +413,9 @@ char *parse_special(char **cmd, SERVER_REC *server, void *item,                    if (toplevel) nested_orig_cmd = NULL;  	} +#else +	if (nested_orig_cmd) nested_orig_cmd = NULL; +#endif    	if (**cmd != \'{\')  		brackets = FALSE; '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','configure.ac','707','4','1','0','MODIFY','@@ -665,6 +665,7 @@ tests/fe-common/Makefile  tests/fe-common/core/Makefile  tests/irc/Makefile  tests/irc/core/Makefile +tests/irc/flood/Makefile  docs/Makefile  docs/help/Makefile  docs/help/in/Makefile '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','Makefile.am','3','0','3','1','MODIFY','@@ -1 +1,3 @@ -SUBDIRS = core +SUBDIRS = \\ +	core \\ +	flood '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','Makefile.am','25','0','32','0','ADD','@@ -0,0 +1,32 @@ +include $(top_srcdir)/utils/glib-tap.mk + +PACKAGE_STRING=irc/flood + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core \\ +	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\ +	$(GLIB_CFLAGS) + +test_programs = \\ +	test-796 + +test_796_CPPFLAGS = \\ +	-I$(top_srcdir)/src/irc/core \\ +	-I$(top_srcdir)/src/irc/flood \\ +	$(AM_CPPFLAGS) + +test_796_DEPENDENCIES = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a + +test_796_LDADD = \\ +	../../../src/irc/flood/libirc_flood.a \\ +	../../../src/irc/core/libirc_core.a \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a \\ +	@GLIB_LIBS@ \\ +	@OPENSSL_LIBS@ + +test_796_SOURCES = \\ +	test-796.c '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','test-796.c','7','1','29','0','ADD','@@ -0,0 +1,29 @@ +/* + test-796.c : irssi + +    Copyright (C) 2017 The Irssi project. + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"common.h\" + +int main(int argc, char **argv) +{ +	g_test_init(&argc, &argv, NULL); + +	g_test_set_nonfatal_assertions(); +	return g_test_run(); +} '),('irssi','1.0.5','c7cd49f8d7e83302c0f21f4449cddac528d28eea','ailin-nemui','first bug case, exposes broken server object in chat-completion','Makefile.am','33','0','8','0','MODIFY','@@ -12,6 +12,7 @@ test_programs = \\  	test-796    test_796_CPPFLAGS = \\ +	-I$(top_srcdir)/src/fe-common/core \\  	-I$(top_srcdir)/src/irc/core \\  	-I$(top_srcdir)/src/irc/flood \\  	$(AM_CPPFLAGS) @@ -21,8 +22,15 @@ test_796_DEPENDENCIES = \\  	../../../src/lib-config/libirssi_config.a    test_796_LDADD = \\ +	../../../src/irc/libirc.a \\ +	../../../src/fe-common/irc/libfe_common_irc.a \\ +	../../../src/fe-common/irc/dcc/libfe_irc_dcc.a \\ +	../../../src/fe-common/irc/notifylist/libfe_irc_notifylist.a \\ +	../../../src/irc/dcc/libirc_dcc.a \\ +	../../../src/irc/notifylist/libirc_notifylist.a \\  	../../../src/irc/flood/libirc_flood.a \\  	../../../src/irc/core/libirc_core.a \\ +	../../../src/fe-common/core/libfe_common_core.a \\  	../../../src/core/libcore.a \\  	../../../src/lib-config/libirssi_config.a \\  	@GLIB_LIBS@ \\ '),('irssi','1.0.5','c7cd49f8d7e83302c0f21f4449cddac528d28eea','ailin-nemui','first bug case, exposes broken server object in chat-completion','test-796.c','92','8','122','0','MODIFY','@@ -19,11 +19,133 @@  */    #include \"common.h\" +#include \"args.h\" +#include \"core.h\" +#include \"misc.h\" +#include \"servers-setup.h\" + +#include \"formats.h\" +#include \"fe-common-core.h\" + +#include \"irc.h\" +#include \"irc-servers.h\" +#include \"irc-channels.h\" + +/* irc.c */ +void irc_init(void); +void irc_deinit(void) ; + +/* irc-session.c */ +void irc_session_init(void); +void irc_session_deinit(void); + +/* fe-common-irc.c */ +void fe_common_irc_init(void); +void fe_common_irc_deinit(void); + +typedef struct { +} ServerDestroyFloodData; + +#define MODULE_NAME \"tests\" + +static void cmd_echo(const char *data, void *server, WI_ITEM_REC *item) +{ +	g_test_message(\"echo: [server=%p,item=%p] %s\", server, item, data); +} + +static void sig_public(SERVER_REC *server, const char *msg, const char *nick, const char *address, const char *target) +{ +	signal_emit(\"send command\", 3, \"/eval echo $tag\", server, NULL); +} + +static void print_disconnect(SERVER_REC *server) +{ +	g_test_message(\"server %p was disconnected\", server); +} + +static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const void *data) +{ +	args_execute(0, NULL); +	core_init(); +	irc_init(); +	fe_common_core_init(); +	fe_common_irc_init(); +	signal_emit(\"irssi init finished\", 0); +	command_bind(\"echo\", NULL, (SIGNAL_FUNC) cmd_echo); +	signal_add(\"message public\", (SIGNAL_FUNC) sig_public); +	signal_add_first(\"server disconnected\", (SIGNAL_FUNC) print_disconnect); +} + +static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, const void *data) +{ +	signal_remove(\"server disconnected\", (SIGNAL_FUNC) print_disconnect); +	signal_remove(\"message public\", (SIGNAL_FUNC) sig_public); +	command_unbind(\"echo\", (SIGNAL_FUNC) cmd_echo); +	fe_common_irc_deinit(); +	fe_common_core_deinit(); +	irc_deinit(); +	core_deinit(); +} + +static void irc_server_init_bare_minimum(IRC_SERVER_REC *server) +{ +	server->isupport = g_hash_table_new((GHashFunc) g_istr_hash, +                                            (GCompareFunc) g_istr_equal); + +        /* set the standards */ +        g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\")); +        g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\")); +} + +static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const void *data) +{ +	SERVER_REC *server; /* = g_new0(IRC_SERVER_REC, 1); */ +        CHAT_PROTOCOL_REC *proto; +	SERVER_CONNECT_REC *conn; + +	g_test_bug(\"796\"); + +	proto = chat_protocol_find(\"IRC\"); +	conn = server_create_conn(proto->id, \"localhost\", 0, \"\", \"\", \"user\"); +	server = proto->server_init_connect(conn); +	server->session_reconnect = TRUE; +	server->tag = g_strdup(\"testserver\"); + +	g_test_message(\"created server: %p\", server); + +	/* we skip some initialisations that would try to send data */ +	/* irc_servers_deinit(); */ +	irc_session_deinit(); +	irc_irc_deinit(); + +	signal_emit(\"server connected\", 1, server); + +	/* make up for the skipped session init */ +	irc_server_init_bare_minimum(IRC_SERVER(server)); + +	irc_irc_init(); +	irc_session_init(); +	/* irc_servers_init(); */ + +	/* simulate failing irc_server_send_data() */ +	server->connection_lost = TRUE; + +	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\"); +}    int main(int argc, char **argv)  {  	g_test_init(&argc, &argv, NULL); +	g_test_bug_base(\"https://github.com/irssi/irssi/issues/\"); + +	g_test_add(\"/test/server_destroy_flood\", ServerDestroyFloodData, NULL, +		   server_destroy_flood_set_up, test_server_destroy_flood, +		   server_destroy_flood_tear_down);    	g_test_set_nonfatal_assertions(); + +	core_preinit(*argv); +	irssi_gui = IRSSI_GUI_NONE; +  	return g_test_run();  } '),('irssi','1.0.5','3b7b868bb11faf74c872ecf606c4eef189e31725','ailin-nemui','finish test case','test-796.c','94','8','13','1','MODIFY','@@ -110,6 +110,7 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	server = proto->server_init_connect(conn);  	server->session_reconnect = TRUE;  	server->tag = g_strdup(\"testserver\"); +	server_ref(server);    	g_test_message(\"created server: %p\", server);   @@ -118,7 +119,8 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	irc_session_deinit();  	irc_irc_deinit();   -	signal_emit(\"server connected\", 1, server); + +	server_connect_finished(server);    	/* make up for the skipped session init */  	irc_server_init_bare_minimum(IRC_SERVER(server)); @@ -130,6 +132,16 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	/* simulate failing irc_server_send_data() */  	server->connection_lost = TRUE;   +	/* +	chat_completion_deinit(); +	fe_messages_deinit(); +	irc_notifylist_deinit(); +	*/ + +	/* for the purpose of this exercise, we are ignoring the +	   errors of g_hash_table_lookup failure */ +	g_log_set_always_fatal(G_LOG_FATAL_MASK); +  	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\");  }   '),('irssi','1.0.5','bffced54981c191f5bac4f9611e4691fe442e58c','ailin-nemui','Update test-796.c  odd space','test-796.c','94','8','1','1','MODIFY','@@ -33,7 +33,7 @@    /* irc.c */  void irc_init(void); -void irc_deinit(void) ; +void irc_deinit(void);    /* irc-session.c */  void irc_session_init(void); '),('irssi','1.0.5','6b0e14099655bf4d94a19dff252cce89b2858c93','ailin-nemui','show destroyed event','test-796.c','103','9','21','10','MODIFY','@@ -63,6 +63,11 @@ static void print_disconnect(SERVER_REC *server)  	g_test_message(\"server %p was disconnected\", server);  }   +static void print_destroyed(SERVER_REC *server) +{ +	g_test_message(\"server %p was destroyed\", server); +} +  static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const void *data)  {  	args_execute(0, NULL); @@ -73,12 +78,14 @@ static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const v  	signal_emit(\"irssi init finished\", 0);  	command_bind(\"echo\", NULL, (SIGNAL_FUNC) cmd_echo);  	signal_add(\"message public\", (SIGNAL_FUNC) sig_public); +	signal_add(\"server destroyed\", (SIGNAL_FUNC) print_destroyed);  	signal_add_first(\"server disconnected\", (SIGNAL_FUNC) print_disconnect);  }    static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, const void *data)  {  	signal_remove(\"server disconnected\", (SIGNAL_FUNC) print_disconnect); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) print_destroyed);  	signal_remove(\"message public\", (SIGNAL_FUNC) sig_public);  	command_unbind(\"echo\", (SIGNAL_FUNC) cmd_echo);  	fe_common_irc_deinit(); @@ -90,27 +97,31 @@ static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, cons  static void irc_server_init_bare_minimum(IRC_SERVER_REC *server)  {  	server->isupport = g_hash_table_new((GHashFunc) g_istr_hash, -                                            (GCompareFunc) g_istr_equal); +					    (GCompareFunc) g_istr_equal);   -        /* set the standards */ -        g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\")); -        g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\")); +	/* set the standards */ +	g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\")); +	g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\"));  }    static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const void *data)  {  	SERVER_REC *server; /* = g_new0(IRC_SERVER_REC, 1); */ -        CHAT_PROTOCOL_REC *proto; +	CHAT_PROTOCOL_REC *proto;  	SERVER_CONNECT_REC *conn; +	GLogLevelFlags loglev;    	g_test_bug(\"796\");   +	/* for the purpose of this exercise, we are ignoring the +	   errors of g_hash_table_lookup failure */ +	loglev = g_log_set_always_fatal(G_LOG_FATAL_MASK); +  	proto = chat_protocol_find(\"IRC\");  	conn = server_create_conn(proto->id, \"localhost\", 0, \"\", \"\", \"user\");  	server = proto->server_init_connect(conn);  	server->session_reconnect = TRUE;  	server->tag = g_strdup(\"testserver\"); -	server_ref(server);    	g_test_message(\"created server: %p\", server);   @@ -138,11 +149,11 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	irc_notifylist_deinit();  	*/   -	/* for the purpose of this exercise, we are ignoring the -	   errors of g_hash_table_lookup failure */ -	g_log_set_always_fatal(G_LOG_FATAL_MASK); - +	server_ref(server);  	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\"); +	server_unref(server); + +	g_log_set_always_fatal(loglev);  }    int main(int argc, char **argv) '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','servers.c','544','132','1','0','MODIFY','@@ -524,6 +524,7 @@ int server_unref(SERVER_REC *server)  		return TRUE;  	}   +	signal_emit(\"server destroyed\", 1, server);          MODULE_DATA_DEINIT(server);  	server_connect_unref(server->connrec);  	if (server->rawlog != NULL) rawlog_destroy(server->rawlog); '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','fe-common-core.c','377','54','3','3','MODIFY','@@ -104,7 +104,7 @@ static void sig_connected(SERVER_REC *server)  	MODULE_DATA_SET(server, g_new0(MODULE_SERVER_REC, 1));  }   -static void sig_disconnected(SERVER_REC *server) +static void sig_destroyed(SERVER_REC *server)  {  	void *data = MODULE_DATA(server);  	g_free(data); @@ -203,7 +203,7 @@ void fe_common_core_init(void)  	settings_check();            signal_add_first(\"server connected\", (SIGNAL_FUNC) sig_connected); -        signal_add_last(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +        signal_add_last(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);          signal_add_first(\"channel created\", (SIGNAL_FUNC) sig_channel_created);          signal_add_last(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);   @@ -249,7 +249,7 @@ void fe_common_core_deinit(void)            signal_remove(\"setup changed\", (SIGNAL_FUNC) sig_setup_changed);          signal_remove(\"server connected\", (SIGNAL_FUNC) sig_connected); -        signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +        signal_remove(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);          signal_remove(\"channel created\", (SIGNAL_FUNC) sig_channel_created);          signal_remove(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);  } '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','irc-servers.c','780','195','3','3','MODIFY','@@ -425,7 +425,7 @@ static void isupport_destroy_hash(void *key, void *value)  	g_free(value);  }   -static void sig_disconnected(IRC_SERVER_REC *server) +static void sig_destroyed(IRC_SERVER_REC *server)  {  	GSList *tmp;   @@ -1031,7 +1031,7 @@ void irc_servers_init(void)  	cmd_tag = -1;    	signal_add_first(\"server connected\", (SIGNAL_FUNC) sig_connected); -	signal_add_last(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +	signal_add_last(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);  	signal_add_last(\"server quit\", (SIGNAL_FUNC) sig_server_quit);  	signal_add(\"event 001\", (SIGNAL_FUNC) event_connected);  	signal_add(\"event 004\", (SIGNAL_FUNC) event_server_info); @@ -1058,7 +1058,7 @@ void irc_servers_deinit(void)  		g_source_remove(cmd_tag);    	signal_remove(\"server connected\", (SIGNAL_FUNC) sig_connected); -	signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);          signal_remove(\"server quit\", (SIGNAL_FUNC) sig_server_quit);  	signal_remove(\"event 001\", (SIGNAL_FUNC) event_connected);  	signal_remove(\"event 004\", (SIGNAL_FUNC) event_server_info); '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','flood.c','253','52','2','2','MODIFY','@@ -324,7 +324,7 @@ void irc_flood_init(void)  	read_settings();  	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings);  	signal_add_first(\"server connected\", (SIGNAL_FUNC) flood_init_server); -	signal_add(\"server disconnected\", (SIGNAL_FUNC) flood_deinit_server); +	signal_add(\"server destroyed\", (SIGNAL_FUNC) flood_deinit_server);    	autoignore_init();  	settings_check(); @@ -344,5 +344,5 @@ void irc_flood_deinit(void)    	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);  	signal_remove(\"server connected\", (SIGNAL_FUNC) flood_init_server); -	signal_remove(\"server disconnected\", (SIGNAL_FUNC) flood_deinit_server); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) flood_deinit_server);  } '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','notifylist.c','258','67','2','2','MODIFY','@@ -331,7 +331,7 @@ void irc_notifylist_init(void)  	notifylist_ison_init();  	notifylist_whois_init();  	signal_add(\"server connected\", (SIGNAL_FUNC) notifylist_init_server); -	signal_add(\"server disconnected\", (SIGNAL_FUNC) notifylist_deinit_server); +	signal_add(\"server destroyed\", (SIGNAL_FUNC) notifylist_deinit_server);  	signal_add(\"event quit\", (SIGNAL_FUNC) event_quit);  	signal_add(\"event privmsg\", (SIGNAL_FUNC) event_privmsg);  	signal_add(\"event join\", (SIGNAL_FUNC) event_join); @@ -349,7 +349,7 @@ void irc_notifylist_deinit(void)  	notifylist_whois_deinit();    	signal_remove(\"server connected\", (SIGNAL_FUNC) notifylist_init_server); -	signal_remove(\"server disconnected\", (SIGNAL_FUNC) notifylist_deinit_server); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) notifylist_deinit_server);  	signal_remove(\"event quit\", (SIGNAL_FUNC) event_quit);  	signal_remove(\"event privmsg\", (SIGNAL_FUNC) event_privmsg);  	signal_remove(\"event join\", (SIGNAL_FUNC) event_join); '),('irssi','1.0.5','956bc592a94d5f4cce03f5762f1976d98de637ef','Will Storey','Fix a typo in the readme  Also uppercase Irssi in a couple places, and escape an argument not shown due to looking like an HTML tag','README.md','99','0','4','4','MODIFY','@@ -28,7 +28,7 @@ think of currently:     queries when msgs/notices are received or when you send a msg, closing     queries when it\'s been idle for some time, etc.   - - **Multiserver friendy** - I think Irssi has clearly the best support + - **Multiserver friendly** - I think Irssi has clearly the best support     for handling multiple server connections. You can have as many as you     want in as many ircnets as you want. Having several connections in one     server works too, for example when you hit the (ircnet\'s) 10 @@ -84,7 +84,7 @@ think of currently:     search command that jumps around in scrollback in GUI-style is still     missing from Irssi, but there\'s something that\'s almost as good as it.     /LASTLOG always shows timestamps when the line was printed, even if you -   didn\'t have timestamps on. Now doing /SB GOTO <timestamp> jumps +   didn\'t have timestamps on. Now doing /SB GOTO \\<timestamp\\> jumps     directly to the position in scrollback you wanted. Great feature when     you want to browse a bit of the discussion what happened when someone     said your name (as seen in awaylog) or topic was changed (/last @@ -96,9 +96,9 @@ think of currently:      - `startup-HOWTO.txt` - new users should read this      - `manual.txt` - manual I started writing but didn\'t get it very far :)      - `perl.txt` - Perl scripting help -    - `formats.txt` - How to use colors, etc. with irssi +    - `formats.txt` - How to use colors, etc. with Irssi      - `faq.txt` - Frequently Asked Questions -    - `special_vars.txt` - some predefined $variables you can use with irssi +    - `special_vars.txt` - some predefined $variables you can use with Irssi    ## Bugs / Suggestions   '),('irssi','1.0.5','816df6d153e937734bdac258ad6bf43173361451','ailin-nemui','Merge tag \'1.0.5\' into integrate/1.0.5','NEWS','2923','0','18','0','MODIFY','@@ -1,5 +1,23 @@  v1.1-head 2017-xx-xx  The Irssi team <staff@irssi.org>   +v1.0.5 2017-10-23  The Irssi team <staff@irssi.org> +	- Fix missing -sasl_method \'\' in /NETWORK (#718, #719). +	- Fix incorrect restoration of term state when hitting SUSP +          inside screen (#737, #733). +	- Fix out of bounds read when compressing colour +          sequences. Found by Hanno BÃ¶ck (GL#12, GL!18). +	- Fix use after free condition during a race condition when +          waiting on channel sync during a rejoin (GL#13, GL!19). +	- Fix null pointer dereference when parsing certain malformed +          CTCP DCC messages (GL#14, GL!20). +	- Fix crash due to null pointer dereference when failing to +          split messages due to overlong nick or target (GL#15, GL!21). +	- Fix out of bounds read when trying to skip a safe channel ID +          without verifying that the ID is long enough (GL#16, GL!22). +	- Fix return of random memory when inet_ntop failed (#769). +	- Minor statusbar help update. By Robert Bisewski (#758, +          #763). +  v1.0.4 2017-07-07  The Irssi team <staff@irssi.org>  	- Fix null pointer dereference when parsing invalid timestamp (GL#10,  	  GL!15). Reported by Brian \'geeknik\' Carpenter. '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','.gitignore','54','0','1','0','MODIFY','@@ -33,6 +33,7 @@ docs/help/in/Makefile.am    src/fe-text/irssi  src/fe-fuzz/irssi-fuzz +src/fe-fuzz/irc/core/event-get-params-fuzz    src/fe-common/irc/irc-modules.c  src/irc/irc.c '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','configure.ac','700','4','2','0','MODIFY','@@ -648,6 +648,8 @@ src/fe-common/irc/Makefile  src/fe-common/irc/dcc/Makefile  src/fe-common/irc/notifylist/Makefile  src/fe-fuzz/Makefile +src/fe-fuzz/irc/Makefile +src/fe-fuzz/irc/core/Makefile  src/fe-none/Makefile  src/fe-text/Makefile  src/lib-config/Makefile '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','Makefile.am','19','0','2','0','MODIFY','@@ -1,3 +1,5 @@ +SUBDIRS = irc +  bin_PROGRAMS = irssi-fuzz    # Force link with CXX for libfuzzer support '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = core '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','Makefile.am','39','0','46','0','ADD','@@ -0,0 +1,46 @@ +bin_PROGRAMS = event-get-params-fuzz + +# Force link with CXX for libfuzzer support +CCLD=$(CXX) $(CXXFLAGS) + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core/ \\ +	-I$(top_srcdir)/src/irc/core/ \\ +	-I$(top_srcdir)/src/fe-common/core/ \\ +	$(GLIB_CFLAGS) + +AM_DEPENDENCIES = \\ +	../../../core/libcore.a \\ +	../../../lib-config/libirssi_config.a \\ +	../../../irc/libirc.a \\ +	../../../irc/core/libirc_core.a \\ +	../../../irc/dcc/libirc_dcc.a \\ +	../../../irc/flood/libirc_flood.a \\ +	../../../irc/notifylist/libirc_notifylist.a \\ +	../../../fe-common/core/libfe_common_core.a \\ +	../../../fe-common/irc/libfe_common_irc.a \\ +	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\ +	../../../fe-common/irc/notifylist/libfe_irc_notifylist a + +LDADD = \\ +	../../../irc/libirc.a \\ +	../../../irc/core/libirc_core.a \\ +	../../../irc/dcc/libirc_dcc.a \\ +	../../../irc/flood/libirc_flood.a \\ +	../../../irc/notifylist/libirc_notifylist.a \\ +	../../../fe-common/core/libfe_common_core.a \\ +	../../../fe-common/irc/libfe_common_irc.a \\ +	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\ +	../../../fe-common/irc/notifylist/libfe_irc_notifylist.a \\ +	../../../core/libcore.a \\ +	../../../lib-config/libirssi_config.a \\ +	@PROG_LIBS@ \\ +	$(FUZZER_LIBS) + +event_get_params_fuzz_SOURCES = \\ +        event-get-params.c \\ +	$(top_srcdir)/src/fe-text/module-formats.c + +noinst_HEADERS = \\ +	$(top_srcdir)/src/fe-text/module-formats.h '),('irssi','1.0.5','84fc92635acd4d513049794fdbc574b79ac1c5d5','Joseph Bisch','Add event_get_params to fe-fuzz','event-get-params.c','61','11','86','0','ADD','@@ -0,0 +1,86 @@ +/* + event-get-params.c : irssi + +    Copyright (C) 2017 Joseph Bisch + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"modules-load.h\" +#include \"levels.h\" +#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text +#include \"themes.h\" +#include \"core.h\" +#include \"fe-common-core.h\" +#include \"args.h\" +#include \"printtext.h\" +#include \"irc.h\" + +#include <stddef.h> +#include <stdint.h> +#include <stdlib.h> +#include <string.h> + +int LLVMFuzzerInitialize(int *argc, char ***argv) { +	core_register_options(); +	fe_common_core_register_options(); +	/* no args */ +	args_execute(0, NULL); +	core_preinit((*argv)[0]); +	core_init(); +	fe_common_core_init(); +	theme_register(gui_text_formats); +	module_register(\"core\", \"fe-fuzz\"); +	return 0; +} + +int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { +	if (size < 1) { +		return 0; +	} +	uint8_t count = *data; +	char *copy = (char *)malloc(sizeof(char)*(size-1+1)); +	memcpy(copy, data+1, size-1); +	copy[size-1] = \'\\0\'; + +	char *output0; +	char *output1; +	char *output2; +	char *output3; +	char *params; +	if (count % 8 == 0) { +		params = event_get_params(copy, 1 | PARAM_FLAG_GETREST, &output0); +	} else if (count % 8 == 1) { +		params = event_get_params(copy, 2 | PARAM_FLAG_GETREST, &output0, &output1); +	} else if (count % 8 == 2) { +		params = event_get_params(copy, 3 | PARAM_FLAG_GETREST, &output0, &output1, &output2); +	} else if (count % 8 == 3) { +		params = event_get_params(copy, 4 | PARAM_FLAG_GETREST, &output0, &output1, &output2, &output3); +	} else if (count % 8 == 4) { +		params = event_get_params(copy, 1, &output0); +	} else if (count % 8 == 5) { +		params = event_get_params(copy, 2, &output0, &output1); +	} else if (count % 8 == 6) { +		params = event_get_params(copy, 3, &output0, &output1, &output2); +	} else if (count % 8 == 7) { +		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3); +	} else { +		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3); +	} +	g_free(params); +	free(copy); +	return 0; +} '),('irssi','1.0.5','87550541e745627cc78507ce573d68b8453959c9','ailin-nemui','fix key length checker to actually do some work','autogen.sh','44','1','1','15','MODIFY','@@ -29,20 +29,6 @@ cat docs/help/in/Makefile.am.gen|sed \"s/@HELPFILES@/$files/g\"|sed \'s/?/\\\\?/g\'|tr  files=`echo $files|sed \'s/\\.in//g\'`  cat docs/help/Makefile.am.gen|sed \"s/@HELPFILES@/$files/g\"|sed \'s/?/\\\\?/g\'|tr \'!?\' \'\\t\\n\' > docs/help/Makefile.am   -# .html -> .txt with lynx or elinks -echo \"Documentation: html -> txt...\" -if type lynx >/dev/null 2>&1 ; then -  LC_ALL=en_IE.utf8 lynx -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt -elif type elinks >/dev/null 2>&1 ; then -  elinks -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt -elif type links >/dev/null 2>&1 ; then -  links -dump docs/faq.html|perl -pe \'s/^ *//; if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne \"\\n\") { $_ = \"   $_\"; };\' > docs/faq.txt -else -  echo \"**Error**: No lynx or elinks present\" -  echo \"Install lynx or elinks, then run autogen.sh again\" -  exit 1 -fi -  if test x$NOCONFIGURE = x && test -z \"$*\"; then    echo \"**Warning**: I am going to run \\`configure\' with no arguments.\"    echo \"If you wish to pass any to it, please specify them on the\" @@ -65,4 +51,4 @@ else  fi    # make sure perl hashes have correct length -find src/perl -name *.c -o -name *.xs | xargs grep -n hv_store | perl -ne \'if (/\"(\\w+)\",\\s*(\\d+)/) { print unless $2 == length $1 }\' +find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\' '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','.gitignore','52','0','0','1','MODIFY','@@ -11,7 +11,6 @@ config.status  configure  default-config.h  default-theme.h -faq.txt  irssi-config  irssi-config.h  irssi-config.h.in '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','Makefile.am','16','0','2','1','MODIFY','@@ -11,7 +11,8 @@ doc_DATA = \\  	perl.txt \\  	signals.txt \\  	special_vars.txt \\ -	startup-HOWTO.html +	startup-HOWTO.html \\ +	startup-HOWTO.txt    EXTRA_DIST = $(doc_DATA) $(man_MANS)   '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','faq.html','42','0','3','1','MODIFY','@@ -1,4 +1,6 @@ +<base href=\'https://irssi.org/documentation/faq/\'>  <h1>Frequently Asked Questions</h1> +  <h3 id=\"q-why-doesnt-irssi-display-colors-even-when-ircii-etc-displays-them\">Q: Why doesnâ€™t irssi display colors even when ircii etc. displays them?</h3>    <p>A: They force ANSI colors even if terminal doesnâ€™t support them. By default, irssi uses colors only if terminfo/termcap so says. The correct way to fix this would be to change your TERM environment to a value where colors work, like xterm-color or color_xterm (eg. <code>TERM=xterm-color irssi</code>). If this doesnâ€™t help, then use the evil way of <code>/SET term_force_colors ON</code>.</p> @@ -77,4 +79,4 @@    <h3 id=\"q-how-to-pronounce-irssi\">Q: How to pronounce Irssi?</h3>   -<p>A: Check <a href=\"https://irssi.org/assets/irssi.wav\">here</a></p> +<p>A: Check <a href=\"/assets/irssi.wav\">here</a></p> \\ No newline at end of file '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','faq.txt','99','0','124','0','ADD','@@ -0,0 +1,124 @@ +   Frequently Asked Questions + +Q: Why doesnâ€™t irssi display colors even when ircii etc. displays them? +A: They force ANSI colors even if terminal doesnâ€™t support them. By default, +   irssi uses colors only if terminfo/termcap so says. The correct way to fix this +   would be to change your TERM environment to a value where colors work, like +   xterm-color or color_xterm (eg. TERM=xterm-color irssi). If this doesnâ€™t help, +   then use the evil way of /SET term_force_colors ON. + +Q: How do I easily write text to channel that starts with â€˜/â€™ character? +A: / /text + +Q: Why doesnâ€™t irssi update my realname (or whatever) after I change it with / +   SET realname and reconnect with /RECONNECT or /SERVER? +A: Irssi is trying to be too smart. This will be fixed in future, but for now +   you should use /DISCONNECT and /CONNECT. + +Q: I connected to some server which isnâ€™t responding but now irssi tries to +   connect back to it all the time! How can I stop it? +A: Two ways. The â€œgood wayâ€ to do it is with /DISCONNECT. Check the server tags +   first with /SERVER without giving it any parameters, reconnections are those +   that have tag starting with â€œreconâ€ text. So most probably youâ€™re going to do / +   DISCONNECT recon-1. The other way is to remove all the reconnections with / +   RMRECONNS, easier but may remove some connections you actually wanted to +   reconnect (if you used multiple servers..). + +Q: How do I add seconds to timestamp? +A: /FORMAT timestamp {timestamp %%H:%%M:%%S} - and remember to add the trailing +   space :) + +Q: Why does irssi say â€œIrssi: Channel not fully synchronized yet, try again +   after a whileâ€ when I try to use /BAN etc? +A: Possibly a bug in irssi, or ircd youâ€™re using does something that irssi +   didnâ€™t really notice. The new code should make this happen far less often than +   before, but one known reason for this is when irssi doesnâ€™t notice that you +   were unable to join some channel. Currently however I donâ€™t know of any such +   events irssi doesnâ€™t know about. + +   Anyway, if this does happen, do /RAWLOG SAVE ~/rawlog soon after joining to +   channel, and either try to figure out yourself why irssi didnâ€™t get reply to +   WHO request, or open a Github issue with the full log included. Note that the +   rawlog is by default only 200 lines and it may not be enough to show all needed +   information, so you might want to do /SET rawlog_lines 1000 or so. + +   MODE +b still works fine though. + +Q: Whereâ€™s the GUI version? +A: There was one on [1]irssi-import/xirssi but it has not been maintained for a +   long time. + +Q: How do I autorejoin channels after being kicked? +A: Thatâ€™s evil and you shouldnâ€™t do it. If you get kicked, you should stay out, +   at least until the channel forgot you existed :) Most channels Iâ€™ve joined just +   ban you if you autorejoin after kick. If youâ€™re joined to channels who kick +   people for fun, try changing channels or something. + +   Anyway, if you REALLY want to do that, and you understand that youâ€™re doing +   evilness, you can use the autorejoin.pl script that comes with irssi. Youâ€™ll +   still need to specify the channels you wish to rejoin with /SET +   autorejoin_channels #chan1 #chan2 ... + +Q: How do I announce that Iâ€™m away/back in all channels Iâ€™ve joined? Or how do +   I change my nick when setting myself away/back? +A: Thatâ€™s even worse than autorejoin. Who could possibly care every time you +   come and go? Many channels will kick you for using this, and I for example have +   added several ignores so Iâ€™d never need to see these messages. Learn to use / +   AWAY command properly and tell its existence to people who donâ€™t know about it. +   /WII yournick shows your away reason much better for people who actually want +   to know if youâ€™re there or not. + +Q: Why does irssi autojoin on invite by default? +A: The setting is /SET join_auto_chans_on_invite - itâ€™s not the same as regular +   autojoin-on-invite, which irssi doesnâ€™t even have. The only channels that are +   joined on invite, are the ones youâ€™ve added to config with /CHANNEL ADD -auto. +   This is very useful with +i channels when you need to first send an invite +   request to bot, or if you get accidentally kicked from channel, the kicker can +   invite you back immediately. + +   I donâ€™t see any bad side effects with this feature, so itâ€™s ON by default. I +   guess someone could start kicking/inviting you all the time but server +   connection shouldnâ€™t drop because of that, and you shouldnâ€™t join channels +   whose operators are that evil. + +Q: How to make UTF-8 support work with irssi? +A: Make sure your terminal supports UTF-8 (for example, xterm -u8). If you use +   screen, you may have to do screen -U. And in Irssi do /SET term_charset utf-8. +   (for 0.8.9 and older: /SET term_type utf-8) + +Q: Will there be /DETACH-like feature? +A: [2]tmux, [3]screen and [4]dtach can be used to do it just fine. + +Q: How do I run scripts automatically at startup? +A: Put them into ~/.irssi/scripts/autorun/ directory. Or better would be if you +   placed them in ~/.irssi/scripts/ and created symlinks to autorun directory (eg. +   cd ~/.irssi/scripts/autorun/ ; ln -s ../script.pl .) + +Q: How do I execute commands automatically at startup? +A: Put them into ~/.irssi/startup file, each command on its own line. The +   preceding slash (/) is not necessary. + +Q: How do I easily edit existing topic? +A: /TOPIC <tab> + +Q: How can I have /WHOIS replies to active window? +A: You can disable the status window, or do /WINDOW LEVEL -CRAP in it which +   would also make several other messages show up in active window. You can also +   use a [5]script. + +Q: How do I add the active network to the statusbar +A: Modify the window-line in statusbar section in config file to window = \"{sb +   $winref:$tag/$T{sbmode $M}}\"; + +Q: How to pronounce Irssi? +A: Check [6]here + + +   References: + +   [1] https://github.com/irssi-import/xirssi +   [2] http://tmux.github.io/ +   [3] http://www.gnu.org/software/screen/screen.html +   [4] http://dtach.sf.net/ +   [5] http://dgl.cx/irssi/hack-whois-in-current-window.pl +   [6] https://irssi.org/assets/irssi.wav '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','startup-HOWTO.html','475','0','267','243','MODIFY','@@ -1,4 +1,6 @@ -                    <h1>Startup How-To</h1> +<base href=\'https://irssi.org/documentation/startup/\'> +<h1>Startup How-To</h1> +  <h3 id=\"to-new-irssi-users-not-to-new-irc-users-\">To new Irssi users (not to new IRC users ..)</h3>    <p>Copyright (c) 2000-2002 by Timo Sirainen, release under <a href=\"http://www.gnu.org/licenses/fdl.html\">GNU FDL</a> 1.1 license.</p> @@ -6,11 +8,7 @@  <p>Index with some FAQ questions that are answered in the chapter:</p>    <ol> -  <li><a href=\"#for-all-the-ircii-people\">For all the ircII people</a> -    <ul> -      <li>This window management is just weird, I want it exactly like ircII</li> -    </ul> -  </li> +  <li><a href=\"#first-steps\">First steps</a></li>    <li><a href=\"#basic-user-interface-usage\">Basic user interface usage</a>      <ul>        <li>Split windows work in weird way</li> @@ -50,7 +48,11 @@      </ul>    </li>    <li><a href=\"#proxies-and-irc-bouncers\">Proxies and IRC bouncers</a></li> -  <li><a href=\"#irssis-settings\">Irssiâ€™s settings</a></li> +  <li><a href=\"#irssis-settings\">Irssiâ€™s settings</a> +    <ul> +      <li><a href=\"#for-all-the-ircii-people\">For all the ircII people</a></li> +    </ul> +  </li>    <li><a href=\"#statusbar\">Statusbar</a>      <ul>        <li>I loaded a statusbar script but itâ€™s not visible anywhere!</li> @@ -58,169 +60,176 @@    </li>  </ol>   -<h2 id=\"for-all-the-ircii-people\">1. For all the ircII people</h2> +<h2 id=\"first-steps\">1. First steps</h2>   -<p>These settings should give you pretty good defaults (the ones I use):</p> +<p>IRC Networks are made of servers, and servers have channels. The default config has a few predefined networks, to list them:</p>   -<p>If colors donâ€™t work, and you know youâ€™re not going to use some weird non-VT compatible terminal (you most probably arenâ€™t), just say:</p> +<div><div><pre><code>/NETWORK LIST +</code></pre></div></div>   -<pre><code> /SET term_force_colors ON -</code></pre> +<p>And to connect to one of those networks and join a channel:</p>   -<p>I donâ€™t like automatic query windows, I donâ€™t like status window, I do like msgs window where all messages go:</p> +<div><div><pre><code>/CONNECT Freenode +/JOIN #irssi +</code></pre></div></div>   -<pre><code> /SET autocreate_own_query OFF - /SET autocreate_query_level DCCMSGS - /SET use_status_window OFF - /SET use_msgs_window ON -</code></pre> +<p>To add more networks:</p>   -<p>Disable automatic window closing when <code>/PART</code>ing channel or <code>/UNQUERY</code>ing query:</p> +<div><div><pre><code>/NETWORK ADD ExampleNet +</code></pre></div></div>   -<pre><code> /SET autoclose_windows OFF - /SET reuse_unused_windows ON -</code></pre> +<p>Then add some servers (with -auto to automatically connect):</p>   -<p>Hereâ€™s the settings that make irssi work exactly like ircII in window management (send me a note if you can think of more):</p> +<div><div><pre><code>/SERVER ADD -auto -network ExampleNet irc.example.net +</code></pre></div></div>   -<pre><code> /SET autocreate_own_query OFF - /SET autocreate_query_level NONE - /SET use_status_window OFF - /SET use_msgs_window OFF - /SET reuse_unused_windows ON - /SET windows_auto_renumber OFF +<p>Automatically join to channels after connected to server:</p>   - /SET autostick_split_windows OFF - /SET autoclose_windows OFF - /SET print_active_channel ON -</code></pre> +<div><div><pre><code>/CHANNEL ADD -auto #lounge ExampleNet +</code></pre></div></div>   -<p>And example how to add servers:</p> +<p>To modify existing networks (or servers, or channels) just ADD again using the same name as before. This configures a network to identify with nickserv and wait for 2 seconds before joining channels:</p>   -<p>(OFTC network, identify with nickserv and wait for 2 seconds before joining channels)</p> +<div><div><pre><code>/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" ExampleNet +</code></pre></div></div>   -<pre><code> /NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC -</code></pre> +<p>If you have irssi 0.8.18 or higher and the irc network supports it, you can use SASL instead of nickserv, which is more reliable:</p>   -<p>(NOTE: use /IRCNET with 0.8.9 and older)</p> +<div><div><pre><code>/NETWORK ADD -sasl_username yourname -sasl_password yourpassword -sasl_mechanism PLAIN Freenode +</code></pre></div></div>   -<p>Then add some servers to different networks (network is already set up for them), irc.kpnqwest.fi is used by default for IRCNet but if it fails, irc.funet.fi is tried next:</p> +<p>These commands have many more options, see their help for details:</p>   -<pre><code> /SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 - /SERVER ADD -network IRCnet irc.funet.fi 6667 - /SERVER ADD -auto -network efnet efnet.cs.hut.fi 6667 -</code></pre> +<div><div><pre><code>/HELP NETWORK +/HELP SERVER +/HELP CHANNEL +/HELP +</code></pre></div></div>   -<p>Automatically join to channels after connected to server, send op request to bot after joined to efnet/#irssi:</p> +<p>If you want lines containing your nick to hilight:</p>   -<pre><code> /CHANNEL ADD -auto #irssi IRCnet - /CHANNEL ADD -auto -bots *!*bot@host.org -botcmd \"/^msg $0 op pass\" #irssi efnet -</code></pre> +<div><div><pre><code>/HILIGHT nick +</code></pre></div></div>   -<p>If you want lines containing your nick to hilight:</p> +<p>Or, for irssi 0.8.18 or higher:</p> + +<div><div><pre><code>/SET hilight_nick_matches_everywhere ON +</code></pre></div></div> + +<p>To get beeps on private messages or highlights:</p> + +<div><div><pre><code>/SET beep_msg_level MSGS HILIGHT DCCMSGS +</code></pre></div></div>   -<pre><code> /HILIGHT nick -</code></pre> +<p>No other irssi settings are needed (donâ€™t enable bell_beeps), but there may be settings to change in your terminal multiplexer (screen/tmux), your terminal, or your desktop environment.</p>    <h2 id=\"basic-user-interface-usage\">2. Basic user interface usage</h2>    <p>Windows can be scrolled up/down with PgUp and PgDown keys. If they donâ€™t work for you, use Meta-p and Meta-n keys. For jumping to beginning or end of the buffer, use <code>/SB HOME</code> and <code>/SB END</code> commands.</p>   -<p>By default, irssi uses â€œhidden windowsâ€ for everything. Hidden window is created every time you <code>/JOIN</code> a channel or <code>/QUERY</code> someone. Thereâ€™s several ways you can change between these windows:</p> +<p>By default, irssi uses â€œhidden windowsâ€ for everything. Hidden windows are created every time you <code>/JOIN</code> a channel or <code>/QUERY</code> someone. Thereâ€™s several ways you can change between these windows:</p>   -<pre><code> Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10 - Meta-q .. Meta-o          - Jump directly between windows 11-19 - /WINDOW &lt;number&gt;          - Jump to any window with specified number - Ctrl-P, Ctrl-N            - Jump to previous / next window -</code></pre> +<div><div><pre><code>Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10 +Meta-q .. Meta-o          - Jump directly between windows 11-19 +/WINDOW &lt;number&gt;          - Jump to any window with specified number +Ctrl-P, Ctrl-N            - Jump to previous / next window +</code></pre></div></div>   -<p>Clearly the easiest way is to use Meta-number keys. And what is the Meta key? ESC key always works as Meta, but thereâ€™s also easier ways. ALT could work as Meta, or if you have Windows keyboard, left Windows key might work as Meta. If they donâ€™t work directly, youâ€™ll need to set a few X resources (NOTE: these work with both xterm and rxvt):</p> +<p>Clearly the easiest way is to use Meta-number keys. Meta usually means the ALT key, but if that doesnâ€™t work, you can use ESC.</p>   -<pre><code> XTerm*eightBitInput:   false +<p>Mac OS X users with ALT key issues might prefer using <a href=\"https://www.iterm2.com/\">iTerm2</a> instead of the default terminal emulator.</p> + +<h3 id=\"alt-key-as-meta-for-xtermrxvt-users\">Alt key as meta, for xterm/rxvt users</h3> + +<p>If you use xterm or rxvt, you may need to set a few X resources:</p> + +<div><div><pre><code> XTerm*eightBitInput:   false   XTerm*metaSendsEscape: true -</code></pre> +</code></pre></div></div>    <p>With rxvt, you can also specify which key acts as Meta key. So if you want to use ALT instead of Windows key for it, use:</p>   -<pre><code> rxvt*modifier: alt -</code></pre> +<div><div><pre><code> rxvt*modifier: alt +</code></pre></div></div>    <p>You could do this by changing the X key mappings:</p>   -<pre><code> xmodmap -e \"keysym Alt_L = Meta_L Alt_L\" -</code></pre> +<div><div><pre><code> xmodmap -e \"keysym Alt_L = Meta_L Alt_L\" +</code></pre></div></div>    <p>And how exactly do you set these X resources? For Debian, thereâ€™s <code>/etc/X11/Xresources/xterm</code> file where you can put them and itâ€™s read automatically when X starts. <code>~/.Xresources</code> and <code>~/.Xdefaults</code> files might also work. If you canâ€™t get anything else to work, just copy and paste those lines to <code>~/.Xresources</code> and directly call <code>xrdb -merge ~/.Xresources</code> in some xterm. The resources affect only the new xterms you start, not existing ones.</p>   -<p>Many windows SSH clients also donâ€™t allow usage of ALT. One excellent client that does allow is putty, you can download it from <a href=\"http://www.chiark.greenend.org.uk/~sgtatham/putty/\"> http://www.chiark.greenend.org.uk/~sgtatham/putty/</a>.</p> +<h3 id=\"split-windows-and-window-items\">Split windows and window items</h3> + +<p><em>Note: <a href=\"http://quadpoint.org/articles/irssisplit/\">this guide</a> might be a better introduction to window splits</em></p>    <p>Irssi also supports split windows, theyâ€™ve had some problems in past but I think they should work pretty well now :) Hereâ€™s some commands related to them:</p>   -<pre><code> /WINDOW NEW                    - Create new split window - /WINDOW NEW HIDE               - Create new hidden window - /WINDOW CLOSE                  - Close split or hidden window +<div><div><pre><code>/WINDOW NEW                    - Create new split window +/WINDOW NEW HIDE               - Create new hidden window +/WINDOW CLOSE                  - Close split or hidden window   - /WINDOW HIDE [&lt;number&gt;|&lt;name&gt;] - Make the split window hidden window - /WINDOW SHOW &lt;number&gt;|&lt;name&gt;   - Make the hidden window a split window +/WINDOW HIDE [&lt;number&gt;|&lt;name&gt;] - Make the split window hidden window +/WINDOW SHOW &lt;number&gt;|&lt;name&gt;   - Make the hidden window a split window   - /WINDOW SHRINK [&lt;lines&gt;]       - Shrink the split window - /WINDOW GROW [&lt;lines&gt;]         - Grow the split window - /WINDOW BALANCE                - Balance the sizes of all split windows -</code></pre> +/WINDOW SHRINK [&lt;lines&gt;]       - Shrink the split window +/WINDOW GROW [&lt;lines&gt;]         - Grow the split window +/WINDOW BALANCE                - Balance the sizes of all split windows +</code></pre></div></div>    <p>By default, irssi uses â€œsticky windowingâ€ for split windows. This means that windows created inside one split window cannot be moved to another split window without some effort. For example you could have following window layout:</p>   -<pre><code> Split window 1: win#1 - Status window, win#2 - Messages window +<div><div><pre><code> Split window 1: win#1 - Status window, win#2 - Messages window   Split window 2: win#3 - IRCnet/#channel1, win#4 - IRCnet/#channel2   Split window 3: win#5 - efnet/#channel1, win#6 - efnet/#channel2 -</code></pre> +</code></pre></div></div>    <p>When you are in win#1 and press ALT-6, irssi jumps to split window #3 and moves the efnet/#channel2 the active window.</p>    <p>With non-sticky windowing the windows donâ€™t have any relationship with split windows, pressing ALT-6 in win#1 moves win#6 to split window 1 and sets it active, except if win#6 was already visible in some other split window irssi just changes to that split window. This it the way windows work with ircii, if you prefer it you can set it with</p>   -<pre><code> /SET autostick_split_windows OFF -</code></pre> +<div><div><pre><code>/SET autostick_split_windows OFF +</code></pre></div></div>    <p>Each window can have multiple channels, queries and other â€œwindow itemsâ€ inside them. If you donâ€™t like windows at all, you disable automatic creating of them with</p>   -<pre><code> /SET autocreate_windows OFF -</code></pre> +<div><div><pre><code>/SET autocreate_windows OFF +</code></pre></div></div>    <p>And if you keep all channels in one window, you most probably want the channel name printed in each line:</p>   -<pre><code> /SET print_active_channel ON -</code></pre> +<div><div><pre><code>/SET print_active_channel ON +</code></pre></div></div>    <p>If you want to group only some channels or queries in one window, use</p>   -<pre><code> /JOIN -window #channel - /QUERY -window nick -</code></pre> +<div><div><pre><code>/JOIN -window #channel +/QUERY -window nick +</code></pre></div></div>    <h2 id=\"server-and-channel-automation\">3. Server and channel automation</h2>    <p>Irssiâ€™s multiple IRC network support is IMHO very good - at least compared to other clients :) Even if youâ€™re only in one IRC network you should group all your servers to be in the same IRC network as this helps with reconnecting if your primary server breaks and is probably useful in some other ways too :) For information how to actually use irssi correctly with multiple servers see the chapter 6.</p>   -<p>First you need to have your IRC network set, use <code>/NETWORK</code> command to see if itâ€™s already there. If it isnâ€™t, use <code>/NETWORK ADD yournetwork</code>. If you want to execute some commands automatically when youâ€™re connected to some network, use <code>-autosendcmd</code> option. (NOTE: use /IRCNET with 0.8.9 and older.) Hereâ€™s some examples:</p> +<p>First you need to have your IRC network set, use <code>/NETWORK</code> command to see if itâ€™s already there. If it isnâ€™t, use <code>/NETWORK ADD yournetwork</code>. If you want to execute some commands automatically when youâ€™re connected to some network, use <code>-autosendcmd</code> option. Hereâ€™s some examples:</p>   -<pre><code> /NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet - /NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC -</code></pre> +<div><div><pre><code>/NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet +/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC +</code></pre></div></div>    <p>After that you need to add your servers. For example:</p>   -<pre><code> /SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 - /SERVER ADD -auto -network worknet irc.mycompany.com 6667 password -</code></pre> +<div><div><pre><code>/SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 +/SERVER ADD -auto -network worknet irc.mycompany.com 6667 password +</code></pre></div></div>    <p>The <code>-auto</code> option specifies that this server is automatically connected at startup. You donâ€™t need to make more than one server with <code>-auto</code> option to one IRC network, other servers are automatically connected in same network if the <code>-auto</code> server fails.</p>    <p>And finally channels:</p>   -<pre><code> /CHANNEL ADD -auto -bots *!*bot@host.org -botcmd \"/^msg $0 op pass\" #irssi efnet - /CHANNEL ADD -auto #secret IRCnet password -</code></pre> +<div><div><pre><code>/CHANNEL ADD -auto -bots *!*user@host -botcmd \"/^msg $0 op pass\" #irssi efnet +/CHANNEL ADD -auto #secret IRCnet password +</code></pre></div></div>    <p><code>-bots</code> and <code>-botcmd</code> should be the only ones needing a bit of explaining. Theyâ€™re used to send commands automatically to bot when channel is joined, usually to get ops automatically. You can specify multiple bot masks with <code>-bots</code> option separated with spaces (and remember to quote the string then). The $0 in <code>-botcmd</code> specifies the first found bot in the list. If you donâ€™t need the bot masks (ie. the bot is always with the same nick, like chanserv) you can give only the <code>-botcmd</code> option and the command is always sent.</p>   @@ -228,9 +237,9 @@    <p>First connect to all the servers, join the channels and create the queries you want. If you want to move the windows or channels around use commands:</p>   -<pre><code> /WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere - /WINDOW ITEM MOVE &lt;number&gt;|&lt;name&gt; - move channel/query to another window -</code></pre> +<div><div><pre><code>/WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere +/WINDOW ITEM MOVE &lt;number&gt;|&lt;name&gt; - move channel/query to another window +</code></pre></div></div>    <p>When everything looks the way you like, use <code>/LAYOUT SAVE</code> command (and <code>/SAVE</code>, if you donâ€™t have autosaving enabled) and when you start irssi next time, irssi remembers the positions of the channels, queries and everything. This â€œrememberingâ€ doesnâ€™t mean that simply using <code>/LAYOUT SAVE</code> would automatically make irssi reconnect to all servers and join all channels, youâ€™ll need the <code>/SERVER ADD -auto</code> and <code>/CHANNEL ADD -auto</code> commands to do that.</p>   @@ -240,32 +249,32 @@    <p>By default, all the â€œextra messagesâ€ go to status window. This means pretty much all messages that donâ€™t clearly belong to some channel or query. Some people like it, some donâ€™t. If you want to remove it, use</p>   -<pre><code> /SET use_status_window OFF -</code></pre> +<div><div><pre><code>/SET use_status_window OFF +</code></pre></div></div>    <p>This doesnâ€™t have any effect until you restart irssi. If you want to remove it immediately, just <code>/WINDOW CLOSE</code> it.</p>    <p>Another common window is â€œmessages windowâ€, where all private messages go. By default itâ€™s disabled and query windows are created instead. To make all private messages go to msgs window, say:</p>   -<pre><code> /SET use_msgs_window ON - /SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to +<div><div><pre><code>/SET use_msgs_window ON +/SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to   				      dcc chats either, say NONE) -</code></pre> +</code></pre></div></div>    <p>use_msgs_window either doesnâ€™t have any effect until restarting irssi. To create it immediately say:</p>   -<pre><code> /WINDOW NEW HIDE     - create the window - /WINDOW NAME (msgs)  - name it to \"(msgs)\" - /WINDOW LEVEL MSGS   - make all private messages go to this window - /WINDOW MOVE 1       - move it to first window -</code></pre> +<div><div><pre><code>/WINDOW NEW HIDE     - create the window +/WINDOW NAME (msgs)  - name it to \"(msgs)\" +/WINDOW LEVEL MSGS   - make all private messages go to this window +/WINDOW MOVE 1       - move it to first window +</code></pre></div></div>    <p>Note that neither use_msgs_window nor use_status_window have any effect at all if <code>/LAYOUT SAVE</code> has been used.</p>    <p>This brings us to message levels.. What are they? All messages that irssi prints have one or more â€œmessage levelsâ€. Most common are PUBLIC for public messages in channels, MSGS for private messages and CRAP for all sorts of messages with no real classification. You can get a whole list of levels with</p>   -<pre><code> /HELP levels -</code></pre> +<div><div><pre><code>/HELP levels +</code></pre></div></div>    <p>Status window has message level <code>ALL -MSGS</code>, meaning that all messages, except private messages, without more specific place go to status window. The <code>-MSGS</code> is there so it doesnâ€™t conflict with messages window.</p>   @@ -273,15 +282,15 @@    <p>ircii and several other clients support multiple servers by placing the connection into some window. IRSSI DOES NOT. There is no required relationship between window and server. You can connect to 10 servers and manage them all in just one window, or join channel in each one of them to one single window if you really want to. That being said, hereâ€™s how you do connect to new server without closing the old connection:</p>   -<pre><code> /CONNECT irc.server.org -</code></pre> +<div><div><pre><code>/CONNECT irc.server.org +</code></pre></div></div>    <p>Instead of the <code>/SERVER</code> which disconnects the existing connection. To see list of all active connections, use <code>/SERVER</code> without any parameters. You should see a list of something like:</p>   -<pre><code> -!- IRCNet: irc.song.fi:6667 (IRCNet) +<div><div><pre><code> -!- IRCNet: irc.song.fi:6667 (IRCNet)   -!- OFTC: irc.oftc.net:6667 (OFTC)   -!- RECON-1: 192.168.0.1:6667 () (02:59 left before reconnecting) -</code></pre> +</code></pre></div></div>    <p>Here you see that weâ€™re connected to IRCNet and OFTC networks. The IRCNet at the beginning is called the â€œserver tagâ€ while the (IRCnet) at the end shows the IRC network. Server tag specifies unique tag to refer to the server, usually itâ€™s the same as the IRC network. When the IRC network isnâ€™t known itâ€™s some part of the server name. When thereâ€™s multiple connections to same IRC network or server, irssi adds a number after the tag so there could be network, network2, network3 etc.</p>   @@ -289,63 +298,63 @@    <p>To disconnect one of the servers, or to stop irssi from reconnecting, use</p>   -<pre><code> /DISCONNECT network   - disconnect server with tag \"network\" - /DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server - /RMRECONNS           - stop all server reconnections +<div><div><pre><code>/DISCONNECT network   - disconnect server with tag \"network\" +/DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server +/RMRECONNS           - stop all server reconnections   - /RECONNECT recon-1   - immediately try reconnecting back to RECON-1 - /RECONNECT ALL       - immediately try reconnecting back to all +/RECONNECT recon-1   - immediately try reconnecting back to RECON-1 +/RECONNECT ALL       - immediately try reconnecting back to all   		       servers in reconnection queue -</code></pre> +</code></pre></div></div>    <p>Now that youâ€™re connected to all your servers, youâ€™ll have to know how to specify which one of them you want to use. One way is to have an empty window, like status or msgs window. In it, you can specify which server to set active with</p>   -<pre><code> /WINDOW SERVER tag    - set server \"tag\" active - Ctrl-X                - set the next server in list active -</code></pre> +<div><div><pre><code>/WINDOW SERVER tag    - set server \"tag\" active +Ctrl-X                - set the next server in list active +</code></pre></div></div>    <p>When the server is active, you can use it normally. When thereâ€™s multiple connected servers, irssi adds [servertag] prefix to all messages in non-channel/query messages so youâ€™ll know where it came from.</p>    <p>Several commands also accept <code>-servertag</code> option to specify which server it should use:</p>   -<pre><code> /MSG -tag nick message - /JOIN -tag #channel - /QUERY -tag nick -</code></pre> +<div><div><pre><code>/MSG -tag nick message +/JOIN -tag #channel +/QUERY -tag nick +</code></pre></div></div>    <p><code>/MSG</code> tab completion also automatically adds the <code>-tag</code> option when nick isnâ€™t in active server.</p>    <p>Windowâ€™s server can be made sticky. When sticky, it will never automatically change to anything else, and if server gets disconnected, the window wonâ€™t have any active server. When the server gets connected again, it is automatically set active in the window. To set the windowâ€™s server sticky use</p>   -<pre><code> /WINDOW SERVER -sticky tag -</code></pre> +<div><div><pre><code>/WINDOW SERVER -sticky tag +</code></pre></div></div>    <p>This is useful if you wish to have multiple status or msgs windows, one for each server. Hereâ€™s how to do them (repeat for each server)</p>   -<pre><code> /WINDOW NEW HIDE - /WINDOW NAME (status) - /WINDOW LEVEL ALL -MSGS - /WINDOW SERVER -sticky network +<div><div><pre><code>/WINDOW NEW HIDE +/WINDOW NAME (status) +/WINDOW LEVEL ALL -MSGS +/WINDOW SERVER -sticky network   - /WINDOW NEW HIDE - /WINDOW NAME (msgs) - /WINDOW LEVEL MSGS - /WINDOW SERVER -sticky network -</code></pre> +/WINDOW NEW HIDE +/WINDOW NAME (msgs) +/WINDOW LEVEL MSGS +/WINDOW SERVER -sticky network +</code></pre></div></div>    <h2 id=\"lastlog-and-jumping-around-in-scrollback\">7. /LASTLOG and jumping around in scrollback</h2>    <p><code>/LASTLOG</code> command can be used for searching texts in scrollback buffer. Simplest usages are</p>   -<pre><code> /LASTLOG word     - print all lines with \"word\" in them - /LASTLOG word 10  - print last 10 occurances of \"word\" - /LASTLOG -topics  - print all topic changes -</code></pre> +<div><div><pre><code>/LASTLOG word     - print all lines with \"word\" in them +/LASTLOG word 10  - print last 10 occurances of \"word\" +/LASTLOG -topics  - print all topic changes +</code></pre></div></div>    <p>If thereâ€™s more than 1000 lines to be printed, irssi thinks that you probably made some mistake and wonâ€™t print them without <code>-force</code> option. If you want to save the full lastlog to file, use</p>   -<pre><code> /LASTLOG -file ~/irc.log -</code></pre> +<div><div><pre><code>/LASTLOG -file ~/irc.log +</code></pre></div></div>    <p>With <code>-file</code> option you donâ€™t need <code>-force</code> even if thereâ€™s more than 1000 lines. <code>/LASTLOG</code> has a lot of other options too, see <code>/HELP lastlog</code> for details.</p>   @@ -355,29 +364,29 @@    <p>Irssi can automatically log important messages when youâ€™re set away (<code>/AWAY reason</code>). When you set yourself unaway (<code>/AWAY</code>), the new messages in away log are printed to screen. You can configure it with:</p>   -<pre><code> /SET awaylog_level MSGS HILIGHT     - Specifies what messages to log - /SET awaylog_file ~/.irssi/away.log - Specifies the file to use -</code></pre> +<div><div><pre><code>/SET awaylog_level MSGS HILIGHT     - Specifies what messages to log +/SET awaylog_file ~/.irssi/away.log - Specifies the file to use +</code></pre></div></div>    <p>Easiest way to start logging with Irssi is to use autologging. With it Irssi logs all channels and private messages to specified directory. You can turn it on with</p>   -<pre><code> /SET autolog ON -</code></pre> +<div><div><pre><code>/SET autolog ON +</code></pre></div></div>    <p>By default it logs pretty much everything execept CTCPS or CRAP (<code>/WHOIS</code> requests, etc). You can specify the logging level yourself with</p>   -<pre><code> /SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default) -</code></pre> +<div><div><pre><code>/SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default) +</code></pre></div></div>    <p>By default irssi logs to ~/irclogs/<servertag>/<target>.log. You can change this with</target></servertag></p>   -<pre><code> /SET autolog_path ~/irclogs/$tag/$0.log (this is the default) -</code></pre> +<div><div><pre><code>/SET autolog_path ~/irclogs/$tag/$0.log (this is the default) +</code></pre></div></div>    <p>The path is automatically created if it doesnâ€™t exist. $0 specifies the target (channel/nick). You can make irssi automatically rotate the logs by adding date/time formats to the file name. The formats are in â€œman strftimeâ€ format. For example</p>   -<pre><code> /SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log -</code></pre> +<div><div><pre><code>/SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log +</code></pre></div></div>    <p>For logging only some specific channels or nicks, see <code>/HELP log</code></p>   @@ -387,16 +396,16 @@    <p><code>/HELP bind</code> tells pretty much everything there is to know about keyboard bindings. However, thereâ€™s the problem of how to bind some non-standard keys. They might differ a bit with each terminal, so youâ€™ll need to find out what exactly the keypress produces. Easiest way to check that would be to see what it prints in <code>cat</code>. Hereâ€™s an example for pressing F1 key:</p>   -<pre><code> [cras@hurina] ~% cat +<div><div><pre><code> [user@host] ~% cat   ^[OP -</code></pre> +</code></pre></div></div>    <p>So in irssi you would use <code>/BIND ^[OP /ECHO F1 pressed</code>. If you use multiple terminals which have different bindings for the key, it would be better to use eg.:</p>   -<pre><code> /BIND ^[OP key F1 - /BIND ^[11~ key F1 - /BIND F1 /ECHO F1 pressed. -</code></pre> +<div><div><pre><code>/BIND ^[OP key F1 +/BIND ^[11~ key F1 +/BIND F1 /ECHO F1 pressed. +</code></pre></div></div>    <h2 id=\"proxies-and-irc-bouncers\">10. Proxies and IRC bouncers</h2>   @@ -404,20 +413,20 @@    <p>Hereâ€™s an example: You have your bouncer (lets say, BNC or BNC-like) listening in irc.bouncer.org port 5000. You want to use it to connect to servers irc.dalnet and irc.efnet.org. First youâ€™d need to setup the bouncer:</p>   -<pre><code> /SET use_proxy ON - /SET proxy_address irc.bouncer.org - /SET proxy_port 5000 +<div><div><pre><code>/SET use_proxy ON +/SET proxy_address irc.bouncer.org +/SET proxy_port 5000   - /SET proxy_password YOUR_BNC_PASSWORD_HERE - /SET -clear proxy_string - /SET proxy_string_after conn %s %d -</code></pre> +/SET proxy_password YOUR_BNC_PASSWORD_HERE +/SET -clear proxy_string +/SET proxy_string_after conn %s %d +</code></pre></div></div>    <p>Then youâ€™ll need to add the server connections. These are done exactly as if youâ€™d want to connect directly to them. Nothing special about them:</p>   -<pre><code> /SERVER ADD -auto -network dalnet irc.dal.net - /SERVER ADD -auto -network efnet irc.efnet.org -</code></pre> +<div><div><pre><code>/SERVER ADD -auto -network dalnet irc.dal.net +/SERVER ADD -auto -network efnet irc.efnet.org +</code></pre></div></div>    <p>With the proxy <code>/SET</code>s however, irssi now connects to those servers through your BNC. All server connections are made through them so you can just forget that your bouncer even exists.</p>   @@ -427,36 +436,36 @@    <p>All proxies have these settings in common:</p>   -<pre><code> /SET use_proxy ON - /SET proxy_address &lt;Proxy host address&gt; - /SET proxy_port &lt;Proxy port&gt; -</code></pre> +<div><div><pre><code>/SET use_proxy ON +/SET proxy_address &lt;Proxy host address&gt; +/SET proxy_port &lt;Proxy port&gt; +</code></pre></div></div>    <p><strong>HTTP proxy</strong></p>    <p>Use these settings with HTTP proxies:</p>   -<pre><code> /SET -clear proxy_password - /EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n -</code></pre> +<div><div><pre><code>/SET -clear proxy_password +/EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n +</code></pre></div></div>    <p><strong>BNC</strong></p>   -<pre><code> /SET proxy_password your_pass - /SET -clear proxy_string - /SET proxy_string_after conn %s %d -</code></pre> +<div><div><pre><code>/SET proxy_password your_pass +/SET -clear proxy_string +/SET proxy_string_after conn %s %d +</code></pre></div></div>    <p><strong>dircproxy</strong></p>    <p>dircproxy separates the server connections by passwords. So, if you for example have network connection with password ircpass and OFTC connection with oftcpass, you would do something like this:</p>   -<pre><code> /SET -clear proxy_password - /SET -clear proxy_string +<div><div><pre><code>/SET -clear proxy_password +/SET -clear proxy_string   - /SERVER ADD -auto -network IRCnet fake.network 6667 ircpass - /SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass -</code></pre> +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass +</code></pre></div></div>    <p>The server name and port you give isnâ€™t used anywhere, so you can put anything you want in there.</p>   @@ -464,19 +473,17 @@    <p>psyBNC has internal support for multiple servers. However, it could be a bit annoying to use, and some people just use different users for connecting to different servers. You can manage this in a bit same way as with dircproxy, by creating fake connections:</p>   -<pre><code> /SET -clear proxy_password - /SET -clear proxy_string +<div><div><pre><code>/SET -clear proxy_password +/SET -clear proxy_string   - /NETWORK ADD -user networkuser IRCnet - /SERVER ADD -auto -network IRCnet fake.network 6667 ircpass - /NETWORK ADD -user oftcuser OFTC - /SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass -</code></pre> +/NETWORK ADD -user networkuser IRCnet +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/NETWORK ADD -user oftcuser OFTC +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass +</code></pre></div></div>    <p>So, youâ€™ll specify the usernames with <code>/NETWORK ADD</code> command, and the userâ€™s password with <code>/SERVER ADD</code>.</p>   -<p>(NOTE: use /IRCNET with 0.8.9 and older.)</p> -  <p><strong>Irssi proxy</strong></p>    <p>Irssi contains itâ€™s own proxy which you can build giving <code>\\--with-proxy</code> option to configure. Youâ€™ll still need to run irssi in a screen to use it though.</p> @@ -487,65 +494,52 @@    <p>Usage in proxy side:</p>   -<pre><code> /LOAD proxy - /SET irssiproxy_password &lt;password&gt; - /SET irssiproxy_ports &lt;network&gt;=&lt;port&gt; ... (eg. IRCnet=2777 efnet=2778) -</code></pre> +<div><div><pre><code>/LOAD proxy +/SET irssiproxy_password &lt;password&gt; +/SET irssiproxy_ports &lt;network&gt;=&lt;port&gt; ... (eg. IRCnet=2777 efnet=2778) +</code></pre></div></div>    <p><strong>NOTE</strong>: you <strong>MUST</strong> add all the servers you are using to server and network lists with <code>/SERVER ADD</code> and <code>/NETWORK ADD</code>. ..Except if you really donâ€™t want to for some reason, and you only use one server connection, you may simply set:</p>   -<pre><code> /SET irssiproxy_ports *=2777 -</code></pre> - -<p>The special network name <code>?</code> allows the client to select the -network dynamically on connect (see below):</p> - -<pre> -/SET irssiproxy_ports ?=2777 -</pre> +<div><div><pre><code>/SET irssiproxy_ports *=2777 +</code></pre></div></div>    <p>Usage in client side:</p>    <p>Just connect to the irssi proxy like it is a normal server with password specified in <code>/SET irssiproxy_password</code>. For example:</p>   -<pre><code> /SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret - /SERVER ADD -network efnet my.irssi-proxy.org 2778 secret -</code></pre> - -<p>Or, if you used <code>?</code> in <code>irssiproxy_ports</code>:</p> - -<pre> -/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 IRCnet:secret -/SERVER ADD -network efnet my.irssi-proxy.org 2777 efnet:secret -</pre> - -<p>I.e. the network to connect to is specified as part of the password, -separated by <code>:</code> from the actual proxy password.</p> +<div><div><pre><code>/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret +/SERVER ADD -network efnet my.irssi-proxy.org 2778 secret +</code></pre></div></div>    <p>Irssi proxy works fine with other IRC clients as well.</p>    <p><strong>SOCKS</strong></p>   -<p>Irssi can be compiled with socks support (<code>\\--with-socks</code> option to configure), but I donâ€™t really know how it works, if at all. <code>/SET proxy</code> settings donâ€™t have anything to do with socks however.</p> +<p>Irssi can be compiled with socks support (<code>\\--with-socks</code> option to configure), which requires â€œdanteâ€ and routes all connections through the proxy specified in the system-wide /etc/socks.conf. This method is known to have issues in Mac OS X.</p> + +<p>Note that <code>/SET proxy</code> settings donâ€™t have anything to do with socks.</p> + +<p>Using <a href=\"https://github.com/rofl0r/proxychains-ng\">proxychains-ng</a> is recommended over recompiling irssi.</p>    <p><strong>Others</strong></p>    <p>IRC bouncers usually work like IRC servers, and want a password. You can give it with:</p>   -<pre><code> /SET proxy_password &lt;password&gt; -</code></pre> +<div><div><pre><code>/SET proxy_password &lt;password&gt; +</code></pre></div></div>    <p>Irssiâ€™s defaults for connect strings are</p>   -<pre><code> /SET proxy_string CONNECT %s %d - /SET proxy_string_after -</code></pre> +<div><div><pre><code>/SET proxy_string CONNECT %s %d +/SET proxy_string_after +</code></pre></div></div>    <p>The proxy_string is sent before NICK/USER commands, the proxy_string_after is sent after them. %s and %d can be used with both of them.</p>    <h2 id=\"irssis-settings\">11. Irssiâ€™s settings</h2>   -<p>You probably donâ€™t like Irssiâ€™s default settings. I donâ€™t like them. But Iâ€™m still convinced that theyâ€™re pretty good defaults. Hereâ€™s some of them you might want to change (the default value is shown): Also check the <a href=\"/documentation/settings/\">Settings Documentation</a></p> +<p>Hereâ€™s some settings you might want to change (the default value is shown): Also check the <a href=\"/documentation/settings/\">Settings Documentation</a></p>    <p><strong>Queries</strong></p>   @@ -633,31 +627,61 @@ separated by <code>:</code> from the actual proxy password.</p>    <dd>Completion character to use.</dd>  </dl>   +<h3 id=\"for-all-the-ircii-people\">For all the ircII people</h3> + +<p>I donâ€™t like automatic query windows, I donâ€™t like status window, I do like msgs window where all messages go:</p> + +<div><div><pre><code>/SET autocreate_own_query OFF +/SET autocreate_query_level DCCMSGS +/SET use_status_window OFF +/SET use_msgs_window ON +</code></pre></div></div> + +<p>Disable automatic window closing when <code>/PART</code>ing channel or <code>/UNQUERY</code>ing query:</p> + +<div><div><pre><code>/SET autoclose_windows OFF +/SET reuse_unused_windows ON +</code></pre></div></div> + +<p>Hereâ€™s the settings that make irssi work exactly like ircII in window management (send me a note if you can think of more):</p> + +<div><div><pre><code>/SET autocreate_own_query OFF +/SET autocreate_query_level NONE +/SET use_status_window OFF +/SET use_msgs_window OFF +/SET reuse_unused_windows ON +/SET windows_auto_renumber OFF + +/SET autostick_split_windows OFF +/SET autoclose_windows OFF +/SET print_active_channel ON +</code></pre></div></div> +  <h2 id=\"statusbar\">12. Statusbar</h2>   -<p><code>/STATUSBAR</code> displays a list of statusbars:</p> +<p><code>/STATUSBAR</code> displays a list of the current statusbars, along with their position and visibility:</p>   -<pre><code> Name                           Type   Placement Position Visible +<div><div><pre><code> Name                           Type   Placement Position Visible   window                         window bottom    0        always   window_inact                   window bottom    1        inactive   prompt                         root   bottom    100      always   topic                          root   top       1        always -</code></pre> +</code></pre></div></div>   -<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings and itâ€™s items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to itâ€™s default settings, or if the statusbar was created by you, it will be removed.</p> +<p><code>/STATUSBAR &lt;name&gt;</code> prints the statusbar settings (type, placement, position, visibility) as well as its items. <code>/STATUSBAR &lt;name&gt; ENABLE|DISABLE</code> enables/disables the statusbar. <code>/STATUSBAR &lt;name&gt; RESET</code> resets the statusbar to its default settings, or if the statusbar was created by you, it will be removed.</p>   -<p>Type can be window or root, meaning if the statusbar should be created for each split window, or just once. Placement can be top or bottom. Position is a number, the higher the value the lower in screen it is. Visible can be always, active or inactive. Active/inactive is useful only with split windows, one split window is active and the rest are inactive. These settings can be changed with:</p> +<p>The statusbar type can be either window or root. If the type is window, then a statusbar will be created for each split window, otherwise it will be created only once. Placement can be top or bottom, which refers to the top or bottom of the screen. Position is a number, the higher the value the lower it will appear in-screen. Visible can be always, active or inactive. Active/inactive is useful only with split windows; one split window is active and the rest are inactive. To adjust these settings, the following commands are available:</p>   -<pre><code> /STATUSBAR &lt;name&gt; TYPE window|root - /STATUSBAR &lt;name&gt; PLACEMENT top|bottom - /STATUSBAR &lt;name&gt; POSITION &lt;num&gt; - /STATUSBAR &lt;name&gt; VISIBLE always|active|inactive -</code></pre> +<div><div><pre><code>/STATUSBAR &lt;name&gt; TYPE window|root +/STATUSBAR &lt;name&gt; PLACEMENT top|bottom +/STATUSBAR &lt;name&gt; POSITION &lt;num&gt; +/STATUSBAR &lt;name&gt; VISIBLE always|active|inactive +</code></pre></div></div>   -<p>When loading a new statusbar scripts, youâ€™ll need to also specify where you want to show it. Statusbar items can be modified with:</p> +<p>Statusbar items can also be added or removed via command. Note that when loading new statusbar scripts that add items, you will need to specify where you want to show the item and how it is aligned. This can be accomplished using the below commands:</p>   -<pre><code> /STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt; - /STATUSBAR &lt;name&gt; REMOVE &lt;item&gt; -</code></pre> +<div><div><pre><code>/STATUSBAR &lt;name&gt; ADD [-before | -after &lt;item&gt;] [-priority #] [-alignment left|right] &lt;item&gt; +/STATUSBAR &lt;name&gt; REMOVE &lt;item&gt; +</code></pre></div></div>   -<p>The item name with statusbar scripts is usually same as the scriptâ€™s name. Scriptâ€™s documentation should tell if this isnâ€™t the case. So, to add mail.pl before the window activity item (see the list with <code>/STATUSBAR</code> window), use: <code>/STATUSBAR window ADD -before act mail</code>.</p> +<p>For statusbar scripts, the item name is usually equivalent to the script name. The documentation of the script ought to tell you if this is not the case. For example, to add mail.pl before the window activity item, use: <code>/STATUSBAR window ADD -before act mail</code>.</p> \\ No newline at end of file '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','startup-HOWTO.txt','582','0','797','0','ADD','@@ -0,0 +1,797 @@ +Startup How-To + +To new Irssi users (not to new IRC users ..) + +Copyright (c) 2000-2002 by Timo Sirainen, release under [1]GNU FDL 1.1 license. + +Index with some FAQ questions that are answered in the chapter: + + 1. First steps + 2. Basic user interface usage +      â–¡ Split windows work in weird way +      â–¡ How can I easily switch between windows? +      â–¡ But alt-1 etc. donâ€™t work! + 3. Server and channel automation +      â–¡ How do I automatically connect to servers at startup? +      â–¡ How do I automatically join to channels at startup? +      â–¡ How do I automatically send commands to server at connect? + 4. Setting up windows and automatically restoring them at startup + 5. Status and msgs windows & message levels +      â–¡ I want /WHOIS to print reply to current window +      â–¡ I want all messages to go to one window, not create new windows + 6. How support for multiple servers works in irssi +      â–¡ I connected to some server that doesnâ€™t respond and now irssi keeps +        trying to reconnect to it again and again, how can I stop it?? +      â–¡ I want to have own status and/or msgs window for each servers + 7. /LASTLOG and jumping around in scrollback +      â–¡ How can I save all texts in a window to file? + 8. Logging + 9. Changing keyboard bindings +      â–¡ How do I make F1 key do something? +10. Proxies and IRC bouncers +11. Irssiâ€™s settings +      â–¡ For all the ircII people +12. Statusbar +      â–¡ I loaded a statusbar script but itâ€™s not visible anywhere! + +1. First steps + +IRC Networks are made of servers, and servers have channels. The default config +has a few predefined networks, to list them: + +/NETWORK LIST + +And to connect to one of those networks and join a channel: + +/CONNECT Freenode +/JOIN #irssi + +To add more networks: + +/NETWORK ADD ExampleNet + +Then add some servers (with -auto to automatically connect): + +/SERVER ADD -auto -network ExampleNet irc.example.net + +Automatically join to channels after connected to server: + +/CHANNEL ADD -auto #lounge ExampleNet + +To modify existing networks (or servers, or channels) just ADD again using the +same name as before. This configures a network to identify with nickserv and +wait for 2 seconds before joining channels: + +/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" ExampleNet + +If you have irssi 0.8.18 or higher and the irc network supports it, you can use +SASL instead of nickserv, which is more reliable: + +/NETWORK ADD -sasl_username yourname -sasl_password yourpassword -sasl_mechanism PLAIN Freenode + +These commands have many more options, see their help for details: + +/HELP NETWORK +/HELP SERVER +/HELP CHANNEL +/HELP + +If you want lines containing your nick to hilight: + +/HILIGHT nick + +Or, for irssi 0.8.18 or higher: + +/SET hilight_nick_matches_everywhere ON + +To get beeps on private messages or highlights: + +/SET beep_msg_level MSGS HILIGHT DCCMSGS + +No other irssi settings are needed (donâ€™t enable bell_beeps), but there may be +settings to change in your terminal multiplexer (screen/tmux), your terminal, +or your desktop environment. + +2. Basic user interface usage + +Windows can be scrolled up/down with PgUp and PgDown keys. If they donâ€™t work +for you, use Meta-p and Meta-n keys. For jumping to beginning or end of the +buffer, use /SB HOME and /SB END commands. + +By default, irssi uses â€œhidden windowsâ€ for everything. Hidden windows are +created every time you /JOIN a channel or /QUERY someone. Thereâ€™s several ways +you can change between these windows: + +Meta-1, Meta-2, .. Meta-0 - Jump directly between windows 1-10 +Meta-q .. Meta-o          - Jump directly between windows 11-19 +/WINDOW <number>          - Jump to any window with specified number +Ctrl-P, Ctrl-N            - Jump to previous / next window + +Clearly the easiest way is to use Meta-number keys. Meta usually means the ALT +key, but if that doesnâ€™t work, you can use ESC. + +Mac OS X users with ALT key issues might prefer using [2]iTerm2 instead of the +default terminal emulator. + +Alt key as meta, for xterm/rxvt users + +If you use xterm or rxvt, you may need to set a few X resources: + + XTerm*eightBitInput:   false + XTerm*metaSendsEscape: true + +With rxvt, you can also specify which key acts as Meta key. So if you want to +use ALT instead of Windows key for it, use: + + rxvt*modifier: alt + +You could do this by changing the X key mappings: + + xmodmap -e \"keysym Alt_L = Meta_L Alt_L\" + +And how exactly do you set these X resources? For Debian, thereâ€™s /etc/X11/ +Xresources/xterm file where you can put them and itâ€™s read automatically when X +starts. ~/.Xresources and ~/.Xdefaults files might also work. If you canâ€™t get +anything else to work, just copy and paste those lines to ~/.Xresources and +directly call xrdb -merge ~/.Xresources in some xterm. The resources affect +only the new xterms you start, not existing ones. + +Split windows and window items + +Note: [3]this guide might be a better introduction to window splits + +Irssi also supports split windows, theyâ€™ve had some problems in past but I +think they should work pretty well now :) Hereâ€™s some commands related to them: + +/WINDOW NEW                    - Create new split window +/WINDOW NEW HIDE               - Create new hidden window +/WINDOW CLOSE                  - Close split or hidden window + +/WINDOW HIDE [<number>|<name>] - Make the split window hidden window +/WINDOW SHOW <number>|<name>   - Make the hidden window a split window + +/WINDOW SHRINK [<lines>]       - Shrink the split window +/WINDOW GROW [<lines>]         - Grow the split window +/WINDOW BALANCE                - Balance the sizes of all split windows + +By default, irssi uses â€œsticky windowingâ€ for split windows. This means that +windows created inside one split window cannot be moved to another split window +without some effort. For example you could have following window layout: + + Split window 1: win#1 - Status window, win#2 - Messages window + Split window 2: win#3 - IRCnet/#channel1, win#4 - IRCnet/#channel2 + Split window 3: win#5 - efnet/#channel1, win#6 - efnet/#channel2 + +When you are in win#1 and press ALT-6, irssi jumps to split window #3 and moves +the efnet/#channel2 the active window. + +With non-sticky windowing the windows donâ€™t have any relationship with split +windows, pressing ALT-6 in win#1 moves win#6 to split window 1 and sets it +active, except if win#6 was already visible in some other split window irssi +just changes to that split window. This it the way windows work with ircii, if +you prefer it you can set it with + +/SET autostick_split_windows OFF + +Each window can have multiple channels, queries and other â€œwindow itemsâ€ inside +them. If you donâ€™t like windows at all, you disable automatic creating of them +with + +/SET autocreate_windows OFF + +And if you keep all channels in one window, you most probably want the channel +name printed in each line: + +/SET print_active_channel ON + +If you want to group only some channels or queries in one window, use + +/JOIN -window #channel +/QUERY -window nick + +3. Server and channel automation + +Irssiâ€™s multiple IRC network support is IMHO very good - at least compared to +other clients :) Even if youâ€™re only in one IRC network you should group all +your servers to be in the same IRC network as this helps with reconnecting if +your primary server breaks and is probably useful in some other ways too :) For +information how to actually use irssi correctly with multiple servers see the +chapter 6. + +First you need to have your IRC network set, use /NETWORK command to see if +itâ€™s already there. If it isnâ€™t, use /NETWORK ADD yournetwork. If you want to +execute some commands automatically when youâ€™re connected to some network, use +-autosendcmd option. Hereâ€™s some examples: + +/NETWORK ADD -autosendcmd \'^msg bot invite\' IRCnet +/NETWORK ADD -autosendcmd \"/^msg nickserv ident pass;wait 2000\" OFTC + +After that you need to add your servers. For example: + +/SERVER ADD -auto -network IRCnet irc.kpnqwest.fi 6667 +/SERVER ADD -auto -network worknet irc.mycompany.com 6667 password + +The -auto option specifies that this server is automatically connected at +startup. You donâ€™t need to make more than one server with -auto option to one +IRC network, other servers are automatically connected in same network if the +-auto server fails. + +And finally channels: + +/CHANNEL ADD -auto -bots *!*user@host -botcmd \"/^msg $0 op pass\" #irssi efnet +/CHANNEL ADD -auto #secret IRCnet password + +-bots and -botcmd should be the only ones needing a bit of explaining. Theyâ€™re +used to send commands automatically to bot when channel is joined, usually to +get ops automatically. You can specify multiple bot masks with -bots option +separated with spaces (and remember to quote the string then). The $0 in +-botcmd specifies the first found bot in the list. If you donâ€™t need the bot +masks (ie. the bot is always with the same nick, like chanserv) you can give +only the -botcmd option and the command is always sent. + +4. Setting up windows and automatically restoring them at startup + +First connect to all the servers, join the channels and create the queries you +want. If you want to move the windows or channels around use commands: + +/WINDOW MOVE LEFT/RIGHT/number    - move window elsewhere +/WINDOW ITEM MOVE <number>|<name> - move channel/query to another window + +When everything looks the way you like, use /LAYOUT SAVE command (and /SAVE, if +you donâ€™t have autosaving enabled) and when you start irssi next time, irssi +remembers the positions of the channels, queries and everything. This +â€œrememberingâ€ doesnâ€™t mean that simply using /LAYOUT SAVE would automatically +make irssi reconnect to all servers and join all channels, youâ€™ll need the / +SERVER ADD -auto and /CHANNEL ADD -auto commands to do that. + +If you want to change the layout, you just rearrange the layout like you want +it and use /LAYOUT SAVE again. If you want to remove the layout for some +reason, use /LAYOUT RESET. + +5. Status and msgs windows & message levels + +By default, all the â€œextra messagesâ€ go to status window. This means pretty +much all messages that donâ€™t clearly belong to some channel or query. Some +people like it, some donâ€™t. If you want to remove it, use + +/SET use_status_window OFF + +This doesnâ€™t have any effect until you restart irssi. If you want to remove it +immediately, just /WINDOW CLOSE it. + +Another common window is â€œmessages windowâ€, where all private messages go. By +default itâ€™s disabled and query windows are created instead. To make all +private messages go to msgs window, say: + +/SET use_msgs_window ON +/SET autocreate_query_level DCCMSGS  (or if you don\'t want queries to +                                      dcc chats either, say NONE) + +use_msgs_window either doesnâ€™t have any effect until restarting irssi. To +create it immediately say: + +/WINDOW NEW HIDE     - create the window +/WINDOW NAME (msgs)  - name it to \"(msgs)\" +/WINDOW LEVEL MSGS   - make all private messages go to this window +/WINDOW MOVE 1       - move it to first window + +Note that neither use_msgs_window nor use_status_window have any effect at all +if /LAYOUT SAVE has been used. + +This brings us to message levels.. What are they? All messages that irssi +prints have one or more â€œmessage levelsâ€. Most common are PUBLIC for public +messages in channels, MSGS for private messages and CRAP for all sorts of +messages with no real classification. You can get a whole list of levels with + +/HELP levels + +Status window has message level ALL -MSGS, meaning that all messages, except +private messages, without more specific place go to status window. The -MSGS is +there so it doesnâ€™t conflict with messages window. + +6. How support for multiple servers works in irssi + +ircii and several other clients support multiple servers by placing the +connection into some window. IRSSI DOES NOT. There is no required relationship +between window and server. You can connect to 10 servers and manage them all in +just one window, or join channel in each one of them to one single window if +you really want to. That being said, hereâ€™s how you do connect to new server +without closing the old connection: + +/CONNECT irc.server.org + +Instead of the /SERVER which disconnects the existing connection. To see list +of all active connections, use /SERVER without any parameters. You should see a +list of something like: + + -!- IRCNet: irc.song.fi:6667 (IRCNet) + -!- OFTC: irc.oftc.net:6667 (OFTC) + -!- RECON-1: 192.168.0.1:6667 () (02:59 left before reconnecting) + +Here you see that weâ€™re connected to IRCNet and OFTC networks. The IRCNet at +the beginning is called the â€œserver tagâ€ while the (IRCnet) at the end shows +the IRC network. Server tag specifies unique tag to refer to the server, +usually itâ€™s the same as the IRC network. When the IRC network isnâ€™t known itâ€™s +some part of the server name. When thereâ€™s multiple connections to same IRC +network or server, irssi adds a number after the tag so there could be network, +network2, network3 etc. + +Server tags beginning with RECON- mean server reconnections. Above we see that +connection to server at 192.168.0.1 wasnâ€™t successful and irssi will try to +connect it again in 3 minutes. + +To disconnect one of the servers, or to stop irssi from reconnecting, use + +/DISCONNECT network   - disconnect server with tag \"network\" +/DISCONNECT recon-1  - stop trying to reconnect to RECON-1 server +/RMRECONNS           - stop all server reconnections + +/RECONNECT recon-1   - immediately try reconnecting back to RECON-1 +/RECONNECT ALL       - immediately try reconnecting back to all +                       servers in reconnection queue + +Now that youâ€™re connected to all your servers, youâ€™ll have to know how to +specify which one of them you want to use. One way is to have an empty window, +like status or msgs window. In it, you can specify which server to set active +with + +/WINDOW SERVER tag    - set server \"tag\" active +Ctrl-X                - set the next server in list active + +When the server is active, you can use it normally. When thereâ€™s multiple +connected servers, irssi adds [servertag] prefix to all messages in non-channel +/query messages so youâ€™ll know where it came from. + +Several commands also accept -servertag option to specify which server it +should use: + +/MSG -tag nick message +/JOIN -tag #channel +/QUERY -tag nick + +/MSG tab completion also automatically adds the -tag option when nick isnâ€™t in +active server. + +Windowâ€™s server can be made sticky. When sticky, it will never automatically +change to anything else, and if server gets disconnected, the window wonâ€™t have +any active server. When the server gets connected again, it is automatically +set active in the window. To set the windowâ€™s server sticky use + +/WINDOW SERVER -sticky tag + +This is useful if you wish to have multiple status or msgs windows, one for +each server. Hereâ€™s how to do them (repeat for each server) + +/WINDOW NEW HIDE +/WINDOW NAME (status) +/WINDOW LEVEL ALL -MSGS +/WINDOW SERVER -sticky network + +/WINDOW NEW HIDE +/WINDOW NAME (msgs) +/WINDOW LEVEL MSGS +/WINDOW SERVER -sticky network + +7. /LASTLOG and jumping around in scrollback + +/LASTLOG command can be used for searching texts in scrollback buffer. Simplest +usages are + +/LASTLOG word     - print all lines with \"word\" in them +/LASTLOG word 10  - print last 10 occurances of \"word\" +/LASTLOG -topics  - print all topic changes + +If thereâ€™s more than 1000 lines to be printed, irssi thinks that you probably +made some mistake and wonâ€™t print them without -force option. If you want to +save the full lastlog to file, use + +/LASTLOG -file ~/irc.log + +With -file option you donâ€™t need -force even if thereâ€™s more than 1000 lines. / +LASTLOG has a lot of other options too, see /HELP lastlog for details. + +Once youâ€™ve found the lines you were interested in, you might want to check the +discussion around them. Irssi has /SCROLLBACK (or alias /SB) command for +jumping around in scrollback buffer. Since /LASTLOG prints the timestamp when +the message was originally printed, you can use /SB GOTO hh:mm to jump directly +there. To get back to the bottom of scrollback, use /SB END command. + +8. Logging + +Irssi can automatically log important messages when youâ€™re set away (/AWAY +reason). When you set yourself unaway (/AWAY), the new messages in away log are +printed to screen. You can configure it with: + +/SET awaylog_level MSGS HILIGHT     - Specifies what messages to log +/SET awaylog_file ~/.irssi/away.log - Specifies the file to use + +Easiest way to start logging with Irssi is to use autologging. With it Irssi +logs all channels and private messages to specified directory. You can turn it +on with + +/SET autolog ON + +By default it logs pretty much everything execept CTCPS or CRAP (/WHOIS +requests, etc). You can specify the logging level yourself with + +/SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default) + +By default irssi logs to ~/irclogs//.log. You can change this with + +/SET autolog_path ~/irclogs/$tag/$0.log (this is the default) + +The path is automatically created if it doesnâ€™t exist. $0 specifies the target +(channel/nick). You can make irssi automatically rotate the logs by adding date +/time formats to the file name. The formats are in â€œman strftimeâ€ format. For +example + +/SET autolog_path ~/irclogs/%Y/$tag/$0.%m-%d.log + +For logging only some specific channels or nicks, see /HELP log + +9. Changing keyboard bindings + +You can change any keyboard binding that terminal lets irssi know about. It +doesnâ€™t let irssi know everything, so for example shift-backspace canâ€™t be +bound unless you modify xterm resources somehow. + +/HELP bind tells pretty much everything there is to know about keyboard +bindings. However, thereâ€™s the problem of how to bind some non-standard keys. +They might differ a bit with each terminal, so youâ€™ll need to find out what +exactly the keypress produces. Easiest way to check that would be to see what +it prints in cat. Hereâ€™s an example for pressing F1 key: + + [user@host] ~% cat + ^[OP + +So in irssi you would use /BIND ^[OP /ECHO F1 pressed. If you use multiple +terminals which have different bindings for the key, it would be better to use +eg.: + +/BIND ^[OP key F1 +/BIND ^[11~ key F1 +/BIND F1 /ECHO F1 pressed. + +10. Proxies and IRC bouncers + +Irssi supports connecting to IRC servers via a proxy. All server connections +are then made through it, and if youâ€™ve set up everything properly, you donâ€™t +need to do any /QUOTE SERVER commands manually. + +Hereâ€™s an example: You have your bouncer (lets say, BNC or BNC-like) listening +in irc.bouncer.org port 5000. You want to use it to connect to servers +irc.dalnet and irc.efnet.org. First youâ€™d need to setup the bouncer: + +/SET use_proxy ON +/SET proxy_address irc.bouncer.org +/SET proxy_port 5000 + +/SET proxy_password YOUR_BNC_PASSWORD_HERE +/SET -clear proxy_string +/SET proxy_string_after conn %s %d + +Then youâ€™ll need to add the server connections. These are done exactly as if +youâ€™d want to connect directly to them. Nothing special about them: + +/SERVER ADD -auto -network dalnet irc.dal.net +/SERVER ADD -auto -network efnet irc.efnet.org + +With the proxy /SETs however, irssi now connects to those servers through your +BNC. All server connections are made through them so you can just forget that +your bouncer even exists. + +If you donâ€™t want to use the proxy for some reason, thereâ€™s -noproxy option +which you can give to /SERVER and /SERVER ADD commands. + +Proxy specific settings: + +All proxies have these settings in common: + +/SET use_proxy ON +/SET proxy_address <Proxy host address> +/SET proxy_port <Proxy port> + +HTTP proxy + +Use these settings with HTTP proxies: + +/SET -clear proxy_password +/EVAL SET proxy_string CONNECT %s:%d HTTP/1.0\\n\\n + +BNC + +/SET proxy_password your_pass +/SET -clear proxy_string +/SET proxy_string_after conn %s %d + +dircproxy + +dircproxy separates the server connections by passwords. So, if you for example +have network connection with password ircpass and OFTC connection with +oftcpass, you would do something like this: + +/SET -clear proxy_password +/SET -clear proxy_string + +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass + +The server name and port you give isnâ€™t used anywhere, so you can put anything +you want in there. + +psyBNC + +psyBNC has internal support for multiple servers. However, it could be a bit +annoying to use, and some people just use different users for connecting to +different servers. You can manage this in a bit same way as with dircproxy, by +creating fake connections: + +/SET -clear proxy_password +/SET -clear proxy_string + +/NETWORK ADD -user networkuser IRCnet +/SERVER ADD -auto -network IRCnet fake.network 6667 ircpass +/NETWORK ADD -user oftcuser OFTC +/SERVER ADD -auto -network OFTC fake.oftc 6667 oftcpass + +So, youâ€™ll specify the usernames with /NETWORK ADD command, and the userâ€™s +password with /SERVER ADD. + +Irssi proxy + +Irssi contains itâ€™s own proxy which you can build giving \\--with-proxy option +to configure. Youâ€™ll still need to run irssi in a screen to use it though. + +Irssi proxy is a bit different than most proxies, normally proxies create a new +connection to IRC server when you connect to it, but irssi proxy shares your +existing IRC connection(s) to multiple clients. And even more clearly: You can +use only one IRC server connection to IRC with as many clients as you want. Can +anyone figure out even more easier ways to say this, so I wouldnâ€™t need to try +to explain this thing for minutes every time? :) + +Irssi proxy supports sharing multiple server connections in different ports, +like you can share network in port 2777 and efnet in port 2778. + +Usage in proxy side: + +/LOAD proxy +/SET irssiproxy_password <password> +/SET irssiproxy_ports <network>=<port> ... (eg. IRCnet=2777 efnet=2778) + +NOTE: you MUST add all the servers you are using to server and network lists +with /SERVER ADD and /NETWORK ADD. ..Except if you really donâ€™t want to for +some reason, and you only use one server connection, you may simply set: + +/SET irssiproxy_ports *=2777 + +Usage in client side: + +Just connect to the irssi proxy like it is a normal server with password +specified in /SET irssiproxy_password. For example: + +/SERVER ADD -network IRCnet my.irssi-proxy.org 2777 secret +/SERVER ADD -network efnet my.irssi-proxy.org 2778 secret + +Irssi proxy works fine with other IRC clients as well. + +SOCKS + +Irssi can be compiled with socks support (\\--with-socks option to configure), +which requires â€œdanteâ€ and routes all connections through the proxy specified +in the system-wide /etc/socks.conf. This method is known to have issues in Mac +OS X. + +Note that /SET proxy settings donâ€™t have anything to do with socks. + +Using [4]proxychains-ng is recommended over recompiling irssi. + +Others + +IRC bouncers usually work like IRC servers, and want a password. You can give +it with: + +/SET proxy_password <password> + +Irssiâ€™s defaults for connect strings are + +/SET proxy_string CONNECT %s %d +/SET proxy_string_after + +The proxy_string is sent before NICK/USER commands, the proxy_string_after is +sent after them. %s and %d can be used with both of them. + +11. Irssiâ€™s settings + +Hereâ€™s some settings you might want to change (the default value is shown): +Also check the [5]Settings Documentation + +Queries + +/SET autocreate_own_query ON +    Should new query window be created when you send message to someone (with / +    MSG). +/SET autocreate_query_level MSGS +    New query window should be created when receiving messages with this level. +    MSGS, DCCMSGS and NOTICES levels work currently. You can disable this with +    /SET -clear autocreate_query_level. +/SET autoclose_query 0 +    Query windows can be automatically closed after certain time of inactivity. +    Queries with unread messages arenâ€™t closed and active window is neither +    never closed. The value is given in seconds. + +Windows + +/SET use_msgs_window OFF +    Create messages window at startup. All private messages go to this window. +    This only makes sense if youâ€™ve disabled automatic query windows. Message +    window can also be created manually with /WINDOW LEVEL MSGS, /WINDOW NAME +    (msgs). +/SET use_status_window ON +    Create status window at startup. All messages that donâ€™t really have better +    place go here, like all /WHOIS replies etc. Status window can also be +    created manually with /WINDOW LEVEL ALL -MSGS, /WINDOW NAME (status). +/SET autocreate_windows ON +    Should we create new windows for new window items or just place everything +    in one window +/SET autoclose_windows ON +    Should window be automatically closed when the last item in them is removed +    (ie. /PART, /UNQUERY). +/SET reuse_unused_windows OFF +    When finding where to place new window item (channel, query) Irssi first +    tries to use already existing empty windows. If this is set ON, new window +    will always be created for all window items. This setting is ignored if +    autoclose_windows is set ON. +/SET window_auto_change OFF +    Should Irssi automatically change to automatically created windows - +    usually queries when someone sends you a message. To prevent accidentally +    sending text meant to some other channel/nick, Irssi clears the input +    buffer when changing the window. The text is still in scrollback buffer, +    you can get it back with pressing arrow up key. +/SET print_active_channel OFF +    When you keep more than one channel in same window, Irssi prints the +    messages coming to active channel as <nick> text and other channels as +    <nick:channel> text. If this setting is set ON, the messages to active +    channels are also printed in the latter way. +/SET window_history OFF +    Should command history be kept separate for each window. + +User information + +/SET nick +    Your nick name +/SET alternate_nick +    Your alternate nick. +/SET user_name +    Your username, if you have ident enabled this doesnâ€™t affect anything +/SET real_name +    Your real name. + +Server information + +/SET skip_motd OFF +    Should we hide serverâ€™s MOTD (Message Of The Day). +/SET server_reconnect_time 300 +    Seconds to wait before connecting to same server again. Donâ€™t set this too +    low since it usually doesnâ€™t help at all - if the host is down, the few +    extra minutes of waiting wonâ€™t hurt much. +/SET lag_max_before_disconnect 300 +    Maximum server lag in seconds before disconnecting and trying to reconnect. +    This happens mostly only when network breaks between you and IRC server. + +Appearance + +/SET timestamps ON +    Show timestamps before each message. +/SET hide_text_style OFF +    Hide all bolds, underlines, MIRC colors, etc. +/SET show_nickmode ON +    Show the nickâ€™s mode before nick in channels, ie. ops have <@nick>, voices +    <+nick> and others < nick> +/SET show_nickmode_empty ON +    If the nick doesnâ€™t have a mode, use one space. ie. ON: < nick>, OFF: +    <nick> +/SET show_quit_once OFF +    Show quit message only once in some of the channel windows the nick was in +    instead of in all windows. +/SET lag_min_show 100 +    Show the server lag in status bar if itâ€™s bigger than this, the unit is 1/ +    100 of seconds (ie. the default value of 100 = 1 second). +/SET indent 10 +    When lines are longer than screen width they have to be split to multiple +    lines. This specifies how much space to put at the beginning of the line +    before the text begins. This can be overridden in text formats with %| +    format. +/SET activity_hide_targets +    If you donâ€™t want to see window activity in some certain channels or +    queries, list them here. For example #boringchannel =bot1 =bot2. If any +    highlighted text or message for you appears in that window, this setting is +    ignored and the activity is shown. + +Nick completion + +/SET completion_auto OFF +    Automatically complete the nick if line begins with start of nick and the +    completion character. Learn to use the tab-completion instead, itâ€™s a lot +    better ;) +/SET completion_char : +    Completion character to use. + +For all the ircII people + +I donâ€™t like automatic query windows, I donâ€™t like status window, I do like +msgs window where all messages go: + +/SET autocreate_own_query OFF +/SET autocreate_query_level DCCMSGS +/SET use_status_window OFF +/SET use_msgs_window ON + +Disable automatic window closing when /PARTing channel or /UNQUERYing query: + +/SET autoclose_windows OFF +/SET reuse_unused_windows ON + +Hereâ€™s the settings that make irssi work exactly like ircII in window +management (send me a note if you can think of more): + +/SET autocreate_own_query OFF +/SET autocreate_query_level NONE +/SET use_status_window OFF +/SET use_msgs_window OFF +/SET reuse_unused_windows ON +/SET windows_auto_renumber OFF + +/SET autostick_split_windows OFF +/SET autoclose_windows OFF +/SET print_active_channel ON + +12. Statusbar + +/STATUSBAR displays a list of the current statusbars, along with their position +and visibility: + + Name                           Type   Placement Position Visible + window                         window bottom    0        always + window_inact                   window bottom    1        inactive + prompt                         root   bottom    100      always + topic                          root   top       1        always + +/STATUSBAR <name> prints the statusbar settings (type, placement, position, +visibility) as well as its items. /STATUSBAR <name> ENABLE|DISABLE enables/ +disables the statusbar. /STATUSBAR <name> RESET resets the statusbar to its +default settings, or if the statusbar was created by you, it will be removed. + +The statusbar type can be either window or root. If the type is window, then a +statusbar will be created for each split window, otherwise it will be created +only once. Placement can be top or bottom, which refers to the top or bottom of +the screen. Position is a number, the higher the value the lower it will appear +in-screen. Visible can be always, active or inactive. Active/inactive is useful +only with split windows; one split window is active and the rest are inactive. +To adjust these settings, the following commands are available: + +/STATUSBAR <name> TYPE window|root +/STATUSBAR <name> PLACEMENT top|bottom +/STATUSBAR <name> POSITION <num> +/STATUSBAR <name> VISIBLE always|active|inactive + +Statusbar items can also be added or removed via command. Note that when +loading new statusbar scripts that add items, you will need to specify where +you want to show the item and how it is aligned. This can be accomplished using +the below commands: + +/STATUSBAR <name> ADD [-before | -after <item>] [-priority #] [-alignment left|right] <item> +/STATUSBAR <name> REMOVE <item> + +For statusbar scripts, the item name is usually equivalent to the script name. +The documentation of the script ought to tell you if this is not the case. For +example, to add mail.pl before the window activity item, use: /STATUSBAR window +ADD -before act mail. + + +References: + +[1] http://www.gnu.org/licenses/fdl.html +[2] https://www.iterm2.com/ +[3] http://quadpoint.org/articles/irssisplit/ +[4] https://github.com/rofl0r/proxychains-ng +[5] https://irssi.org/documentation/settings/ '),('irssi','1.0.5','245bd5579cc680e8eeba4769da87bccb8a4d0de3','ailin-nemui','remove lynx from autogen and make a separate syncdocs script','syncdocs.sh','79','7','101','0','ADD','@@ -0,0 +1,101 @@ +#!/bin/sh -e +# Run this to download FAQ and startup-HOWTO from irssi.org + +PKG_NAME=\"Irssi\" + +site=https://irssi.org + +faq=$site/documentation/faq/ +howto=$site/documentation/startup/ + +# remove everything until H1 and optionally 2 DIVs before the +# FOOTER. May need to be adjusted as the source pages change +pageclean_regex=\'s{.*(?=<h1)}{}s; +s{\\s*(</div>\\s*)?(</div>\\s*)?<footer.*}{}s; +s{(<.*?)\\sclass=\"(?:highlighter-rouge|highlight)\"(.*?>)}{\\1\\2}g;\' + +srcdir=`dirname \"$0\"` +test -z \"$srcdir\" && srcdir=. + +if test ! -f \"$srcdir\"/configure.ac; then +    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" +    echo \" top-level $PKG_NAME directory\" +    exit 1 +fi + +# detect downloader app +downloader=false + +if type curl >/dev/null 2>&1 ; then +    downloader=\"curl -Ssf\" +elif type wget >/dev/null 2>&1 ; then +    downloader=\"wget -nv -O-\" +else +    echo \"**Error**: No wget or curl present\" +    echo \"Install wget or curl, then run syncdocs.sh again\" +fi + +# detect html converter app +converter=false +if [ \"$1\" = \"-any\" ]; then +    any=true +else +    any=false +fi + +if type w3m >/dev/null 2>&1 ; then +    converter=\"w3m -o display_link_number=1 -dump -T text/html\" +    any=true +elif type lynx >/dev/null 2>&1 ; then +    converter=\"lynx -dump -stdin -force_html\" +elif type elinks >/dev/null 2>&1 ; then +    converter=\"elinks -dump -force-html\" +else +    echo \"**Error**: Neither w3m, nor lynx or elinks present\" +    echo \"Install w3m, then run syncdocs.sh again\" +    exit 1 +fi + +if ! $any ; then +    echo \"**Error**: w3m not present\" +    echo \"If you want to use lynx or elinks, run syncdocs.sh -any\" +    exit 1 +fi + +check_download() { +    if test \"$1\" -ne 0 || test ! -e \"$2\" || test \"$(wc -l \"$2\" | awk \'{print $1}\')\" -le 1 ; then +	rm -f \"$2\" +	echo \"... download failed ( $1 )\" +	exit 2 +    fi +} + +download_it() { +    echo \"Downloading $1 from $2 ...\" +    ret=0 +    $downloader \"$2\" > \"$3\".tmp || ret=$? +    check_download \"$ret\" \"$3\".tmp +    perl -i -0777 -p -e \"$pageclean_regex\" \"$3\".tmp +    perl -i -0777 -p -e \'s{\\A}{\'\"<base href=\'$2\'>\"\'\\n}\' \"$3\".tmp +    perl -i -0777 -p -e \'s{<a href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\".*?\">\\[email&#160;protected\\]</a>}{user\\@host}g\' \"$3\".tmp +    mv \"$3\".tmp \"$3\" +} + +download_it \"FAQ\" \"$faq\" \"$srcdir\"/docs/faq.html +download_it \"Startup How-To\" \"$howto\" \"$srcdir\"/docs/startup-HOWTO.html + +# .html -> .txt with lynx or elinks +echo \"Documentation: html -> txt...\" + +cat \"$srcdir\"/docs/faq.html \\ +    | LC_ALL=en_IE.utf8 $converter \\ +    | perl -pe \' +	s/^ *//; +	if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; } +	elsif (/^([QA]):/) { $state = $1 } +	elsif ($_ ne \"\\n\") { $_ = \"   $_\"; }; +\' > docs/faq.txt + +cat \"$srcdir\"/docs/startup-HOWTO.html \\ +    | perl -pe \"s/\\\\bhref=([\\\"\\\'])#.*?\\\\1//\" \\ +    | LC_ALL=en_IE.utf8 $converter > \"$srcdir\"/docs/startup-HOWTO.txt '),('irssi','1.0.5','9a3c0bce48d3f172d5638ecb37967528812129b1','ailin-nemui','add a script to sync scripts as well','syncscripts.sh','30','1','38','0','ADD','@@ -0,0 +1,38 @@ +#!/bin/sh -e +# Run this script to sync dual lived scripts from scripts.irssi.org to scripts/ + +PKG_NAME=\"Irssi\" + +scriptbase=https://scripts.irssi.org/scripts + +srcdir=`dirname \"$0\"` +test -z \"$srcdir\" && srcdir=. + +if test ! -f \"$srcdir\"/configure.ac; then +    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" +    echo \" top-level $PKG_NAME directory\" +    exit 1 +fi + +dl2=\'curl -Ssf\' + +dl_it() { +    echo \"$1\" +    $dl2 -o \"$srcdir/scripts/$1\" \"$scriptbase/$1\" +} + +for script in \\ +    autoop.pl \\ +    autorejoin.pl \\ +    buf.pl \\ +    dns.pl \\ +    kills.pl \\ +    mail.pl \\ +    mlock.pl \\ +    quitmsg.pl \\ +    scriptassist.pl \\ +    usercount.pl \\ +    ; +do +    dl_it $script +done '),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','Strip : from <trailing> parameters  This is to fix #601. The function used to extract the mode string assumed that \":\" would only occur in a particular spot. This lead to the possibility that \":\" could be treated as part of things like nicknames or mode arguments, where it should have been stripped as part of protocol escaping.','fe-events.c','376','58','1','1','MODIFY','@@ -224,7 +224,7 @@ static void event_nick(IRC_SERVER_REC *server, const char *data,  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick, const char *addr)  { -	char *params, *channel, *mode; +	char *params = NULL, *channel = NULL, *mode = NULL;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','Strip : from <trailing> parameters  This is to fix #601. The function used to extract the mode string assumed that \":\" would only occur in a particular spot. This lead to the possibility that \":\" could be treated as part of things like nicknames or mode arguments, where it should have been stripped as part of protocol escaping.','irc.c','316','74','30','2','MODIFY','@@ -40,6 +40,8 @@ static int signal_server_incoming;  #  define MAX_SOCKET_READS 5  #endif   +static void strip_params_colon(char *const); +  /* The core of the irc_send_cmd* functions. If `raw\' is TRUE, the `cmd\'     won\'t be checked at all if it\'s 512 bytes or not, or if it contains     line feeds or not. Use with extreme caution! */ @@ -269,8 +271,9 @@ char *event_get_params(const char *data, int count, ...)  	while (count-- > 0) {  		str = (char **) va_arg(args, char **);  		if (count == 0 && rest) { -			/* put the rest to last parameter */ -			tmp = *datad == \':\' ? datad+1 : datad; +			/* Put the rest into the last parameter. */ +			strip_params_colon(datad); +			tmp = datad;  		} else {  			tmp = event_get_param(&datad);  		} @@ -281,6 +284,31 @@ char *event_get_params(const char *data, int count, ...)  	return duprec;  }   +/* Given a string containing <params>, strip any colon prefixing <trailing>. */ +static void strip_params_colon(char *const params) +{ +	if (!params) { +		return; +	} + +	char *s = params; +	while (*s != \'\\0\') { +		if (*s == \':\') { +			memmove(s, s+1, strlen(s+1)+1); +			return; +		} + +		s = strchr(s, \' \'); +		if (!s) { +			return; +		} + +		while (*s == \' \') { +			s++; +		} +	} +} +  static void irc_server_event(IRC_SERVER_REC *server, const char *line,  			     const char *nick, const char *address)  { '),('irssi','1.0.5','8843d4f77d8e829135e2ff9b354990134c58c46a','Will Storey','Strip : from <trailing> parameters  This is to fix #601. The function used to extract the mode string assumed that \":\" would only occur in a particular spot. This lead to the possibility that \":\" could be treated as part of things like nicknames or mode arguments, where it should have been stripped as part of protocol escaping.','modes.c','700','195','2','2','MODIFY','@@ -480,8 +480,8 @@ static void event_user_mode(IRC_SERVER_REC *server, const char *data)  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick)  { -	IRC_CHANNEL_REC *chanrec; -	char *params, *channel, *mode; +	IRC_CHANNEL_REC *chanrec = NULL; +	char *params = NULL, *channel = NULL, *mode = NULL;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','22','0','7','14','MODIFY','@@ -7,33 +7,26 @@ CLEANFILES = default-config.h default-theme.h  @MAINTAINER_MODE_TRUE@.PHONY: irssi-version.h    default-config.h: $(srcdir)/irssi.conf -	$(srcdir)/file2header.sh $(srcdir)/irssi.conf default_config > default-config.h +	$(srcdir)/utils/file2header.sh $(srcdir)/irssi.conf default_config > default-config.h   -default-theme.h: $(srcdir)/default.theme -	$(srcdir)/file2header.sh $(srcdir)/default.theme default_theme > default-theme.h +default-theme.h: $(srcdir)/themes/default.theme +	$(srcdir)/utils/file2header.sh $(srcdir)/themes/default.theme default_theme > default-theme.h    irssi-version.h: -	VERSION=\"$(VERSION)\" $(srcdir)/irssi-version.sh $(srcdir) | \\ -		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/irssi-version.sh $(srcdir) >$@ +	VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) | \\ +		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) >$@   -SUBDIRS = src docs scripts +SUBDIRS = src docs scripts themes utils    confdir = $(sysconfdir)  conf_DATA = irssi.conf   -themedir = $(datadir)/irssi/themes -theme_DATA = default.theme colorless.theme -  pkginclude_HEADERS = irssi-config.h irssi-version.h    EXTRA_DIST = \\  	ChangeLog \\  	autogen.sh \\  	README.md \\ -	file2header.sh \\  	$(conf_DATA) \\ -	$(theme_DATA) \\  	irssi-config.in \\ -	irssi-icon.png \\ -	irssi-version.sh \\ -	syntax.pl +	irssi-icon.png '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','autogen.sh','45','1','16','11','MODIFY','@@ -3,21 +3,24 @@    PKG_NAME=\"Irssi\"   -srcdir=`dirname $0` +srcdir=`dirname \"$0\"`  test -z \"$srcdir\" && srcdir=. +mydir=`pwd`   -if test ! -f $srcdir/configure.ac; then -    echo -n \"**Error**: Directory \\`$srcdir\\\' does not look like the\" +if test ! -f \"$srcdir\"/configure.ac; then +    echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\"      echo \" top-level $PKG_NAME directory\"      exit 1  fi   +cd \"$srcdir\" +  # create help files  echo \"Creating help files...\" -perl syntax.pl +perl utils/syntax.pl    echo \"Creating ChangeLog...\" -git log > $srcdir/ChangeLog +git log > ChangeLog  if test \"$?\" -ne 0; then      echo \"**Error**: ${PKG_NAME} Autogen must be run in a git clone, cannot proceed.\"      exit 1 @@ -38,17 +41,19 @@ fi    rm -f aclocal.m4  echo \"Running autoreconf ...\" -autoreconf -i || exit 1 +autoreconf -i || exit $? + +# make sure perl hashes have correct length +find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\' + +cd \"$mydir\"    conf_flags=\"--enable-maintainer-mode\"    if test x$NOCONFIGURE = x; then -  echo Running $srcdir/configure $conf_flags \"$@\" ... -  $srcdir/configure $conf_flags \"$@\" \\ +  echo Running \"$srcdir\"/configure $conf_flags \"$@\" ... +  \"$srcdir\"/configure $conf_flags \"$@\" \\    && echo Now type \\`make\\\' to compile $PKG_NAME || exit 1  else    echo Skipping configure process.  fi - -# make sure perl hashes have correct length -find src/perl -name \'*.c\' -o -name \'*.xs\' -exec grep -n hv_store {} + | perl -l -ne \'if (/\"(\\w+)\",\\s*(\\d+)/ && $2 != length $1) { $X=1; print \"Incorrect key length in $_\" } END { exit $X }\' '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','configure.ac','700','4','2','0','MODIFY','@@ -661,6 +661,8 @@ scripts/examples/Makefile  docs/Makefile  docs/help/Makefile  docs/help/in/Makefile +utils/Makefile +themes/Makefile  irssi-config  ])   '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','4','0','5','0','ADD','@@ -0,0 +1,5 @@ +themedir = $(datadir)/irssi/themes +theme_DATA = default.theme colorless.theme + +EXTRA_DIST = \\ +	$(theme_DATA) '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','colorless.theme','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','default.theme','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','Makefile.am','4','0','4','0','ADD','@@ -0,0 +1,4 @@ +EXTRA_DIST = \\ +	file2header.sh \\ +	irssi-version.sh \\ +	syntax.pl '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','file2header.sh','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','irssi-version.sh','None','None','0','0','RENAME',''),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syncdocs.sh','80','7','2','1','RENAME','@@ -16,6 +16,7 @@ s{(<.*?)\\sclass=\"(?:highlighter-rouge|highlight)\"(.*?>)}{\\1\\2}g;\'    srcdir=`dirname \"$0\"`  test -z \"$srcdir\" && srcdir=. +srcdir=\"$srcdir\"/..    if test ! -f \"$srcdir\"/configure.ac; then      echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" @@ -94,7 +95,7 @@ cat \"$srcdir\"/docs/faq.html \\  	if ($_ eq \"\\n\" && $state eq \"Q\") { $_ = \"\"; }  	elsif (/^([QA]):/) { $state = $1 }  	elsif ($_ ne \"\\n\") { $_ = \"   $_\"; }; -\' > docs/faq.txt +\' > \"$srcdir\"/docs/faq.txt    cat \"$srcdir\"/docs/startup-HOWTO.html \\      | perl -pe \"s/\\\\bhref=([\\\"\\\'])#.*?\\\\1//\" \\ '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syncscripts.sh','31','1','1','0','RENAME','@@ -7,6 +7,7 @@ scriptbase=https://scripts.irssi.org/scripts    srcdir=`dirname \"$0\"`  test -z \"$srcdir\" && srcdir=. +srcdir=\"$srcdir\"/..    if test ! -f \"$srcdir\"/configure.ac; then      echo -n \"**Error**: Directory \\`$srcdir\' does not look like the\" '),('irssi','1.0.5','ca3498d42d29383024382b0eb983f97ab4e6b614','ailin-nemui','move some files into subdirs','syntax.pl','None','None','0','0','RENAME',''),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','autorejoin.pl','67','0','32','17','MODIFY','@@ -1,6 +1,9 @@ -# automatically rejoin to channel after kick +# automatically rejoin to channel after kicked  # delayed rejoin: Lam 28.10.2001 (lam@lac.pl)   +# /SET autorejoin_channels #channel1 #channel2 ... +# /SET autorejoin_delay 5 +  # NOTE: I personally don\'t like this feature, in most channels I\'m in it  # will just result as ban. You\'ve probably misunderstood the idea of /KICK  # if you kick/get kicked all the time \"just for fun\" ... @@ -9,31 +12,22 @@ use Irssi;  use Irssi::Irc;  use strict;  use vars qw($VERSION %IRSSI); -$VERSION = \"1.0.0\"; +$VERSION = \"1.1.0\";  %IRSSI = (  	authors => \"Timo \'cras\' Sirainen, Leszek Matok\",  	contact => \"lam\\@lac.pl\",  	name => \"autorejoin\", -	description => \"Automatically rejoin to channel after being kick, after a (short) user-defined delay\", +	description => \"Automatically rejoin to channel after being kicked, after a (short) user-defined delay\",  	license => \"GPLv2\",  	changed => \"10.3.2002 14:00\"  );   - -# How many seconds to wait before the rejoin? -# TODO: make this a /setting -my $delay = 5; - -my @tags; -my $acttag = 0; -  sub rejoin {  	my ( $data ) = @_; -	my ( $tag, $servtag, $channel, $pass ) = split( / +/, $data ); +	my ( $servtag, $channel, $pass ) = @{$data};    	my $server = Irssi::server_find_tag( $servtag );  	$server->send_raw( \"JOIN $channel $pass\" ) if ( $server ); -	Irssi::timeout_remove( $tags[$tag] );  }    sub event_rejoin_kick { @@ -48,10 +42,31 @@ sub event_rejoin_kick {  	my $rejoinchan = $chanrec->{ name } if ( $chanrec );  	my $servtag = $server->{ tag };   -	Irssi::print \"Rejoining $rejoinchan in $delay seconds.\"; -	$tags[$acttag] = Irssi::timeout_add( $delay * 1000, \"rejoin\", \"$acttag $servtag $rejoinchan $password\" ); -	$acttag++; -	$acttag = 0 if ( $acttag > 60 ); +	# check if we want to autorejoin this channel +	my $chans = Irssi::settings_get_str( \'autorejoin_channels\' ); + +	if ( $chans ) { +		my $found = 0; +		foreach my $chan ( split( /[ ,]/, $chans ) ) { +			if ( lc( $chan ) eq lc( $channel ) ) { +				$found = 1; +				last; +			} +		} +		return unless $found; +	} + +	my @args = ($servtag, $rejoinchan, $password); +	my $delay = Irssi::settings_get_int( \"autorejoin_delay\" ); + +	if ($delay) { +		Irssi::print \"Rejoining $rejoinchan in $delay seconds.\"; +		Irssi::timeout_add_once( $delay * 1000, \"rejoin\", \\@args ); +	} else { +		rejoin( \\@args ); +	}  }   +Irssi::settings_add_int(\'misc\', \'autorejoin_delay\', 5); +Irssi::settings_add_str(\'misc\', \'autorejoin_channels\', \'\');  Irssi::signal_add( \'event kick\', \'event_rejoin_kick\' ); '),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','mail.pl','389','0','1','0','MODIFY','@@ -6,6 +6,7 @@ $VERSION = \"2.92\";      contact     => \"tss\\@iki.fi, matti\\@hiljanen.com, joost\\@carnique.nl, bart\\@dreamflow.nl\",      name        => \"mail\",      description => \"Fully customizable mail counter statusbar item with multiple mailbox and multiple Maildir support\", +    sbitems     => \"mail\",      license     => \"Public Domain\",      url         => \"http://irssi.org, http://scripts.irssi.de\",  ); '),('irssi','1.0.5','8c0e0c81ee79684201020f843eeb0a4d656ed14c','ailin-nemui','run syncscripts.sh','usercount.pl','150','9','1','0','MODIFY','@@ -7,6 +7,7 @@ $VERSION = \"1.19\";      contact     => \'dgl@dgl.cx, tss@iki.fi, georg@boerde.de\',      name        => \'usercount\',      description => \'Adds a usercount for a channel as a statusbar item\', +    sbitems     => \'usercount\',      license     => \'GNU GPLv2 or later\',      url         => \'http://irssi.dgl.cx/\',      changes     => \'Only show halfops if server supports them\', '),('irssi','1.0.5','96c7f68b3579ae5f83b635d946dc705d6322a16c','ailin-nemui','clean up file path after move','Makefile.am','156','0','1','1','MODIFY','@@ -59,7 +59,7 @@ perl-signals-list.h: $(top_srcdir)/docs/signals.txt $(srcdir)/get-signals.pl  	cat $(top_srcdir)/docs/signals.txt | $(perlpath) $(srcdir)/get-signals.pl > perl-signals-list.h    irssi-core.pl.h: irssi-core.pl -	$(top_srcdir)/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code > irssi-core.pl.h +	$(top_srcdir)/utils/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code > irssi-core.pl.h    common_sources = \\  	common/Irssi.xs \\ '),('irssi','1.0.5','7e619ed990503faf45fc1ae1e28a3a6062dc7532','ailin-nemui','Update README.md','README.md','51','0','62','98','MODIFY','@@ -1,109 +1,73 @@ -# Irssi +# [Irssi](https://irssi.org/)    [![Build Status](https://travis-ci.org/irssi/irssi.svg?branch=master)](https://travis-ci.org/irssi/irssi)    Irssi is a modular chat client that is most commonly known for its  text mode user interface, but 80% of the code isn\'t text mode -specific. We have a working but currently unmaintained GTK2 frontend -called xirssi. Irssi comes with IRC support built in, and there are +specific. Irssi comes with IRC support built in, and there are  third party [ICB](https://github.com/jperkin/irssi-icb),  [SILC](http://www.silcnet.org/),  [XMPP](http://cybione.org/~irssi-xmpp/) (Jabber), -[PSYC](https://github.com/electric-blue/irssyc) and +[PSYC](http://about.psyc.eu/Irssyc) and  [Quassel](https://github.com/phhusson/quassel-irssi) protocol modules  available.   -## Installation - -See the `INSTALL` file. - -## Features - -So what\'s so great about Irssi? Here\'s a list of some features I can -think of currently: - - - **Optional automation** - There\'s lots of things Irssi does for you -   automatically that some people like and others just hate. Things like: -   nick completion, creating new window for newly joined channel, creating -   queries when msgs/notices are received or when you send a msg, closing -   queries when it\'s been idle for some time, etc. - - - **Multiserver friendly** - I think Irssi has clearly the best support -   for handling multiple server connections. You can have as many as you -   want in as many ircnets as you want. Having several connections in one -   server works too, for example when you hit the (ircnet\'s) 10 -   channels/connection limit you can just create another connection and -   you hardly notice it. If connection to server is lost, Irssi tries to -   connect back until it\'s successful. Also channels you were joined -   before disconnection are restored, even if they\'re \"temporarily -   unavailable\" because of netsplits, Irssi keeps rejoining back to them. -   Also worth noticing - there\'s not that stupid \"server is bound to this -   window, if this window gets closed the connection closes\" thing that -   ircII based clients have. - - - **Channel automation** - You can specify what channels to join to -   immediately after connected to some server or IRC network. After joined -   to channel, Irssi can automatically request ops for you (or do -   anything, actually) from channel\'s bots. - - - **Window content saving** - Say /LAYOUT SAVE when you\'ve put all the -   channels and queries to their correct place, and after restarting -   Irssi, the channels will be joined back into windows where they were -   saved. - - - **Tab completing anything** - You can complete lots of things with tab: -   nicks, commands, command -options, file names, settings, text format -   names, channels and server names. There\'s also an excellent /msg -   completion that works transparently with multiple IRC networks. -   Completing channel nicks is also pretty intelligent, it first goes -   through the people who have talked to you recently, then the people who -   have talked to anyone recently and only then it fallbacks to rest of -   the nicks. You can also complete a set of words you\'ve specified, for -   example homepage<tab> changes it to your actual home page URL. - - - **Excellent logging** - You can log any way you want and as easily or -   hard as you want. With autologging Irssi logs everything to specified -   directory, one file per channel/nick. ircII style /WINDOW LOG ON is -   also supported. There\'s also the \"hard way\" of logging - /LOG command -   which lets you specify exactly what you wish to log and where. Log -   rotating is supported with all the different logging methods, you can -   specify how often you want it to rotate and what kind of time stamp to -   use. - - - **Excellent ignoring** - You can most probably ignore anything any way -   you want. Nick masks, words, regular expressions. You can add -   exceptions to ignores. You can ignore other people\'s replies in -   channels to nicks you have ignored. You can also specify that the -   specific ignores work only in specific channel(s). - - - **Lastlog and scrollback handling** - /LASTLOG command has some new -   features: -new option checks only lines that came since you last did -   /LASTLOG command, -away option checks new lines since you last went -   away. Regular expression matches work also, of course. Going to some -   wanted place at scrollback has always been hard with non-GUI clients. A -   search command that jumps around in scrollback in GUI-style is still -   missing from Irssi, but there\'s something that\'s almost as good as it. -   /LASTLOG always shows timestamps when the line was printed, even if you -   didn\'t have timestamps on. Now doing /SB GOTO \\<timestamp\\> jumps -   directly to the position in scrollback you wanted. Great feature when -   you want to browse a bit of the discussion what happened when someone -   said your name (as seen in awaylog) or topic was changed (/last -   -topics) - -## Files - - - The `docs/` directory contains several documents: -    - `startup-HOWTO.txt` - new users should read this -    - `manual.txt` - manual I started writing but didn\'t get it very far :) -    - `perl.txt` - Perl scripting help -    - `formats.txt` - How to use colors, etc. with Irssi -    - `faq.txt` - Frequently Asked Questions -    - `special_vars.txt` - some predefined $variables you can use with Irssi - -## Bugs / Suggestions - -See the `TODO` file, http://bugs.irssi.org and the GitHub issues if it is -already listed in there; if not, open an issue on GitHub or send a mail to -[staff@irssi.org](mailto:staff@irssi.org). - -You can also contact the Irssi developers in #irssi on freenode. +![irssi](https://user-images.githubusercontent.com/5665186/32180643-cf127f60-bd92-11e7-8aa2-882313ce1d8e.png) + +## [Download information](https://irssi.org/download/) + +#### Development source installation + +``` +git clone https://github.com/irssi/irssi +cd irssi +./autogen.sh +make && sudo make install +``` + +#### Release source installation + +* Download [release](https://github.com/irssi/irssi/releases) +* [Verify](https://irssi.org/download/#release-sources) signature +``` +tar xJf irssi-*.tar.xz +cd irssi-* +./configure +make && sudo make install +``` + +### Requirements + +- [glib-2.28](https://wiki.gnome.org/Projects/GLib) or greater +- [openssl](https://www.openssl.org/) +- [perl-5.6](https://www.perl.org/) or greater (for perl support) +- terminfo or ncurses (for text frontend) + +#### See the [INSTALL](INSTALL) file for details + +## [Documentation](https://irssi.org/documentation/) + +* [Frequently Asked Questions](https://irssi.org/documentation/faq) +* [Startup How-To](https://irssi.org/documentation/startup) +* Check the built-in `/HELP`, it has all the details on command syntax + +## [Themes](https://irssi-import.github.io/themes/) + +## [Scripts](http://scripts.irssi.org/) + +## [Modules](https://irssi.org/modules/) + +## [Security information](https://irssi.org/security/) + +Please report security issues to staff@irssi.org. Thanks! + +## [Bugs](https://github.com/irssi/irssi/issues) / Suggestions / [Contributing](https://irssi.org/development/) + +Check the GitHub issues if it is already listed in there; if not, open +an issue on GitHub or send a mail to [staff@irssi.org](mailto:staff@irssi.org). + +Irssi is always looking for developers. Feel free to submit patches through +GitHub pull requests. + +You can also contact the Irssi developers in +[#irssi](https://irssi.org/support/irc/) on freenode. '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','settings.c','693','161','10','0','MODIFY','@@ -39,6 +39,7 @@ static GString *last_errors;  static GSList *last_invalid_modules;  static int fe_initialized;  static int config_changed; /* FIXME: remove after .98 (unless needed again) */ +static int user_settings_changed;    static GHashTable *settings;  static int timeout_tag; @@ -464,6 +465,11 @@ SETTINGS_REC *settings_get_record(const char *key)  	return g_hash_table_lookup(settings, key);  }   +static void sig_init_userinfo_changed(gpointer changedp) +{ +	user_settings_changed = GPOINTER_TO_INT(changedp); +} +  static void sig_init_finished(void)  {  	fe_initialized = TRUE; @@ -479,6 +485,8 @@ static void sig_init_finished(void)  			  \"updated, please /SAVE\");  		signal_emit(\"setup changed\", 0);  	} + +	signal_emit(\"settings userinfo changed\", 1, GINT_TO_POINTER(user_settings_changed));  }    static void settings_clean_invalid_module(const char *module) @@ -875,6 +883,7 @@ void settings_init(void)  	timeout_tag = g_timeout_add(SETTINGS_AUTOSAVE_TIMEOUT,  				    (GSourceFunc) sig_autosave, NULL);  	signal_add(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished); +	signal_add(\"irssi init userinfo changed\", (SIGNAL_FUNC) sig_init_userinfo_changed);  	signal_add(\"gui exit\", (SIGNAL_FUNC) sig_autosave);  }   @@ -887,6 +896,7 @@ void settings_deinit(void)  {          g_source_remove(timeout_tag);  	signal_remove(\"irssi init finished\", (SIGNAL_FUNC) sig_init_finished); +	signal_remove(\"irssi init userinfo changed\", (SIGNAL_FUNC) sig_init_userinfo_changed);  	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_autosave);    	g_slist_foreach(last_invalid_modules, (GFunc) g_free, NULL); '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','Makefile.am','67','0','1','0','MODIFY','@@ -55,6 +55,7 @@ pkginc_fe_common_core_HEADERS = \\  	fe-exec.h \\  	fe-messages.h \\  	fe-queries.h \\ +	fe-settings.h \\  	fe-tls.h \\  	formats.h \\  	hilight-text.h \\ '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','fe-settings.c','328','91','6','1','MODIFY','@@ -26,7 +26,7 @@  #include \"misc.h\"  #include \"lib-config/iconfig.h\"  #include \"settings.h\" - +#include \"fe-settings.h\"  #include \"levels.h\"  #include \"printtext.h\"  #include \"keyboard.h\" @@ -41,6 +41,11 @@ static void set_print(SETTINGS_REC *rec)  	g_free(value);  }   +void fe_settings_set_print(const char *key) +{ +	set_print(settings_get_record(key)); +} +  static void set_print_pattern(const char *pattern)  {  	GSList *sets, *tmp; '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','fe-settings.h','1','0','6','0','ADD','@@ -0,0 +1,6 @@ +#ifndef __FE_CHANNELS_H +#define __FE_CHANNELS_H + +void fe_settings_set_print(const char *key); + +#endif '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','irssi.c','224','30','25','24','MODIFY','@@ -31,6 +31,7 @@    #include \"printtext.h\"  #include \"fe-common-core.h\" +#include \"fe-settings.h\"  #include \"themes.h\"    #include \"term.h\" @@ -79,25 +80,8 @@ static int dirty, full_redraw;  static GMainLoop *main_loop;  int quitting;   -static const char *banner_text = -	\" ___           _\\n\" -	\"|_ _|_ _ _____(_)\\n\" - 	\" | || \'_(_-<_-< |\\n\" -	\"|___|_| /__/__/_|\\n\" -	\"Irssi v\" PACKAGE_VERSION \" - http://www.irssi.org\"; - -static const char *firsttimer_text = -	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n\" -	\"Hi there! If this is your first time using Irssi, you\\n\" -	\"might want to go to our website and read the startup\\n\" -	\"documentation to get you going.\\n\\n\" -	\"Our community and staff are available to assist you or\\n\" -	\"to answer any questions you may have.\\n\\n\" -	\"Use the /HELP command to get detailed information about\\n\" -	\"the available commands.\\n\" -	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\"; -  static int display_firsttimer = FALSE; +static int user_settings_changed = 0;      static void sig_exit(void) @@ -105,6 +89,11 @@ static void sig_exit(void)          quitting = TRUE;  }   +static void sig_settings_userinfo_changed(gpointer changedp) +{ +	user_settings_changed = GPOINTER_TO_INT(changedp); +} +  /* redraw irssi\'s screen.. */  void irssi_redraw(void)  { @@ -161,6 +150,7 @@ static void textui_init(void)  	fe_common_irc_init();    	theme_register(gui_text_formats); +	signal_add(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);  	signal_add_last(\"gui exit\", (SIGNAL_FUNC) sig_exit);  }   @@ -199,14 +189,24 @@ static void textui_finish_init(void)  	statusbar_redraw(NULL, TRUE);    	if (servers == NULL && lookup_servers == NULL) { -		printtext(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, -			  \"%s\", banner_text); +		printformat(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, TXT_IRSSI_BANNER);  	}    	if (display_firsttimer) { -		printtext(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, -			  \"%s\", firsttimer_text); +		printformat(NULL, NULL, MSGLEVEL_CRAP|MSGLEVEL_NO_ACT, TXT_WELCOME_FIRSTTIME);  	} + +	/* see irc-servers-setup.c:init_userinfo */ +	if (user_settings_changed) +		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_WELCOME_INIT_SETTINGS); +	if (user_settings_changed & (1<<0)) +		fe_settings_set_print(\"real_name\"); +	if (user_settings_changed & (1<<1)) +		fe_settings_set_print(\"user_name\"); +	if (user_settings_changed & (1<<2)) +		fe_settings_set_print(\"nick\"); +	if (user_settings_changed & (1<<3)) +		fe_settings_set_print(\"hostname\");  }    static void textui_deinit(void) @@ -223,6 +223,7 @@ static void textui_deinit(void)  #endif            dirty_check(); /* one last time to print any quit messages */ +	signal_remove(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);  	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_exit);    	lastlog_deinit(); @@ -249,6 +250,7 @@ static void textui_deinit(void)  	core_deinit();  }   +  static void check_files(void)  {  	struct stat statbuf; @@ -259,12 +261,11 @@ static void check_files(void)  	}  }   -  int main(int argc, char **argv)  {  	static int version = 0;  	static GOptionEntry options[] = { -		{ \"version\", \'v\', 0, G_OPTION_ARG_NONE, &version, \"Display irssi version\", NULL }, +		{ \"version\", \'v\', 0, G_OPTION_ARG_NONE, &version, \"Display Irssi version\", NULL },  		{ NULL }  	};  	int loglev; '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','module-formats.c','66','0','21','0','MODIFY','@@ -78,5 +78,26 @@ FORMAT_REC gui_text_formats[] =  	{ \"paste_warning\", \"Pasting $0 lines to $1. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.\", 2, { 1, 0 } },  	{ \"paste_prompt\", \"Hit Ctrl-K to paste, Ctrl-C to abort?\", 0 },   +	/* ---- */ +	{ NULL, \"Welcome\", 0 }, + +	{ \"irssi_banner\", +	  \" ___           _%:\" +	  \"|_ _|_ _ _____(_)%:\" +	  \" | || \'_(_-<_-< |%:\" +	  \"|___|_| /__/__/_|%:\" +	  \"Irssi v$J - http://www.irssi.org\", 0 }, +	{ \"welcome_firsttime\", +	  \"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n\" +	  \"Hi there! If this is your first time using Irssi, you%:\" +	  \"might want to go to our website and read the startup%:\" +	  \"documentation to get you going.%:%:\" +	  \"Our community and staff are available to assist you or%:\" +	  \"to answer any questions you may have.%:%:\" +	  \"Use the /HELP command to get detailed information about%:\" +	  \"the available commands.%:\" +	  \"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\", 0 }, +	{ \"welcome_init_settings\", \"The following settings were initialized\", 0 }, +  	{ NULL, NULL, 0 }  }; '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','module-formats.h','51','0','6','0','MODIFY','@@ -52,6 +52,12 @@ enum {  	TXT_PASTE_WARNING,  	TXT_PASTE_PROMPT,   +	TXT_FILL_5, /* Welcome */ + +	TXT_IRSSI_BANNER, +	TXT_WELCOME_FIRSTTIME, +	TXT_WELCOME_INIT_SETTINGS, +  	TXT_COUNT  };   '),('irssi','1.0.5','b0fa4dd46d8bf1cf63880fabf2105dd9134100df','ailin-nemui','show initial nick and name on first start','irc-servers-setup.c','157','52','10','1','MODIFY','@@ -116,14 +116,17 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,    static void init_userinfo(void)  { +	int changed;  	const char *set, *nick, *user_name, *str;   +	changed = 0;  	/* check if nick/username/realname wasn\'t read from setup.. */          set = settings_get_str(\"real_name\");  	if (set == NULL || *set == \'\\0\') {  		str = g_getenv(\"IRCNAME\");  		settings_set_str(\"real_name\",  				 str != NULL ? str : g_get_real_name()); +		changed |= 1<<0;  	}    	/* username */ @@ -134,6 +137,7 @@ static void init_userinfo(void)  				 str != NULL ? str : g_get_user_name());    		user_name = settings_get_str(\"user_name\"); +		changed |= 1<<1;  	}    	/* nick */ @@ -143,15 +147,20 @@ static void init_userinfo(void)  		settings_set_str(\"nick\", str != NULL ? str : user_name);    		nick = settings_get_str(\"nick\"); +		changed |= 1<<2;  	}    	/* host name */          set = settings_get_str(\"hostname\");  	if (set == NULL || *set == \'\\0\') {  		str = g_getenv(\"IRCHOST\"); -		if (str != NULL) +		if (str != NULL) {  			settings_set_str(\"hostname\", str); +			changed |= 1<<3; +		}  	} + +	signal_emit(\"irssi init userinfo changed\", 1, GINT_TO_POINTER(changed));  }    static void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node) '),('irssi','1.0.5','4d6822b1c43d876856a5df07ce69fb4e67c3591a','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 11 +#define IRSSI_ABI_VERSION 12    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.0.5','56013367983b61d8ee4d2e905767ce50b25ffb82','LemonBoy','Turn the style guide into a clang-format file','.clang-format','35','0','37','0','ADD','@@ -0,0 +1,37 @@ +# IndentPPDirectives: None +# SpaceInParentheses: false +AlignAfterOpenBracket: Align +AlignConsecutiveAssignments: false +AlignConsecutiveDeclarations: false +AlignOperands: true +AlignTrailingComments: true +AllowAllParametersOfDeclarationOnNextLine: true +AllowShortBlocksOnASingleLine: false +AllowShortCaseLabelsOnASingleLine: false +AllowShortFunctionsOnASingleLine: Empty +AllowShortIfStatementsOnASingleLine: false +AllowShortLoopsOnASingleLine: false +AlwaysBreakAfterReturnType: None +AlwaysBreakBeforeMultilineStrings: true +BinPackArguments: true +BinPackParameters: true +BreakBeforeBinaryOperators: None +BreakBeforeBraces: Attach +BreakBeforeTernaryOperators: true +ColumnLimit: 100 +IndentCaseLabels: true +IndentWidth: 8 +IndentWrappedFunctionNames: true +KeepEmptyLinesAtTheStartOfBlocks: false +Language: Cpp +MaxEmptyLinesToKeep: 1 +PointerAlignment: Right +SortIncludes: true +SpaceAfterCStyleCast: false +SpaceBeforeAssignmentOperators: true +SpaceBeforeParens: ControlStatements +SpaceInEmptyParentheses: false +SpacesInCStyleCastParentheses: false +SpacesInSquareBrackets: false +TabWidth: 8 +UseTab: ForIndentation '),('irssi','1.0.5','60c31219a278330498e695e4d7fca05ea69962e4','Jari Matilainen','Allow selection of what kind of activity targets to ignore  Initialize tagtarget on declaration  move code around for better flow, extra checks for uninitialized values  remove unnecessary item->type checks  don\'t strdup sign  add braces around if statements, use strcmp0 with single characters and remove g_str_has_prefix  refactoring  changed g_ascii_strcasecmp to g_strcmp0  Add networktag/ shorthand  fixed memory leaks  changed from #@= to ::channels, ::queries and ::dccqueries  check for empty string and continue; if found  fixed bug with empty string check  Clean up code','fe-common-core.c','389','62','31','14','MODIFY','@@ -461,26 +461,43 @@ void fe_common_core_finish_init(void)    gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)  { +	int channel_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"CHANNEL\"); +	int query_type = module_get_uniq_id_str(\"WINDOW ITEM TYPE\", \"QUERY\"); +	char **tmp; +  	g_return_val_if_fail(array != NULL, FALSE); +	g_return_val_if_fail(dest != NULL, FALSE); +	g_return_val_if_fail(dest->window != NULL, FALSE); +	g_return_val_if_fail(dest->target != NULL, FALSE);   -	if (strarray_find(array, \"*\") != -1) -		return TRUE; +	WI_ITEM_REC *item = window_item_find_window(dest->window, dest->server, dest->target); +	if (item == NULL) { +		return FALSE; +	}   -	if (strarray_find(array, dest->target) != -1) -		return TRUE; +	int server_tag_len = dest->server_tag ? strlen(dest->server_tag) : 0; +	for (tmp = array; *tmp != NULL; tmp++) { +		char *str = *tmp; +		if (*str == \'\\0\') { +			continue; +		}   -	if (dest->server_tag != NULL) { -		char *tagtarget = g_strdup_printf(\"%s/%s\", dest->server_tag, \"*\"); -		int ret = strarray_find(array, tagtarget); -		g_free(tagtarget); -		if (ret != -1) -			return TRUE; +		if (server_tag_len && !g_ascii_strncasecmp(str, dest->server_tag, server_tag_len) && str[server_tag_len] == \'/\') { +			str += server_tag_len + 1; +		}   -		tagtarget = g_strdup_printf(\"%s/%s\", dest->server_tag, dest->target); -		ret = strarray_find(array, tagtarget); -		g_free(tagtarget); -		if (ret != -1) +		if (!g_strcmp0(str, \"\") || !g_strcmp0(str, \"::all\")) {  			return TRUE; +		} else if (!g_ascii_strcasecmp(str, dest->target)) { +			return TRUE; +		} else if (item->type == query_type && +			!g_strcmp0(str, (dest->target[0] == \'=\') ? \"::dccqueries\" : \"::queries\")) { +			return TRUE; +		} else if (item->type == channel_type && +			!g_strcmp0(str, \"::channels\")) { +			return TRUE; +		}  	} +  	return FALSE;  } '),('irssi','1.0.5','f9d69597ef1e204640d5ce104061717aca0d213a','Joseph Bisch','Remove unnecessary malloc cast in fe-fuzz  We compile this as C code, so the cast is unnecessary.','event-get-params.c','61','11','1','1','MODIFY','@@ -52,7 +52,7 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		return 0;  	}  	uint8_t count = *data; -	char *copy = (char *)malloc(sizeof(char)*(size-1+1)); +	char *copy = malloc(sizeof(char)*(size-1+1));  	memcpy(copy, data+1, size-1);  	copy[size-1] = \'\\0\';   '),('irssi','1.0.5','f4b89044f075038d29089435f7620a068507d80e','Joseph Bisch','Fix malloc parameter in fe-fuzz  It is fairly safe to assume that sizeof(char) will always be 1 anyway and replace the size calculation with a comment explaining the calculation.','event-get-params.c','61','11','2','1','MODIFY','@@ -52,7 +52,8 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		return 0;  	}  	uint8_t count = *data; -	char *copy = malloc(sizeof(char)*(size-1+1)); +	/* malloc(size) instead of size+1, because we already used one byte of data */ +	char *copy = malloc(size);  	memcpy(copy, data+1, size-1);  	copy[size-1] = \'\\0\';   '),('irssi','1.0.5','532527ffa6a5eaccdbf607a2dc3d0e6ef884fce9','Joseph Bisch','Use gchar and g_strndup in fe-fuzz','event-get-params.c','59','11','2','4','MODIFY','@@ -53,9 +53,7 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  	}  	uint8_t count = *data;  	/* malloc(size) instead of size+1, because we already used one byte of data */ -	char *copy = malloc(size); -	memcpy(copy, data+1, size-1); -	copy[size-1] = \'\\0\'; +	gchar *copy = g_strndup((const gchar *)data+1, size-1);    	char *output0;  	char *output1; @@ -82,6 +80,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);  	}  	g_free(params); -	free(copy); +	g_free(copy);  	return 0;  } '),('irssi','1.0.5','66b2c9bc91a3b6e34ba59491c95747db75d21c6b','LemonBoy','Keep a copy of the strings coming from the config  The \"HILIGHT_REC\" structure used to keep a pointer to the \"servertag\" string, owned by the \"CONFIG_NODE\", causing a double-free.','hilight-text.c','543','156','5','2','MODIFY','@@ -106,6 +106,7 @@ static void hilight_destroy(HILIGHT_REC *rec)  	if (rec->channels != NULL) g_strfreev(rec->channels);  	g_free_not_null(rec->color);  	g_free_not_null(rec->act_color); +	g_free_not_null(rec->servertag);  	g_free(rec->text);  	g_free(rec);  } @@ -424,7 +425,7 @@ static void read_hilight_config(void)  	CONFIG_NODE *node;  	HILIGHT_REC *rec;  	GSList *tmp; -	char *text, *color; +	char *text, *color, *servertag;    	hilights_destroy_all();   @@ -467,7 +468,9 @@ static void read_hilight_config(void)  		rec->nickmask = config_node_get_bool(node, \"mask\", FALSE);  		rec->fullword = config_node_get_bool(node, \"fullword\", FALSE);  		rec->regexp = config_node_get_bool(node, \"regexp\", FALSE); -		rec->servertag = config_node_get_str(node, \"servertag\", NULL); +		servertag = config_node_get_str(node, \"servertag\", NULL); +		rec->servertag = servertag == NULL || *servertag == \'\\0\' ? NULL : +			g_strdup(servertag);  		hilight_init_rec(rec);    		node = iconfig_node_section(node, \"channels\", -1); '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','settings.c','693','161','3','3','MODIFY','@@ -39,7 +39,7 @@ static GString *last_errors;  static GSList *last_invalid_modules;  static int fe_initialized;  static int config_changed; /* FIXME: remove after .98 (unless needed again) */ -static int user_settings_changed; +static unsigned int user_settings_changed;    static GHashTable *settings;  static int timeout_tag; @@ -467,7 +467,7 @@ SETTINGS_REC *settings_get_record(const char *key)    static void sig_init_userinfo_changed(gpointer changedp)  { -	user_settings_changed = GPOINTER_TO_INT(changedp); +	user_settings_changed |= GPOINTER_TO_UINT(changedp);  }    static void sig_init_finished(void) @@ -486,7 +486,7 @@ static void sig_init_finished(void)  		signal_emit(\"setup changed\", 0);  	}   -	signal_emit(\"settings userinfo changed\", 1, GINT_TO_POINTER(user_settings_changed)); +	signal_emit(\"settings userinfo changed\", 1, GUINT_TO_POINTER(user_settings_changed));  }    static void settings_clean_invalid_module(const char *module) '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','settings.h','73','0','7','0','MODIFY','@@ -30,6 +30,13 @@ typedef struct {  	char **choices;  } SETTINGS_REC;   +enum { +	USER_SETTINGS_REAL_NAME = 0x1, +	USER_SETTINGS_USER_NAME = 0x2, +	USER_SETTINGS_NICK	= 0x4, +	USER_SETTINGS_HOSTNAME	= 0x8, +}; +  /* macros for handling the default Irssi configuration */  #define iconfig_get_str(a, b, c) config_get_str(mainconfig, a, b, c)  #define iconfig_get_int(a, b, c) config_get_int(mainconfig, a, b, c) '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','irssi.c','224','30','7','8','MODIFY','@@ -81,7 +81,7 @@ static GMainLoop *main_loop;  int quitting;    static int display_firsttimer = FALSE; -static int user_settings_changed = 0; +static unsigned int user_settings_changed = 0;      static void sig_exit(void) @@ -91,7 +91,7 @@ static void sig_exit(void)    static void sig_settings_userinfo_changed(gpointer changedp)  { -	user_settings_changed = GPOINTER_TO_INT(changedp); +	user_settings_changed = GPOINTER_TO_UINT(changedp);  }    /* redraw irssi\'s screen.. */ @@ -199,13 +199,13 @@ static void textui_finish_init(void)  	/* see irc-servers-setup.c:init_userinfo */  	if (user_settings_changed)  		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_WELCOME_INIT_SETTINGS); -	if (user_settings_changed & (1<<0)) +	if (user_settings_changed & USER_SETTINGS_REAL_NAME)  		fe_settings_set_print(\"real_name\"); -	if (user_settings_changed & (1<<1)) +	if (user_settings_changed & USER_SETTINGS_USER_NAME)  		fe_settings_set_print(\"user_name\"); -	if (user_settings_changed & (1<<2)) +	if (user_settings_changed & USER_SETTINGS_NICK)  		fe_settings_set_print(\"nick\"); -	if (user_settings_changed & (1<<3)) +	if (user_settings_changed & USER_SETTINGS_HOSTNAME)  		fe_settings_set_print(\"hostname\");  }   @@ -222,7 +222,7 @@ static void textui_deinit(void)          fe_perl_deinit();  #endif   -        dirty_check(); /* one last time to print any quit messages */ +	dirty_check(); /* one last time to print any quit messages */  	signal_remove(\"settings userinfo changed\", (SIGNAL_FUNC) sig_settings_userinfo_changed);  	signal_remove(\"gui exit\", (SIGNAL_FUNC) sig_exit);   @@ -250,7 +250,6 @@ static void textui_deinit(void)  	core_deinit();  }   -  static void check_files(void)  {  	struct stat statbuf; '),('irssi','1.0.5','02c677f467b398f8b91b1e90544502ff98a6e0da','ailin-nemui','use enum','irc-servers-setup.c','157','52','6','6','MODIFY','@@ -116,7 +116,7 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,    static void init_userinfo(void)  { -	int changed; +	unsigned int changed;  	const char *set, *nick, *user_name, *str;    	changed = 0; @@ -126,7 +126,7 @@ static void init_userinfo(void)  		str = g_getenv(\"IRCNAME\");  		settings_set_str(\"real_name\",  				 str != NULL ? str : g_get_real_name()); -		changed |= 1<<0; +		changed |= USER_SETTINGS_REAL_NAME;  	}    	/* username */ @@ -137,7 +137,7 @@ static void init_userinfo(void)  				 str != NULL ? str : g_get_user_name());    		user_name = settings_get_str(\"user_name\"); -		changed |= 1<<1; +		changed |= USER_SETTINGS_USER_NAME;  	}    	/* nick */ @@ -147,7 +147,7 @@ static void init_userinfo(void)  		settings_set_str(\"nick\", str != NULL ? str : user_name);    		nick = settings_get_str(\"nick\"); -		changed |= 1<<2; +		changed |= USER_SETTINGS_NICK;  	}    	/* host name */ @@ -156,11 +156,11 @@ static void init_userinfo(void)  		str = g_getenv(\"IRCHOST\");  		if (str != NULL) {  			settings_set_str(\"hostname\", str); -			changed |= 1<<3; +			changed |= USER_SETTINGS_HOSTNAME;  		}  	}   -	signal_emit(\"irssi init userinfo changed\", 1, GINT_TO_POINTER(changed)); +	signal_emit(\"irssi init userinfo changed\", 1, GUINT_TO_POINTER(changed));  }    static void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node) '),('irssi','1.0.5','596fa6b51ed2ab6be80041684ad805f7b22256ac','LemonBoy','Take into account Nei\'s suggestions','.clang-format','36','0','6','5','MODIFY','@@ -1,4 +1,4 @@ -# IndentPPDirectives: None +# IndentPPDirectives: AfterHash  # SpaceInParentheses: false  AlignAfterOpenBracket: Align  AlignConsecutiveAssignments: false @@ -12,22 +12,23 @@ AllowShortFunctionsOnASingleLine: Empty  AllowShortIfStatementsOnASingleLine: false  AllowShortLoopsOnASingleLine: false  AlwaysBreakAfterReturnType: None -AlwaysBreakBeforeMultilineStrings: true +AlwaysBreakBeforeMultilineStrings: false  BinPackArguments: true  BinPackParameters: true  BreakBeforeBinaryOperators: None -BreakBeforeBraces: Attach -BreakBeforeTernaryOperators: true +BreakBeforeBraces: Linux +BreakBeforeTernaryOperators: false  ColumnLimit: 100  IndentCaseLabels: true  IndentWidth: 8  IndentWrappedFunctionNames: true  KeepEmptyLinesAtTheStartOfBlocks: false  Language: Cpp +Cpp11BracedListStyle: false  MaxEmptyLinesToKeep: 1  PointerAlignment: Right  SortIncludes: true -SpaceAfterCStyleCast: false +SpaceAfterCStyleCast: true  SpaceBeforeAssignmentOperators: true  SpaceBeforeParens: ControlStatements  SpaceInEmptyParentheses: false '),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','Prevent a UAF error during the execution of some commands  Some arguments were free\'d first and then printed, leading to gibberish being output to screen or a crash.  Found by Joseph Bisch. Closes: !GL17','fe-channels.c','520','131','1','1','MODIFY','@@ -278,9 +278,9 @@ static void cmd_channel_add_modify(const char *data, gboolean add)  	rec = channel_setup_find(channel, chatnet);  	if (rec == NULL) {  		if (add == FALSE) { -			cmd_params_free(free_arg);  			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,  				TXT_CHANSETUP_NOT_FOUND, channel, chatnet); +			cmd_params_free(free_arg);  			return;  		}   '),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','Prevent a UAF error during the execution of some commands  Some arguments were free\'d first and then printed, leading to gibberish being output to screen or a crash.  Found by Joseph Bisch. Closes: !GL17','fe-server.c','382','113','1','1','MODIFY','@@ -136,9 +136,9 @@ static void cmd_server_add_modify(const char *data, gboolean add)    	if (rec == NULL) {  		if (add == FALSE) { -			cmd_params_free(free_arg);  			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,  				TXT_SETUPSERVER_NOT_FOUND, addr, port); +			cmd_params_free(free_arg);  			return;  		}   '),('irssi','1.0.5','7605f67f95b6ee1ac26dd8fb7f3121f319497943','LemonBoy','Prevent a UAF error during the execution of some commands  Some arguments were free\'d first and then printed, leading to gibberish being output to screen or a crash.  Found by Joseph Bisch. Closes: !GL17','fe-ircnet.c','191','72','1','1','MODIFY','@@ -106,9 +106,9 @@ static void cmd_network_add_modify(const char *data, gboolean add)  	rec = ircnet_find(name);  	if (rec == NULL) {  		if (add == FALSE) { -			cmd_params_free(free_arg);  			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE,  				IRCTXT_NETWORK_NOT_FOUND, name); +			cmd_params_free(free_arg);  			return;  		}   '),('irssi','1.0.5','3acc72f842a021ffcff8809c1f245ca614f68598','ailin-nemui','reset colour at comma, like mIRC  Fixes #742 and #740','formats.c','1129','356','3','6','MODIFY','@@ -1072,7 +1072,8 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  	fg = fg_ret == NULL ? -1 : *fg_ret;  	bg = bg_ret == NULL ? -1 : *bg_ret;   -	if (!i_isdigit(**str) && **str != \',\') { +	if (!i_isdigit(**str)) { +		/* turn off color */  		fg = -1;  		bg = -1;  	} else { @@ -1085,11 +1086,8 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  				(*str)++;  			}  		} -		if (**str == \',\') { +		if ((*str)[0] == \',\' && i_isdigit((*str)[1])) {  			/* background color */ -			if (!i_isdigit((*str)[1])) -				bg = -1; -			else {  				(*str)++;  				bg = **str-\'0\';  				(*str)++; @@ -1097,7 +1095,6 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  					bg = bg*10 + (**str-\'0\');  					(*str)++;  				} -			}  		}  	}   '),('irssi','1.0.5','ba3c5801a4bb175fe1e0d0fd273ae15318dd2b03','ailin-nemui','Update .clang-format  do not indent case deeper','.clang-format','36','0','1','1','MODIFY','@@ -19,7 +19,7 @@ BreakBeforeBinaryOperators: None  BreakBeforeBraces: Linux  BreakBeforeTernaryOperators: false  ColumnLimit: 100 -IndentCaseLabels: true +IndentCaseLabels: false  IndentWidth: 8  IndentWrappedFunctionNames: true  KeepEmptyLinesAtTheStartOfBlocks: false '),('irssi','1.0.5','47400d405a0680bfe4d69ce8b06ecbfd09931999','ailin-nemui','Update formats.c  remove now useless check for ,','formats.c','1127','355','11','12','MODIFY','@@ -1078,23 +1078,22 @@ static void get_mirc_color(const char **str, int *fg_ret, int *bg_ret)  		bg = -1;  	} else {  		/* foreground color */ -		if (**str != \',\') { -			fg = **str-\'0\'; +		fg = **str-\'0\'; +		(*str)++; +		if (i_isdigit(**str)) { +			fg = fg*10 + (**str-\'0\');  			(*str)++; -			if (i_isdigit(**str)) { -				fg = fg*10 + (**str-\'0\'); -				(*str)++; -			}  		} +  		if ((*str)[0] == \',\' && i_isdigit((*str)[1])) {  			/* background color */ +			(*str)++; +			bg = **str-\'0\'; +			(*str)++; +			if (i_isdigit(**str)) { +				bg = bg*10 + (**str-\'0\');  				(*str)++; -				bg = **str-\'0\'; -				(*str)++; -				if (i_isdigit(**str)) { -					bg = bg*10 + (**str-\'0\'); -					(*str)++; -				} +			}  		}  	}   '),('irssi','1.0.5','1a49787ef25103d1a393c81e35fb949322fe0523','Will Storey','Revert initializing pointers to NULL  To maintain C89 compatibility','fe-events.c','376','58','1','1','MODIFY','@@ -224,7 +224,7 @@ static void event_nick(IRC_SERVER_REC *server, const char *data,  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick, const char *addr)  { -	char *params = NULL, *channel = NULL, *mode = NULL; +	char *params, *channel, *mode;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','1a49787ef25103d1a393c81e35fb949322fe0523','Will Storey','Revert initializing pointers to NULL  To maintain C89 compatibility','modes.c','700','195','2','2','MODIFY','@@ -480,8 +480,8 @@ static void event_user_mode(IRC_SERVER_REC *server, const char *data)  static void event_mode(IRC_SERVER_REC *server, const char *data,  		       const char *nick)  { -	IRC_CHANNEL_REC *chanrec = NULL; -	char *params = NULL, *channel = NULL, *mode = NULL; +	IRC_CHANNEL_REC *chanrec; +	char *params, *channel, *mode;    	g_return_if_fail(data != NULL);   '),('irssi','1.0.5','b2ca8c04778866bd07cf1b612adf0df55f45b78e','ailin-nemui','check for declaration-after-statement on travis','.travis.yml','48','0','1','1','MODIFY','@@ -31,7 +31,7 @@ before_install:    install:      - ./configure --with-proxy --with-bot --with-perl=module --prefix=$HOME/irssi-build -    - make CFLAGS=\"-Wall -Werror\" +    - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"      - make install    before_script: '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','ignore.h','30','0','3','3','MODIFY','@@ -27,14 +27,14 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  		 const char *channel, const char *text, int level);    enum { -	IGNORE_FIND_PATTERN = 0x01, // Match the pattern -	IGNORE_FIND_NOACT   = 0x02, // Exclude the targets with NOACT level +	IGNORE_FIND_PATTERN = 0x01, /* Match the pattern */ +	IGNORE_FIND_NOACT   = 0x02, /* Exclude the targets with NOACT level */  };    IGNORE_REC *ignore_find_full (const char *servertag, const char *mask, const char *pattern,                  char **channels, const int flags);   -// Convenience wrappers around ignore_find_full, for compatibility purpose +/* Convenience wrappers around ignore_find_full, for compatibility purpose */    IGNORE_REC *ignore_find(const char *servertag, const char *mask, char **channels);  IGNORE_REC *ignore_find_noact(const char *servertag, const char *mask, char **channels, int noact); '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','network-openssl.c','679','147','10','10','MODIFY','@@ -600,7 +600,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	tls_rec_set_certificate_fingerprint(tls, cert_fingerprint_hex);  	tls_rec_set_certificate_fingerprint_algorithm(tls, \"SHA256\");   -	// Show algorithm. +	/* Show algorithm. */  	switch (EVP_PKEY_id(pubkey)) {  		case EVP_PKEY_RSA:  			tls_rec_set_public_key_algorithm(tls, \"RSA\"); @@ -624,7 +624,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	tls_rec_set_public_key_size(tls, EVP_PKEY_bits(pubkey));  	tls_rec_set_public_key_fingerprint_algorithm(tls, \"SHA256\");   -	// Read the NotBefore timestamp. +	/* Read the NotBefore timestamp. */  	bio = BIO_new(BIO_s_mem());  	ASN1_TIME_print(bio, X509_get_notBefore(cert));  	length = BIO_read(bio, buffer, sizeof(buffer)); @@ -632,7 +632,7 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	BIO_free(bio);  	tls_rec_set_not_before(tls, buffer);   -	// Read the NotAfter timestamp. +	/* Read the NotAfter timestamp. */  	bio = BIO_new(BIO_s_mem());  	ASN1_TIME_print(bio, X509_get_notAfter(cert));  	length = BIO_read(bio, buffer, sizeof(buffer)); @@ -670,7 +670,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  	for (i = 0; i < sk_X509_num(chain); i++) {  		cert_rec = tls_cert_create_rec();   -		// Subject. +		/* Subject. */  		name = X509_get_subject_name(sk_X509_value(chain, i));    		for (j = 0; j < X509_NAME_entry_count(name); j++) { @@ -689,7 +689,7 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  			tls_cert_rec_append_subject_entry(cert_rec, tls_cert_entry_rec);  		}   -		// Issuer. +		/* Issuer. */  		name = X509_get_issuer_name(sk_X509_value(chain, i));    		for (j = 0; j < X509_NAME_entry_count(name); j++) { @@ -718,10 +718,10 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  	g_return_if_fail(ssl != NULL);    #ifdef SSL_get_server_tmp_key -	// Show ephemeral key information. +	/* Show ephemeral key information. */  	EVP_PKEY *ephemeral_key = NULL;   -	// OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 +	/* OPENSSL_NO_EC is for solaris 11.3 (2016), github ticket #598 */  #ifndef OPENSSL_NO_EC  	EC_KEY *ec_key = NULL;  #endif @@ -759,7 +759,7 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)    		EVP_PKEY_free(ephemeral_key);  	} -#endif // SSL_get_server_tmp_key. +#endif /* SSL_get_server_tmp_key. */  }    GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, SERVER_REC *server) @@ -866,7 +866,7 @@ int irssi_ssl_handshake(GIOChannel *handle)  	set_peer_cert_chain_info(tls, chan->ssl);  	set_server_temporary_key_info(tls, chan->ssl);   -	// Emit the TLS rec. +	/* Emit the TLS rec. */  	signal_emit(\"tls handshake finished\", 2, chan->server, tls);    	ret = 1; @@ -893,7 +893,7 @@ int irssi_ssl_handshake(GIOChannel *handle)  		ret = irssi_ssl_verify(chan->ssl, chan->ctx, chan->server->connrec->address, chan->port, cert, chan->server, tls);    		if (! ret) { -			// irssi_ssl_verify emits a warning itself. +			/* irssi_ssl_verify emits a warning itself. */  			goto done;  		}  	} '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','irssi.c','33','2','1','1','MODIFY','@@ -21,7 +21,7 @@  #include \"module.h\"  #include \"modules-load.h\"  #include \"levels.h\" -#include \"../fe-text/module-formats.h\" // need to explicitly grab from fe-text +#include \"../fe-text/module-formats.h\" /* need to explicitly grab from fe-text */  #include \"themes.h\"  #include \"core.h\"  #include \"fe-common-core.h\" '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','statusbar-items.c','391','99','2','2','MODIFY','@@ -369,8 +369,8 @@ static void item_lag(SBAR_ITEM_REC *item, int get_size_only)  	last_lag_unknown = lag_unknown;    	if (lag_unknown) { -		// \"??)\" in C becomes \']\' -		// See: https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C +		/* \"??)\" in C becomes \']\' +		   See: https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C */  		g_snprintf(str, sizeof(str), \"%d (?\"\"?)\", lag / 100);  	} else {  		if (lag % 100 == 0) '),('irssi','1.0.5','b332d448f7e3c7e4b40ea4a08932d0bd46007bbf','ailin-nemui','fix comments','sasl.c','199','35','3','3','MODIFY','@@ -30,16 +30,16 @@   * Based on IRCv3 SASL Extension Specification:   * http://ircv3.net/specs/extensions/sasl-3.1.html   */ -#define AUTHENTICATE_CHUNK_SIZE 400 // bytes +#define AUTHENTICATE_CHUNK_SIZE 400 /* bytes */    /*   * Maximum size to allow the buffer to grow to before the next fragment comes in. Note that   * due to the way fragmentation works, the maximum message size will actually be:   * floor(AUTHENTICATE_MAX_SIZE / AUTHENTICATE_CHUNK_SIZE) + AUTHENTICATE_CHUNK_SIZE - 1   */ -#define AUTHENTICATE_MAX_SIZE 8192 // bytes +#define AUTHENTICATE_MAX_SIZE 8192 /* bytes */   -#define SASL_TIMEOUT (20 * 1000) // ms +#define SASL_TIMEOUT (20 * 1000) /* ms */    static gboolean sasl_timeout(IRC_SERVER_REC *server)  { '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','network-openssl.c','679','147','9','9','MODIFY','@@ -583,9 +583,6 @@ static void set_cipher_info(TLS_REC *tls, SSL *ssl)    static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_fingerprint, size_t cert_fingerprint_size, unsigned char *public_key_fingerprint, size_t public_key_fingerprint_size)  { -	g_return_if_fail(tls != NULL); -	g_return_if_fail(cert != NULL); -  	EVP_PKEY *pubkey = NULL;  	char *cert_fingerprint_hex = NULL;  	char *public_key_fingerprint_hex = NULL; @@ -594,6 +591,9 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger  	char buffer[128];  	size_t length;   +	g_return_if_fail(tls != NULL); +	g_return_if_fail(cert != NULL); +  	pubkey = X509_get_pubkey(cert);    	cert_fingerprint_hex = binary_to_hex(cert_fingerprint, cert_fingerprint_size); @@ -647,9 +647,6 @@ static void set_pubkey_info(TLS_REC *tls, X509 *cert, unsigned char *cert_finger    static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  { -	g_return_if_fail(tls != NULL); -	g_return_if_fail(ssl != NULL); -  	int nid;  	char *key = NULL;  	char *value = NULL; @@ -662,6 +659,9 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)  	TLS_CERT_ENTRY_REC *tls_cert_entry_rec = NULL;  	ASN1_STRING *data = NULL;   +	g_return_if_fail(tls != NULL); +	g_return_if_fail(ssl != NULL); +  	chain = SSL_get_peer_cert_chain(ssl);    	if (chain == NULL) @@ -714,9 +714,6 @@ static void set_peer_cert_chain_info(TLS_REC *tls, SSL *ssl)    static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  { -	g_return_if_fail(tls != NULL); -	g_return_if_fail(ssl != NULL); -  #ifdef SSL_get_server_tmp_key  	/* Show ephemeral key information. */  	EVP_PKEY *ephemeral_key = NULL; @@ -729,6 +726,9 @@ static void set_server_temporary_key_info(TLS_REC *tls, SSL *ssl)  	char *cname = NULL;  	int nid;   +	g_return_if_fail(tls != NULL); +	g_return_if_fail(ssl != NULL); +  	if (SSL_get_server_tmp_key(ssl, &ephemeral_key)) {  		switch (EVP_PKEY_id(ephemeral_key)) {  			case EVP_PKEY_DH: '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','fe-windows.c','623','184','3','1','MODIFY','@@ -563,8 +563,10 @@ GSList *windows_get_sorted(void)  	begin = windows_seq_begin();    	while (iter != begin) { +		WINDOW_REC *rec; +  		iter = g_sequence_iter_prev(iter); -		WINDOW_REC *rec = g_sequence_get(iter); +		rec = g_sequence_get(iter);    		sorted = g_slist_prepend(sorted, rec);  	} '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','Expando.xs','147','21','2','1','MODIFY','@@ -74,6 +74,7 @@ static char *perl_expando_event(PerlExpando *rec, SERVER_REC *server,    	ret = NULL;  	if (SvTRUE(ERRSV)) { +		char *error;  		PERL_SCRIPT_REC *script = rec->script;    		(void) POPs; @@ -85,7 +86,7 @@ static char *perl_expando_event(PerlExpando *rec, SERVER_REC *server,  			script_unregister_expandos(script);  		/* rec has been freed now */   -		char *error = g_strdup(SvPV_nolen(ERRSV)); +		error = g_strdup(SvPV_nolen(ERRSV));  		signal_emit(\"script error\", 2, script, error);  		g_free(error);  	} else if (retcount > 0) { '),('irssi','1.0.5','2b918fd9b8438eeef8f33556723140263e36f731','ailin-nemui','move decls before code','Statusbar.xs','136','17','2','2','MODIFY','@@ -67,7 +67,7 @@ static void perl_statusbar_event(char *function, SBAR_ITEM_REC *item,    	if (SvTRUE(ERRSV)) {                  PERL_SCRIPT_REC *script; -                char *package; +                char *package, *error;                    package = perl_function_get_package(function);                  script = perl_script_find_package(package); @@ -78,7 +78,7 @@ static void perl_statusbar_event(char *function, SBAR_ITEM_REC *item,  			script_unregister_statusbars(script);  		}   -		char *error = g_strdup(SvPV_nolen(ERRSV)); +		error = g_strdup(SvPV_nolen(ERRSV));  		signal_emit(\"script error\", 2, script, error);  		g_free(error);  	} else { '),('irssi','1.0.5','b0637ad6ea8784d3b2be829ca40f9dddf0c049fc','Will Storey','Update NULL comparison style and be C89 compatible','irc.c','317','74','5','3','MODIFY','@@ -287,11 +287,13 @@ char *event_get_params(const char *data, int count, ...)  /* Given a string containing <params>, strip any colon prefixing <trailing>. */  static void strip_params_colon(char *const params)  { -	if (!params) { +	char *s; + +	if (params == NULL) {  		return;  	}   -	char *s = params; +	s = params;  	while (*s != \'\\0\') {  		if (*s == \':\') {  			memmove(s, s+1, strlen(s+1)+1); @@ -299,7 +301,7 @@ static void strip_params_colon(char *const params)  		}    		s = strchr(s, \' \'); -		if (!s) { +		if (s == NULL) {  			return;  		}   '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','.gitignore','54','0','3','0','MODIFY','@@ -49,6 +49,9 @@ src/perl/*/Makefile.old  src/fe-fuzz/crash-*  src/fe-fuzz/oom-*   +tests/irc/core/test-irc +tests/irc/core/test-irc.trs +  *.a  *.bs  *.la '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','.travis.yml','50','0','3','1','MODIFY','@@ -49,5 +49,7 @@ before_script:      - echo ^quit >> irssi-test/startup      - irssi-build/bin/irssi --home irssi-test      - cat irc.log.* +    - cd $TRAVIS_BUILD_DIR   -script: true +script: +    - make check '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','22','0','1','1','MODIFY','@@ -16,7 +16,7 @@ irssi-version.h:  	VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) | \\  		cmp -s - $@ || VERSION=\"$(VERSION)\" $(srcdir)/utils/irssi-version.sh $(srcdir) >$@   -SUBDIRS = src docs scripts themes utils +SUBDIRS = src tests docs scripts themes utils    confdir = $(sysconfdir)  conf_DATA = irssi.conf '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','configure.ac','703','4','3','0','MODIFY','@@ -658,6 +658,9 @@ src/perl/ui/Makefile.PL  src/perl/textui/Makefile.PL  scripts/Makefile  scripts/examples/Makefile +tests/Makefile +tests/irc/Makefile +tests/irc/core/Makefile  docs/Makefile  docs/help/Makefile  docs/help/in/Makefile '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = irc '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = core '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','Makefile.am','31','0','36','0','ADD','@@ -0,0 +1,36 @@ +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core \\ +	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\ +	$(GLIB_CFLAGS) + +TESTS = test-irc +check_PROGRAMS = test-irc + +test_irc_CPPFLAGS = \\ +	-I$(top_srcdir)/src/irc/core \\ +	$(AM_CPPFLAGS) + +test_irc_DEPENDENCIES = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a + +test_irc_LDADD = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a \\ +	@GLIB_LIBS@ \\ +	@OPENSSL_LIBS@ + +test_irc_SOURCES = \\ +	test-irc.c \\ +	../../../src/irc/core/irc-cap.c \\ +	../../../src/irc/core/irc-nicklist.c \\ +	../../../src/irc/core/irc-queries.c \\ +	../../../src/irc/core/irc-servers-reconnect.c \\ +	../../../src/irc/core/irc-servers-setup.c \\ +	../../../src/irc/core/irc-servers.c \\ +	../../../src/irc/core/irc.c \\ +	../../../src/irc/core/mode-lists.c \\ +	../../../src/irc/core/modes.c \\ +	../../../src/irc/core/servers-idle.c \\ +	../../../src/irc/core/servers-redirect.c '),('irssi','1.0.5','1328e1ba08430b0eaa589919272d732bb84a6921','Will Storey','Add a test program to test mode parsing  This uses GLib\'s testing framework. It is to test the changes to the mode parsing for #603.','test-irc.c','189','5','230','0','ADD','@@ -0,0 +1,230 @@ +/* + test-irc.c : irssi + +    Copyright (C) 2017 Will Storey + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include <glib.h> +#include <irc.h> +#include <string.h> + +static void test_event_get_param(void); +static void test_event_get_params(void); + +int main(int argc, char **argv) +{ +	g_test_init(&argc, &argv, NULL); + +	g_test_add_func(\"/test/event_get_param\", test_event_get_param); +	g_test_add_func(\"/test/event_get_params\", test_event_get_params); + +	return g_test_run(); +} + +static void test_event_get_param(void) +{ +	struct test_case { +		char const *const description; +		char const *const input; +		char const *const input_after; +		char const *const output; +	}; + +	struct test_case const tests[] = { +		{ +			.description = \"Zero parameters\", +			.input       = \"\", +			.input_after = \"\", +			.output      = \"\", +		}, +		{ +			.description = \"One parameter\", +			.input       = \"#test\", +			.input_after = \"\", +			.output      = \"#test\", +		}, +		{ +			.description = \"One parameter, trailing space\", +			.input       = \"#test \", +			.input_after = \"\", +			.output      = \"#test\", +		}, +		{ +			.description = \"One parameter, more trailing space\", +			.input       = \"#test  \", +			.input_after = \" \", +			.output      = \"#test\", +		}, +		{ +			.description = \"Two parameters\", +			.input       = \"#test +o\", +			.input_after = \"+o\", +			.output      = \"#test\", +		}, +		{ +			.description = \"Two parameters continued\", +			.input       = \"+o\", +			.input_after = \"\", +			.output      = \"+o\", +		}, +		{ +			.description = \"Two parameters with trailing space\", +			.input       = \"#test +o \", +			.input_after = \"+o \", +			.output      = \"#test\", +		}, +		{ +			.description = \"Two parameters with trailing space continued\", +			.input       = \"+o \", +			.input_after = \"\", +			.output      = \"+o\", +		}, +		{ +			.description = \"Two parameters with inline and trailing space\", +			.input       = \"#test  +o \", +			.input_after = \" +o \", +			.output      = \"#test\", +		}, +		/* TODO: It seems not ideal that the caller has to deal with inline space. +		 */ +		{ +			.description = \"Two parameters with inline and trailing space continued\", +			.input       = \" +o \", +			.input_after = \"+o \", +			.output      = \"\", +		}, +	}; + +	char *buf = g_malloc0(1024); + +	int i = 0; +	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { +		struct test_case const test = tests[i]; + +		memcpy(buf, test.input, strlen(test.input)+1); +		char *input = buf; + +		char *const output = event_get_param(&input); + +		g_assert_cmpstr(input, ==, test.input_after); +		g_assert_cmpstr(output, ==, test.output); +	} + +	g_free(buf); +} + +static void test_event_get_params(void) +{ +	struct test_case { +		char const *const description; +		char const *const input; +		char const *const output0; +		char const *const output1; +	}; + +	struct test_case const tests[] = { +		{ +			.description = \"Only a channel\", +			.input       = \"#test\", +			.output0     = \"#test\", +			.output1     = \"\", +		}, +		{ +			.description = \"Only a channel with trailing space\", +			.input       = \"#test \", +			.output0     = \"#test\", +			.output1     = \"\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with one parameter after channel name\", +			.input       = \"#test +i\", +			.output0     = \"#test\", +			.output1     = \"+i\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with two parameters after channel name\", +			.input       = \"#test +o tester\", +			.output0     = \"#test\", +			.output1     = \"+o tester\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with three parameters afer channel name\", +			.input       = \"#test +ov tester tester2\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2\", +		}, +		{ +			.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\", +			.input       = \"#test  +ov  tester  tester2 \", +			.output0     = \"#test\", +			.output1     = \" +ov  tester  tester2 \", +		}, +		{ +			.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\", +			.input       = \"#test :+i\", +			.output0     = \"#test\", +			.output1     = \"+i\", +		}, +		{ +			.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\", +			.input       = \"#test :+o tester\", +			.output0     = \"#test\", +			.output1     = \"+o tester\", +		}, +		{ +			.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\", +			.input       = \"#test :+ov tester tester2\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2\", +		}, +		{ +			.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\", +			.input       = \"#test +o :tester\", +			.output0     = \"#test\", +			.output1     = \"+o tester\", +		}, +		{ +			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\", +			.input       = \"#test +ov tester :tester2\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2\", +		}, +		{ +			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\", +			.input       = \"#test +ov tester :tester2 hi:there\", +			.output0     = \"#test\", +			.output1     = \"+ov tester tester2 hi:there\", +		}, +	}; + +	int i = 0; +	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { +		struct test_case const test = tests[i]; + +		char *output0 = NULL; +		char *output1 = NULL; +		char *const params = event_get_params(test.input, 2 | PARAM_FLAG_GETREST, +				&output0, &output1); + +		/* params happens to always point at the first output */ +		g_assert_cmpstr(params, ==, test.output0); +		g_assert_cmpstr(output0, ==, test.output0); +		g_assert_cmpstr(output1, ==, test.output1); + +		g_free(params); +	} +} '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','configure.ac','704','4','2','0','MODIFY','@@ -295,6 +295,8 @@ fi    LIBS=\"$LIBS $GLIB_LIBS\"   +GLIB_TESTS +  dnl **  dnl ** OpenSSL checks  dnl ** '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','glibtests.m4','27','0','28','0','ADD','@@ -0,0 +1,28 @@ +dnl GLIB_TESTS +dnl + +AC_DEFUN([GLIB_TESTS], +[ +  AC_ARG_ENABLE(installed-tests, +                AS_HELP_STRING([--enable-installed-tests], +                               [Enable installation of some test cases]), +                [case ${enableval} in +                  yes) ENABLE_INSTALLED_TESTS=\"1\"  ;; +                  no)  ENABLE_INSTALLED_TESTS=\"\" ;; +                  *) AC_MSG_ERROR([bad value ${enableval} for --enable-installed-tests]) ;; +                 esac]) +  AM_CONDITIONAL([ENABLE_INSTALLED_TESTS], test \"$ENABLE_INSTALLED_TESTS\" = \"1\") +  AC_ARG_ENABLE(always-build-tests, +                AS_HELP_STRING([--enable-always-build-tests], +                               [Enable always building tests during \'make all\']), +                [case ${enableval} in +                  yes) ENABLE_ALWAYS_BUILD_TESTS=\"1\"  ;; +                  no)  ENABLE_ALWAYS_BUILD_TESTS=\"\" ;; +                  *) AC_MSG_ERROR([bad value ${enableval} for --enable-always-build-tests]) ;; +                 esac]) +  AM_CONDITIONAL([ENABLE_ALWAYS_BUILD_TESTS], test \"$ENABLE_ALWAYS_BUILD_TESTS\" = \"1\") +  if test \"$ENABLE_INSTALLED_TESTS\" = \"1\"; then +    AC_SUBST(installed_test_metadir, [${datadir}/installed-tests/]AC_PACKAGE_NAME) +    AC_SUBST(installed_testdir, [${libexecdir}/installed-tests/]AC_PACKAGE_NAME) +  fi +]) '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','Makefile.am','31','0','3','2','MODIFY','@@ -1,11 +1,12 @@ +include $(top_srcdir)/utils/glib-tap.mk +  AM_CPPFLAGS = \\  	-I$(top_srcdir)/src \\  	-I$(top_srcdir)/src/core \\  	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\  	$(GLIB_CFLAGS)   -TESTS = test-irc -check_PROGRAMS = test-irc +test_programs = test-irc    test_irc_CPPFLAGS = \\  	-I$(top_srcdir)/src/irc/core \\ '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','test-irc.c','190','5','1','0','MODIFY','@@ -32,6 +32,7 @@ int main(int argc, char **argv)  	g_test_add_func(\"/test/event_get_param\", test_event_get_param);  	g_test_add_func(\"/test/event_get_params\", test_event_get_params);   +	g_test_set_nonfatal_assertions();  	return g_test_run();  }   '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','Makefile.am','6','0','3','1','MODIFY','@@ -1,4 +1,6 @@  EXTRA_DIST = \\  	file2header.sh \\  	irssi-version.sh \\ -	syntax.pl +	syntax.pl \\ +	tap-driver.sh \\ +	tap-test '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','glib-tap.mk','86','0','134','0','ADD','@@ -0,0 +1,134 @@ +# GLIB - Library of useful C routines + +TESTS_ENVIRONMENT= \\ +	G_TEST_SRCDIR=\"$(abs_srcdir)\" 		\\ +	G_TEST_BUILDDIR=\"$(abs_builddir)\" 	\\ +	G_DEBUG=gc-friendly 			\\ +	MALLOC_CHECK_=2 			\\ +	MALLOC_PERTURB_=$$(($${RANDOM:-256} % 256)) +LOG_DRIVER = env AM_TAP_AWK=\'$(AWK)\' $(SHELL) $(top_srcdir)/utils/tap-driver.sh +LOG_COMPILER = $(top_srcdir)/utils/tap-test + +NULL = + +# initialize variables for unconditional += appending +BUILT_SOURCES = +BUILT_EXTRA_DIST = +CLEANFILES = *.log *.trs +DISTCLEANFILES = +MAINTAINERCLEANFILES = +EXTRA_DIST = +TESTS = + +installed_test_LTLIBRARIES = +installed_test_PROGRAMS = +installed_test_SCRIPTS = +nobase_installed_test_DATA = + +noinst_LTLIBRARIES = +noinst_PROGRAMS = +noinst_SCRIPTS = +noinst_DATA = + +check_LTLIBRARIES = +check_PROGRAMS = +check_SCRIPTS = +check_DATA = + +# We support a fairly large range of possible variables.  It is expected that all types of files in a test suite +# will belong in exactly one of the following variables. +# +# First, we support the usual automake suffixes, but in lowercase, with the customary meaning: +# +#   test_programs, test_scripts, test_data, test_ltlibraries +# +# The above are used to list files that are involved in both uninstalled and installed testing.  The +# test_programs and test_scripts are taken to be actual testcases and will be run as part of the test suite. +# Note that _data is always used with the nobase_ automake variable name to ensure that installed test data is +# installed in the same way as it appears in the package layout. +# +# In order to mark a particular file as being only for one type of testing, use \'installed\' or \'uninstalled\', +# like so: +# +#   installed_test_programs, uninstalled_test_programs +#   installed_test_scripts, uninstalled_test_scripts +#   installed_test_data, uninstalled_test_data +#   installed_test_ltlibraries, uninstalled_test_ltlibraries +# +# Additionally, we support \'extra\' infixes for programs and scripts.  This is used for support programs/scripts +# that should not themselves be run as testcases (but exist to be used from other testcases): +# +#   test_extra_programs, installed_test_extra_programs, uninstalled_test_extra_programs +#   test_extra_scripts, installed_test_extra_scripts, uninstalled_test_extra_scripts +# +# Additionally, for _scripts and _data, we support the customary dist_ prefix so that the named script or data +# file automatically end up in the tarball. +# +#   dist_test_scripts, dist_test_data, dist_test_extra_scripts +#   dist_installed_test_scripts, dist_installed_test_data, dist_installed_test_extra_scripts +#   dist_uninstalled_test_scripts, dist_uninstalled_test_data, dist_uninstalled_test_extra_scripts +# +# Note that no file is automatically disted unless it appears in one of the dist_ variables.  This follows the +# standard automake convention of not disting programs scripts or data by default. +# +# test_programs, test_scripts, uninstalled_test_programs and uninstalled_test_scripts (as well as their disted +# variants) will be run as part of the in-tree \'make check\'.  These are all assumed to be runnable under +# gtester.  That\'s a bit strange for scripts, but it\'s possible. + +TESTS += $(test_programs) $(test_scripts) $(uninstalled_test_programs) $(uninstalled_test_scripts) \\ +         $(dist_test_scripts) $(dist_uninstalled_test_scripts) + +# Note: build even the installed-only targets during \'make check\' to ensure that they still work. +# We need to do a bit of trickery here and manage disting via EXTRA_DIST instead of using dist_ prefixes to +# prevent automake from mistreating gmake functions like $(wildcard ...) and $(addprefix ...) as if they were +# filenames, including removing duplicate instances of the opening part before the space, eg. \'$(addprefix\'. +all_test_programs     = $(test_programs) $(uninstalled_test_programs) $(installed_test_programs) \\ +                        $(test_extra_programs) $(uninstalled_test_extra_programs) $(installed_test_extra_programs) +all_test_scripts      = $(test_scripts) $(uninstalled_test_scripts) $(installed_test_scripts) \\ +                        $(test_extra_scripts) $(uninstalled_test_extra_scripts) $(installed_test_extra_scripts) +all_dist_test_scripts = $(dist_test_scripts) $(dist_uninstalled_test_scripts) $(dist_installed_test_scripts) \\ +                        $(dist_test_extra_scripts) $(dist_uninstalled_test_extra_scripts) $(dist_installed_test_extra_scripts) +all_test_scripts     += $(all_dist_test_scripts) +EXTRA_DIST           += $(all_dist_test_scripts) +all_test_data         = $(test_data) $(uninstalled_test_data) $(installed_test_data) +all_dist_test_data    = $(dist_test_data) $(dist_uninstalled_test_data) $(dist_installed_test_data) +all_test_data        += $(all_dist_test_data) +EXTRA_DIST           += $(all_dist_test_data) +all_test_ltlibs       = $(test_ltlibraries) $(uninstalled_test_ltlibraries) $(installed_test_ltlibraries) + +if ENABLE_ALWAYS_BUILD_TESTS +noinst_LTLIBRARIES += $(all_test_ltlibs) +noinst_PROGRAMS += $(all_test_programs) +noinst_SCRIPTS += $(all_test_scripts) +noinst_DATA += $(all_test_data) +else +check_LTLIBRARIES += $(all_test_ltlibs) +check_PROGRAMS += $(all_test_programs) +check_SCRIPTS += $(all_test_scripts) +check_DATA += $(all_test_data) +endif + +if ENABLE_INSTALLED_TESTS +installed_test_PROGRAMS += $(test_programs) $(installed_test_programs) \\ +                          $(test_extra_programs) $(installed_test_extra_programs) +installed_test_SCRIPTS += $(test_scripts) $(installed_test_scripts) \\ +                          $(test_extra_scripts) $(test_installed_extra_scripts) +installed_test_SCRIPTS += $(dist_test_scripts) $(dist_test_extra_scripts) \\ +                          $(dist_installed_test_scripts) $(dist_installed_test_extra_scripts) +nobase_installed_test_DATA += $(test_data) $(installed_test_data) +nobase_installed_test_DATA += $(dist_test_data) $(dist_installed_test_data) +installed_test_LTLIBRARIES += $(test_ltlibraries) $(installed_test_ltlibraries) +installed_testcases = $(test_programs) $(installed_test_programs) \\ +                      $(test_scripts) $(installed_test_scripts) \\ +                      $(dist_test_scripts) $(dist_installed_test_scripts) + +installed_test_meta_DATA = $(installed_testcases:=.test) + +%.test: %$(EXEEXT) Makefile +	$(AM_V_GEN) (echo \'[Test]\' > $@.tmp; \\ +	echo \'Type=session\' >> $@.tmp; \\ +	echo \'Exec=$(installed_testdir)/$<\' >> $@.tmp; \\ +	mv $@.tmp $@) + +CLEANFILES += $(installed_test_meta_DATA) +endif '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','tap-driver.sh','452','2','652','0','ADD','@@ -0,0 +1,652 @@ +#! /bin/sh +# Copyright (C) 2011-2013 Free Software Foundation, Inc. +# +# This program is free software; you can redistribute it and/or modify +# it under the terms of the GNU General Public License as published by +# the Free Software Foundation; either version 2, or (at your option) +# any later version. +# +# This program is distributed in the hope that it will be useful, +# but WITHOUT ANY WARRANTY; without even the implied warranty of +# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +# GNU General Public License for more details. +# +# You should have received a copy of the GNU General Public License +# along with this program.  If not, see <http://www.gnu.org/licenses/>. + +# As a special exception to the GNU General Public License, if you +# distribute this file as part of a program that contains a +# configuration script generated by Autoconf, you may include it under +# the same distribution terms that you use for the rest of that program. + +# This file is maintained in Automake, please report +# bugs to <bug-automake@gnu.org> or send patches to +# <automake-patches@gnu.org>. + +scriptversion=2011-12-27.17; # UTC + +# Make unconditional expansion of undefined variables an error.  This +# helps a lot in preventing typo-related bugs. +set -u + +me=tap-driver.sh + +fatal () +{ +  echo \"$me: fatal: $*\" >&2 +  exit 1 +} + +usage_error () +{ +  echo \"$me: $*\" >&2 +  print_usage >&2 +  exit 2 +} + +print_usage () +{ +  cat <<END +Usage: +  tap-driver.sh --test-name=NAME --log-file=PATH --trs-file=PATH +                [--expect-failure={yes|no}] [--color-tests={yes|no}] +                [--enable-hard-errors={yes|no}] [--ignore-exit] +                [--diagnostic-string=STRING] [--merge|--no-merge] +                [--comments|--no-comments] [--] TEST-COMMAND +The \\`--test-name\', \\`--log-file\' and \\`--trs-file\' options are mandatory. +END +} + +# TODO: better error handling in option parsing (in particular, ensure +# TODO: $log_file, $trs_file and $test_name are defined). +test_name= # Used for reporting. +log_file=  # Where to save the result and output of the test script. +trs_file=  # Where to save the metadata of the test run. +expect_failure=0 +color_tests=0 +merge=0 +ignore_exit=0 +comments=0 +diag_string=\'#\' +while test $# -gt 0; do +  case $1 in +  --help) print_usage; exit $?;; +  --version) echo \"$me $scriptversion\"; exit $?;; +  --test-name) test_name=$2; shift;; +  --log-file) log_file=$2; shift;; +  --trs-file) trs_file=$2; shift;; +  --color-tests) color_tests=$2; shift;; +  --expect-failure) expect_failure=$2; shift;; +  --enable-hard-errors) shift;; # No-op. +  --merge) merge=1;; +  --no-merge) merge=0;; +  --ignore-exit) ignore_exit=1;; +  --comments) comments=1;; +  --no-comments) comments=0;; +  --diagnostic-string) diag_string=$2; shift;; +  --) shift; break;; +  -*) usage_error \"invalid option: \'$1\'\";; +  esac +  shift +done + +test $# -gt 0 || usage_error \"missing test command\" + +case $expect_failure in +  yes) expect_failure=1;; +    *) expect_failure=0;; +esac + +if test $color_tests = yes; then +  init_colors=\' +    color_map[\"red\"]=\"[0;31m\" # Red. +    color_map[\"grn\"]=\"[0;32m\" # Green. +    color_map[\"lgn\"]=\"[1;32m\" # Light green. +    color_map[\"blu\"]=\"[1;34m\" # Blue. +    color_map[\"mgn\"]=\"[0;35m\" # Magenta. +    color_map[\"std\"]=\"[m\"     # No color. +    color_for_result[\"ERROR\"] = \"mgn\" +    color_for_result[\"PASS\"]  = \"grn\" +    color_for_result[\"XPASS\"] = \"red\" +    color_for_result[\"FAIL\"]  = \"red\" +    color_for_result[\"XFAIL\"] = \"lgn\" +    color_for_result[\"SKIP\"]  = \"blu\"\' +else +  init_colors=\'\' +fi + +# :; is there to work around a bug in bash 3.2 (and earlier) which +# does not always set \'$?\' properly on redirection failure. +# See the Autoconf manual for more details. +:;{ +  ( +    # Ignore common signals (in this subshell only!), to avoid potential +    # problems with Korn shells.  Some Korn shells are known to propagate +    # to themselves signals that have killed a child process they were +    # waiting for; this is done at least for SIGINT (and usually only for +    # it, in truth).  Without the `trap\' below, such a behaviour could +    # cause a premature exit in the current subshell, e.g., in case the +    # test command it runs gets terminated by a SIGINT.  Thus, the awk +    # script we are piping into would never seen the exit status it +    # expects on its last input line (which is displayed below by the +    # last `echo $?\' statement), and would thus die reporting an internal +    # error. +    # For more information, see the Autoconf manual and the threads: +    # <http://lists.gnu.org/archive/html/bug-autoconf/2011-09/msg00004.html> +    # <http://mail.opensolaris.org/pipermail/ksh93-integration-discuss/2009-February/004121.html> +    trap : 1 3 2 13 15 +    if test $merge -gt 0; then +      exec 2>&1 +    else +      exec 2>&3 +    fi +    \"$@\" +    echo $? +  ) | LC_ALL=C ${AM_TAP_AWK-awk} \\ +        -v me=\"$me\" \\ +        -v test_script_name=\"$test_name\" \\ +        -v log_file=\"$log_file\" \\ +        -v trs_file=\"$trs_file\" \\ +        -v expect_failure=\"$expect_failure\" \\ +        -v merge=\"$merge\" \\ +        -v ignore_exit=\"$ignore_exit\" \\ +        -v comments=\"$comments\" \\ +        -v diag_string=\"$diag_string\" \\ +\' +# FIXME: the usages of \"cat >&3\" below could be optimized when using +# FIXME: GNU awk, and/on on systems that supports /dev/fd/. + +# Implementation note: in what follows, `result_obj` will be an +# associative array that (partly) simulates a TAP result object +# from the `TAP::Parser` perl module. + +## ----------- ## +##  FUNCTIONS  ## +## ----------- ## + +function fatal(msg) +{ +  print me \": \" msg | \"cat >&2\" +  exit 1 +} + +function abort(where) +{ +  fatal(\"internal error \" where) +} + +# Convert a boolean to a \"yes\"/\"no\" string. +function yn(bool) +{ +  return bool ? \"yes\" : \"no\"; +} + +function add_test_result(result) +{ +  if (!test_results_index) +    test_results_index = 0 +  test_results_list[test_results_index] = result +  test_results_index += 1 +  test_results_seen[result] = 1; +} + +# Whether the test script should be re-run by \"make recheck\". +function must_recheck() +{ +  for (k in test_results_seen) +    if (k != \"XFAIL\" && k != \"PASS\" && k != \"SKIP\") +      return 1 +  return 0 +} + +# Whether the content of the log file associated to this test should +# be copied into the \"global\" test-suite.log. +function copy_in_global_log() +{ +  for (k in test_results_seen) +    if (k != \"PASS\") +      return 1 +  return 0 +} + +# FIXME: this can certainly be improved ... +function get_global_test_result() +{ +    if (\"ERROR\" in test_results_seen) +      return \"ERROR\" +    if (\"FAIL\" in test_results_seen || \"XPASS\" in test_results_seen) +      return \"FAIL\" +    all_skipped = 1 +    for (k in test_results_seen) +      if (k != \"SKIP\") +        all_skipped = 0 +    if (all_skipped) +      return \"SKIP\" +    return \"PASS\"; +} + +function stringify_result_obj(result_obj) +{ +  if (result_obj[\"is_unplanned\"] || result_obj[\"number\"] != testno) +    return \"ERROR\" + +  if (plan_seen == LATE_PLAN) +    return \"ERROR\" + +  if (result_obj[\"directive\"] == \"TODO\") +    return result_obj[\"is_ok\"] ? \"XPASS\" : \"XFAIL\" + +  if (result_obj[\"directive\"] == \"SKIP\") +    return result_obj[\"is_ok\"] ? \"SKIP\" : COOKED_FAIL; + +  if (length(result_obj[\"directive\"])) +      abort(\"in function stringify_result_obj()\") + +  return result_obj[\"is_ok\"] ? COOKED_PASS : COOKED_FAIL +} + +function decorate_result(result) +{ +  color_name = color_for_result[result] +  if (color_name) +    return color_map[color_name] \"\" result \"\" color_map[\"std\"] +  # If we are not using colorized output, or if we do not know how +  # to colorize the given result, we should return it unchanged. +  return result +} + +function report(result, details) +{ +  if (result ~ /^(X?(PASS|FAIL)|SKIP|ERROR)/) +    { +      msg = \": \" test_script_name +      add_test_result(result) +    } +  else if (result == \"#\") +    { +      msg = \" \" test_script_name \":\" +    } +  else +    { +      abort(\"in function report()\") +    } +  if (length(details)) +    msg = msg \" \" details +  # Output on console might be colorized. +  print decorate_result(result) msg +  # Log the result in the log file too, to help debugging (this is +  # especially true when said result is a TAP error or \"Bail out!\"). +  print result msg | \"cat >&3\"; +} + +function testsuite_error(error_message) +{ +  report(\"ERROR\", \"- \" error_message) +} + +function handle_tap_result() +{ +  details = result_obj[\"number\"]; +  if (length(result_obj[\"description\"])) +    details = details \" \" result_obj[\"description\"] + +  if (plan_seen == LATE_PLAN) +    { +      details = details \" # AFTER LATE PLAN\"; +    } +  else if (result_obj[\"is_unplanned\"]) +    { +       details = details \" # UNPLANNED\"; +    } +  else if (result_obj[\"number\"] != testno) +    { +       details = sprintf(\"%s # OUT-OF-ORDER (expecting %d)\", +                         details, testno); +    } +  else if (result_obj[\"directive\"]) +    { +      details = details \" # \" result_obj[\"directive\"]; +      if (length(result_obj[\"explanation\"])) +        details = details \" \" result_obj[\"explanation\"] +    } + +  report(stringify_result_obj(result_obj), details) +} + +# `skip_reason` should be empty whenever planned > 0. +function handle_tap_plan(planned, skip_reason) +{ +  planned += 0 # Avoid getting confused if, say, `planned` is \"00\" +  if (length(skip_reason) && planned > 0) +    abort(\"in function handle_tap_plan()\") +  if (plan_seen) +    { +      # Error, only one plan per stream is acceptable. +      testsuite_error(\"multiple test plans\") +      return; +    } +  planned_tests = planned +  # The TAP plan can come before or after *all* the TAP results; we speak +  # respectively of an \"early\" or a \"late\" plan.  If we see the plan line +  # after at least one TAP result has been seen, assume we have a late +  # plan; in this case, any further test result seen after the plan will +  # be flagged as an error. +  plan_seen = (testno >= 1 ? LATE_PLAN : EARLY_PLAN) +  # If testno > 0, we have an error (\"too many tests run\") that will be +  # automatically dealt with later, so do not worry about it here.  If +  # $plan_seen is true, we have an error due to a repeated plan, and that +  # has already been dealt with above.  Otherwise, we have a valid \"plan +  # with SKIP\" specification, and should report it as a particular kind +  # of SKIP result. +  if (planned == 0 && testno == 0) +    { +      if (length(skip_reason)) +        skip_reason = \"- \"  skip_reason; +      report(\"SKIP\", skip_reason); +    } +} + +function extract_tap_comment(line) +{ +  if (index(line, diag_string) == 1) +    { +      # Strip leading `diag_string` from `line`. +      line = substr(line, length(diag_string) + 1) +      # And strip any leading and trailing whitespace left. +      sub(\"^[ \\t]*\", \"\", line) +      sub(\"[ \\t]*$\", \"\", line) +      # Return what is left (if any). +      return line; +    } +  return \"\"; +} + +# When this function is called, we know that line is a TAP result line, +# so that it matches the (perl) RE \"^(not )?ok\\b\". +function setup_result_obj(line) +{ +  # Get the result, and remove it from the line. +  result_obj[\"is_ok\"] = (substr(line, 1, 2) == \"ok\" ? 1 : 0) +  sub(\"^(not )?ok[ \\t]*\", \"\", line) + +  # If the result has an explicit number, get it and strip it; otherwise, +  # automatically assing the next progresive number to it. +  if (line ~ /^[0-9]+$/ || line ~ /^[0-9]+[^a-zA-Z0-9_]/) +    { +      match(line, \"^[0-9]+\") +      # The final `+ 0` is to normalize numbers with leading zeros. +      result_obj[\"number\"] = substr(line, 1, RLENGTH) + 0 +      line = substr(line, RLENGTH + 1) +    } +  else +    { +      result_obj[\"number\"] = testno +    } + +  if (plan_seen == LATE_PLAN) +    # No further test results are acceptable after a \"late\" TAP plan +    # has been seen. +    result_obj[\"is_unplanned\"] = 1 +  else if (plan_seen && testno > planned_tests) +    result_obj[\"is_unplanned\"] = 1 +  else +    result_obj[\"is_unplanned\"] = 0 + +  # Strip trailing and leading whitespace. +  sub(\"^[ \\t]*\", \"\", line) +  sub(\"[ \\t]*$\", \"\", line) + +  # This will have to be corrected if we have a \"TODO\"/\"SKIP\" directive. +  result_obj[\"description\"] = line +  result_obj[\"directive\"] = \"\" +  result_obj[\"explanation\"] = \"\" + +  if (index(line, \"#\") == 0) +    return # No possible directive, nothing more to do. + +  # Directives are case-insensitive. +  rx = \"[ \\t]*#[ \\t]*([tT][oO][dD][oO]|[sS][kK][iI][pP])[ \\t]*\" + +  # See whether we have the directive, and if yes, where. +  pos = match(line, rx \"$\") +  if (!pos) +    pos = match(line, rx \"[^a-zA-Z0-9_]\") + +  # If there was no TAP directive, we have nothing more to do. +  if (!pos) +    return + +  # Let`s now see if the TAP directive has been escaped.  For example: +  #  escaped:     ok \\# SKIP +  #  not escaped: ok \\\\# SKIP +  #  escaped:     ok \\\\\\\\\\# SKIP +  #  not escaped: ok \\ # SKIP +  if (substr(line, pos, 1) == \"#\") +    { +      bslash_count = 0 +      for (i = pos; i > 1 && substr(line, i - 1, 1) == \"\\\\\"; i--) +        bslash_count += 1 +      if (bslash_count % 2) +        return # Directive was escaped. +    } + +  # Strip the directive and its explanation (if any) from the test +  # description. +  result_obj[\"description\"] = substr(line, 1, pos - 1) +  # Now remove the test description from the line, that has been dealt +  # with already. +  line = substr(line, pos) +  # Strip the directive, and save its value (normalized to upper case). +  sub(\"^[ \\t]*#[ \\t]*\", \"\", line) +  result_obj[\"directive\"] = toupper(substr(line, 1, 4)) +  line = substr(line, 5) +  # Now get the explanation for the directive (if any), with leading +  # and trailing whitespace removed. +  sub(\"^[ \\t]*\", \"\", line) +  sub(\"[ \\t]*$\", \"\", line) +  result_obj[\"explanation\"] = line +} + +function get_test_exit_message(status) +{ +  if (status == 0) +    return \"\" +  if (status !~ /^[1-9][0-9]*$/) +    abort(\"getting exit status\") +  if (status < 127) +    exit_details = \"\" +  else if (status == 127) +    exit_details = \" (command not found?)\" +  else if (status >= 128 && status <= 255) +    exit_details = sprintf(\" (terminated by signal %d?)\", status - 128) +  else if (status > 256 && status <= 384) +    # We used to report an \"abnormal termination\" here, but some Korn +    # shells, when a child process die due to signal number n, can leave +    # in $? an exit status of 256+n instead of the more standard 128+n. +    # Apparently, both behaviours are allowed by POSIX (2008), so be +    # prepared to handle them both.  See also Austing Group report ID +    # 0000051 <http://www.austingroupbugs.net/view.php?id=51> +    exit_details = sprintf(\" (terminated by signal %d?)\", status - 256) +  else +    # Never seen in practice. +    exit_details = \" (abnormal termination)\" +  return sprintf(\"exited with status %d%s\", status, exit_details) +} + +function write_test_results() +{ +  print \":global-test-result: \" get_global_test_result() > trs_file +  print \":recheck: \"  yn(must_recheck()) > trs_file +  print \":copy-in-global-log: \" yn(copy_in_global_log()) > trs_file +  for (i = 0; i < test_results_index; i += 1) +    print \":test-result: \" test_results_list[i] > trs_file +  close(trs_file); +} + +BEGIN { + +## ------- ## +##  SETUP  ## +## ------- ## + +\'\"$init_colors\"\' + +# Properly initialized once the TAP plan is seen. +planned_tests = 0 + +COOKED_PASS = expect_failure ? \"XPASS\": \"PASS\"; +COOKED_FAIL = expect_failure ? \"XFAIL\": \"FAIL\"; + +# Enumeration-like constants to remember which kind of plan (if any) +# has been seen.  It is important that NO_PLAN evaluates \"false\" as +# a boolean. +NO_PLAN = 0 +EARLY_PLAN = 1 +LATE_PLAN = 2 + +testno = 0     # Number of test results seen so far. +bailed_out = 0 # Whether a \"Bail out!\" directive has been seen. + +# Whether the TAP plan has been seen or not, and if yes, which kind +# it is (\"early\" is seen before any test result, \"late\" otherwise). +plan_seen = NO_PLAN + +## --------- ## +##  PARSING  ## +## --------- ## + +is_first_read = 1 + +while (1) +  { +    # Involutions required so that we are able to read the exit status +    # from the last input line. +    st = getline +    if (st < 0) # I/O error. +      fatal(\"I/O error while reading from input stream\") +    else if (st == 0) # End-of-input +      { +        if (is_first_read) +          abort(\"in input loop: only one input line\") +        break +      } +    if (is_first_read) +      { +        is_first_read = 0 +        nextline = $0 +        continue +      } +    else +      { +        curline = nextline +        nextline = $0 +        $0 = curline +      } +    # Copy any input line verbatim into the log file. +    print | \"cat >&3\" +    # Parsing of TAP input should stop after a \"Bail out!\" directive. +    if (bailed_out) +      continue + +    # TAP test result. +    if ($0 ~ /^(not )?ok$/ || $0 ~ /^(not )?ok[^a-zA-Z0-9_]/) +      { +        testno += 1 +        setup_result_obj($0) +        handle_tap_result() +      } +    # TAP plan (normal or \"SKIP\" without explanation). +    else if ($0 ~ /^1\\.\\.[0-9]+[ \\t]*$/) +      { +        # The next two lines will put the number of planned tests in $0. +        sub(\"^1\\\\.\\\\.\", \"\") +        sub(\"[^0-9]*$\", \"\") +        handle_tap_plan($0, \"\") +        continue +      } +    # TAP \"SKIP\" plan, with an explanation. +    else if ($0 ~ /^1\\.\\.0+[ \\t]*#/) +      { +        # The next lines will put the skip explanation in $0, stripping +        # any leading and trailing whitespace.  This is a little more +        # tricky in truth, since we want to also strip a potential leading +        # \"SKIP\" string from the message. +        sub(\"^[^#]*#[ \\t]*(SKIP[: \\t][ \\t]*)?\", \"\") +        sub(\"[ \\t]*$\", \"\"); +        handle_tap_plan(0, $0) +      } +    # \"Bail out!\" magic. +    # Older versions of prove and TAP::Harness (e.g., 3.17) did not +    # recognize a \"Bail out!\" directive when preceded by leading +    # whitespace, but more modern versions (e.g., 3.23) do.  So we +    # emulate the latter, \"more modern\" behaviour. +    else if ($0 ~ /^[ \\t]*Bail out!/) +      { +        bailed_out = 1 +        # Get the bailout message (if any), with leading and trailing +        # whitespace stripped.  The message remains stored in `$0`. +        sub(\"^[ \\t]*Bail out![ \\t]*\", \"\"); +        sub(\"[ \\t]*$\", \"\"); +        # Format the error message for the +        bailout_message = \"Bail out!\" +        if (length($0)) +          bailout_message = bailout_message \" \" $0 +        testsuite_error(bailout_message) +      } +    # Maybe we have too look for dianogtic comments too. +    else if (comments != 0) +      { +        comment = extract_tap_comment($0); +        if (length(comment)) +          report(\"#\", comment); +      } +  } + +## -------- ## +##  FINISH  ## +## -------- ## + +# A \"Bail out!\" directive should cause us to ignore any following TAP +# error, as well as a non-zero exit status from the TAP producer. +if (!bailed_out) +  { +    if (!plan_seen) +      { +        testsuite_error(\"missing test plan\") +      } +    else if (planned_tests != testno) +      { +        bad_amount = testno > planned_tests ? \"many\" : \"few\" +        testsuite_error(sprintf(\"too %s tests run (expected %d, got %d)\", +                                bad_amount, planned_tests, testno)) +      } +    if (!ignore_exit) +      { +        # Fetch exit status from the last line. +        exit_message = get_test_exit_message(nextline) +        if (exit_message) +          testsuite_error(exit_message) +      } +  } + +write_test_results() + +exit 0 + +} # End of \"BEGIN\" block. +\' + +# TODO: document that we consume the file descriptor 3 :-( +} 3>\"$log_file\" + +test $? -eq 0 || fatal \"I/O or internal error\" + +# Local Variables: +# mode: shell-script +# sh-indentation: 2 +# eval: (add-hook \'write-file-hooks \'time-stamp) +# time-stamp-start: \"scriptversion=\" +# time-stamp-format: \"%:y-%02m-%02d.%02H\" +# time-stamp-time-zone: \"UTC\" +# time-stamp-end: \"; # UTC\" +# End: '),('irssi','1.0.5','c20eddeb385974d6f46494e71ab63d4493df119b','ailin-nemui','add glib testing TAP utilities','tap-test','2','0','5','0','ADD','@@ -0,0 +1,5 @@ +#! /bin/sh + +# run a GTest in tap mode. The test binary is passed as $1 + +$1 -k --tap '),('irssi','1.0.5','43d06369bf8e5c5e470dc2b00656ddcdb9ee0480','ailin-nemui','move fixtures to outer scope','Makefile.am','22','0','4','12','MODIFY','@@ -1,5 +1,7 @@  include $(top_srcdir)/utils/glib-tap.mk   +PACKAGE_STRING=irc/core +  AM_CPPFLAGS = \\  	-I$(top_srcdir)/src \\  	-I$(top_srcdir)/src/core \\ @@ -17,21 +19,11 @@ test_irc_DEPENDENCIES = \\  	../../../src/lib-config/libirssi_config.a    test_irc_LDADD = \\ +	../../../src/irc/core/libirc_core.a \\  	../../../src/core/libcore.a \\  	../../../src/lib-config/libirssi_config.a \\  	@GLIB_LIBS@ \\  	@OPENSSL_LIBS@    test_irc_SOURCES = \\ -	test-irc.c \\ -	../../../src/irc/core/irc-cap.c \\ -	../../../src/irc/core/irc-nicklist.c \\ -	../../../src/irc/core/irc-queries.c \\ -	../../../src/irc/core/irc-servers-reconnect.c \\ -	../../../src/irc/core/irc-servers-setup.c \\ -	../../../src/irc/core/irc-servers.c \\ -	../../../src/irc/core/irc.c \\ -	../../../src/irc/core/mode-lists.c \\ -	../../../src/irc/core/modes.c \\ -	../../../src/irc/core/servers-idle.c \\ -	../../../src/irc/core/servers-redirect.c +	test-irc.c '),('irssi','1.0.5','43d06369bf8e5c5e470dc2b00656ddcdb9ee0480','ailin-nemui','move fixtures to outer scope','test-irc.c','191','5','190','190','MODIFY','@@ -22,210 +22,210 @@  #include <irc.h>  #include <string.h>   -static void test_event_get_param(void); -static void test_event_get_params(void); +typedef struct { +	char const *const description; +	char const *const input; +	char const *const input_after; +	char const *const output; +} event_get_param_test_case; + +event_get_param_test_case const event_get_param_fixtures[] = { +	{ +		.description = \"Zero parameters\", +		.input       = \"\", +		.input_after = \"\", +		.output      = \"\", +	}, +	{ +		.description = \"One parameter\", +		.input       = \"#test\", +		.input_after = \"\", +		.output      = \"#test\", +	}, +	{ +		.description = \"One parameter, trailing space\", +		.input       = \"#test \", +		.input_after = \"\", +		.output      = \"#test\", +	}, +	{ +		.description = \"One parameter, more trailing space\", +		.input       = \"#test  \", +		.input_after = \" \", +		.output      = \"#test\", +	}, +	{ +		.description = \"Two parameters\", +		.input       = \"#test +o\", +		.input_after = \"+o\", +		.output      = \"#test\", +	}, +	{ +		.description = \"Two parameters continued\", +		.input       = \"+o\", +		.input_after = \"\", +		.output      = \"+o\", +	}, +	{ +		.description = \"Two parameters with trailing space\", +		.input       = \"#test +o \", +		.input_after = \"+o \", +		.output      = \"#test\", +	}, +	{ +		.description = \"Two parameters with trailing space continued\", +		.input       = \"+o \", +		.input_after = \"\", +		.output      = \"+o\", +	}, +	{ +		.description = \"Two parameters with inline and trailing space\", +		.input       = \"#test  +o \", +		.input_after = \" +o \", +		.output      = \"#test\", +	}, +	/* TODO: It seems not ideal that the caller has to deal with inline space. +	 */ +	{ +		.description = \"Two parameters with inline and trailing space continued\", +		.input       = \" +o \", +		.input_after = \"+o \", +		.output      = \"\", +	}, +}; + +static void test_event_get_param(const event_get_param_test_case *test); + +typedef struct { +	char const *const description; +	char const *const input; +	char const *const output0; +	char const *const output1; +} event_get_params_test_case; + +event_get_params_test_case const event_get_params_fixtures[] = { +	{ +		.description = \"Only a channel\", +		.input       = \"#test\", +		.output0     = \"#test\", +		.output1     = \"\", +	}, +	{ +		.description = \"Only a channel with trailing space\", +		.input       = \"#test \", +		.output0     = \"#test\", +		.output1     = \"\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with one parameter after channel name\", +		.input       = \"#test +i\", +		.output0     = \"#test\", +		.output1     = \"+i\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with two parameters after channel name\", +		.input       = \"#test +o tester\", +		.output0     = \"#test\", +		.output1     = \"+o tester\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with three parameters afer channel name\", +		.input       = \"#test +ov tester tester2\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2\", +	}, +	{ +		.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\", +		.input       = \"#test  +ov  tester  tester2 \", +		.output0     = \"#test\", +		.output1     = \" +ov  tester  tester2 \", +	}, +	{ +		.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\", +		.input       = \"#test :+i\", +		.output0     = \"#test\", +		.output1     = \"+i\", +	}, +	{ +		.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\", +		.input       = \"#test :+o tester\", +		.output0     = \"#test\", +		.output1     = \"+o tester\", +	}, +	{ +		.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\", +		.input       = \"#test :+ov tester tester2\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2\", +	}, +	{ +		.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\", +		.input       = \"#test +o :tester\", +		.output0     = \"#test\", +		.output1     = \"+o tester\", +	}, +	{ +		.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\", +		.input       = \"#test +ov tester :tester2\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2\", +	}, +	{ +		.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\", +		.input       = \"#test +ov tester :tester2 hi:there\", +		.output0     = \"#test\", +		.output1     = \"+ov tester tester2 hi:there\", +	}, +}; + +static void test_event_get_params(const event_get_params_test_case *test);    int main(int argc, char **argv)  { +	int i; +  	g_test_init(&argc, &argv, NULL);   -	g_test_add_func(\"/test/event_get_param\", test_event_get_param); -	g_test_add_func(\"/test/event_get_params\", test_event_get_params); +	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) { +		char *name = g_strdup_printf(\"/test/event_get_params/%d\", i); +		g_test_add_data_func(name, &event_get_params_fixtures[i], (GTestDataFunc)test_event_get_params); +		g_free(name); +	} +	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) { +		char *name = g_strdup_printf(\"/test/event_get_param/%d\", i); +		g_test_add_data_func(name, &event_get_param_fixtures[i], (GTestDataFunc)test_event_get_param); +		g_free(name); +	}    	g_test_set_nonfatal_assertions();  	return g_test_run();  }   -static void test_event_get_param(void) +static void test_event_get_param(const event_get_param_test_case *test)  { -	struct test_case { -		char const *const description; -		char const *const input; -		char const *const input_after; -		char const *const output; -	}; - -	struct test_case const tests[] = { -		{ -			.description = \"Zero parameters\", -			.input       = \"\", -			.input_after = \"\", -			.output      = \"\", -		}, -		{ -			.description = \"One parameter\", -			.input       = \"#test\", -			.input_after = \"\", -			.output      = \"#test\", -		}, -		{ -			.description = \"One parameter, trailing space\", -			.input       = \"#test \", -			.input_after = \"\", -			.output      = \"#test\", -		}, -		{ -			.description = \"One parameter, more trailing space\", -			.input       = \"#test  \", -			.input_after = \" \", -			.output      = \"#test\", -		}, -		{ -			.description = \"Two parameters\", -			.input       = \"#test +o\", -			.input_after = \"+o\", -			.output      = \"#test\", -		}, -		{ -			.description = \"Two parameters continued\", -			.input       = \"+o\", -			.input_after = \"\", -			.output      = \"+o\", -		}, -		{ -			.description = \"Two parameters with trailing space\", -			.input       = \"#test +o \", -			.input_after = \"+o \", -			.output      = \"#test\", -		}, -		{ -			.description = \"Two parameters with trailing space continued\", -			.input       = \"+o \", -			.input_after = \"\", -			.output      = \"+o\", -		}, -		{ -			.description = \"Two parameters with inline and trailing space\", -			.input       = \"#test  +o \", -			.input_after = \" +o \", -			.output      = \"#test\", -		}, -		/* TODO: It seems not ideal that the caller has to deal with inline space. -		 */ -		{ -			.description = \"Two parameters with inline and trailing space continued\", -			.input       = \" +o \", -			.input_after = \"+o \", -			.output      = \"\", -		}, -	}; - -	char *buf = g_malloc0(1024); - -	int i = 0; -	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { -		struct test_case const test = tests[i]; - -		memcpy(buf, test.input, strlen(test.input)+1); -		char *input = buf; - -		char *const output = event_get_param(&input); - -		g_assert_cmpstr(input, ==, test.input_after); -		g_assert_cmpstr(output, ==, test.output); -	} +	char *buf, *input, *output; + +	input = buf = g_strdup(test->input); +	output = event_get_param(&input); + +	g_assert_cmpstr(input, ==, test->input_after); +	g_assert_cmpstr(output, ==, test->output);    	g_free(buf);  }   -static void test_event_get_params(void) +static void test_event_get_params(const event_get_params_test_case *test)  { -	struct test_case { -		char const *const description; -		char const *const input; -		char const *const output0; -		char const *const output1; -	}; - -	struct test_case const tests[] = { -		{ -			.description = \"Only a channel\", -			.input       = \"#test\", -			.output0     = \"#test\", -			.output1     = \"\", -		}, -		{ -			.description = \"Only a channel with trailing space\", -			.input       = \"#test \", -			.output0     = \"#test\", -			.output1     = \"\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with one parameter after channel name\", -			.input       = \"#test +i\", -			.output0     = \"#test\", -			.output1     = \"+i\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with two parameters after channel name\", -			.input       = \"#test +o tester\", -			.output0     = \"#test\", -			.output1     = \"+o tester\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with three parameters afer channel name\", -			.input       = \"#test +ov tester tester2\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2\", -		}, -		{ -			.description = \"No :<trailing>, channel mode with three parameters afer channel name, bunch of extra space\", -			.input       = \"#test  +ov  tester  tester2 \", -			.output0     = \"#test\", -			.output1     = \" +ov  tester  tester2 \", -		}, -		{ -			.description = \"Channel mode with one parameter after channel name, :<trailing> at the start of modes\", -			.input       = \"#test :+i\", -			.output0     = \"#test\", -			.output1     = \"+i\", -		}, -		{ -			.description = \"Channel mode with two parameters after channel name, :<trailing> at the  start of modes\", -			.input       = \"#test :+o tester\", -			.output0     = \"#test\", -			.output1     = \"+o tester\", -		}, -		{ -			.description = \"Channel mode with three parameters after channel name, :<trailing> at the start of modes\", -			.input       = \"#test :+ov tester tester2\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2\", -		}, -		{ -			.description = \"Channel mode with two parameters after channel name, :<trailing> on the final parameter\", -			.input       = \"#test +o :tester\", -			.output0     = \"#test\", -			.output1     = \"+o tester\", -		}, -		{ -			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter\", -			.input       = \"#test +ov tester :tester2\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2\", -		}, -		{ -			.description = \"Channel mode with three parameters after channel name, :<trailing> on the final parameter, also a second : present\", -			.input       = \"#test +ov tester :tester2 hi:there\", -			.output0     = \"#test\", -			.output1     = \"+ov tester tester2 hi:there\", -		}, -	}; - -	int i = 0; -	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) { -		struct test_case const test = tests[i]; - -		char *output0 = NULL; -		char *output1 = NULL; -		char *const params = event_get_params(test.input, 2 | PARAM_FLAG_GETREST, -				&output0, &output1); - -		/* params happens to always point at the first output */ -		g_assert_cmpstr(params, ==, test.output0); -		g_assert_cmpstr(output0, ==, test.output0); -		g_assert_cmpstr(output1, ==, test.output1); - -		g_free(params); -	} +	char *output0, *output1, *params; +	output0 = NULL; +	output1 = NULL; +	params = event_get_params(test->input, 2 | PARAM_FLAG_GETREST, +			&output0, &output1); + +	/* params happens to always point at the first output */ +	g_assert_cmpstr(params, ==, test->output0); +	g_assert_cmpstr(output0, ==, test->output0); +	g_assert_cmpstr(output1, ==, test->output1); + +	g_free(params);  } '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','configure.ac','706','4','2','0','MODIFY','@@ -661,6 +661,8 @@ src/perl/textui/Makefile.PL  scripts/Makefile  scripts/examples/Makefile  tests/Makefile +tests/fe-common/Makefile +tests/fe-common/core/Makefile  tests/irc/Makefile  tests/irc/core/Makefile  docs/Makefile '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','1','0','1','1','MODIFY','@@ -1 +1 @@ -SUBDIRS = irc +SUBDIRS = fe-common irc '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','1','0','1','0','ADD','@@ -0,0 +1 @@ +SUBDIRS = core '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','Makefile.am','21','0','28','0','ADD','@@ -0,0 +1,28 @@ +include $(top_srcdir)/utils/glib-tap.mk + +PACKAGE_STRING=fe-common/core + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core \\ +	$(GLIB_CFLAGS) + +test_programs = test-formats + +test_formats_CPPFLAGS = \\ +	-I$(top_srcdir)/src/fe-common/core \\ +	$(AM_CPPFLAGS) + +test_formats_DEPENDENCIES = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a + +test_formats_LDADD = \\ +	../../../src/fe-common/core/libfe_common_core.a \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a \\ +	@GLIB_LIBS@ \\ +	@OPENSSL_LIBS@ + +test_formats_SOURCES = \\ +	test-formats.c '),('irssi','1.0.5','d932e6e4b78383e0874721a76a8480a9a7e03667','ailin-nemui','add test case for format_real_length','test-formats.c','37','4','50','0','ADD','@@ -0,0 +1,50 @@ +#include \"common.h\" +#include \"formats.h\" + +#define MAX_LENGTH 5 + +typedef struct { +	char const *const description; +	char const *const input; +	int const result[ MAX_LENGTH ]; +} format_real_length_test_case; + +static void test_format_real_length(const format_real_length_test_case *test); + +format_real_length_test_case const format_real_length_fixtures[] = { +	{ +		.description = \"\", +		.input = \"%4%w \", +		.result = { 0, 5, 5, -1 }, +	}, +}; + +int main(int argc, char **argv) +{ +	int i; + +	g_test_init(&argc, &argv, NULL); + +	for (i = 0; i < G_N_ELEMENTS(format_real_length_fixtures); i++) { +		char *name = g_strdup_printf(\"/test/format_real_length/%d\", i); +		g_test_add_data_func(name, &format_real_length_fixtures[i], (GTestDataFunc)test_format_real_length); +		g_free(name); +	} + +	g_test_set_nonfatal_assertions(); +	return g_test_run(); +} + +static void test_format_real_length(const format_real_length_test_case *test) +{ +	int j, len; + +	g_test_message(\"Testing format %s\", test->input); + +	for (j = 0; test->result[j] != -1; j++) { +		len = format_real_length(test->input, j); +		g_assert_cmpint(len, ==, test->result[j]); +	} + +	return; +} '),('irssi','1.0.5','d6458304d7dba0644fb4b682e09baf0acebdbb97','ailin-nemui','mess with travis','.travis.yml','58','0','16','7','MODIFY','@@ -12,8 +12,13 @@ perl:      # - \"5.18-shrplib\"      - \"system-perl\"  env: -    - CC=clang -    - CC=gcc +    - CC=clang UNITTESTS=false +    - CC=gcc   UNITTESTS=false +    - CC=clang UNITTESTS=true +matrix: +    exclude: +        - env: CC=clang UNITTESTS=true +          perl: \"system-perl\"    addons:      apt: @@ -31,11 +36,12 @@ before_install:    install:      - ./configure --with-proxy --with-bot --with-perl=module --prefix=$HOME/irssi-build +      $( $UNITTESTS && echo --enable-always-build-tests )      - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"      - make install    before_script: -    - cd +    - pushd ~      - mkdir irssi-test      - echo echo automated irssi launch test > irssi-test/startup;        echo ^set settings_autosave off >> irssi-test/startup; @@ -47,9 +53,12 @@ before_script:      - echo load perl >> irssi-test/startup      - echo load proxy >> irssi-test/startup      - echo ^quit >> irssi-test/startup -    - irssi-build/bin/irssi --home irssi-test -    - cat irc.log.* -    - cd $TRAVIS_BUILD_DIR    script: -    - make check +    - irssi-build/bin/irssi --home irssi-test +    - popd +    - if $UNITTESTS; then make -C tests -sk check; fi + +after_script: +    - cat ~/irc.log.*; +      find -name test-suite.log -exec cat {} + '),('irssi','1.0.5','eb9e2ed6fdacc3fa262b4907de51dea3f12be5fe','ailin-nemui','Update test-irc.c  Fix wrong array (missing an s)','test-irc.c','191','5','1','1','MODIFY','@@ -186,7 +186,7 @@ int main(int argc, char **argv)    	g_test_init(&argc, &argv, NULL);   -	for (i = 0; i < G_N_ELEMENTS(event_get_param_fixtures); i++) { +	for (i = 0; i < G_N_ELEMENTS(event_get_params_fixtures); i++) {  		char *name = g_strdup_printf(\"/test/event_get_params/%d\", i);  		g_test_add_data_func(name, &event_get_params_fixtures[i], (GTestDataFunc)test_event_get_params);  		g_free(name); '),('irssi','1.0.5','8b34871ea67c420b045ead9e317b67a247c02aae','ailin-nemui','make travis pass despite failures','.travis.yml','60','0','2','0','MODIFY','@@ -19,6 +19,8 @@ matrix:      exclude:          - env: CC=clang UNITTESTS=true            perl: \"system-perl\" +    allow_failures: +        - env: CC=clang UNITTESTS=true    addons:      apt: '),('irssi','1.0.5','58557d18c49c11cd4a4de44c5a9e7c00f2d8f880','ailin-nemui','add separator in travis.yml','.travis.yml','60','0','2','2','MODIFY','@@ -62,5 +62,5 @@ script:      - if $UNITTESTS; then make -C tests -sk check; fi    after_script: -    - cat ~/irc.log.*; -      find -name test-suite.log -exec cat {} + +    - cat ~/irc.log.* +    - find -name test-suite.log -exec cat {} + '),('irssi','1.0.5','ef07b3c60c80a828f529a2075246185d7d0b5b25','Joseph Bisch','Remove redundant if case','event-get-params.c','57','10','0','2','MODIFY','@@ -74,8 +74,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		params = event_get_params(copy, 2, &output0, &output1);  	} else if (count % 8 == 6) {  		params = event_get_params(copy, 3, &output0, &output1, &output2); -	} else if (count % 8 == 7) { -		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);  	} else {  		params = event_get_params(copy, 4, &output0, &output1, &output2, &output3);  	} '),('irssi','1.0.5','15705432e1fb88d9f784cb3fc12c89f8f9164043','Joseph Bisch','Remove outdated comment','event-get-params.c','57','10','0','1','MODIFY','@@ -52,7 +52,6 @@ int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {  		return 0;  	}  	uint8_t count = *data; -	/* malloc(size) instead of size+1, because we already used one byte of data */  	gchar *copy = g_strndup((const gchar *)data+1, size-1);    	char *output0; '),('irssi','1.0.5','54d453623d879ea83d0818a80bd14151192953ec','ailin-nemui','do not record topic change time when sender is blank','channel-events.c','275','68','7','1','MODIFY','@@ -138,7 +138,13 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,  	g_free_not_null(chanrec->topic_by);  	chanrec->topic_by = g_strdup(setby);   -	chanrec->topic_time = settime; +	if (chanrec->topic_by == NULL) { +		/* ensure invariant topic_time > 0 <=> topic_by != NULL. +		   this could be triggered by a topic command without sender */ +		chanrec->topic_time = 0; +	} else { +		chanrec->topic_time = settime; +	}    	signal_emit(\"channel topic changed\", 1, chanrec);  } '),('irssi','1.0.5','7a83c63701b7395ee6cc606905314318eef77971','ailin-nemui','check if \\\\c is complete in eval','misc.c','781','258','5','2','MODIFY','@@ -703,8 +703,11 @@ int expand_escape(const char **data)  		*data += 2;  		return strtol(digit, NULL, 16);  	case \'c\': -                /* control character (\\cA = ^A) */ -                (*data)++; +		/* check for end of string */ +		if ((*data)[1] == \'\\0\') +			return 0; +		/* control character (\\cA = ^A) */ +		(*data)++;  		return i_toupper(**data) - 64;  	case \'0\': case \'1\': case \'2\': case \'3\':  	case \'4\': case \'5\': case \'6\': case \'7\': '),('irssi','1.0.5','2361d4b1e5d38701f35146219ceddd318ac4e645','ailin-nemui','rewrite completion code and check for direct match of separator','completion.c','658','185','12','6','MODIFY','@@ -187,12 +187,18 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  			char *old;    			old = linestart; -			linestart = *linestart == \'\\0\' ? -				g_strdup(word) : -				g_strdup_printf(\"%s%c%s\", -						/* do not accidentally duplicate the word separator */ -						line == wordstart - 1 ? \"\" : linestart, -						old_wordstart[-1], word); +			/* we want to move word into linestart */ +			if (*linestart == \'\\0\') { +				linestart = g_strdup(word); +			} else { +				GString *str = g_string_new(linestart); +				if (old_wordstart[-1] != str->str[str->len - 1]) { +					/* do not accidentally duplicate the word separator */ +					g_string_append_c(str, old_wordstart[-1]); +				} +				g_string_append(str, word); +				linestart = g_string_free(str, FALSE); +			}  			g_free(old);    			g_free(word); '),('irssi','1.0.5','cc17837a9b326ec9100a35981348fa0f5d6316fa','ailin-nemui','disable variable arguments code','special-vars.c','541','162','4','0','MODIFY','@@ -384,6 +384,7 @@ char *parse_special(char **cmd, SERVER_REC *server, void *item,  	}    	nest_free = FALSE; nest_value = NULL; +#if 0 /* this code is disabled due to security issues until it is fixed */  	if (**cmd == \'(\' && (*cmd)[1] != \'\\0\') {  		/* subvariable */  		int toplevel = nested_orig_cmd == NULL; @@ -412,6 +413,9 @@ char *parse_special(char **cmd, SERVER_REC *server, void *item,                    if (toplevel) nested_orig_cmd = NULL;  	} +#else +	if (nested_orig_cmd) nested_orig_cmd = NULL; +#endif    	if (**cmd != \'{\')  		brackets = FALSE; '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','configure.ac','707','4','1','0','MODIFY','@@ -665,6 +665,7 @@ tests/fe-common/Makefile  tests/fe-common/core/Makefile  tests/irc/Makefile  tests/irc/core/Makefile +tests/irc/flood/Makefile  docs/Makefile  docs/help/Makefile  docs/help/in/Makefile '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','Makefile.am','3','0','3','1','MODIFY','@@ -1 +1,3 @@ -SUBDIRS = core +SUBDIRS = \\ +	core \\ +	flood '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','Makefile.am','25','0','32','0','ADD','@@ -0,0 +1,32 @@ +include $(top_srcdir)/utils/glib-tap.mk + +PACKAGE_STRING=irc/flood + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core \\ +	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\ +	$(GLIB_CFLAGS) + +test_programs = \\ +	test-796 + +test_796_CPPFLAGS = \\ +	-I$(top_srcdir)/src/irc/core \\ +	-I$(top_srcdir)/src/irc/flood \\ +	$(AM_CPPFLAGS) + +test_796_DEPENDENCIES = \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a + +test_796_LDADD = \\ +	../../../src/irc/flood/libirc_flood.a \\ +	../../../src/irc/core/libirc_core.a \\ +	../../../src/core/libcore.a \\ +	../../../src/lib-config/libirssi_config.a \\ +	@GLIB_LIBS@ \\ +	@OPENSSL_LIBS@ + +test_796_SOURCES = \\ +	test-796.c '),('irssi','1.0.5','5bddfe7b7336f6b48408c72955dbcb664cc4dc97','ailin-nemui','add new test skeleton','test-796.c','7','1','29','0','ADD','@@ -0,0 +1,29 @@ +/* + test-796.c : irssi + +    Copyright (C) 2017 The Irssi project. + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"common.h\" + +int main(int argc, char **argv) +{ +	g_test_init(&argc, &argv, NULL); + +	g_test_set_nonfatal_assertions(); +	return g_test_run(); +} '),('irssi','1.0.5','c7cd49f8d7e83302c0f21f4449cddac528d28eea','ailin-nemui','first bug case, exposes broken server object in chat-completion','Makefile.am','33','0','8','0','MODIFY','@@ -12,6 +12,7 @@ test_programs = \\  	test-796    test_796_CPPFLAGS = \\ +	-I$(top_srcdir)/src/fe-common/core \\  	-I$(top_srcdir)/src/irc/core \\  	-I$(top_srcdir)/src/irc/flood \\  	$(AM_CPPFLAGS) @@ -21,8 +22,15 @@ test_796_DEPENDENCIES = \\  	../../../src/lib-config/libirssi_config.a    test_796_LDADD = \\ +	../../../src/irc/libirc.a \\ +	../../../src/fe-common/irc/libfe_common_irc.a \\ +	../../../src/fe-common/irc/dcc/libfe_irc_dcc.a \\ +	../../../src/fe-common/irc/notifylist/libfe_irc_notifylist.a \\ +	../../../src/irc/dcc/libirc_dcc.a \\ +	../../../src/irc/notifylist/libirc_notifylist.a \\  	../../../src/irc/flood/libirc_flood.a \\  	../../../src/irc/core/libirc_core.a \\ +	../../../src/fe-common/core/libfe_common_core.a \\  	../../../src/core/libcore.a \\  	../../../src/lib-config/libirssi_config.a \\  	@GLIB_LIBS@ \\ '),('irssi','1.0.5','c7cd49f8d7e83302c0f21f4449cddac528d28eea','ailin-nemui','first bug case, exposes broken server object in chat-completion','test-796.c','92','8','122','0','MODIFY','@@ -19,11 +19,133 @@  */    #include \"common.h\" +#include \"args.h\" +#include \"core.h\" +#include \"misc.h\" +#include \"servers-setup.h\" + +#include \"formats.h\" +#include \"fe-common-core.h\" + +#include \"irc.h\" +#include \"irc-servers.h\" +#include \"irc-channels.h\" + +/* irc.c */ +void irc_init(void); +void irc_deinit(void) ; + +/* irc-session.c */ +void irc_session_init(void); +void irc_session_deinit(void); + +/* fe-common-irc.c */ +void fe_common_irc_init(void); +void fe_common_irc_deinit(void); + +typedef struct { +} ServerDestroyFloodData; + +#define MODULE_NAME \"tests\" + +static void cmd_echo(const char *data, void *server, WI_ITEM_REC *item) +{ +	g_test_message(\"echo: [server=%p,item=%p] %s\", server, item, data); +} + +static void sig_public(SERVER_REC *server, const char *msg, const char *nick, const char *address, const char *target) +{ +	signal_emit(\"send command\", 3, \"/eval echo $tag\", server, NULL); +} + +static void print_disconnect(SERVER_REC *server) +{ +	g_test_message(\"server %p was disconnected\", server); +} + +static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const void *data) +{ +	args_execute(0, NULL); +	core_init(); +	irc_init(); +	fe_common_core_init(); +	fe_common_irc_init(); +	signal_emit(\"irssi init finished\", 0); +	command_bind(\"echo\", NULL, (SIGNAL_FUNC) cmd_echo); +	signal_add(\"message public\", (SIGNAL_FUNC) sig_public); +	signal_add_first(\"server disconnected\", (SIGNAL_FUNC) print_disconnect); +} + +static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, const void *data) +{ +	signal_remove(\"server disconnected\", (SIGNAL_FUNC) print_disconnect); +	signal_remove(\"message public\", (SIGNAL_FUNC) sig_public); +	command_unbind(\"echo\", (SIGNAL_FUNC) cmd_echo); +	fe_common_irc_deinit(); +	fe_common_core_deinit(); +	irc_deinit(); +	core_deinit(); +} + +static void irc_server_init_bare_minimum(IRC_SERVER_REC *server) +{ +	server->isupport = g_hash_table_new((GHashFunc) g_istr_hash, +                                            (GCompareFunc) g_istr_equal); + +        /* set the standards */ +        g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\")); +        g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\")); +} + +static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const void *data) +{ +	SERVER_REC *server; /* = g_new0(IRC_SERVER_REC, 1); */ +        CHAT_PROTOCOL_REC *proto; +	SERVER_CONNECT_REC *conn; + +	g_test_bug(\"796\"); + +	proto = chat_protocol_find(\"IRC\"); +	conn = server_create_conn(proto->id, \"localhost\", 0, \"\", \"\", \"user\"); +	server = proto->server_init_connect(conn); +	server->session_reconnect = TRUE; +	server->tag = g_strdup(\"testserver\"); + +	g_test_message(\"created server: %p\", server); + +	/* we skip some initialisations that would try to send data */ +	/* irc_servers_deinit(); */ +	irc_session_deinit(); +	irc_irc_deinit(); + +	signal_emit(\"server connected\", 1, server); + +	/* make up for the skipped session init */ +	irc_server_init_bare_minimum(IRC_SERVER(server)); + +	irc_irc_init(); +	irc_session_init(); +	/* irc_servers_init(); */ + +	/* simulate failing irc_server_send_data() */ +	server->connection_lost = TRUE; + +	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\"); +}    int main(int argc, char **argv)  {  	g_test_init(&argc, &argv, NULL); +	g_test_bug_base(\"https://github.com/irssi/irssi/issues/\"); + +	g_test_add(\"/test/server_destroy_flood\", ServerDestroyFloodData, NULL, +		   server_destroy_flood_set_up, test_server_destroy_flood, +		   server_destroy_flood_tear_down);    	g_test_set_nonfatal_assertions(); + +	core_preinit(*argv); +	irssi_gui = IRSSI_GUI_NONE; +  	return g_test_run();  } '),('irssi','1.0.5','3b7b868bb11faf74c872ecf606c4eef189e31725','ailin-nemui','finish test case','test-796.c','94','8','13','1','MODIFY','@@ -110,6 +110,7 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	server = proto->server_init_connect(conn);  	server->session_reconnect = TRUE;  	server->tag = g_strdup(\"testserver\"); +	server_ref(server);    	g_test_message(\"created server: %p\", server);   @@ -118,7 +119,8 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	irc_session_deinit();  	irc_irc_deinit();   -	signal_emit(\"server connected\", 1, server); + +	server_connect_finished(server);    	/* make up for the skipped session init */  	irc_server_init_bare_minimum(IRC_SERVER(server)); @@ -130,6 +132,16 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	/* simulate failing irc_server_send_data() */  	server->connection_lost = TRUE;   +	/* +	chat_completion_deinit(); +	fe_messages_deinit(); +	irc_notifylist_deinit(); +	*/ + +	/* for the purpose of this exercise, we are ignoring the +	   errors of g_hash_table_lookup failure */ +	g_log_set_always_fatal(G_LOG_FATAL_MASK); +  	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\");  }   '),('irssi','1.0.5','bffced54981c191f5bac4f9611e4691fe442e58c','ailin-nemui','Update test-796.c  odd space','test-796.c','94','8','1','1','MODIFY','@@ -33,7 +33,7 @@    /* irc.c */  void irc_init(void); -void irc_deinit(void) ; +void irc_deinit(void);    /* irc-session.c */  void irc_session_init(void); '),('irssi','1.0.5','6b0e14099655bf4d94a19dff252cce89b2858c93','ailin-nemui','show destroyed event','test-796.c','103','9','21','10','MODIFY','@@ -63,6 +63,11 @@ static void print_disconnect(SERVER_REC *server)  	g_test_message(\"server %p was disconnected\", server);  }   +static void print_destroyed(SERVER_REC *server) +{ +	g_test_message(\"server %p was destroyed\", server); +} +  static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const void *data)  {  	args_execute(0, NULL); @@ -73,12 +78,14 @@ static void server_destroy_flood_set_up(ServerDestroyFloodData *fixture, const v  	signal_emit(\"irssi init finished\", 0);  	command_bind(\"echo\", NULL, (SIGNAL_FUNC) cmd_echo);  	signal_add(\"message public\", (SIGNAL_FUNC) sig_public); +	signal_add(\"server destroyed\", (SIGNAL_FUNC) print_destroyed);  	signal_add_first(\"server disconnected\", (SIGNAL_FUNC) print_disconnect);  }    static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, const void *data)  {  	signal_remove(\"server disconnected\", (SIGNAL_FUNC) print_disconnect); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) print_destroyed);  	signal_remove(\"message public\", (SIGNAL_FUNC) sig_public);  	command_unbind(\"echo\", (SIGNAL_FUNC) cmd_echo);  	fe_common_irc_deinit(); @@ -90,27 +97,31 @@ static void server_destroy_flood_tear_down(ServerDestroyFloodData *fixture, cons  static void irc_server_init_bare_minimum(IRC_SERVER_REC *server)  {  	server->isupport = g_hash_table_new((GHashFunc) g_istr_hash, -                                            (GCompareFunc) g_istr_equal); +					    (GCompareFunc) g_istr_equal);   -        /* set the standards */ -        g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\")); -        g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\")); +	/* set the standards */ +	g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\")); +	g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\"));  }    static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const void *data)  {  	SERVER_REC *server; /* = g_new0(IRC_SERVER_REC, 1); */ -        CHAT_PROTOCOL_REC *proto; +	CHAT_PROTOCOL_REC *proto;  	SERVER_CONNECT_REC *conn; +	GLogLevelFlags loglev;    	g_test_bug(\"796\");   +	/* for the purpose of this exercise, we are ignoring the +	   errors of g_hash_table_lookup failure */ +	loglev = g_log_set_always_fatal(G_LOG_FATAL_MASK); +  	proto = chat_protocol_find(\"IRC\");  	conn = server_create_conn(proto->id, \"localhost\", 0, \"\", \"\", \"user\");  	server = proto->server_init_connect(conn);  	server->session_reconnect = TRUE;  	server->tag = g_strdup(\"testserver\"); -	server_ref(server);    	g_test_message(\"created server: %p\", server);   @@ -138,11 +149,11 @@ static void test_server_destroy_flood(ServerDestroyFloodData *fixture, const voi  	irc_notifylist_deinit();  	*/   -	/* for the purpose of this exercise, we are ignoring the -	   errors of g_hash_table_lookup failure */ -	g_log_set_always_fatal(G_LOG_FATAL_MASK); - +	server_ref(server);  	signal_emit(\"event privmsg\", 4, server, \"#someroom :test message\", \"nick\", \"user@host\"); +	server_unref(server); + +	g_log_set_always_fatal(loglev);  }    int main(int argc, char **argv) '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','servers.c','544','132','1','0','MODIFY','@@ -524,6 +524,7 @@ int server_unref(SERVER_REC *server)  		return TRUE;  	}   +	signal_emit(\"server destroyed\", 1, server);          MODULE_DATA_DEINIT(server);  	server_connect_unref(server->connrec);  	if (server->rawlog != NULL) rawlog_destroy(server->rawlog); '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','fe-common-core.c','377','54','3','3','MODIFY','@@ -104,7 +104,7 @@ static void sig_connected(SERVER_REC *server)  	MODULE_DATA_SET(server, g_new0(MODULE_SERVER_REC, 1));  }   -static void sig_disconnected(SERVER_REC *server) +static void sig_destroyed(SERVER_REC *server)  {  	void *data = MODULE_DATA(server);  	g_free(data); @@ -203,7 +203,7 @@ void fe_common_core_init(void)  	settings_check();            signal_add_first(\"server connected\", (SIGNAL_FUNC) sig_connected); -        signal_add_last(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +        signal_add_last(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);          signal_add_first(\"channel created\", (SIGNAL_FUNC) sig_channel_created);          signal_add_last(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);   @@ -249,7 +249,7 @@ void fe_common_core_deinit(void)            signal_remove(\"setup changed\", (SIGNAL_FUNC) sig_setup_changed);          signal_remove(\"server connected\", (SIGNAL_FUNC) sig_connected); -        signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +        signal_remove(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);          signal_remove(\"channel created\", (SIGNAL_FUNC) sig_channel_created);          signal_remove(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);  } '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','irc-servers.c','780','195','3','3','MODIFY','@@ -425,7 +425,7 @@ static void isupport_destroy_hash(void *key, void *value)  	g_free(value);  }   -static void sig_disconnected(IRC_SERVER_REC *server) +static void sig_destroyed(IRC_SERVER_REC *server)  {  	GSList *tmp;   @@ -1031,7 +1031,7 @@ void irc_servers_init(void)  	cmd_tag = -1;    	signal_add_first(\"server connected\", (SIGNAL_FUNC) sig_connected); -	signal_add_last(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +	signal_add_last(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);  	signal_add_last(\"server quit\", (SIGNAL_FUNC) sig_server_quit);  	signal_add(\"event 001\", (SIGNAL_FUNC) event_connected);  	signal_add(\"event 004\", (SIGNAL_FUNC) event_server_info); @@ -1058,7 +1058,7 @@ void irc_servers_deinit(void)  		g_source_remove(cmd_tag);    	signal_remove(\"server connected\", (SIGNAL_FUNC) sig_connected); -	signal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_disconnected); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) sig_destroyed);          signal_remove(\"server quit\", (SIGNAL_FUNC) sig_server_quit);  	signal_remove(\"event 001\", (SIGNAL_FUNC) event_connected);  	signal_remove(\"event 004\", (SIGNAL_FUNC) event_server_info); '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','flood.c','253','52','2','2','MODIFY','@@ -324,7 +324,7 @@ void irc_flood_init(void)  	read_settings();  	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings);  	signal_add_first(\"server connected\", (SIGNAL_FUNC) flood_init_server); -	signal_add(\"server disconnected\", (SIGNAL_FUNC) flood_deinit_server); +	signal_add(\"server destroyed\", (SIGNAL_FUNC) flood_deinit_server);    	autoignore_init();  	settings_check(); @@ -344,5 +344,5 @@ void irc_flood_deinit(void)    	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);  	signal_remove(\"server connected\", (SIGNAL_FUNC) flood_init_server); -	signal_remove(\"server disconnected\", (SIGNAL_FUNC) flood_deinit_server); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) flood_deinit_server);  } '),('irssi','1.0.5','c9b3d87eb7ef2ce99f659d7e567fc83629439142','ailin-nemui','Postpone server cleanup until after unref  Add a new signal, server destroyed, that is supposed to run the clean up tasks of server disconnected. This is so that some structures will stay around longer.','notifylist.c','258','67','2','2','MODIFY','@@ -331,7 +331,7 @@ void irc_notifylist_init(void)  	notifylist_ison_init();  	notifylist_whois_init();  	signal_add(\"server connected\", (SIGNAL_FUNC) notifylist_init_server); -	signal_add(\"server disconnected\", (SIGNAL_FUNC) notifylist_deinit_server); +	signal_add(\"server destroyed\", (SIGNAL_FUNC) notifylist_deinit_server);  	signal_add(\"event quit\", (SIGNAL_FUNC) event_quit);  	signal_add(\"event privmsg\", (SIGNAL_FUNC) event_privmsg);  	signal_add(\"event join\", (SIGNAL_FUNC) event_join); @@ -349,7 +349,7 @@ void irc_notifylist_deinit(void)  	notifylist_whois_deinit();    	signal_remove(\"server connected\", (SIGNAL_FUNC) notifylist_init_server); -	signal_remove(\"server disconnected\", (SIGNAL_FUNC) notifylist_deinit_server); +	signal_remove(\"server destroyed\", (SIGNAL_FUNC) notifylist_deinit_server);  	signal_remove(\"event quit\", (SIGNAL_FUNC) event_quit);  	signal_remove(\"event privmsg\", (SIGNAL_FUNC) event_privmsg);  	signal_remove(\"event join\", (SIGNAL_FUNC) event_join); '),('irssi','1.1.1','0b9beeb01d4ff3890120ace913884fcd915e4b26','ailin-nemui','Merge tag \'1.1.1\' into integrate/1.1.1','NEWS','2985','0','7','0','MODIFY','@@ -1,5 +1,12 @@  v1.2-head 2018-xx-xx  The Irssi team <staff@irssi.org>   +v1.1.1 2018-02-15 The Irssi team <staff@irssi.org> +	! Contains all changes from 1.0.7 +	- Restore compatibility with OpenSSL < 1.0.2 (#820, #831) +	- Fix test compilation on some platforms (#815, #816) +	- Fix portability and backwards compatibility of test runner +          (#818, #845) +  v1.0.7 2018-02-15 The Irssi team <staff@irssi.org>  	- Prevent use after free error during the execution of some  	  commands. Found by Joseph Bisch (GL#17, GL!24). '),('irssi','1.1.1','0b9beeb01d4ff3890120ace913884fcd915e4b26','ailin-nemui','Merge tag \'1.1.1\' into integrate/1.1.1','configure.ac','710','4','1','1','MODIFY','@@ -1,4 +1,4 @@ -AC_INIT(irssi, 1.1-head) +AC_INIT(irssi, 1.2-head)  AC_CONFIG_SRCDIR([src])  AC_CONFIG_AUX_DIR(build-aux)  AC_PREREQ(2.50) '),('irssi','1.1.1','203f6c532947e8b7c7e30fad91220aad083c7f08','ailin-nemui','also unblock theme elements when processing finished','themes.c','1146','282','7','2','MODIFY','@@ -413,7 +413,7 @@ static char *theme_format_expand_abstract(THEME_REC *theme, const char **formatp  {  	GString *str;  	const char *p, *format; -	char *abstract, *data, *ret; +	char *abstract, *data, *ret, *blocking;  	theme_rm_col default_fg, default_bg;  	int len;   @@ -455,8 +455,10 @@ static char *theme_format_expand_abstract(THEME_REC *theme, const char **formatp  		/* unknown abstract, just display the data */  		data = \"$0-\";  		g_free(abstract); +		blocking = NULL;  	} else { -		g_tree_insert(block_list, abstract, abstract); +		blocking = abstract; +		g_tree_insert(block_list, blocking, blocking);  	}  	abstract = g_strdup(data);   @@ -503,6 +505,9 @@ static char *theme_format_expand_abstract(THEME_REC *theme, const char **formatp  	ret = theme_format_expand_data_rec(theme, &p, default_fg, default_bg, last_fg, last_bg,  	                                   flags | EXPAND_FLAG_LASTCOLOR_ARG, block_list);  	g_free(abstract); +	if (blocking != NULL) { +		g_tree_remove(block_list, blocking); +	}  	g_tree_unref(block_list);  	return ret;  } '),('irssi','1.1.1','097a9f4988333b1d445ba70df006da6ef26bfaa9','dequis','Document second parameter (seek position) of /cat command','cat.in','14','0','5','1','MODIFY','@@ -5,12 +5,16 @@    %9Parameters:%9   -    The file to display. +    The file to display and optionally a position to seek in the file, +    in bytes.    %9Description:%9        Displays the contents of the specified file into the active window.   +    The seek position parameter is used internally to display away logs, if +    omitted the whole file is shown. +  %9Examples:%9        /CAT /etc/network/interfaces '),('irssi','1.1.1','097a9f4988333b1d445ba70df006da6ef26bfaa9','dequis','Document second parameter (seek position) of /cat command','fe-core-commands.c','255','53','1','1','MODIFY','@@ -114,7 +114,7 @@ static void cmd_version(char *data)  	}  }   -/* SYNTAX: CAT <file> */ +/* SYNTAX: CAT <file> [<seek position>] */  static void cmd_cat(const char *data)  {  	char *fname, *fposstr; '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','.travis.yml','66','0','8','2','MODIFY','@@ -27,17 +27,23 @@ addons:          packages:              - libperl-dev              - elinks +            - libgcrypt11-dev    before_install:      - perl -V -    - ./autogen.sh --with-proxy --with-bot --with-perl=module +    - wget https://otr.cypherpunks.ca/libotr-4.1.1.tar.gz +    - tar zxf libotr-*.tar.gz +    - cd libotr-* +    - ./configure --prefix $HOME/otr-prefix && make && make install +    - cd .. +    - ./autogen.sh --with-proxy --with-bot --with-perl=module --with-otr=yes --with-libotr-prefix=$HOME/otr-prefix/lib --with-libotr-inc-prefix=$HOME/otr-prefix/include      - make dist      - cd ..      - tar xaf */irssi-*.tar.*      - cd irssi-*    install: -    - ./configure --with-proxy --with-bot --with-perl=module --prefix=$HOME/irssi-build +    - ./configure --with-proxy --with-bot --with-perl=module --with-otr=yes --with-libotr-prefix=$HOME/otr-prefix/lib --with-libotr-inc-prefix=$HOME/otr-prefix/include --prefix=$HOME/irssi-build        $( $UNITTESTS && echo --enable-always-build-tests )      - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"      - make install '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','AUTHORS','94','0','2','0','MODIFY','@@ -27,6 +27,8 @@ Large feature patches by:    Heikki Orsila : DCC SEND queueing    Mark Trumbull : DCC SERVER    Francesco Fracassi : Passive DCC +  Uli Meis : OTR support +  David Goulet : OTR support    Other patches (grep for \"patch\" in ChangeLog) by:   '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','configure.ac','778','4','69','0','MODIFY','@@ -148,6 +148,21 @@ AC_ARG_WITH(perl,  	fi,  	want_perl=static)   +AC_ARG_WITH(otr, +[  --with-otr[=yes|no|module]   Build with OTR support - also specifies +                                if it should be built into the main irssi +                                binary or as a module (default)], +	if test x$withval = xyes; then +		want_otr=module +	elif test x$withval = xstatic; then +		want_otr=static +	elif test x$withval = xmodule; then +		want_otr=module +	else +		want_otr=no +	fi, +	want_otr=no) +  AC_ARG_ENABLE(true-color,  [  --enable-true-color     Build with true color support in terminal],  	if test x$enableval = xno ; then @@ -527,6 +542,48 @@ if test \"x$want_capsicum\" = \"xyes\"; then  	])  fi   +dnl ** +dnl ** OTR checks +dnl ** + +have_otr=no +if test \"x$want_otr\" != \"xno\"; then +	AM_PATH_LIBGCRYPT(1:1.2.0, [], [AC_ERROR(libgcrypt 1.2.0 or newer is required.)]) +	AM_PATH_LIBOTR(4.1.0, [], [AC_ERROR([libotr 4.1.0 or newer is required.])]) + +	OTR_CFLAGS=\"$LIBOTR_CFLAGS $LIBGCRYPT_CFLAGS\" +	OTR_LDFLAGS=\"$LIBOTR_LIBS $LIBGCRYPT_LIBS\" + +	AC_SUBST(otr_module_lib) +	AC_SUBST(otr_static_lib) + +	if test \"x$want_otr\" != \"xno\"; then +		if test \"x$want_otr\" = \"xstatic\"; then +			otr_module_lib= +			otr_static_lib=libotr_core_static.la + +			OTR_LINK_LIBS=\"../otr/libotr_core_static.la\" +			OTR_LINK_FLAGS=\"$OTR_LDFLAGS\" + +			AC_DEFINE(HAVE_STATIC_OTR) +		else +			otr_module_lib=libotr_core.la +			otr_static_lib= +		fi +	fi + +	AC_SUBST(otr_module_lib) +	AC_SUBST(otr_static_lib) + +	AC_SUBST(OTR_CFLAGS) +	AC_SUBST(OTR_LDFLAGS) + +	AC_SUBST(OTR_LINK_LIBS) +	AC_SUBST(OTR_LINK_FLAGS) + +	have_otr=yes +fi +  dnl ** check what we want to build  AM_CONDITIONAL(BUILD_TEXTUI, test \"$want_textui\" = \"yes\")  AM_CONDITIONAL(BUILD_IRSSIBOT, test \"$want_irssibot\" = \"yes\") @@ -535,6 +592,7 @@ AM_CONDITIONAL(BUILD_IRSSIPROXY, test \"$want_irssiproxy\" = \"yes\")  AM_CONDITIONAL(HAVE_PERL, test \"$want_perl\" != \"no\")  AM_CONDITIONAL(HAVE_CAPSICUM, test \"x$want_capsicum\" = \"xyes\")  AM_CONDITIONAL(USE_GREGEX, test \"x$want_gregex\" = \"xyes\") +AM_CONDITIONAL(HAVE_OTR, test \"x$have_otr\" != \"xno\")    # move LIBS to PROG_LIBS so they\'re not tried to be used when linking eg. perl libraries  PROG_LIBS=$LIBS @@ -629,6 +687,7 @@ fi  AH_TEMPLATE(HAVE_GMODULE)  AH_TEMPLATE(HAVE_SOCKS_H, [misc..])  AH_TEMPLATE(HAVE_STATIC_PERL) +AH_TEMPLATE(HAVE_STATIC_OTR)  AH_TEMPLATE(PRIuUOFF_T, [printf()-format for uoff_t, eg. \"u\" or \"lu\" or \"llu\"])  AH_TEMPLATE(UOFF_T_INT, [What type should be used for uoff_t])  AH_TEMPLATE(UOFF_T_LONG) @@ -662,6 +721,7 @@ src/perl/common/Makefile.PL  src/perl/irc/Makefile.PL  src/perl/ui/Makefile.PL  src/perl/textui/Makefile.PL +src/otr/Makefile  scripts/Makefile  scripts/examples/Makefile  tests/Makefile @@ -755,5 +815,14 @@ echo \"Building with true color support.. : $want_truecolor\"  echo \"Building with GRegex ............. : $want_gregex\"  echo \"Building with Capsicum ........... : $want_capsicum\"   +if test \"x$want_otr\" = \"xstatic\"; then +	echo \"Building with OTR support ........ : static (in irssi binary)\" +elif test \"x$want_otr\" = \"xmodule\"; then +	echo \"Building with OTR support ........ : module\" +else +	echo \"Building with OTR support ........ : no\" +fi + +  echo  echo \"If there are any problems, read the INSTALL file.\" '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr.in','73','0','111','0','ADD','@@ -0,0 +1,111 @@ + +OTR %|[OPTION] + +Command to control the OTR module. Without an option, this help is printed. + +This help contains three sections which are %9options, quickstart and files.%n + +To add the OTR status bar (highly recommended): + +%9/statusbar window add otr%n + +%9Options:%n + +AUTH <secret> +    Start or respond to an authentication process. + +AUTHQ <question> <secret> +    Start a SMP authentication process. + +    Example: %9/otr authq \"My question is\" \"this is the secret\"%n + +AUTHABORT +    Abort an ongoing authentication process. + +CONTEXTS +    List known contexts which basically list the known fingerprints and their +    state. + +DEBUG +    Turn on debugging. + +DISTRUST <fingerprint> +    Distrust a specific fingerprint. This command can be done inside a private +    window for which the current fingerprint of the other person will be used +    or else set fp to a human readable OTR fingerprint available with the above +    contexts command. + +    Examples: %9/otr distrust 487FFADA 5073FEDD C5AB5C14 5BB6C1FF 6D40D48A%n + +FINISH +    End the OTR session. This MUST be done inside a private conversation +    window. + +FORGET <fingerprint> +    Forget a specific fingerprint (deleted from the known fingerprints). The +    behavior is the same as the distrust command explained above. + +GENKEY <name> +    Generate OTR keys for a given account name. This is done automatically +    if someone tries to establish a secure session. + +    This process is done in a background worker and can take an arbitrary +    amount of time. The completion is checked when another irssi event is +    catched. + +HELP +    Print this help. + +INFO +    Display the OTR fingerprint(s) of all your account(s). + +INIT +    Initialize an OTR conversation within a private conversation window. + +TRUST <fingerprint> +    Trust a specific fingerprint. The behavior is the same as the forget and +    distrust commands explained above. + +VERSION +    Print the version of the OTR module. + +%9Quickstart:%n + +Start a private conversation with the person you want to initiate a secure +session. Once in the private message window: + +%9/otr init%n + +Key generation should start if no key is found for your account name. Once the +process is done, either type a message which should automatically start the +session or redo the init command. + +Time to authenticate the person. Either use a shared secret exchange through +phone or GPG-signed email or use the socialist millionaire problem mechanism +(SMP) which is basically to ask a question for which the answer can only be +known by the other person. + +%9/otr auth <shared-secret>%n OR %9/otr authq \"A question\" <shared-secret>%n + +Or to respond to an authentication: + +%9/otr auth <secret>%n + +%9Files:%n + +This otr modules creates a directory in %9$HOME/.irssi/otr%n and creates three +files: + +* %9otr.key%n +    Contains your OTR private key(s). NEVER shared this directory with someone +    else unless you know what you are doing. + +* %9otr.fp%n +    The known fingerprints with their _trust_ status. + +* %9otr.instag +    Instance tag of the libotr. This should NEVER be copied to an other +    computer. If unsure, just ignore this file. + +For more information on OTR, see https://otr.cypherpunks.ca/ + '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','signals.txt','274','0','6','0','MODIFY','@@ -350,3 +350,9 @@ Perl  ----    \"script error\", PERL_SCRIPT_REC, char *errormsg + +OTR Core +-------- + +otr.c: + \"otr event\", SERVER_REC, char *nick, char *status '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','libotr.m4','105','0','134','0','ADD','@@ -0,0 +1,134 @@ +dnl +dnl  Off-the-Record Messaging library +dnl  Copyright (C) 2004-2007  Ian Goldberg, Chris Alexander, Nikita Borisov +dnl                           <otr@cypherpunks.ca> +dnl +dnl  This library is free software; you can redistribute it and/or +dnl  modify it under the terms of version 2.1 of the GNU Lesser General +dnl  Public License as published by the Free Software Foundation. +dnl +dnl  This library is distributed in the hope that it will be useful, +dnl  but WITHOUT ANY WARRANTY; without even the implied warranty of +dnl  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU +dnl  Lesser General Public License for more details. +dnl +dnl  You should have received a copy of the GNU Lesser General Public +dnl  License along with this library; if not, write to the Free Software +dnl  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA +dnl + +dnl AM_PATH_LIBOTR([MINIMUM-VERSION [, ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]]) +dnl Test for libotr, and define LIBOTR_CFLAGS and LIBOTR_LIBS as appropriate. +dnl enables arguments --with-libotr-prefix= +dnl                   --with-libotr-inc-prefix= +dnl +dnl You must already have found libgcrypt with AM_PATH_LIBGCRYPT +dnl +dnl Adapted from alsa.m4, originally by +dnl      Richard Boulton <richard-alsa@tartarus.org> +dnl      Christopher Lansdown <lansdoct@cs.alfred.edu> +dnl      Jaroslav Kysela <perex@suse.cz> + +AC_DEFUN([AM_PATH_LIBOTR], +[dnl Save the original CFLAGS, LDFLAGS, and LIBS +libotr_save_CFLAGS=\"$CFLAGS\" +libotr_save_LDFLAGS=\"$LDFLAGS\" +libotr_save_LIBS=\"$LIBS\" +libotr_found=yes + +dnl +dnl Get the cflags and libraries for libotr +dnl +AC_ARG_WITH(libotr-prefix, +[  --with-libotr-prefix=PFX  Prefix where libotr is installed(optional)], +[libotr_prefix=\"$withval\"], [libotr_prefix=\"\"]) + +AC_ARG_WITH(libotr-inc-prefix, +[  --with-libotr-inc-prefix=PFX  Prefix where libotr includes are (optional)], +[libotr_inc_prefix=\"$withval\"], [libotr_inc_prefix=\"\"]) + +dnl Add any special include directories +AC_MSG_CHECKING(for libotr CFLAGS) +if test \"$libotr_inc_prefix\" != \"\" ; then +	LIBOTR_CFLAGS=\"$LIBOTR_CFLAGS -I$libotr_inc_prefix\" +	CFLAGS=\"$CFLAGS $LIBOTR_CFLAGS\" +fi +AC_MSG_RESULT($LIBOTR_CFLAGS) + +dnl add any special lib dirs +AC_MSG_CHECKING(for libotr LIBS) +if test \"$libotr_prefix\" != \"\" ; then +	LIBOTR_LIBS=\"$LIBOTR_LIBS -L$libotr_prefix\" +	LDFLAGS=\"$LDFLAGS $LIBOTR_LIBS\" +fi + +dnl add the libotr library +LIBOTR_LIBS=\"$LIBOTR_LIBS -lotr\" +LIBS=\"$LIBOTR_LIBS $LIBS\" +AC_MSG_RESULT($LIBOTR_LIBS) + +dnl Check for a working version of libotr that is of the right version. +min_libotr_version=ifelse([$1], ,3.0.0,$1) +no_libotr=\"\" +    libotr_min_major_version=`echo $min_libotr_version | \\ +           sed \'s/\\([[0-9]]*\\).\\([[0-9]]*\\).\\([[0-9]]*\\)/\\1/\'` +    libotr_min_minor_version=`echo $min_libotr_version | \\ +           sed \'s/\\([[0-9]]*\\).\\([[0-9]]*\\).\\([[0-9]]*\\)/\\2/\'` +    libotr_min_sub_version=`echo $min_libotr_version | \\ +           sed \'s/\\([[0-9]]*\\).\\([[0-9]]*\\).\\([[0-9]]*\\)/\\3/\'` +AC_MSG_CHECKING(for libotr headers version $libotr_min_major_version.x >= $min_libotr_version) + +AC_LANG_SAVE +AC_LANG_C +AC_TRY_COMPILE([ +#include <stdlib.h> +#include <libotr/version.h> +], [ +#  if(OTRL_VERSION_MAJOR != $libotr_min_major_version) +#    error not present +#  else + +#    if(OTRL_VERSION_MINOR > $libotr_min_minor_version) +       exit(0); +#    else +#      if(OTRL_VERSION_MINOR < $libotr_min_minor_version) +#        error not present +#      endif + +#      if(OTRL_VERSION_SUB < $libotr_min_sub_version) +#        error not present +#      endif +#    endif +#  endif +exit(0); +], +  [AC_MSG_RESULT(found.)], +  [AC_MSG_RESULT(not present.) +   ifelse([$3], , [AC_MSG_ERROR(Sufficiently new version of libotr not found.)]) +   libotr_found=no] +) +AC_LANG_RESTORE + +dnl Now that we know that we have the right version, let\'s see if we have the library and not just the headers. +AC_CHECK_LIB([otr], [otrl_message_receiving],, +	[ifelse([$3], , [AC_MSG_ERROR(No linkable libotr was found.)]) +	 libotr_found=no], +	 $LIBGCRYPT_LIBS +) + +LDFLAGS=\"$libotr_save_LDFLAGS\" +LIBS=\"$libotr_save_LIBS\" + +if test \"x$libotr_found\" = \"xyes\" ; then +   ifelse([$2], , :, [$2]) +else +   LIBOTR_CFLAGS=\"\" +   LIBOTR_LIBS=\"\" +   ifelse([$3], , :, [$3]) +fi + +dnl That should be it.  Now just export our symbols: +AC_SUBST(LIBOTR_CFLAGS) +AC_SUBST(LIBOTR_LIBS) +]) + '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','Makefile.am','19','0','5','1','MODIFY','@@ -14,8 +14,12 @@ if HAVE_PERL  PERLDIR=perl  endif   +if HAVE_OTR +OTRDIR=otr +endif +  pkginc_srcdir=$(pkgincludedir)/src  pkginc_src_HEADERS = \\  	common.h   -SUBDIRS = lib-config core irc fe-common $(PERLDIR) $(TEXTUI) $(BOTUI) $(FUZZERUI) +SUBDIRS = lib-config core irc fe-common $(PERLDIR) $(OTRDIR) $(TEXTUI) $(BOTUI) $(FUZZERUI) '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','net-nonblock.c','169','28','0','35','MODIFY','@@ -35,41 +35,6 @@ typedef struct {  	int tag;  } SIMPLE_THREAD_REC;   -static int g_io_channel_write_block(GIOChannel *channel, void *data, int len) -{ -        gsize ret; -	int sent; -	GIOStatus status; - -	sent = 0; -	do { -		status = g_io_channel_write_chars(channel, (char *) data + sent, -						  len-sent, &ret, NULL); -                sent += ret; -	} while (sent < len && status != G_IO_STATUS_ERROR); - -	return sent < len ? -1 : 0; -} - -static int g_io_channel_read_block(GIOChannel *channel, void *data, int len) -{ -	time_t maxwait; -        gsize ret; -	int received; -	GIOStatus status; - -	maxwait = time(NULL)+2; -	received = 0; -	do { -		status = g_io_channel_read_chars(channel, (char *) data + received, -						 len-received, &ret, NULL); -		received += ret; -	} while (received < len && time(NULL) < maxwait && -		 status != G_IO_STATUS_ERROR && status != G_IO_STATUS_EOF); - -	return received < len ? -1 : 0; -} -  /* nonblocking gethostbyname(), ip (IPADDR) + error (int, 0 = not error) is     written to pipe when found PID of the resolver child is returned */  int net_gethostbyname_nonblock(const char *addr, GIOChannel *pipe, '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','network.c','393','107','33','0','MODIFY','@@ -48,6 +48,39 @@ GIOChannel *g_io_channel_new(int handle)  	return chan;  }   +int g_io_channel_write_block(GIOChannel *channel, void *data, int len) +{ +	gsize ret; +	int sent; +	GIOStatus status; + +	sent = 0; +	do { +		status = g_io_channel_write_chars(channel, (char *) data + sent, len - sent, &ret, NULL); +		sent += ret; +	} while (sent < len && status != G_IO_STATUS_ERROR); + +	return sent < len ? -1 : 0; +} + +int g_io_channel_read_block(GIOChannel *channel, void *data, int len) +{ +	time_t maxwait; +	gsize ret; +	int received; +	GIOStatus status; + +	maxwait = time(NULL)+2; +	received = 0; +	do { +		status = g_io_channel_read_chars(channel, (char *) data + received, len - received, &ret, NULL); +		received += ret; +	} while (received < len && time(NULL) < maxwait && +		status != G_IO_STATUS_ERROR && status != G_IO_STATUS_EOF); + +	return received < len ? -1 : 0; +} +  IPADDR ip4_any = {  	AF_INET,  #if defined(IN6ADDR_ANY_INIT) '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','network.h','37','0','2','0','MODIFY','@@ -36,6 +36,8 @@ GIOChannel *g_io_channel_new(int handle);  /* Returns 1 if IPADDRs are the same. */  /* Deprecated since it is unused. It will be deleted in a later release. */  int net_ip_compare(IPADDR *ip1, IPADDR *ip2) G_GNUC_DEPRECATED; +int g_io_channel_write_block(GIOChannel *channel, void *data, int len); +int g_io_channel_read_block(GIOChannel *channel, void *data, int len);    int net_connect_ip_handle(const IPADDR *ip, int port, const IPADDR *my_ip);   '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','Makefile.am','64','0','4','1','MODIFY','@@ -9,7 +9,8 @@ AM_CPPFLAGS = \\  irssi_DEPENDENCIES = \\  	@COMMON_LIBS@ \\  	@PERL_LINK_LIBS@ \\ -	@PERL_FE_LINK_LIBS@ +	@PERL_FE_LINK_LIBS@ \\ +	@OTR_LINK_LIBS@    irssi_LDFLAGS = -export-dynamic   @@ -17,6 +18,8 @@ irssi_LDADD = \\  	@COMMON_LIBS@ \\  	@PERL_LINK_LIBS@ \\  	@PERL_FE_LINK_LIBS@ \\ +	@OTR_LINK_LIBS@ \\ +	@OTR_LINK_FLAGS@ \\  	@PERL_LINK_FLAGS@ \\  	@PROG_LIBS@ \\  	@TEXTUI_LIBS@ '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','irssi.c','231','32','15','2','MODIFY','@@ -54,6 +54,11 @@ void fe_perl_init(void);  void fe_perl_deinit(void);  #endif   +#ifdef HAVE_STATIC_OTR +void otr_core_init(void); +void otr_core_deinit(void); +#endif +  void irc_init(void);  void irc_deinit(void);   @@ -183,6 +188,10 @@ static void textui_finish_init(void)  	fe_perl_init();  #endif   +#ifdef HAVE_STATIC_OTR +	otr_core_init(); +#endif +  	dirty_check();    	fe_common_core_finish_init(); @@ -221,8 +230,12 @@ static void textui_deinit(void)  		module_unload(modules->data);    #ifdef HAVE_STATIC_PERL -        perl_core_deinit(); -        fe_perl_deinit(); +	perl_core_deinit(); +	fe_perl_deinit(); +#endif + +#ifdef HAVE_STATIC_OTR +	otr_core_deinit();  #endif    	dirty_check(); /* one last time to print any quit messages */ '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','Makefile.am','34','0','42','0','ADD','@@ -0,0 +1,42 @@ +moduledir = $(libdir)/irssi/modules + +module_LTLIBRARIES = $(otr_module_lib) +noinst_LTLIBRARIES = $(otr_static_lib) + +EXTRA_LTLIBRARIES = \\ +	libotr_core.la \\ +	libotr_core_static.la + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core/ \\ +	-I$(top_srcdir)/src/irc/core/ \\ +	-I$(top_srcdir)/src/fe-common/core/ \\ +	-I$(top_srcdir)/src/fe-text/ \\ +	$(GLIB_CFLAGS) \\ +	$(OTR_CFLAGS) + +libotr_core_la_LDFLAGS = -module -avoid-version -rpath $(moduledir) +libotr_core_la_LIBADD = $(OTR_LDFLAGS) + +otr_sources = \\ +	key.c \\ +	module.c \\ +	otr-formats.c \\ +	otr-ops.c \\ +	otr-fe.c \\ +	otr.c + +libotr_core_la_SOURCES = \\ +	$(otr_sources) + +libotr_core_static_la_SOURCES = \\ +	$(otr_sources) + +noinst_HEADERS = \\ +	irssi-otr.h \\ +	key.h \\ +	module.h \\ +	otr-formats.h \\ +	otr-fe.h \\ +	otr.h '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','irssi-otr.h','0','0','39','0','ADD','@@ -0,0 +1,39 @@ +/* + * Off-the-Record Messaging (OTR) module for the irssi IRC client + * + * Copyright (C) 2008 - Uli Meis <a.sporto+bee@gmail.com> + *               2012 - David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#ifndef IRSSI_IRSSI_OTR_H +#define IRSSI_IRSSI_OTR_H + +/* Ease our life a bit. */ +#define OTR_IRSSI_MSG_PREFIX	\"%9OTR%9: \" + +/* + * Irssi macros for printing text to console. + */ +#define IRSSI_OTR_DEBUG(fmt, ...) \\ +	do {                                                                    \\ +		if (otr_debug_get()) {                                              \\ +			printtext(NULL, NULL, MSGLEVEL_MSGS, OTR_IRSSI_MSG_PREFIX fmt,  \\ +						## __VA_ARGS__);                                    \\ +		}                                                                   \\ +	} while (0) + +#endif /* IRSSI_IRSSI_OTR_H */ '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','key.c','253','27','402','0','ADD','@@ -0,0 +1,402 @@ +/* + * Off-the-Record Messaging (OTR) modules for IRC + * + * Copyright (C) 2008 - Uli Meis <a.sporto+bee@gmail.com> + *               2012 - David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#define _GNU_SOURCE +#include <glib.h> +#include <libgen.h> +#include <sys/types.h> +#include <sys/wait.h> +#include <sys/poll.h> +#include <signal.h> +#include <unistd.h> + +#include \"key.h\" + +#include \"levels.h\" +#include \"network.h\" +#include \"pidwait.h\" +#include \"printtext.h\" + +#include \"irssi-otr.h\" +#include \"otr-formats.h\" + +/* + * Status of key generation. + */ +enum key_gen_status { +	KEY_GEN_IDLE		= 0, +	KEY_GEN_RUNNING		= 1, +	KEY_GEN_FINISHED	= 2, +	KEY_GEN_ERROR		= 3, +}; + +/* + * Data of the state of key generation. + */ +struct key_gen_data { +	struct otr_user_state *ustate; +	char *account_name; +	char *key_file_path; +	enum key_gen_status status; +	gcry_error_t gcry_error; +}; + +/* + * Event from the key generation process. + */ +struct key_gen_event { +	enum key_gen_status status; +	gcry_error_t error; +}; + +/* + * Key generation process. + */ +struct key_gen_worker { +	int tag; +	GIOChannel *pipes[2]; +}; + +/* + * Key generation data for the thread in charge of creating the key. + */ +static struct key_gen_data key_gen_state = { +	.status = KEY_GEN_IDLE, +	.gcry_error = GPG_ERR_NO_ERROR, +}; + +/* + * Build file path concatenate to the irssi config dir. + */ +static char *file_path_build(const char *path) +{ +	g_return_val_if_fail(path != NULL, NULL); + +	/* Either NULL or the filename is returned here which is valid. */ +	return g_strdup_printf(\"%s/%s\", get_irssi_dir(), path); +} + +/* + * Emit a key generation status event. + */ +static void emit_event(GIOChannel *pipe, enum key_gen_status status, gcry_error_t error) +{ +	struct key_gen_event event; + +	g_return_if_fail(pipe != NULL); + +	event.status = status; +	event.error = error; + +	g_io_channel_write_block(pipe, &event, sizeof(event)); +} + +/* + * Reset key generation state and status is IDLE. + */ +static void reset_key_gen_state(void) +{ +	/* Safety. */ +	g_free(key_gen_state.key_file_path); +	g_free(key_gen_state.account_name); + +	/* Nullify everything. */ +	memset(&key_gen_state, 0, sizeof(key_gen_state)); +	key_gen_state.status = KEY_GEN_IDLE; +	key_gen_state.gcry_error = GPG_ERR_NO_ERROR; +} + +/* + * Read status event from key generation worker. + */ +static void read_key_gen_status(struct key_gen_worker *worker, GIOChannel *pipe) +{ +	struct key_gen_event event; +	gcry_error_t err; + +	g_return_if_fail(worker != NULL); + +	fcntl(g_io_channel_unix_get_fd(pipe), F_SETFL, O_NONBLOCK); + +	if (g_io_channel_read_block(pipe, &event, sizeof(event)) == -1) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +				TXT_OTR_KEYGEN_FAILED, +				key_gen_state.account_name, +				g_strerror(errno)); +		return; +	} + +	key_gen_state.status = event.status; +	key_gen_state.gcry_error = event.error; + +	if (event.status == KEY_GEN_FINISHED || event.status == KEY_GEN_ERROR) { +		/* Worker is done. */ +		g_source_remove(worker->tag); + +		g_io_channel_shutdown(worker->pipes[0], TRUE, NULL); +		g_io_channel_unref(worker->pipes[0]); + +		g_io_channel_shutdown(worker->pipes[1], TRUE, NULL); +		g_io_channel_unref(worker->pipes[1]); + +		g_free(worker); + +		if (event.status == KEY_GEN_ERROR) { +			printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +					TXT_OTR_KEYGEN_FAILED, +					key_gen_state.account_name, +					gcry_strerror(key_gen_state.gcry_error)); +			reset_key_gen_state(); +			return; +		} + +		err = otrl_privkey_read(key_gen_state.ustate->otr_state, key_gen_state.key_file_path); + +		if (err != GPG_ERR_NO_ERROR) { +			printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +					TXT_OTR_KEYGEN_FAILED, +					key_gen_state.account_name, +					gcry_strerror(key_gen_state.gcry_error)); +		} else { +			printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, +					TXT_OTR_KEYGEN_COMPLETED, +					key_gen_state.account_name); +		} + +		reset_key_gen_state(); +	} +} + +/* + * Run key generation in a seperate process (takes ages). The other process + * will rewrite the key file, we shouldn\'t change anything till it\'s done and + * we\'ve reloaded the keys. + */ +void key_gen_run(struct otr_user_state *ustate, const char *account_name) +{ +	struct key_gen_worker *worker; +	int fd[2]; +	gcry_error_t err; +	pid_t pid; + +	g_return_if_fail(ustate != NULL); +	g_return_if_fail(account_name != NULL); + +	if (key_gen_state.status != KEY_GEN_IDLE) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_OTR_KEYGEN_RUNNING, key_gen_state.account_name); +		return; +	} + +	/* Make sure the pointer does not go away during the proess. */ +	key_gen_state.account_name = strdup(account_name); +	key_gen_state.ustate = ustate; + +	/* Creating key file path. */ +	key_gen_state.key_file_path = file_path_build(OTR_KEYFILE); +	if (key_gen_state.key_file_path == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +				TXT_OTR_KEYGEN_FAILED, +				key_gen_state.account_name, +				g_strerror(errno)); +		reset_key_gen_state(); +		return; +	} + +	printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_OTR_KEYGEN_STARTED, key_gen_state.account_name); + +	if (pipe(fd) != 0) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +				TXT_OTR_KEYGEN_FAILED, +				key_gen_state.account_name, +				g_strerror(errno)); +		reset_key_gen_state(); +		return; +	} + +	worker = g_new0(struct key_gen_worker, 1); + +	if (worker == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +				TXT_OTR_KEYGEN_FAILED, +				key_gen_state.account_name, +				g_strerror(errno)); +		reset_key_gen_state(); +		return; +	} + +	worker->pipes[0] = g_io_channel_new(fd[0]); +	worker->pipes[1] = g_io_channel_new(fd[1]); + +	pid = fork(); + +	if (pid > 0) { +		/* Parent process */ +		pidwait_add(pid); +		worker->tag = g_input_add(worker->pipes[0], G_INPUT_READ, (GInputFunction)read_key_gen_status, worker); +		return; +	} + +	if (pid != 0) { +		/* error */ +		g_warning(\"Key generation failed: %s\", g_strerror(errno)); + +		g_source_remove(worker->tag); + +		g_io_channel_shutdown(worker->pipes[0], TRUE, NULL); +		g_io_channel_unref(worker->pipes[0]); + +		g_io_channel_shutdown(worker->pipes[1], TRUE, NULL); +		g_io_channel_unref(worker->pipes[1]); + +		g_free(worker); + +		return; +	} + +	/* Child process */ +	key_gen_state.status = KEY_GEN_RUNNING; +	emit_event(worker->pipes[1], KEY_GEN_RUNNING, GPG_ERR_NO_ERROR); + +	err = otrl_privkey_generate(key_gen_state.ustate->otr_state, key_gen_state.key_file_path, key_gen_state.account_name, OTR_PROTOCOL_ID); + +	if (err != GPG_ERR_NO_ERROR) { +		emit_event(worker->pipes[1], KEY_GEN_ERROR, err); +		_exit(99); +		return; +	} + +	emit_event(worker->pipes[1], KEY_GEN_FINISHED, GPG_ERR_NO_ERROR); + +	_exit(99); +} + +/* + * Write fingerprints to file. + */ +void key_write_fingerprints(struct otr_user_state *ustate) +{ +	gcry_error_t err; +	char *filename; + +	g_return_if_fail(ustate != NULL); + +	filename = file_path_build(OTR_FINGERPRINTS_FILE); +	g_return_if_fail(filename != NULL); + +	err = otrl_privkey_write_fingerprints(ustate->otr_state, filename); +	if (err == GPG_ERR_NO_ERROR) { +		IRSSI_OTR_DEBUG(\"Fingerprints saved to %9%s%9\", filename); +	} else { +		IRSSI_OTR_DEBUG(\"Error writing fingerprints: %d (%d)\", +				gcry_strerror(err), gcry_strsource(err)); +	} + +	g_free(filename); +} + +/* + * Write instance tags to file. + */ +void key_write_instags(struct otr_user_state *ustate) +{ +	gcry_error_t err; +	char *filename; + +	g_return_if_fail(ustate != NULL); + +	filename = file_path_build(OTR_INSTAG_FILE); +	g_return_if_fail(filename != NULL); + +	err = otrl_instag_write(ustate->otr_state, filename); +	if (err == GPG_ERR_NO_ERROR) { +		IRSSI_OTR_DEBUG(\"Instance tags saved in %9%s%9\", filename); +	} else { +		IRSSI_OTR_DEBUG(\"Error saving instance tags: %d (%d)\", +				gcry_strerror(err), gcry_strsource(err)); +	} + +	g_free(filename); +} + +/* + * Load private keys. + */ +void key_load(struct otr_user_state *ustate) +{ +	int ret; +	gcry_error_t err; +	char *filename; + +	g_return_if_fail(ustate != NULL); + +	filename = file_path_build(OTR_KEYFILE); +	g_return_if_fail(filename != NULL); + +	ret = access(filename, F_OK); +	if (ret < 0) { +		IRSSI_OTR_DEBUG(\"No private keys found in %9%s%9\", filename); +		g_free(filename); +		return; +	} + +	err = otrl_privkey_read(ustate->otr_state, filename); +	if (err == GPG_ERR_NO_ERROR) { +		IRSSI_OTR_DEBUG(\"Private keys loaded from %9%s%9\", filename); +	} else { +		IRSSI_OTR_DEBUG(\"Error loading private keys: %d (%d)\", +				gcry_strerror(err), gcry_strsource(err)); +	} + +	g_free(filename); +} + +/* + * Load fingerprints. + */ +void key_load_fingerprints(struct otr_user_state *ustate) +{ +	int ret; +	gcry_error_t err; +	char *filename; + +	g_return_if_fail(ustate != NULL); + +	filename = file_path_build(OTR_FINGERPRINTS_FILE); +	g_return_if_fail(filename != NULL); + +	ret = access(filename, F_OK); +	if (ret < 0) { +		IRSSI_OTR_DEBUG(\"No fingerprints found in %9%s%9\", filename); +		g_free(filename); +		return; +	} + +	err = otrl_privkey_read_fingerprints(ustate->otr_state, filename, NULL, +			NULL); +	if (err == GPG_ERR_NO_ERROR) { +		IRSSI_OTR_DEBUG(\"Fingerprints loaded from %9%s%9\", filename); +	} else { +		IRSSI_OTR_DEBUG(\"Error loading fingerprints: %d (%d)\", +				gcry_strerror(err), gcry_strsource(err)); +	} + +	g_free(filename); +} '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','key.h','8','0','35','0','ADD','@@ -0,0 +1,35 @@ +/* + * Off-the-Record Messaging (OTR) modules for IRC + * + * Copyright (C) 2012 - David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#ifndef IRSSI_OTR_KEY_H +#define IRSSI_OTR_KEY_H + +#include \"common.h\" +#include \"servers.h\" + +#include \"otr.h\" + +void key_gen_run(struct otr_user_state *ustate, const char *account_name); +void key_load(struct otr_user_state *ustate); +void key_load_fingerprints(struct otr_user_state *ustate); +void key_write_fingerprints(struct otr_user_state *ustate); +void key_write_instags(struct otr_user_state *ustate); + +#endif /* IRSSI_OTR_KEY_H */ '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','module.c','144','28','261','0','ADD','@@ -0,0 +1,261 @@ +/* + * Off-the-Record Messaging (OTR) module for the irssi IRC client + * + * Copyright (C) 2008  Uli Meis <a.sporto+bee@gmail.com> + *               2012  David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#define _GNU_SOURCE +#include <glib.h> + +#include \"module.h\" + +#include \"signals.h\" +#include \"queries.h\" +#include \"commands.h\" + +#include \"irc.h\" +#include \"irc-servers.h\" +#include \"irc-queries.h\" +#include \"irc-commands.h\" + +#include \"key.h\" +#include \"otr.h\" +#include \"otr-formats.h\" +#include \"otr-fe.h\" +#include \"misc.h\" + +/* + * Global state for the user. Init when the module loads. + */ +struct otr_user_state *user_state_global; + +/* + * Pipes all outgoing private messages through OTR + */ +static void sig_server_sendmsg(SERVER_REC *server, const char *target, +		const char *msg, void *target_type_p) +{ +	char *otrmsg = NULL; + +	if (GPOINTER_TO_INT(target_type_p) != SEND_TARGET_NICK) { +		otrl_message_free(otrmsg); +		return; +	} + +	/* Critical section. On error, message MUST NOT be sent */ +	if (otr_send(server, msg, target, &otrmsg)) { +		signal_stop(); +		otrl_message_free(otrmsg); +		return; +	} + +	if (otrmsg == NULL) { +		/* Send original message */ +		signal_continue(4, server, target, msg, target_type_p); +	} else { +		/* Send encrypted message */ +		signal_continue(4, server, target, otrmsg, target_type_p); +	} + +	otrl_message_free(otrmsg); +} + +/* + * Pipes all incoming private messages through OTR + */ +void sig_message_private(SERVER_REC *server, const char *msg, const char *nick, const char *address) +{ +	char *new_msg = NULL; + +	if (otr_receive(server, msg, nick, &new_msg)) { +		signal_stop(); +		otrl_message_free(new_msg); +		return; +	} + +	if (new_msg == NULL) { +		/* This message was not OTR */ +		signal_continue(4, server, msg, nick, address); +	} else { +		/* +		 * Check for /me IRC marker and if so, handle it so the user does not +		 * receive a message beginning with /me but rather let irssi handle it +		 * as a IRC action. +		 */ +		if (strncmp(new_msg, OTR_IRC_MARKER_ME, OTR_IRC_MARKER_ME_LEN) == 0) { +			signal_stop(); +			signal_emit(\"message irc action\", 5, server, new_msg + OTR_IRC_MARKER_ME_LEN, nick, address, nick); +		} else { +			/* OTR received message */ +			signal_continue(4, server, new_msg, nick, address); +		} +	} + +	otrl_message_free(new_msg); +} + +/* + * Finish an OTR conversation when its query is closed. + */ +static void sig_query_destroyed(QUERY_REC *query) +{ +	if (query && query->server && query->server->connrec) { +		otr_finish(query->server, query->name); +	} +} + +/* + * Handle /me IRC command. + */ +static void cmd_me(const char *data, IRC_SERVER_REC *server, +		WI_ITEM_REC *item) +{ +	const char *target; +	char *msg, *otrmsg = NULL; +	QUERY_REC *query; + +	query = QUERY(item); + +	if (query == NULL || query->server == NULL) { +		return; +	} + +	CMD_IRC_SERVER(server); +	if (!IS_IRC_QUERY(query)) { +		return; +	} + +	if (server == NULL || !server->connected) { +		cmd_return_error(CMDERR_NOT_CONNECTED); +	} + +	target = window_item_get_target(item); + +	msg = g_strdup_printf(OTR_IRC_MARKER_ME \"%s\", data); +	g_return_if_fail(msg != NULL); + +	/* Critical section. On error, message MUST NOT be sent */ +	otr_send(query->server, msg, target, &otrmsg); +	g_free(msg); + +	if (otrmsg == NULL) { +		return; +	} + +	signal_stop(); + +	if (otrmsg) { +		/* Send encrypted message */ +		otr_send_message(SERVER(server), target, otrmsg); +		otrl_message_free(otrmsg); +	} + +	signal_emit(\"message irc own_action\", 3, server, data, item->visible_name); +} + +/* + * Optionally finish conversations on /quit. We\'re already doing this on unload + * but the quit handler terminates irc connections before unloading. + */ +static void cmd_quit(const char *data, void *server, WI_ITEM_REC *item) +{ +	otr_finishall(user_state_global); +} + +/* + * Create otr module directory if none exists. + */ +static void create_module_dir(void) +{ +	char *dir_path = NULL; +	struct stat statbuf; + +	/* Create ~/.irssi/otr directory. */ +	dir_path = g_strdup_printf(\"%s/%s\", get_irssi_dir(), OTR_DIR); +	g_return_if_fail(dir_path != NULL); + +	if (stat(dir_path, &statbuf) != 0) { +		if (g_mkdir_with_parents(dir_path, 0700) != 0) +			g_warning(\"Unable to create OTR directory path.\"); +	} else if (!S_ISDIR(statbuf.st_mode)) { +		g_warning(\"%s is not a directory.\", dir_path); +		g_warning(\"You should remove it with command: rm %s\", dir_path); +	} + +	g_free(dir_path); +} + +void otr_send_message(SERVER_REC *server, const char *recipient, const char *msg) +{ +	/* +	 * Apparently, there are cases where the server record is NULL which has +	 * been reported with the irssi xmpp plugin. In that case, just return an +	 * do nothing. +	 */ +	g_return_if_fail(server != NULL); + +	server->send_message(server, recipient, msg, GPOINTER_TO_INT(SEND_TARGET_NICK)); +} + +/* + * irssi init() + */ +void otr_core_init(void) +{ +	module_register(\"otr\", \"core\"); + +	create_module_dir(); + +	otr_lib_init(); + +	user_state_global = otr_init_user_state(); +	g_return_if_fail(user_state_global != NULL); + +	signal_add_first(\"server sendmsg\", (SIGNAL_FUNC) sig_server_sendmsg); +	signal_add_first(\"message private\", (SIGNAL_FUNC) sig_message_private); +	signal_add(\"query destroyed\", (SIGNAL_FUNC) sig_query_destroyed); + +	command_bind_first(\"quit\", NULL, (SIGNAL_FUNC) cmd_quit); +	command_bind_irc_first(\"me\", NULL, (SIGNAL_FUNC) cmd_me); + +	otr_fe_init(); +} + +/* + * irssi deinit() + */ +void otr_core_deinit(void) +{ +	signal_remove(\"server sendmsg\", (SIGNAL_FUNC) sig_server_sendmsg); +	signal_remove(\"message private\", (SIGNAL_FUNC) sig_message_private); +	signal_remove(\"query destroyed\", (SIGNAL_FUNC) sig_query_destroyed); + +	otr_fe_deinit(); + +	command_unbind(\"quit\", (SIGNAL_FUNC) cmd_quit); +	command_unbind(\"me\", (SIGNAL_FUNC) cmd_me); + +	otr_finishall(user_state_global); + +	/* Remove glib timer if any. */ +	otr_control_timer(0, NULL); + +	otr_free_user_state(user_state_global); + +	otr_lib_uninit(); +} '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','module.h','3','0','29','0','ADD','@@ -0,0 +1,29 @@ +/* + * Off-the-Record Messaging (OTR) module for the irssi IRC client + * + * Copyright (C) 2012 - David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#ifndef IRSSI_OTR_MODULE +#define IRSSI_OTR_MODULE + +#include \"common.h\" +#include \"servers.h\" + +void sig_message_private(SERVER_REC *server, const char *msg, const char *nick, const char *address); + +#endif /* IRSSI_OTR_MODULE */ '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr-fe.c','231','59','344','0','ADD','@@ -0,0 +1,344 @@ +/* + * Off-the-Record Messaging (OTR) module for the irssi IRC client + * + * Copyright (C) 2008  Uli Meis <a.sporto+bee@gmail.com> + *               2012  David Goulet <dgoulet@ev0ke.net> + *               2014  Alexander FÃ¦rÃ¸y <ahf@0x90.dk> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#include \"common.h\" +#include \"levels.h\" +#include \"printtext.h\" +#include \"commands.h\" +#include \"irc.h\" +#include \"irc-servers.h\" +#include \"irc-queries.h\" +#include \"statusbar-item.h\" + +#include \"otr.h\" +#include \"otr-formats.h\" +#include \"key.h\" + +static void cmd_otr(const char *data, SERVER_REC *server, void *item) +{ +	if (*data == \'\\0\') +		data = \"info\"; // FIXME(ahf): Is this really what we want as default? + +	command_runsub(\"otr\", data, server, item); + +	// We always redraw the OTR statusbar, just in case. +	statusbar_items_redraw(\"otr\"); +} + +static void cmd_otr_debug(const char *data) +{ +	otr_debug_toggle(); + +	if (otr_debug_get()) +		printtext(NULL, NULL, MSGLEVEL_CRAP, \"OTR debugging enabled\"); +	else +		printtext(NULL, NULL, MSGLEVEL_CRAP, \"OTR debugging disabled\"); +} + +static void cmd_otr_init(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; +	ConnContext *ctx; + +	g_return_if_fail(server != NULL); + +	if (!server->connected) +		cmd_return_error(CMDERR_NOT_CONNECTED); + +	if (!IS_QUERY(item)) +		cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS); + +	query = QUERY(item); +	target = query->name; + +	ctx = otr_find_context(server, target, FALSE); +	if (ctx && ctx->msgstate == OTRL_MSGSTATE_ENCRYPTED) { +		printformat(server, target, MSGLEVEL_CRAP, TXT_OTR_SESSION_ALREADY_SECURED, ctx->accountname); +		return; +	} + +	printformat(server, target, MSGLEVEL_CRAP, TXT_OTR_SESSION_INITIATING); + +	/* +	 * Irssi does not handle well the HTML tag in the default OTR query message +	 * so just send the OTR tag instead. Contact me for a better fix! :) +	 */ +	otr_send_message(server, target, \"?OTRv23?\"); +} + +static void cmd_otr_finish(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; + +	g_return_if_fail(server != NULL); + +	if (!server->connected) +		cmd_return_error(CMDERR_NOT_CONNECTED); + +	if (!IS_QUERY(item)) +		cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS); + +	query = QUERY(item); +	target = query->name; + +	otr_finish(server, target); +} + +static void cmd_otr_trust(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; + +	char *fingerprint, *human_fingerprint; +	void *free_arg; + +	g_return_if_fail(server != NULL); + +	query = QUERY(item); +	target = query ? query->name : NULL; + +	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_GETREST, &fingerprint)) +		return; + +	// We fallback to target if fingerprint isn\'t specified. +	if (*fingerprint == \'\\0\' && target == NULL) +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); + +	human_fingerprint = g_ascii_strup(fingerprint, -1); +	otr_trust(server, target, human_fingerprint, user_state_global); +	g_free(human_fingerprint); + +	cmd_params_free(free_arg); +} + +static void cmd_otr_distrust(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; + +	char *fingerprint, *human_fingerprint; +	void *free_arg; + +	g_return_if_fail(server != NULL); + +	query = QUERY(item); +	target = query ? query->name : NULL; + +	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_GETREST, &fingerprint)) +		return; + +	// We fallback to target if fingerprint isn\'t specified. +	if (*fingerprint == \'\\0\' && target == NULL) +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); + +	human_fingerprint = g_ascii_strup(fingerprint, -1); +	otr_distrust(server, target, human_fingerprint, user_state_global); +	g_free(human_fingerprint); + +	cmd_params_free(free_arg); +} + +static void cmd_otr_forget(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; + +	char *fingerprint, *human_fingerprint; +	void *free_arg; + +	g_return_if_fail(server != NULL); + +	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_GETREST, &fingerprint)) +		return; + +	query = QUERY(item); +	target = query ? query->name : NULL; + +	// We fallback to target if fingerprint isn\'t specified. +	if (*fingerprint == \'\\0\' && target == NULL) +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); + +	human_fingerprint = g_ascii_strup(fingerprint, -1); +	otr_forget(server, target, human_fingerprint, user_state_global); +	g_free(human_fingerprint); + +	cmd_params_free(free_arg); +} + +static void cmd_otr_authabort(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; + +	query = QUERY(item); +	target = query ? query->name : NULL; + +	if (server == NULL || target == NULL) +		cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS); + +	otr_auth_abort(server, target); +} + +static void cmd_otr_auth(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; + +	char *secret; +	void *free_arg; + +	if (!cmd_get_params(data, &free_arg, 1, &secret)) +		return; + +	query = QUERY(item); +	target = query ? query->name : NULL; + +	if (server == NULL || target == NULL || *secret == \'\\0\') +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); + +	if (*secret == \'\\0\') +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); + +	otr_auth(server, target, NULL, secret); + +	cmd_params_free(free_arg); +} + +static void cmd_otr_authq(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	QUERY_REC *query; +	char *target; + +	char *question, *secret; +	void *free_arg; + +	if (!cmd_get_params(data, &free_arg, 2, &question, &secret)) +		return; + +	query = QUERY(item); +	target = query ? query->name : NULL; + +	if (server == NULL || target == NULL || *question == \'\\0\' || *secret == \'\\0\') +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); + +	otr_auth(server, target, question, secret); + +	cmd_params_free(free_arg); +} + +static void cmd_otr_genkey(const char *data) +{ +	char *account_name; +	void *free_arg; + +	if (!cmd_get_params(data, &free_arg, 1, &account_name)) +		return; + +	if (*account_name == \'\\0\') +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); + +	key_gen_run(user_state_global, account_name); + +	cmd_params_free(free_arg); +} + +static void cmd_otr_contexts(const char *data) +{ +	otr_contexts(user_state_global); +} + +static void cmd_otr_info(const char *data) +{ +	gboolean empty = TRUE; +	char ownfp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN]; +	OtrlPrivKey *key; + +	for (key = user_state_global->otr_state->privkey_root; key != NULL; key = key->next) { +		otrl_privkey_fingerprint(user_state_global->otr_state, ownfp, key->accountname, OTR_PROTOCOL_ID); + +		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_OTR_FP_NICK, key->accountname, ownfp); + +		empty = FALSE; +	} + +	if (empty) +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_OTR_KEYS_UNAVAILABLE); +} + +static void statusbar_otr(struct SBAR_ITEM_REC *item, int get_size_only) +{ +	WI_ITEM_REC *wi_item = active_win->active; +	QUERY_REC *query = QUERY(wi_item); +	enum otr_status_format format = TXT_OTR_MODULE_NAME; + +	if (query && query->server && query->server->connrec) { +		format = otr_get_status_format(query->server, query->name); +	} + +	statusbar_item_default_handler(item, get_size_only, +			format ? fe_otr_formats[format].def : \"\", \" \", FALSE); +} + +void otr_fe_init(void) +{ +	theme_register(fe_otr_formats); + +	command_bind(\"otr\", NULL, (SIGNAL_FUNC) cmd_otr); +	command_bind(\"otr debug\", NULL, (SIGNAL_FUNC) cmd_otr_debug); +	command_bind(\"otr init\", NULL, (SIGNAL_FUNC) cmd_otr_init); +	command_bind(\"otr finish\", NULL, (SIGNAL_FUNC) cmd_otr_finish); +	command_bind(\"otr trust\", NULL, (SIGNAL_FUNC) cmd_otr_trust); +	command_bind(\"otr distrust\", NULL, (SIGNAL_FUNC) cmd_otr_distrust); +	command_bind(\"otr forget\", NULL, (SIGNAL_FUNC) cmd_otr_forget); +	command_bind(\"otr authabort\", NULL, (SIGNAL_FUNC) cmd_otr_authabort); +	command_bind(\"otr auth\", NULL, (SIGNAL_FUNC) cmd_otr_auth); +	command_bind(\"otr authq\", NULL, (SIGNAL_FUNC) cmd_otr_authq); +	command_bind(\"otr genkey\", NULL, (SIGNAL_FUNC) cmd_otr_genkey); +	command_bind(\"otr contexts\", NULL, (SIGNAL_FUNC) cmd_otr_contexts); +	command_bind(\"otr info\", NULL, (SIGNAL_FUNC) cmd_otr_info); + +	statusbar_item_register(\"otr\", NULL, statusbar_otr); +	statusbar_items_redraw(\"window\"); +} + +void otr_fe_deinit(void) +{ +	theme_unregister(); + +	command_unbind(\"otr\", (SIGNAL_FUNC) cmd_otr); +	command_unbind(\"otr debug\", (SIGNAL_FUNC) cmd_otr_debug); +	command_unbind(\"otr init\", (SIGNAL_FUNC) cmd_otr_init); +	command_unbind(\"otr finish\", (SIGNAL_FUNC) cmd_otr_finish); +	command_unbind(\"otr trust\", (SIGNAL_FUNC) cmd_otr_trust); +	command_unbind(\"otr distrust\", (SIGNAL_FUNC) cmd_otr_distrust); +	command_unbind(\"otr forget\", (SIGNAL_FUNC) cmd_otr_forget); +	command_unbind(\"otr authabort\", (SIGNAL_FUNC) cmd_otr_authabort); +	command_unbind(\"otr auth\", (SIGNAL_FUNC) cmd_otr_auth); +	command_unbind(\"otr authq\", (SIGNAL_FUNC) cmd_otr_authq); +	command_unbind(\"otr genkey\", (SIGNAL_FUNC) cmd_otr_genkey); +	command_unbind(\"otr contexts\", (SIGNAL_FUNC) cmd_otr_contexts); +	command_unbind(\"otr info\", (SIGNAL_FUNC) cmd_otr_info); + +	statusbar_item_unregister(\"otr\"); +} '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr-fe.h','2','0','28','0','ADD','@@ -0,0 +1,28 @@ +/* + * Off-the-Record Messaging (OTR) module for the irssi IRC client + * + * Copyright (C) 2008  Uli Meis <a.sporto+bee@gmail.com> + *               2012  David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#ifndef IRSSI_OTR_FE_H +#define IRSSI_OTR_FE_H + +void otr_fe_init(void); +void otr_fe_deinit(void); + +#endif '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr-formats.c','71','0','108','0','ADD','@@ -0,0 +1,108 @@ +/* + * Off-the-Record Messaging (OTR) modules for IRC + * + * Copyright (C) - 2012  David Goulet <dgoulet@ev0ke.net> + *                 2014  Alexander FÃ¦rÃ¸y <ahf@0x90.dk> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#include \"otr.h\" +#include \"otr-formats.h\" + +FORMAT_REC fe_otr_formats[] = { +	{ MODULE_NAME, \"Core\", 0 }, + +	/* Status bar format. */ +	{ NULL, \"OTR Statusbar\", 0 }, + +	{ \"otr_stb_plaintext\", \"{sb plaintext}\", 0}, +	{ \"otr_stb_finished\", \"{sb %yfinished%n}\", 0}, +	{ \"otr_stb_unknown\", \"{sb {hilight state unknown (BUG!)}}\", 0}, +	{ \"otr_stb_untrusted\", \"{sb %GOTR%n (%runverified%n)}\", 0}, +	{ \"otr_stb_trust\", \"{sb %GOTR%n}\", 0}, + +	/* OTR format. */ +	{ NULL, \"OTR\", 0 }, + +	{ \"otr_auth_aborted\", \"Authentication aborted\", 0}, +	{ \"otr_auth_initiated\", \"Initiated authentication\", 0}, +	{ \"otr_auth_ongoing_aborted\", \"Ongoing authentication aborted\", 0}, +	{ \"otr_auth_response\", \"Responding to authentication\", 0}, + +	{ \"otr_ctx_list_header\", \"{hilight Contexts}\", 0}, +	{ \"otr_ctx_list_encrypted_line\", \"{hilight $0} - {hilight $1} (Encrypted)\", 2, { 0, 0 }}, +	{ \"otr_ctx_list_finished_line\", \"{hilight $0} - {hilight $1} (Finished)\", 2, { 0, 0 }}, +	{ \"otr_ctx_list_manual_line\", \"  {hilight $0} (Manual)\", 1, { 0, 0 }}, +	{ \"otr_ctx_list_plaintext_line\", \"{hilight $0} - {hilight $1} (Plaintext)\", 2, { 0, 0 }}, +	{ \"otr_ctx_list_smp_line\", \"  {hilight $0} (SMP)\", 1, { 0, 0 }}, +	{ \"otr_ctx_list_unknown_line\", \"{hilight $0} - {hilight $1} (Unknown)\", 2, { 0, 0 }}, +	{ \"otr_ctx_list_unused_line\", \"{hilight $0} - {hilight $1} (Unused)\", 2, { 0, 0 }}, +	{ \"otr_ctx_list_unverified_line\", \"  {hilight $0} (Unverified)\", 1, { 0, 0 }}, +	{ \"otr_ctx_list_footer\", \"\", 0}, +	{ \"otr_ctx_missing\", \"{error No active OTR contexts found}\", 0}, +	{ \"otr_ctx_nick_missing\", \"{error Context for {hilight $0} not found}\", 1, { 1 }}, + +	{ \"otr_fp_already_distrusted\", \"{error Already distrusting: {hilight $0}\", 1, { 0 }}, +	{ \"otr_fp_already_trusted\", \"{error Already trusting: {hilight $0}\", 1, { 0 }}, +	{ \"otr_fp_ctx_encrypted\", \"Fingerprint context is still encrypted. Finish the OTR session before forgetting a fingerprint\", 0}, +	{ \"otr_fp_distrusted\", \"Distrusting {hilight $0}\", 1, { 0 }}, +	{ \"otr_fp_forgotten\", \"Fingerprint {hilight $0} forgotten\", 1, { 0 }}, +	{ \"otr_fp_info\", \"OTR key fingerprint: {hilight $1} for {hilight $0}\", 2, { 0, 0 }}, +	{ \"otr_fp_missing\", \"{error Fingerprint {hilight $0} not found\", 1, { 0 }}, +	{ \"otr_fp_nick\", \"Fingerprint for {hilight $0}: {hilight $1}\", 2, { 0, 0 }}, +	{ \"otr_fp_trusted\", \"Trusting {hilight $0}\", 1, { 0 }}, + +	{ \"otr_keygen_completed\", \"OTR key generation for {hilight $0} completed\", 1, { 0 }}, +	{ \"otr_keygen_failed\", \"OTR key generation for {hilight $0} failed: {error $1}\", 2, { 0, 0 }}, +	{ \"otr_keygen_running\", \"OTR key generation for {hilight $0} is still in progress\", 1, { 0 }}, +	{ \"otr_keygen_started\", \"OTR key generation for {hilight $0} started\", 1, { 0 }}, + +	{ \"otr_keys_unavailable\", \"{error No OTR keys available}\", 0}, + +	{ \"otr_msg_encryption_ended\", \"{hilight $0} has closed the connection to you\", 1, { 0 }}, +	{ \"otr_msg_encryption_error\", \"{error An error occured when encrypting your message}\", 0}, +	{ \"otr_msg_encryption_required\", \"Encryptioned is required\", 0}, +	{ \"otr_msg_error\", \"Error in private conversation: {error $0}\", 1, { 0 }}, +	{ \"otr_msg_general_error\", \"General Error: {error $0}\", 1, { 0 }}, +	{ \"otr_msg_malformed\", \"Malformed message from {hilight $0}\", 1, { 0 }}, +	{ \"otr_msg_not_in_private\", \"The encrypted message from {hilight $0} was is unreadable because you\'re not communicating privately\", 1, { 0 }}, +	{ \"otr_msg_reflected\", \"Received reflected message from {hilight $0}\", 0, { 0 }}, +	{ \"otr_msg_resent\", \"The last message to {hilight $0} was resent: $1\", 2, { 0, 0 }}, +	{ \"otr_msg_unencrypted\", \"The following message from {hilight $0} was {error not} encrypted\", 1, { 0 }}, +	{ \"otr_msg_unreadable\", \"Unreadable encrypted message from {hilight $0}\", 1, { 0 }}, +	{ \"otr_msg_unrecognized\", \"Unrecognized OTR message from {hilight $0}\", 1, { 0 }}, + +	{ \"otr_session_already_finished\", \"Nothing to do\", 0}, +	{ \"otr_session_already_secured\", \"Secure session with {hilight $0} already established\", 1, { 0 }}, +	{ \"otr_session_finished\", \"{hilight $0} has finished the OTR session. Use /otr init to restart or /otr finish to finish.\", 1, { 0 }}, +	{ \"otr_session_finishing\", \"Finished conversation with {hilight $0}\", 1, { 0 }}, +	{ \"otr_session_initiating\", \"Initiating OTR session ...\", 0}, +	{ \"otr_session_insecure\", \"Session insecured\", 0}, +	{ \"otr_session_missing\", \"{error No OTR session available}\", 0}, +	{ \"otr_session_secure\", \"Session secured\", 0}, +	{ \"otr_session_unauthenticated_warning\", \"Your peer is not authenticated\", 0}, + +	{ \"otr_smp_answer_footer\", \"Use /otr auth <answer> to complete\", 0}, +	{ \"otr_smp_answer_header\", \"{hilight $0} wants to authenticate and asked:\", 1, { 0 }}, +	{ \"otr_smp_answer_question\", \"Question: {hilight $0}\", 1, { 0 }}, +	{ \"otr_smp_failure\", \"Authentication with {hilight $0} failed\", 1, { 0 }}, +	{ \"otr_smp_in_progress\", \"{hilight $0} replied to your auth request\", 1, { 0 }}, +	{ \"otr_smp_secret_question\", \"{hilight $0} wants to authenticate. Use /otr auth <secret> to complete\", 1, { 0 }}, +	{ \"otr_smp_success\", \"Authentication with {hilight $0} succesful\", 1, { 0 }}, + +	/* Last element. */ +	{ NULL, NULL, 0 } +}; '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr-formats.h','70','0','112','0','ADD','@@ -0,0 +1,112 @@ +/* + * Off-the-Record Messaging (OTR) modules for IRC + * + * Copyright (C) - 2012  David Goulet <dgoulet@ev0ke.net> + *                 2014  Alexander FÃ¦rÃ¸y <ahf@0x90.dk> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#ifndef IRSSI_OTR_FORMATS_H +#define IRSSI_OTR_FORMATS_H + +#include \"formats.h\" + +/* + * Must be in sync with the fe_otr_formats array. + */ +enum otr_status_format { +	TXT_OTR_MODULE_NAME, + +	/* Status bar format. */ +	TXT_OTR_FILL_1, +	TXT_OTR_STB_PLAINTEXT, +	TXT_OTR_STB_FINISHED, +	TXT_OTR_STB_UNKNOWN, +	TXT_OTR_STB_UNTRUSTED, +	TXT_OTR_STB_TRUST, + +	/* OTR format. */ +	TXT_OTR_FILL_2, +	TXT_OTR_AUTH_ABORTED, +	TXT_OTR_AUTH_INITIATED, +	TXT_OTR_AUTH_ONGOING_ABORTED, +	TXT_OTR_AUTH_RESPONSE, + +	TXT_OTR_CTX_LIST_HEADER, +	TXT_OTR_CTX_LIST_ENCRYPTED_LINE, +	TXT_OTR_CTX_LIST_FINISHED_LINE, +	TXT_OTR_CTX_LIST_MANUAL_LINE, +	TXT_OTR_CTX_LIST_PLAINTEXT_LINE, +	TXT_OTR_CTX_LIST_SMP_LINE, +	TXT_OTR_CTX_LIST_UNKNOWN_LINE, +	TXT_OTR_CTX_LIST_UNUSED_LINE, +	TXT_OTR_CTX_LIST_UNVERIFIED_LINE, +	TXT_OTR_CTX_LIST_FOOTER, +	TXT_OTR_CTX_MISSING, +	TXT_OTR_CTX_NICK_MISSING, + +	TXT_OTR_FP_ALREADY_DISTRUSED, +	TXT_OTR_FP_ALREADY_TRUSTED, +	TXT_OTR_FP_CTX_ENCRYPTED, +	TXT_OTR_FP_DISTRUSTED, +	TXT_OTR_FP_FORGOTTEN, +	TXT_OTR_FP_INFO, +	TXT_OTR_FP_MISSING, +	TXT_OTR_FP_NICK, +	TXT_OTR_FP_TRUSTED, + +	TXT_OTR_KEYGEN_COMPLETED, +	TXT_OTR_KEYGEN_FAILED, +	TXT_OTR_KEYGEN_RUNNING, +	TXT_OTR_KEYGEN_STARTED, + +	TXT_OTR_KEYS_UNAVAILABLE, + +	TXT_OTR_MSG_ENCRYPTION_ENDED, +	TXT_OTR_MSG_ENCRYPTION_ERROR, +	TXT_OTR_MSG_ENCRYPTION_REQUIRED, +	TXT_OTR_MSG_ERROR, +	TXT_OTR_MSG_GENERAL_ERROR, +	TXT_OTR_MSG_MALFORMED, +	TXT_OTR_MSG_NOT_IN_PRIVATE, +	TXT_OTR_MSG_REFLECTED, +	TXT_OTR_MSG_RESENT, +	TXT_OTR_MSG_UNENCRYPTED, +	TXT_OTR_MSG_UNREADABLE, +	TXT_OTR_MSG_UNRECOGNIZED, + +	TXT_OTR_SESSION_ALREADY_FINISHED, +	TXT_OTR_SESSION_ALREADY_SECURED, +	TXT_OTR_SESSION_FINISHED, +	TXT_OTR_SESSION_FINISHING, +	TXT_OTR_SESSION_INITIATING, +	TXT_OTR_SESSION_INSECURE, +	TXT_OTR_SESSION_MISSING, +	TXT_OTR_SESSION_SECURE, +	TXT_OTR_SESSION_UNAUTHENTICATED_WARNING, + +	TXT_OTR_SMP_ANSWER_FOOTER, +	TXT_OTR_SMP_ANSWER_HEADER, +	TXT_OTR_SMP_ANSWER_QUESTION, +	TXT_OTR_SMP_FAILURE, +	TXT_OTR_SMP_IN_PROGRESS, +	TXT_OTR_SMP_SECRET_QUESTION, +	TXT_OTR_SMP_SUCCESS +}; + +extern FORMAT_REC fe_otr_formats[]; + +#endif /* IRSSI_OTR_FORMATS_H */ '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr-ops.c','248','49','362','0','ADD','@@ -0,0 +1,362 @@ +/* + * Off-the-Record Messaging (OTR) modules for IRC + * Copyright (C) 2008  Uli Meis <a.sporto+bee@gmail.com> + * + * This program is free software; you can redistribute it and/or modify + * it under the terms of the GNU General Public License as published by + * the Free Software Foundation; either version 2 of the License, or + * (at your option) any later version. + * + * This program is distributed in the hope that it will be useful, + * but WITHOUT ANY WARRANTY; without even the implied warranty of + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the + * GNU General Public License for more details. + * + * You should have received a copy of the GNU General Public License + * along with this program; if not, write to the Free Software + * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#include \"common.h\" + +#include \"signals.h\" +#include \"levels.h\" +#include \"printtext.h\" +#include \"fe-windows.h\" + +#include \"key.h\" +#include \"module.h\" +#include \"otr-formats.h\" +#include \"irssi-otr.h\" + +static OtrlPolicy OTR_DEFAULT_POLICY = OTRL_POLICY_MANUAL | OTRL_POLICY_WHITESPACE_START_AKE; + +/* + * Return default policy for now. + */ +static OtrlPolicy ops_policy(void *opdata, ConnContext *context) +{ +	return OTR_DEFAULT_POLICY; +} + +/* + * Request for key generation. + * + * The lib actually expects us to be finished before the call returns. Since + * this can take more than an hour on some systems there isn\'t even a point in + * trying... + */ +static void ops_create_privkey(void *opdata, const char *accountname, +		const char *protocol) +{ +	key_gen_run(user_state_global, accountname); +} + +/* + * Inject OTR message. + */ +static void ops_inject_msg(void *opdata, const char *accountname, +		const char *protocol, const char *recipient, const char *message) +{ +	SERVER_REC *server = opdata; + +	IRSSI_OTR_DEBUG(\"Inject msg:\\n[%s]\", message); +	otr_send_message(server, recipient, message); +} + +/* + * Gone secure. + */ +static void ops_secure(void *opdata, ConnContext *context) +{ +	char ownfp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN]; +	char peerfp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN]; +	SERVER_REC *server = opdata; +	struct otr_peer_context *opc; + +	g_return_if_fail(context != NULL); +	/* This should *really* not happened */ +	g_return_if_fail(context->msgstate == OTRL_MSGSTATE_ENCRYPTED); + +	printformat(server, context->username, MSGLEVEL_CLIENTCRAP, TXT_OTR_SESSION_SECURE); +	otr_status_change(server, context->username, OTR_STATUS_GONE_SECURE); + +	opc = context->app_data; +	opc->active_fingerprint = context->active_fingerprint; + +	if (otrl_context_is_fingerprint_trusted(context->active_fingerprint)) { +		/* Secure and trusted */ +		return; +	} + +	/* Not authenticated. Let\'s print out the fingerprints for comparison. */ +	otrl_privkey_hash_to_human(peerfp, context->active_fingerprint->fingerprint); +	otrl_privkey_fingerprint(user_state_global->otr_state, ownfp, context->accountname, OTR_PROTOCOL_ID); + +	printformat(server, context->username, MSGLEVEL_CLIENTCRAP, TXT_OTR_SESSION_UNAUTHENTICATED_WARNING); +	printformat(server, context->username, MSGLEVEL_CLIENTCRAP, TXT_OTR_FP_INFO, server->nick, ownfp); +	printformat(server, context->username, MSGLEVEL_CLIENTCRAP, TXT_OTR_FP_INFO, context->username, peerfp); +} + +/* + * Gone insecure. + */ +static void ops_insecure(void *opdata, ConnContext *context) +{ +	SERVER_REC *server = opdata; + +	printformat(server, context->username, MSGLEVEL_CLIENTCRAP, TXT_OTR_SESSION_INSECURE); +	otr_status_change(server, context->username, OTR_STATUS_GONE_INSECURE); +} + +/* + * Really critical with IRC. Unfortunately, we can\'t tell our peer which size + * to use. + */ +static int ops_max_msg(void *opdata, ConnContext *context) +{ +	return OTR_MAX_MSG_SIZE; +} + +static void ops_handle_msg_event(void *opdata, OtrlMessageEvent msg_event, ConnContext *context, const char *message, gcry_error_t err) +{ +	SERVER_REC *server = opdata; +	char *username = context->username; + +	switch (msg_event) { +		case OTRL_MSGEVENT_NONE: +			break; +		case OTRL_MSGEVENT_ENCRYPTION_REQUIRED: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_ENCRYPTION_REQUIRED); +			break; +		case OTRL_MSGEVENT_ENCRYPTION_ERROR: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_ENCRYPTION_ERROR); +			break; +		case OTRL_MSGEVENT_CONNECTION_ENDED: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_ENCRYPTION_ENDED, username); +			break; +		case OTRL_MSGEVENT_SETUP_ERROR: +			if (!err) { +				err = GPG_ERR_INV_VALUE; +			} +			switch (err) { +				case GPG_ERR_INV_VALUE: +					printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_MALFORMED, username); +					break; +				default: +					printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_ERROR, gcry_strerror(err)); +					break; +			} +			break; +		case OTRL_MSGEVENT_MSG_REFLECTED: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_REFLECTED, username); +			break; +		case OTRL_MSGEVENT_MSG_RESENT: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_RESENT, username, message); +			break; +		case OTRL_MSGEVENT_RCVDMSG_NOT_IN_PRIVATE: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_NOT_IN_PRIVATE, username); +			break; +		case OTRL_MSGEVENT_RCVDMSG_UNREADABLE: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_UNREADABLE, username); +			break; +		case OTRL_MSGEVENT_RCVDMSG_MALFORMED: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_MALFORMED, username); +			break; +		case OTRL_MSGEVENT_LOG_HEARTBEAT_RCVD: +			IRSSI_OTR_DEBUG(\"Heartbeat received from %s.\", username); +			break; +		case OTRL_MSGEVENT_LOG_HEARTBEAT_SENT: +			IRSSI_OTR_DEBUG(\"Heartbeat sent to %s.\", username); +			break; +		case OTRL_MSGEVENT_RCVDMSG_GENERAL_ERR: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_ERROR, message); +			break; +		case OTRL_MSGEVENT_RCVDMSG_UNENCRYPTED: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_UNENCRYPTED, username); + +			/* +			 * This is a hack I found to send the message in a private window of +			 * the username without creating an infinite loop since the \'message +			 * private\' signal is hijacked in this module. If someone is able to +			 * clean this up with a more elegant solution, by all means PLEASE +			 * submit a patch or email me a better way. +			 */ +			signal_remove(\"message private\", (SIGNAL_FUNC) sig_message_private); +			signal_emit(\"message private\", 4, server, message, username, server->connrec->address); +			signal_add_first(\"message private\", (SIGNAL_FUNC) sig_message_private); +			break; +		case OTRL_MSGEVENT_RCVDMSG_UNRECOGNIZED: +			printformat(server, username, MSGLEVEL_CLIENTERROR, TXT_OTR_MSG_UNRECOGNIZED, username); +			break; +		case OTRL_MSGEVENT_RCVDMSG_FOR_OTHER_INSTANCE: +			IRSSI_OTR_DEBUG(\"%s has sent a message for a different instance.\", username); +			break; +	} +} + +/* + * A context changed. + */ +static void ops_up_ctx_list(void *opdata) +{ +	otr_status_change(opdata, NULL, OTR_STATUS_CTX_UPDATE); +} + +/* + * Save fingerprint changes. + */ +static void ops_write_fingerprints(void *data) +{ +	key_write_fingerprints(user_state_global); +} + +static int ops_is_logged_in(void *opdata, const char *accountname, const char *protocol, const char *recipient) +{ +	int ret; +	SERVER_REC *server = opdata; + +	/* Logged in? */ +	ret = server != NULL; + +	IRSSI_OTR_DEBUG(\"User %s %s logged in\", accountname, ret ? \"\" : \"not\"); + +	return ret; +} + +static void ops_create_instag(void *opdata, const char *accountname, +		const char *protocol) +{ +	otrl_instag_generate(user_state_global->otr_state, \"/dev/null\", accountname, protocol); +	key_write_instags(user_state_global); +} + +static void ops_smp_event(void *opdata, OtrlSMPEvent smp_event, +		ConnContext *context, unsigned short progress_percent, char *question) +{ +	SERVER_REC *server = opdata; +	const char *from = context->username; +	struct otr_peer_context *opc = context->app_data; + +	/* +	 * Without a peer context, we can\'t update the status bar. Code flow error +	 * if none is found. This context is created automatically by an otrl_* +	 * call or if non existent when returned from +	 * otrl_message_sending/receiving. +	 */ +	g_return_if_fail(opc != NULL); + +	opc->smp_event = smp_event; + +	switch (smp_event) { +		case OTRL_SMPEVENT_ASK_FOR_SECRET: +			printformat(server, from, MSGLEVEL_CLIENTCRAP, TXT_OTR_SMP_SECRET_QUESTION, from); +			opc->ask_secret = 1; +			otr_status_change(server, from, OTR_STATUS_SMP_INCOMING); +			break; +		case OTRL_SMPEVENT_ASK_FOR_ANSWER: +			printformat(server, from, MSGLEVEL_CLIENTCRAP, TXT_OTR_SMP_ANSWER_HEADER, from); +			printformat(server, from, MSGLEVEL_CLIENTCRAP, TXT_OTR_SMP_ANSWER_QUESTION, question); +			printformat(server, from, MSGLEVEL_CLIENTCRAP, TXT_OTR_SMP_ANSWER_FOOTER); +			opc->ask_secret = 1; +			otr_status_change(server, from, OTR_STATUS_SMP_INCOMING); +			break; +		case OTRL_SMPEVENT_IN_PROGRESS: +			printformat(server, from, MSGLEVEL_CLIENTCRAP, TXT_OTR_SMP_IN_PROGRESS, from); +			otr_status_change(server, from, OTR_STATUS_SMP_FINALIZE); +			break; +		case OTRL_SMPEVENT_SUCCESS: +			printformat(server, from, MSGLEVEL_CLIENTCRAP, TXT_OTR_SMP_SUCCESS, from); +			otr_status_change(server, from, OTR_STATUS_SMP_SUCCESS); +			break; +		case OTRL_SMPEVENT_ABORT: +			otr_auth_abort(server, context->username); +			otr_status_change(server, from, OTR_STATUS_SMP_ABORTED); +			break; +		case OTRL_SMPEVENT_FAILURE: +		case OTRL_SMPEVENT_CHEATED: +		case OTRL_SMPEVENT_ERROR: +			printformat(server, from, MSGLEVEL_CLIENTERROR, TXT_OTR_SMP_FAILURE, from); +			otr_status_change(server, from, OTR_STATUS_SMP_FAILED); +			break; +		default: +			g_warning(\"Received unknown SMP event: %d\", smp_event); +			break; +	} +} + +/* + * timer_control callback. + */ +static void ops_timer_control(void *opdata, unsigned int interval) +{ +	otr_control_timer(interval, opdata); +} + +/* + * Handle otr error message. + */ +static const char *ops_otr_error_message(void *opdata, ConnContext *context, +		OtrlErrorCode code) +{ +	char *msg = NULL; + +	switch (code) { +	case OTRL_ERRCODE_NONE: +		break; +	case OTRL_ERRCODE_ENCRYPTION_ERROR: +		msg = strdup(\"Error occurred encrypting message.\"); +		break; +	case OTRL_ERRCODE_MSG_NOT_IN_PRIVATE: +		if (context) { +			msg = strdup(\"You sent encrypted data which was unexpected\"); +		} +		break; +	case OTRL_ERRCODE_MSG_UNREADABLE: +		msg = strdup(\"You transmitted an unreadable encrypted message\"); +		break; +	case OTRL_ERRCODE_MSG_MALFORMED: +		msg = strdup(\"You transmitted a malformed data message.\"); +		break; +	} + +	return msg; +} + +/* + * Free otr error message callback. + */ +static void ops_otr_error_message_free(void *opdata, const char *err_msg) +{ +	g_free_not_null((char *)err_msg); +} + +/* + * Assign OTR message operations. + */ +OtrlMessageAppOps otr_ops = { +	ops_policy, +	ops_create_privkey, +	ops_is_logged_in, +	ops_inject_msg, +	ops_up_ctx_list, +	NULL, /* new_fingerprint */ +	ops_write_fingerprints, +	ops_secure, +	ops_insecure, +	NULL, /* still_secure */ +	ops_max_msg, +	NULL, /* account_name */ +	NULL, /* account_name_free */ +	NULL, /* received_symkey */ +	ops_otr_error_message, +	ops_otr_error_message_free, +	NULL, /* resent_msg_prefix */ +	NULL, /* resent_msg_prefix_free */ +	ops_smp_event, +	ops_handle_msg_event, +	ops_create_instag, +	NULL, /* convert_msg */ +	NULL, /* convert_free */ +	ops_timer_control, +}; '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr.c','600','114','941','0','ADD','@@ -0,0 +1,941 @@ +/* + * Off-the-Record Messaging (OTR) modules for IRC + * + * Copyright (C) 2008 - Uli Meis <a.sporto+bee@gmail.com> + *               2012 - David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#define _GNU_SOURCE +#include <glib.h> +#include <gcrypt.h> +#include <unistd.h> + +#include \"common.h\" +#include \"levels.h\" +#include \"signals.h\" +#include \"printtext.h\" +#include \"statusbar-item.h\" + +#include \"irssi-otr.h\" +#include \"otr-formats.h\" +#include \"key.h\" + +static int otr_debug = 0; + +static const char *statusbar_txt[] = { +	\"FINISHED\", +	\"TRUST_MANUAL\", +	\"TRUST_SMP\", +	\"SMP_ABORT\", +	\"SMP_STARTED\", +	\"SMP_RESPONDED\", +	\"SMP_INCOMING\", +	\"SMP_FINALIZE\", +	\"SMP_ABORTED\", +	\"PEER_FINISHED\", +	\"SMP_FAILED\", +	\"SMP_SUCCESS\", +	\"GONE_SECURE\", +	\"GONE_INSECURE\", +	\"CTX_UPDATE\" +}; + +/* Glib timer for otr. */ +static guint otr_timerid; + +/* + * Load instance tags. + */ +static void instag_load(struct otr_user_state *ustate) +{ +	int ret; +	char *filename; +	gcry_error_t err; + +	g_return_if_fail(ustate != NULL); + +	/* Getting the otr instance filename path */ +	filename = g_strdup_printf(\"%s%s\", get_irssi_dir(), OTR_INSTAG_FILE); +	g_return_if_fail(filename != NULL); + +	ret = access(filename, F_OK); +	if (ret < 0) { +		IRSSI_OTR_DEBUG(\"no instance tags found at %9%s%9\", filename); +		g_free(filename); +		return; +	} + +	err = otrl_instag_read(ustate->otr_state, filename); +	if (err == GPG_ERR_NO_ERROR) +		IRSSI_OTR_DEBUG(\"Instance tags loaded from %9%s%9\", filename); +	else +		IRSSI_OTR_DEBUG(\"Error loading instance tags: %d (%d)\", gcry_strerror(err), gcry_strsource(err)); + +	g_free(filename); +} + +/* + * Free otr peer context. Callback passed to libotr. + */ +static void free_peer_context_cb(void *data) +{ +	g_free_not_null(data); +} + +/* + * Allocate otr peer context. Callback passed to libotr. + */ +static void add_peer_context_cb(void *data, ConnContext *context) +{ +	struct otr_peer_context *opc; + +	opc = otr_create_peer_context(); +	if (opc == NULL) { +		return; +	} + +	opc->active_fingerprint = context->active_fingerprint; + +	context->app_data = opc; +	context->app_data_free = free_peer_context_cb; + +	IRSSI_OTR_DEBUG(\"Peer context created for %s\", context->username); +} + +/* + * Find Irssi server record by network name. + */ +static SERVER_REC *find_server_by_network(const char *network) +{ +	GSList *tmp; +	SERVER_REC *server; + +	g_return_val_if_fail(network != NULL, NULL); + +	for (tmp = servers; tmp; tmp = tmp->next) { +		server = tmp->data; + +		if (g_ascii_strncasecmp(server->tag, network, strlen(server->tag))) +			return server; +	} + +	return NULL; +} + +/* + * Check if fingerprint is in an encrypted context. + * + * Return 1 if it does, else 0. + */ +static int check_fp_encrypted_msgstate(Fingerprint *fp) +{ +	ConnContext *context; + +	g_return_val_if_fail(fp != NULL, 0); + +	/* Loop on all fingerprint\'s context(es). */ +	for (context = fp->context; +			context != NULL && context->m_context == fp->context; +			context = context->next) { +		if (context->msgstate == OTRL_MSGSTATE_ENCRYPTED && +				context->active_fingerprint == fp) { +			return 1; +		} +	} + +	/* No state is encrypted. */ +	return 0; +} + +/* + * Timer called from the glib main loop and set up by the timer_control + * callback of libotr. + */ +static gboolean timer_fired_cb(gpointer data) +{ +	otrl_message_poll(user_state_global->otr_state, &otr_ops, NULL); +	return TRUE; +} + +void otr_control_timer(unsigned int interval, void *opdata) +{ +	if (otr_timerid) { +		g_source_remove(otr_timerid); +		otr_timerid = 0; +	} + +	if (interval > 0) { +		otr_timerid = g_timeout_add_seconds(interval, timer_fired_cb, opdata); +	} +} + +/* + * Is OTR debugging enabled or disabled? + */ +int otr_debug_get(void) +{ +    return otr_debug; +} + +/* + * Toggle OTR debugging. + */ +void otr_debug_toggle(void) +{ +    otr_debug = !otr_debug; +} + +/* + * Find context from nickname and irssi server record. + */ +ConnContext *otr_find_context(SERVER_REC *server, const char *nick, int create) +{ +	ConnContext *ctx = NULL; + +	g_return_val_if_fail(server != NULL, NULL); +	g_return_val_if_fail(server->tag != NULL, NULL); +	g_return_val_if_fail(nick != NULL, NULL); + +	ctx = otrl_context_find(user_state_global->otr_state, nick, server->tag, +			OTR_PROTOCOL_ID, OTRL_INSTAG_BEST, create, NULL, +			add_peer_context_cb, server); + +	return ctx; +} + +/* + * Create otr peer context. + */ +struct otr_peer_context *otr_create_peer_context(void) +{ +	return g_new0(struct otr_peer_context, 1); +} + +/* + * Return a newly allocated OTR user state. + */ +struct otr_user_state *otr_init_user_state(void) +{ +	struct otr_user_state *ous = NULL; + +	ous = g_new0(struct otr_user_state, 1); +	if (ous == NULL) { +		return ous; +	} + +	ous->otr_state = otrl_userstate_create(); + +	instag_load(ous); + +	/* Load keys and fingerprints. */ +	key_load(ous); +	key_load_fingerprints(ous); + +	return ous; +} + +/* + * Destroy otr user state. + */ +void otr_free_user_state(struct otr_user_state *ustate) +{ +	if (ustate->otr_state) { +		otrl_userstate_free(ustate->otr_state); +		ustate->otr_state = NULL; +	} + +	g_free(ustate); +} + +/* + * init otr lib. + */ +void otr_lib_init() +{ +	OTRL_INIT; +} + +/* + * deinit otr lib. + */ +void otr_lib_uninit() +{ +} + +/* + * Hand the given message to OTR. + * + * Return 0 if the message was successfully handled or else a negative value. + */ +int otr_send(SERVER_REC *server, const char *msg, const char *to, char **otr_msg) +{ +	gcry_error_t err; +	ConnContext *ctx = NULL; + +	g_return_val_if_fail(server != NULL, -1); +	g_return_val_if_fail(server->tag != NULL, -1); + +	IRSSI_OTR_DEBUG(\"OTR: Sending message: %s\", msg); + +	err = otrl_message_sending(user_state_global->otr_state, &otr_ops, +		server, server->tag, OTR_PROTOCOL_ID, to, OTRL_INSTAG_BEST, msg, NULL, otr_msg, +		OTRL_FRAGMENT_SEND_ALL_BUT_LAST, &ctx, add_peer_context_cb, server); +	if (err) { +		g_warning(\"OTR: Send failed: %s\", gcry_strerror(err)); +		return -1; +	} + +	/* Add peer context to OTR context if none exists. */ +	if (ctx && !ctx->app_data) { +		add_peer_context_cb(server, ctx); +	} + +	return 0; +} + +/* + * List otr contexts to the main Irssi windows. + */ +void otr_contexts(struct otr_user_state *ustate) +{ +	char human_fp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN], *trust; +	ConnContext *ctx, *c_iter; +	Fingerprint *fp; + +	g_return_if_fail(ustate != NULL); + +	if (ustate->otr_state->context_root == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_OTR_CTX_MISSING); +		return; +	} + +	printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_HEADER); + +	/* Iterate over all contextes of the user state. */ +	for (ctx = ustate->otr_state->context_root; ctx != NULL; ctx = ctx->next) { +		OtrlMessageState best_mstate = OTRL_MSGSTATE_PLAINTEXT; + +		/* Skip master context. */ +		if (ctx != ctx->m_context) +			continue; + +		for (fp = ctx->fingerprint_root.next; fp != NULL; fp = fp->next) { +			int used = 0; +			char *username, *accountname; + +			username = ctx->username; +			accountname = ctx->accountname; + +			for (c_iter = ctx->m_context; c_iter && c_iter->m_context == ctx->m_context; c_iter = c_iter->next) { +				/* Print account name, username and msgstate. */ +				if (c_iter->active_fingerprint == fp) { +					used = 1; + +					if (c_iter->msgstate == OTRL_MSGSTATE_ENCRYPTED) +						best_mstate = OTRL_MSGSTATE_ENCRYPTED; +					else if (c_iter->msgstate == OTRL_MSGSTATE_FINISHED && best_mstate == OTRL_MSGSTATE_PLAINTEXT) +						best_mstate = OTRL_MSGSTATE_FINISHED; +				} +			} + +			if (used) { +				switch (best_mstate) { +					case OTRL_MSGSTATE_ENCRYPTED: +						printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_ENCRYPTED_LINE, accountname, username); +						break; +					case OTRL_MSGSTATE_PLAINTEXT: +						printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_PLAINTEXT_LINE, accountname, username); +						break; +					case OTRL_MSGSTATE_FINISHED: +						printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_FINISHED_LINE, accountname, username); +						break; +					default: +						printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_UNKNOWN_LINE, accountname, username); +						break; +				}; +			} else +				printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_UNUSED_LINE, accountname, username); + +			/* Hash fingerprint to human. */ +			otrl_privkey_hash_to_human(human_fp, fp->fingerprint); + +			trust = fp->trust; +			if (trust && trust[0] != \'\\0\') { +				if (strncmp(trust, \"smp\", 3) == 0) +					printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_SMP_LINE, human_fp); +				else +					printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_MANUAL_LINE, human_fp); +			} else +				printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_UNVERIFIED_LINE, human_fp); +		} +	} + +	printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_OTR_CTX_LIST_FOOTER); +} + +/* + * Finish the conversation. + */ +void otr_finish(SERVER_REC *server, const char *nick) +{ +	ConnContext *ctx; + +	g_return_if_fail(server != NULL); +	g_return_if_fail(nick != NULL); + +	ctx = otr_find_context(server, nick, FALSE); +	if (ctx == NULL) { +		printformat(server, nick, MSGLEVEL_CRAP, TXT_OTR_SESSION_ALREADY_FINISHED); +		return; +	} + +	otrl_message_disconnect(user_state_global->otr_state, &otr_ops, server, +			ctx->accountname, OTR_PROTOCOL_ID, nick, ctx->their_instance); + +	otr_status_change(server, nick, OTR_STATUS_FINISHED); + +	printformat(server, nick, MSGLEVEL_CRAP, TXT_OTR_SESSION_FINISHING, nick); +} + +/* + * Finish all otr contexts. + */ +void otr_finishall(struct otr_user_state *ustate) +{ +	ConnContext *context; +	SERVER_REC *server; + +	g_return_if_fail(ustate != NULL); + +	for (context = ustate->otr_state->context_root; context; +			context = context->next) { +		/* Only finish encrypted session. */ +		if (context->msgstate != OTRL_MSGSTATE_ENCRYPTED) { +			continue; +		} + +		server = find_server_by_network(context->accountname); +		if (server == NULL) { +			IRSSI_OTR_DEBUG(\"Unable to find server window for account %s\", context->accountname); +			continue; +		} + +		otr_finish(server, context->username); +	} +} + +/* + * Trust our peer. + */ +void otr_trust(SERVER_REC *server, const char *nick, char *str_fp, +		struct otr_user_state *ustate) +{ +	char peerfp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN]; +	struct otr_peer_context *opc; +	ConnContext *ctx; +	Fingerprint *fp_trust; + +	g_return_if_fail(ustate != NULL); + +	/* No human string fingerprint given. */ +	if (*str_fp == \'\\0\') { +		ctx = otr_find_context(server, nick, FALSE); +		if (ctx == NULL) { +			return; +		} + +		opc = ctx->app_data; +		/* Always NEED a peer context or else code error. */ +		g_return_if_fail(opc != NULL); + +		fp_trust = ctx->active_fingerprint; +	} else { +		fp_trust = otr_find_hash_fingerprint_from_human(str_fp, ustate); +	} + +	if (fp_trust != NULL) { +		otrl_privkey_hash_to_human(peerfp, fp_trust->fingerprint); + +		if (otrl_context_is_fingerprint_trusted(fp_trust)) { +			printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_FP_ALREADY_TRUSTED, peerfp); +			return; +		} + +		/* Trust level is manual at this point. */ +		otrl_context_set_trust(fp_trust, \"manual\"); +		key_write_fingerprints(ustate); + +		otr_status_change(server, nick, OTR_STATUS_TRUST_MANUAL); + +		printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_FP_TRUSTED, peerfp); +	} else +		printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_FP_MISSING, str_fp); +} + +/* + * implements /otr authabort + */ +void otr_auth_abort(SERVER_REC *server, const char *nick) +{ +	ConnContext *ctx; + +	g_return_if_fail(server != NULL); +	g_return_if_fail(nick != NULL); + +	ctx = otr_find_context(server, nick, FALSE); +	if (ctx == NULL) { +		printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_CTX_NICK_MISSING, nick); +		return; +	} + +	otrl_message_abort_smp(user_state_global->otr_state, &otr_ops, server, ctx); +	otr_status_change(server, nick, OTR_STATUS_SMP_ABORT); + +	if (ctx->smstate->nextExpected != OTRL_SMP_EXPECT1) +		printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_AUTH_ONGOING_ABORTED); +	else +		printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_AUTH_ABORTED); +} + +/* + * Initiate or respond to SMP authentication. + */ +void otr_auth(SERVER_REC *server, const char *nick, const char *question, +		const char *secret) +{ +	int ret; +	size_t secret_len = 0; +	ConnContext *ctx; +	struct otr_peer_context *opc; + +	g_return_if_fail(server != NULL); +	g_return_if_fail(nick != NULL); + +	ctx = otr_find_context(server, nick, 0); +	if (ctx == NULL) { +		printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_CTX_NICK_MISSING, nick); +		return; +	} + +	opc = ctx->app_data; +	/* Again, code flow error. */ +	g_return_if_fail(opc != NULL); + +	if (ctx->msgstate != OTRL_MSGSTATE_ENCRYPTED) { +		printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_SESSION_MISSING); +		return; +	} + +	/* Aborting an ongoing auth */ +	if (ctx->smstate->nextExpected != OTRL_SMP_EXPECT1) { +		otr_auth_abort(server, nick); +	} + +	/* reset trust level */ +	if (ctx->active_fingerprint) { +		ret = otrl_context_is_fingerprint_trusted(ctx->active_fingerprint); +		if (!ret) { +			otrl_context_set_trust(ctx->active_fingerprint, \"\"); +			key_write_fingerprints(user_state_global); +		} +	} + +	/* Libotr allows empty secret. */ +	if (secret) { +		secret_len = strlen(secret); +	} + +	if (opc->ask_secret) { +		otrl_message_respond_smp(user_state_global->otr_state, &otr_ops, +				server, ctx, (unsigned char *) secret, secret_len); +		otr_status_change(server, nick, OTR_STATUS_SMP_RESPONDED); +		printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_AUTH_RESPONSE); +	} else { +		if (question != NULL) +			otrl_message_initiate_smp_q(user_state_global->otr_state, &otr_ops, server, ctx, question, (unsigned char *) secret, secret_len); +		else +			otrl_message_initiate_smp(user_state_global->otr_state, &otr_ops, server, ctx, (unsigned char *) secret, secret_len); + +		otr_status_change(server, nick, OTR_STATUS_SMP_STARTED); +		printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_AUTH_INITIATED); +	} + +	opc->ask_secret = 0; +} + +/* + * For the given message we received through irssi, check if we need to queue + * it for the case where that message is part of a bigger OTR full message. + * This can happen with bitlbee for instance where OTR message are split in + * different PRIVMSG. + * + * This uses a \"queue\" in the peer context so it\'s it very important to have + * the peer context associated with the message (nickname + irssi object). + * + * Return an otr_msg_status code indicating the caller what to do with the msg. + * OTR_MSG_ERROR indicates an error probably memory related. OTR_MSG_WAIT_MORE + * tells the caller to NOT send out the message since we are waiting for more + * to complete the OTR original message. OTR_MSG_ORIGINAL tell the caller to + * simply use the original message. OTR_MSG_USE_QUEUE indicates that full_msg + * can be used containing the reconstructed message. The caller SHOULD free(3) + * this pointer after use. + */ +static enum otr_msg_status enqueue_otr_fragment(const char *msg, struct otr_peer_context *opc, char **full_msg) +{ +	enum otr_msg_status ret; +	size_t msg_len; + +	g_return_val_if_fail(msg != NULL, OTR_MSG_ERROR); +	g_return_val_if_fail(opc != NULL, OTR_MSG_ERROR); + +	/* We are going to use it quite a bit so ease our life a bit. */ +	msg_len = strlen(msg); + +	if (opc->full_msg) { +		if (msg_len > (opc->msg_size - opc->msg_len)) { +			char *tmp_ptr; + +			/* Realloc memory if there is not enough space. */ +			tmp_ptr = realloc(opc->full_msg, opc->msg_size + msg_len + 1); +			if (tmp_ptr == NULL) { +				free(opc->full_msg); +				opc->full_msg = NULL; +				ret = OTR_MSG_ERROR; +				return ret; +			} +			opc->full_msg = tmp_ptr; +			opc->msg_size += msg_len + 1; +		} + +		/* Copy msg to full message since we already have a part pending. */ +		strncpy(opc->full_msg + opc->msg_len, msg, msg_len); +		opc->msg_len += msg_len; +		opc->full_msg[opc->msg_len] = \'\\0\'; + +		IRSSI_OTR_DEBUG(\"Partial OTR message added to queue: %s\", msg); + +		/* +		 * Are we waiting for more? If the message ends with a \".\", the +		 * transmission has ended else we have to wait for more. +		 */ +		if (msg[msg_len - 1] != OTR_MSG_END_TAG) { +			ret = OTR_MSG_WAIT_MORE; +			return ret; +		} + +		/* +		 * Dup the string with enough space for the NULL byte since we are +		 * about to free it before passing it to the caller. +		 */ +		*full_msg = strndup(opc->full_msg, opc->msg_len + 1); +		/* Reset everything. */ +		free(opc->full_msg); +		opc->full_msg = NULL; +		opc->msg_size = opc->msg_len = 0; +		ret = OTR_MSG_USE_QUEUE; +		return ret; +	} else { +		char *pos; + +		/* +		 * Try to find the OTR message tag at the _beginning_of the packet and +		 * check if this packet is not the end with the end tag of OTR \".\" +		 */ +		pos = strstr(msg, OTR_MSG_BEGIN_TAG); +		if (pos && (pos == msg) && msg[msg_len - 1] != OTR_MSG_END_TAG) { +			/* Allocate full message buffer with an extra for NULL byte. */ +			opc->full_msg = g_new0(char, (msg_len * 2) + 1); +			if (!opc->full_msg) { +				ret = OTR_MSG_ERROR; +				return ret; +			} +			/* Copy full message with NULL terminated byte. */ +			strncpy(opc->full_msg, msg, msg_len); +			opc->msg_len += msg_len; +			opc->msg_size += ((msg_len * 2) + 1); +			opc->full_msg[opc->msg_len] = \'\\0\'; +			ret = OTR_MSG_WAIT_MORE; +			IRSSI_OTR_DEBUG(\"Partial OTR message begins the queue: %s\", msg); +			return ret; +		} + +		/* Use original message. */ +		ret = OTR_MSG_ORIGINAL; +	} + +	return ret; +} + +/* + * Hand the given message to OTR. + * + * Returns 0 if its an OTR protocol message or else negative value. + */ +int otr_receive(SERVER_REC *server, const char *msg, const char *from, char **new_msg) +{ +	int ret = -1; +	char *full_msg = NULL; +	const char *recv_msg = NULL; +	OtrlTLV *tlvs; +	ConnContext *ctx; +	struct otr_peer_context *opc; +	OtrlTLV *tlv = NULL; + +	g_return_val_if_fail(server != NULL, -1); +	g_return_val_if_fail(server->tag != NULL, -1); + +	IRSSI_OTR_DEBUG(\"Receiving message: %s\", msg); + +	ctx = otr_find_context(server, from, 1); +	if (ctx == NULL) { +		return ret; +	} + +	/* Add peer context to OTR context if none exists */ +	if (ctx->app_data == NULL) +		add_peer_context_cb(server, ctx); + +	opc = ctx->app_data; +	g_return_val_if_fail(opc != NULL, -1); + +	ret = enqueue_otr_fragment(msg, opc, &full_msg); +	switch (ret) { +		case OTR_MSG_ORIGINAL: +			recv_msg = msg; +			break; +		case OTR_MSG_USE_QUEUE: +			recv_msg = full_msg; +			break; +		case OTR_MSG_WAIT_MORE: +			ret = 1; +			g_free_not_null(full_msg); +			return ret; +		case OTR_MSG_ERROR: +			ret = -1; +			g_free_not_null(full_msg); +			return ret; +	} + +	ret = otrl_message_receiving(user_state_global->otr_state, +		&otr_ops, server, server->tag, OTR_PROTOCOL_ID, from, recv_msg, new_msg, +		&tlvs, &ctx, add_peer_context_cb, server); +	if (ret) { +		IRSSI_OTR_DEBUG(\"Ignoring message of length %d from %s to %s.\\n%s\", strlen(msg), from, server->tag, msg); +	} else { +		if (*new_msg) { +			IRSSI_OTR_DEBUG(\"Converted received message.\"); +		} +	} + +	/* Check for disconnected message */ +	tlv = otrl_tlv_find(tlvs, OTRL_TLV_DISCONNECTED); +	if (tlv != NULL) { +		otr_status_change(server, from, OTR_STATUS_PEER_FINISHED); +		printformat(server, from, MSGLEVEL_CLIENTCRAP, TXT_OTR_SESSION_FINISHED, from); +	} + +	otrl_tlv_free(tlvs); + +	IRSSI_OTR_DEBUG(\"Message received.\"); + +	g_free_not_null(full_msg); + +	return ret; +} + +/* + * Get the OTR status of this conversation. + */ +enum otr_status_format otr_get_status_format(SERVER_REC *server, const char *nick) +{ +	int ret; +	enum otr_status_format code; +	ConnContext *ctx = NULL; + +	g_return_val_if_fail(server != NULL, TXT_OTR_STB_UNKNOWN); + +	ctx = otr_find_context(server, nick, FALSE); +	if (ctx == NULL) { +		code = TXT_OTR_STB_PLAINTEXT; +		return code; +	} + +	switch (ctx->msgstate) { +		case OTRL_MSGSTATE_PLAINTEXT: +			code = TXT_OTR_STB_PLAINTEXT; +			break; +		case OTRL_MSGSTATE_ENCRYPTED: +			/* Begin by checking trust. */ +			ret = otrl_context_is_fingerprint_trusted(ctx->active_fingerprint); +			if (ret) { +				code = TXT_OTR_STB_TRUST; +			} else { +				code = TXT_OTR_STB_UNTRUSTED; +			} +			break; +		case OTRL_MSGSTATE_FINISHED: +			code = TXT_OTR_STB_FINISHED; +			break; +		default: +			g_warning(\"BUG! Invalid msgstate: %d\", ctx->msgstate); +			code = TXT_OTR_STB_UNKNOWN; +			break; +	} + +	if (ctx) { +		IRSSI_OTR_DEBUG(\"Code: %d, state: %d, sm_prog_state: %d, auth state: %d\", +				code, ctx->msgstate, ctx->smstate->sm_prog_state, +				ctx->auth.authstate); +	} +	return code; +} + +/* + * Change status bar text for a given nickname. + */ +void otr_status_change(SERVER_REC *server, const char *nick, +		enum otr_status_event event) +{ +	statusbar_items_redraw(\"otr\"); +	signal_emit(\"otr event\", 3, server, nick, statusbar_txt[event]); +} + +/* + * Search for a OTR Fingerprint object from the given human readable string and + * return a pointer to the object if found else NULL. + */ +Fingerprint *otr_find_hash_fingerprint_from_human(const char *human_fp, struct otr_user_state *ustate) +{ +	char str_fp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN]; +	Fingerprint *fp = NULL, *fp_iter = NULL; +	ConnContext *context; + +	/* Loop on all context of the user state */ +	for (context = ustate->otr_state->context_root; context != NULL; +			context = context->next) { +		/* Loop on all fingerprint of the context */ +		for (fp_iter = context->fingerprint_root.next; fp_iter; +				fp_iter = fp_iter->next) { +			otrl_privkey_hash_to_human(str_fp, fp_iter->fingerprint); +			/* Compare human fingerprint given in argument to the current. */ +			if (strncmp(str_fp, human_fp, sizeof(str_fp)) == 0) { +				fp = otrl_context_find_fingerprint(context, +						fp_iter->fingerprint, 0, NULL); +				return fp; +			} +		} +	} + +	return fp; +} + +/* + * Forget a fingerprint. + * + * If str_fp is not NULL, it must be on the OTR human format like this: + * \"487FFADA 5073FEDD C5AB5C14 5BB6C1FF 6D40D48A\". If str_fp is NULL, get the + * context of the target nickname, check for the OTR peer context active + * fingerprint and forget this one if possible. + */ +void otr_forget(SERVER_REC *server, const char *nick, char *str_fp, struct otr_user_state *ustate) +{ +	char fp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN]; +	Fingerprint *fp_forget; +	ConnContext *ctx = NULL; +	struct otr_peer_context *opc; + +	/* No human string fingerprint given. */ +	if (*str_fp == \'\\0\') { +		ctx = otr_find_context(server, nick, FALSE); +		if (ctx == NULL) { +			return; +		} + +		opc = ctx->app_data; +		/* Always NEED a peer context or else code error. */ +		g_return_if_fail(opc != NULL); + +		fp_forget = opc->active_fingerprint; +	} else { +		fp_forget = otr_find_hash_fingerprint_from_human(str_fp, ustate); +	} + +	if (fp_forget) { +		/* Don\'t do anything if context is in encrypted state. */ +		if (check_fp_encrypted_msgstate(fp_forget)) { +			printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_FP_CTX_ENCRYPTED); +			return; +		} + +		otrl_privkey_hash_to_human(fp, fp_forget->fingerprint); +		/* Forget fp and context if it\'s the only one remaining. */ +		otrl_context_forget_fingerprint(fp_forget, 1); +		/* Update fingerprints file. */ +		key_write_fingerprints(ustate); +		printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_FP_FORGOTTEN, fp); +	} else +		printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_FP_MISSING, str_fp); +} + +/* + * Distrust a fingerprint. + * + * If str_fp is not NULL, it must be on the OTR human format like this: + * \"487FFADA 5073FEDD C5AB5C14 5BB6C1FF 6D40D48A\". If str_fp is NULL, get the + * context of the target nickname, check for the OTR peer context active + * fingerprint and distrust it. + */ +void otr_distrust(SERVER_REC *server, const char *nick, char *str_fp, +		struct otr_user_state *ustate) +{ +	char fp[OTRL_PRIVKEY_FPRINT_HUMAN_LEN]; +	Fingerprint *fp_distrust; +	ConnContext *ctx; +	struct otr_peer_context *opc; + +	/* No human string fingerprint given. */ +	if (*str_fp == \'\\0\') { +		ctx = otr_find_context(server, nick, FALSE); +		if (ctx == NULL) { +			return; +		} + +		opc = ctx->app_data; +		/* Always NEED a peer context or else code error. */ +		g_return_if_fail(opc != NULL); + +		fp_distrust = opc->active_fingerprint; +	} else +		fp_distrust = otr_find_hash_fingerprint_from_human(str_fp, ustate); + +	if (fp_distrust != NULL) { +		otrl_privkey_hash_to_human(fp, fp_distrust->fingerprint); + +		if (!otrl_context_is_fingerprint_trusted(fp_distrust)) { +			/* Fingerprint already not trusted. Do nothing. */ +			printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_FP_ALREADY_DISTRUSED, fp); +			return; +		} + +		otrl_context_set_trust(fp_distrust, \"\"); + +		/* Update fingerprints file. */ +		key_write_fingerprints(ustate); +		printformat(server, nick, MSGLEVEL_CLIENTCRAP, TXT_OTR_FP_DISTRUSTED, fp); +	} else +		printformat(server, nick, MSGLEVEL_CLIENTERROR, TXT_OTR_FP_MISSING, str_fp); +} '),('irssi','1.1.1','016b42baea9d7dcd2a284f873246c06259c560dd','Alexander FÃ¦rÃ¸y','Add OTR support.  This patch adds support for the OTR protocol to irssi. This is an import of the external irssi-otr project that we are now taking over maintership for.  Major thanks to the original authors of Irssi-OTR: Uli Meis and David Goulet. Thanks to the OTR community in #OTR on OFTC, thanks to everyone who have helped testing the patches and submitted UI suggestions.','otr.h','75','0','170','0','ADD','@@ -0,0 +1,170 @@ +/* + * Off-the-Record Messaging (OTR) modules for IRC + * + * Copyright (C) 2008 - Uli Meis <a.sporto+bee@gmail.com> + *               2012 - David Goulet <dgoulet@ev0ke.net> + * + * This program is free software; you can redistribute it and/or modify it + * under the terms of the GNU General Public License as published by the Free + * Software Foundation; either version 2 of the License, or (at your option) + * any later version. + * + * This program is distributed in the hope that it will be useful, but WITHOUT + * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or + * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for + * more details. + * + * You should have received a copy of the GNU General Public License along with + * this program; if not, write to the Free Software Foundation, Inc., 51 + * Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA + */ + +#ifndef IRSSI_OTR_OTR_H +#define IRSSI_OTR_OTR_H + +/* Libotr */ +#include <libotr/proto.h> +#include <libotr/message.h> +#include <libotr/context.h> +#include <libotr/privkey.h> + +#include \"common.h\" +#include \"servers.h\" + +/* irssi module name */ +#define MODULE_NAME                   \"otr/core\" + +/* + * XXX: Maybe this should be configurable? + */ +#define OTR_MAX_MSG_SIZE              400 + +/* OTR protocol id */ +#define OTR_PROTOCOL_ID               \"IRC\" + +#define OTR_DIR                       \"otr\" +#define OTR_KEYFILE                   OTR_DIR \"/otr.key\" +#define OTR_FINGERPRINTS_FILE         OTR_DIR \"/otr.fp\" +#define OTR_INSTAG_FILE               OTR_DIR \"/otr.instag\" + +/* + * Specified in OTR protocol version 3. See: + * http://www.cypherpunks.ca/otr/Protocol-v3-4.0.0.html + */ +#define OTR_MSG_BEGIN_TAG             \"?OTR:\" +#define OTR_MSG_END_TAG               \'.\' + +/* IRC /me command marker and len. */ +#define OTR_IRC_MARKER_ME             \"/me \" +#define OTR_IRC_MARKER_ME_LEN         sizeof(OTR_IRC_MARKER_ME) - 1 + +/* Irssi otr user state */ +struct otr_user_state { +	OtrlUserState otr_state; +}; + +/* + * Peer OTR internal context. + */ +struct otr_peer_context { +	/* The SMP event status. Used for the Irssi status bar. */ +	OtrlSMPEvent smp_event; +	/* Did the SMP secret was asked so are we in a responder state? */ +	unsigned int ask_secret; +	/* +	 * The fingerprint of the private message OTR session. This is useful for +	 * the forget command for which we can recover the fingerprint +	 * automatically. +	 */ +	Fingerprint *active_fingerprint; +	/* +	 * If needed, used to reconstruct the full message from fragmentation. +	 * Bitlbee for instance does that where we receive a *long* OTR message +	 * split in multiple PRIVMSG so we need to reconstruct it. +	 */ +	char *full_msg; +	/* Size of full_msg. Note this is the allocated memory size. */ +	size_t msg_size; +	/* Len of the actual string in full_msg NOT counting the NULL byte. */ +	size_t msg_len; +}; + +/* given to otr_status_change */ +enum otr_status_event { +	OTR_STATUS_FINISHED, +	OTR_STATUS_TRUST_MANUAL, +	OTR_STATUS_TRUST_SMP, +	OTR_STATUS_SMP_ABORT, +	OTR_STATUS_SMP_STARTED, +	OTR_STATUS_SMP_RESPONDED, +	OTR_STATUS_SMP_INCOMING, +	OTR_STATUS_SMP_FINALIZE, +	OTR_STATUS_SMP_ABORTED, +	OTR_STATUS_PEER_FINISHED, +	OTR_STATUS_SMP_FAILED, +	OTR_STATUS_SMP_SUCCESS, +	OTR_STATUS_GONE_SECURE, +	OTR_STATUS_GONE_INSECURE, +	OTR_STATUS_CTX_UPDATE +}; + +enum otr_msg_status { +	OTR_MSG_ORIGINAL		= 1, +	OTR_MSG_WAIT_MORE		= 2, +	OTR_MSG_USE_QUEUE		= 3, +	OTR_MSG_ERROR			= 4, +}; + +/* there can be only one */ +extern struct otr_user_state *user_state_global; + +/* Libotr ops functions */ +extern OtrlMessageAppOps otr_ops; + +int otr_debug_get(void); +void otr_debug_toggle(void); + +void otr_send_message(SERVER_REC *irssi, const char *recipient, +		const char *message); +void otr_status_change(SERVER_REC *irssi, const char *nick, +		enum otr_status_event event); + +/* init stuff */ + +struct otr_user_state *otr_init_user_state(void); +void otr_free_user_state(struct otr_user_state *ustate); + +void otr_lib_init(); +void otr_lib_uninit(); + +void otr_control_timer(unsigned int interval, void *opdata); + +/* Message transport. */ +int otr_send(SERVER_REC *irssi, const char *msg, const char *to, +		char **otr_msg); +int otr_receive(SERVER_REC *irssi, const char *msg, +		const char *from, char **new_msg); + +/* User interaction */ +void otr_finish(SERVER_REC *irssi, const char *nick); +void otr_auth(SERVER_REC *irssi, const char *nick, const char *question, +		const char *secret); +void otr_auth_abort(SERVER_REC *irssi, const char *nick); +void otr_contexts(struct otr_user_state *ustate); +void otr_finishall(struct otr_user_state *ustate); +void otr_forget(SERVER_REC *irssi, const char *nick, char *str_fp, +		struct otr_user_state *ustate); +void otr_distrust(SERVER_REC *irssi, const char *nick, char *str_fp, +		struct otr_user_state *ustate); +void otr_trust(SERVER_REC *irssi, const char *nick, char *str_fp, +		struct otr_user_state *ustate); + +enum otr_status_format otr_get_status_format(SERVER_REC *irssi, +		const char *nick); + +struct otr_peer_context *otr_create_peer_context(void); +ConnContext *otr_find_context(SERVER_REC *irssi, const char *nick, int create); +Fingerprint *otr_find_hash_fingerprint_from_human(const char *human_fp, +		struct otr_user_state *ustate); + +#endif /* IRSSI_OTR_OTR_H */ '),('irssi','1.1.1','7a4bfc16021e7762bd8e6c5d11d0f913101dc5b4','Alexander FÃ¦rÃ¸y','Better wording.','configure.ac','778','4','2','2','MODIFY','@@ -149,9 +149,9 @@ AC_ARG_WITH(perl,  	want_perl=static)    AC_ARG_WITH(otr, -[  --with-otr[=yes|no|module]   Build with OTR support - also specifies +[  --with-otr[=yes|no|static]   Build with OTR support - also specifies                                  if it should be built into the main irssi -                                binary or as a module (default)], +                                binary (static) or as a module (default)],  	if test x$withval = xyes; then  		want_otr=module  	elif test x$withval = xstatic; then '),('irssi','1.1.1','0b057b4ff43cfc560f67fe8312830289534de7d5','ailin-nemui','run syncdocs.sh and syncscripts.sh  Sync startup howto to fd1ed2227d529a7ee00d6206caa871ee40c08b69 Sync scriptassist to (2003020806) 211cd515ec87cf9a5d893e97894c2e4b58952f19','startup-HOWTO.html','475','0','3','3','MODIFY','@@ -411,7 +411,7 @@ Ctrl-X                - set the next server in list active    <p>Irssi supports connecting to IRC servers via a proxy. All server connections are then made through it, and if youâ€™ve set up everything properly, you donâ€™t need to do any <code>/QUOTE SERVER</code> commands manually.</p>   -<p>Hereâ€™s an example: You have your bouncer (lets say, BNC or BNC-like) listening in irc.bouncer.org port 5000. You want to use it to connect to servers irc.dalnet and irc.efnet.org. First youâ€™d need to setup the bouncer:</p> +<p>Hereâ€™s an example: You have your bouncer (lets say, BNC or BNC-like) listening in irc.bouncer.org port 5000. You want to use it to connect to servers irc.dal.net and irc.efnet.org. First youâ€™d need to setup the bouncer:</p>    <div><div><pre><code>/SET use_proxy ON  /SET proxy_address irc.bouncer.org @@ -434,7 +434,7 @@ Ctrl-X                - set the next server in list active    <p><strong>Proxy specific settings:</strong></p>   -<p>All proxies have these settings in common:</p> +<p>All proxies except irssi proxy and socks proxy have these settings in common:</p>    <div><div><pre><code>/SET use_proxy ON  /SET proxy_address &lt;Proxy host address&gt; @@ -488,7 +488,7 @@ Ctrl-X                - set the next server in list active    <p>Irssi contains itâ€™s own proxy which you can build giving <code>\\--with-proxy</code> option to configure. Youâ€™ll still need to run irssi in a screen to use it though.</p>   -<p>Irssi proxy is a bit different than most proxies, normally proxies create a new connection to IRC server when you connect to it, but <strong>irssi proxy shares your existing IRC connection(s) to multiple clients</strong>. And even more clearly: <strong>You can use only one IRC server connection to IRC with as many clients as you want</strong>. Can anyone figure out even more easier ways to say this, so I wouldnâ€™t need to try to explain this thing for minutes every time? :)</p> +<p>Irssi proxy is a bit different than most proxies, normally proxies create a new connection to IRC server when a new client connects to it, but <strong>irssi proxy shares your existing IRC connection(s) to multiple clients</strong>. And even more clearly: <strong>You can use only one IRC server connection of the irssi proxy to IRC with as many clients as you want</strong>. Can anyone figure out even more easier ways to say this, so I wouldnâ€™t need to try to explain this thing for minutes every time? :)</p>    <p>Irssi proxy supports sharing multiple server connections in different ports, like you can share network in port 2777 and efnet in port 2778.</p>   '),('irssi','1.1.1','0b057b4ff43cfc560f67fe8312830289534de7d5','ailin-nemui','run syncdocs.sh and syncscripts.sh  Sync startup howto to fd1ed2227d529a7ee00d6206caa871ee40c08b69 Sync scriptassist to (2003020806) 211cd515ec87cf9a5d893e97894c2e4b58952f19','startup-HOWTO.txt','583','0','8','7','MODIFY','@@ -460,7 +460,7 @@ need to do any /QUOTE SERVER commands manually.    Hereâ€™s an example: You have your bouncer (lets say, BNC or BNC-like) listening  in irc.bouncer.org port 5000. You want to use it to connect to servers -irc.dalnet and irc.efnet.org. First youâ€™d need to setup the bouncer: +irc.dal.net and irc.efnet.org. First youâ€™d need to setup the bouncer:    /SET use_proxy ON  /SET proxy_address irc.bouncer.org @@ -485,7 +485,7 @@ which you can give to /SERVER and /SERVER ADD commands.    Proxy specific settings:   -All proxies have these settings in common: +All proxies except irssi proxy and socks proxy have these settings in common:    /SET use_proxy ON  /SET proxy_address <Proxy host address> @@ -543,11 +543,12 @@ Irssi contains itâ€™s own proxy which you can build giving \\--with-proxy option  to configure. Youâ€™ll still need to run irssi in a screen to use it though.    Irssi proxy is a bit different than most proxies, normally proxies create a new -connection to IRC server when you connect to it, but irssi proxy shares your -existing IRC connection(s) to multiple clients. And even more clearly: You can -use only one IRC server connection to IRC with as many clients as you want. Can -anyone figure out even more easier ways to say this, so I wouldnâ€™t need to try -to explain this thing for minutes every time? :) +connection to IRC server when a new client connects to it, but irssi proxy +shares your existing IRC connection(s) to multiple clients. And even more +clearly: You can use only one IRC server connection of the irssi proxy to IRC +with as many clients as you want. Can anyone figure out even more easier ways +to say this, so I wouldnâ€™t need to try to explain this thing for minutes every +time? :)    Irssi proxy supports sharing multiple server connections in different ports,  like you can share network in port 2777 and efnet in port 2778. '),('irssi','1.1.1','0b057b4ff43cfc560f67fe8312830289534de7d5','ailin-nemui','run syncdocs.sh and syncscripts.sh  Sync startup howto to fd1ed2227d529a7ee00d6206caa871ee40c08b69 Sync scriptassist to (2003020806) 211cd515ec87cf9a5d893e97894c2e4b58952f19','scriptassist.pl','1169','74','9','4','MODIFY','@@ -5,7 +5,7 @@    use strict;   -our $VERSION = \'2003020804\'; +our $VERSION = \'2003020806\';  our %IRSSI = (      authors     => \'Stefan \\\'tommie\\\' Tomanek\',      contact     => \'stefan@pico.ruhr.de\', @@ -315,6 +315,7 @@ sub get_new {      my $xml = get_scripts();      foreach (sort {$xml->{$b}{last_modified} cmp $xml->{$a}{last_modified}} keys %$xml) {  	my %entry = %{ $xml->{$_} }; +	next if $entry{HIDDEN};  	$result->{$_} = \\%entry;  	$num--;  	last unless $num; @@ -390,6 +391,7 @@ sub search_scripts {      my %result;      foreach (sort keys %{$database}) {  	my %entry = %{$database->{$_}}; +	next if $entry{HIDDEN};  	my $string = $_.\" \";  	$string .= $entry{description} if defined $entry{description};  	if ($string =~ /$query/i) { @@ -1051,7 +1053,7 @@ sub toggle_autorun {      my $dir = Irssi::get_irssi_dir().\"/scripts/\";      mkdir $dir.\"autorun/\" unless (-e $dir.\"autorun/\");      return unless (-e $dir.$plname); -    if (check_autorun($sname)) { +    if (-e $dir.\"/autorun/\".$plname) {  	if (readlink($dir.\"/autorun/\".$plname) eq \"../\".$plname) {  	    if (unlink($dir.\"/autorun/\".$plname)) {  		print CLIENTCRAP \"%R>>%n Autorun of \".$sname.\" disabled\"; @@ -1062,8 +1064,11 @@ sub toggle_autorun {  	    print CLIENTCRAP \"%R>>%n \".$dir.\"/autorun/\".$plname.\" is not a correct link\";  	}      } else { -	symlink(\"../\".$plname, $dir.\"/autorun/\".$plname); -    	print CLIENTCRAP \"%R>>%n Autorun of \".$sname.\" enabled\"; +	if (symlink(\"../\".$plname, $dir.\"/autorun/\".$plname)) { +    	    print CLIENTCRAP \"%R>>%n Autorun of \".$sname.\" enabled\"; +	} else { +	    print CLIENTCRAP \"%R>>%n Unable to create autorun link\"; +	}      }  }   '),('irssi','1.1.1','0b057b4ff43cfc560f67fe8312830289534de7d5','ailin-nemui','run syncdocs.sh and syncscripts.sh  Sync startup howto to fd1ed2227d529a7ee00d6206caa871ee40c08b69 Sync scriptassist to (2003020806) 211cd515ec87cf9a5d893e97894c2e4b58952f19','syncdocs.sh','80','7','1','1','MODIFY','@@ -11,7 +11,7 @@ howto=$site/documentation/startup/  # remove everything until H1 and optionally 2 DIVs before the  # FOOTER. May need to be adjusted as the source pages change  pageclean_regex=\'s{.*(?=<h1)}{}s; -s{\\s*(</div>\\s*)?(</div>\\s*)?<footer.*}{}s; +s{(\\s*<script\\s.*?</script>)?\\s*(</div>\\s*){0,3}<footer.*}{}s;  s{(<.*?)\\sclass=\"(?:highlighter-rouge|highlight)\"(.*?>)}{\\1\\2}g;\'    srcdir=`dirname \"$0\"` '),('irssi','1.1.1','fb9f5174c2f85c113dac8dbc1d146fe530e53e44','LemonBoy','Compare channels/networks fields case-insensitively  Fixes #856','channels-setup.c','156','34','7','2','MODIFY','@@ -37,9 +37,14 @@ static int compare_channel_setup (CONFIG_NODE *node, CHANNEL_SETUP_REC *channel)  	name = config_node_get_str(node, \"name\", NULL);  	chatnet = config_node_get_str(node, \"chatnet\", NULL);   -	if (g_strcmp0(name, channel->name) != 0 ||  -	    g_strcmp0(chatnet, channel->chatnet) != 0) +	if (name == NULL || chatnet == NULL) { +		return 0; +	} + +	if (g_ascii_strcasecmp(name, channel->name) != 0 || +	    g_ascii_strcasecmp(chatnet, channel->chatnet) != 0) {  		return 1; +	}    	return 0;  } '),('irssi','1.1.1','fb9f5174c2f85c113dac8dbc1d146fe530e53e44','LemonBoy','Compare channels/networks fields case-insensitively  Fixes #856','servers-setup.c','508','151','6','1','MODIFY','@@ -474,10 +474,15 @@ static int compare_server_setup (CONFIG_NODE *node, SERVER_SETUP_REC *server)  	chatnet = config_node_get_str(node, \"chatnet\", NULL);  	port = config_node_get_int(node, \"port\", 0);   +	if (address == NULL || chatnet == NULL) { +		return 0; +	} +  	if (g_strcmp0(address, server->address) != 0 ||  	    g_strcmp0(chatnet, server->chatnet) != 0 || -	    port != server->port) +	    port != server->port) {  		return 1; +	}    	return 0;  } '),('irssi','1.1.1','76d958a87fea1d744f45a9e022cf980752c7ea73','LemonBoy','More g_strcmp0 -> g_ascii_strcasecmp','servers-setup.c','508','151','2','2','MODIFY','@@ -478,8 +478,8 @@ static int compare_server_setup (CONFIG_NODE *node, SERVER_SETUP_REC *server)  		return 0;  	}   -	if (g_strcmp0(address, server->address) != 0 || -	    g_strcmp0(chatnet, server->chatnet) != 0 || +	if (g_ascii_strcasecmp(address, server->address) != 0 || +	    g_ascii_strcasecmp(chatnet, server->chatnet) != 0 ||  	    port != server->port) {  		return 1;  	} '),('irssi','1.1.1','7ec6c500b4abed6f3a93a7afaba26ba08ca09be9','ailin-nemui','make default keybinds deletable','keyboard.c','711','159','49','5','MODIFY','@@ -156,6 +156,7 @@ static void keyconfig_save(const char *id, const char *key, const char *data)  static void keyconfig_clear(const char *key)  {  	CONFIG_NODE *node; +	KEY_REC *rec;    	g_return_if_fail(key != NULL);   @@ -165,6 +166,11 @@ static void keyconfig_clear(const char *key)  		iconfig_node_remove(iconfig_node_traverse(\"(keyboard\", FALSE),  				    node);  	} +	if ((rec = g_hash_table_lookup(default_keys, key)) != NULL) { +		node = iconfig_node_traverse(\"(keyboard\", TRUE); +		node = iconfig_node_section(node, NULL, NODE_TYPE_BLOCK); +		iconfig_node_set_str(node, \"key\", key); +	}  }    KEYINFO_REC *key_info_find(const char *id) @@ -569,13 +575,38 @@ void key_configure_remove(const char *key)    	g_return_if_fail(key != NULL);   +	keyconfig_clear(key); +  	rec = g_hash_table_lookup(keys, key);  	if (rec == NULL) return;   -        keyconfig_clear(key);  	key_configure_destroy(rec);  }   +/* Reset key to default */ +void key_configure_reset(const char *key) +{ +	KEY_REC *rec; +	CONFIG_NODE *node; + +	g_return_if_fail(key != NULL); + +	node = key_config_find(key); +	if (node != NULL) { +		iconfig_node_remove(iconfig_node_traverse(\"(keyboard\", FALSE), node); +	} + +	if ((rec = g_hash_table_lookup(default_keys, key)) != NULL) { +		key_configure_create(rec->info->id, rec->key, rec->data); +	} else { +		rec = g_hash_table_lookup(keys, key); +		if (rec == NULL) +			return; + +		key_configure_destroy(rec); +	} +} +  static int key_emit_signal(KEYBOARD_REC *keyboard, KEY_REC *key)  {  	int consumed; @@ -739,7 +770,9 @@ static void cmd_show_keys(const char *searchkey, int full)  		for (key = rec->keys; key != NULL; key = key->next) {  			KEY_REC *rec = key->data;   -			if ((len == 0 || g_ascii_strncasecmp(rec->key, searchkey, len) == 0) && +			if ((len == 0 || +			     (full ? strncmp(rec->key, searchkey, len) == 0 : +			             g_ascii_strncasecmp(rec->key, searchkey, len) == 0)) &&  			    (!full || rec->key[len] == \'\\0\')) {  				printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_BIND_LIST,  					    rec->key, rec->info->id, rec->data == NULL ? \"\" : rec->data); @@ -750,7 +783,7 @@ static void cmd_show_keys(const char *searchkey, int full)  	printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_BIND_FOOTER);  }   -/* SYNTAX: BIND [-list] [-delete] [<key> [<command> [<data>]]] */ +/* SYNTAX: BIND [-list] [-delete | -reset] [<key> [<command> [<data>]]] */  static void cmd_bind(const char *data)  {  	GHashTable *optlist; @@ -780,6 +813,12 @@ static void cmd_bind(const char *data)  		key_configure_remove(key);  		cmd_params_free(free_arg);  		return; +	} else if (*key != \'\\0\' && g_hash_table_lookup(optlist, \"reset\")) { +		/* reset key */ +		key_configure_reset(key); +		cmd_show_keys(key, TRUE); +		cmd_params_free(free_arg); +		return;  	}    	if (*id == \'\\0\') { @@ -878,8 +917,13 @@ static void key_config_read(CONFIG_NODE *node)  	id = config_node_get_str(node, \"id\", NULL);  	data = config_node_get_str(node, \"data\", NULL);   -	if (key != NULL && id != NULL) +	if (key != NULL && id != NULL) {  		key_configure_create(id, key, data); +	} else if (key != NULL && id == NULL && data == NULL) { +		KEY_REC *rec = g_hash_table_lookup(keys, key); +		if (rec != NULL) +			key_configure_destroy(rec); +	}  }    static void read_keyboard_config(void) @@ -938,7 +982,7 @@ void keyboard_init(void)  	signal_add(\"complete command bind\", (SIGNAL_FUNC) sig_complete_bind);    	command_bind(\"bind\", NULL, (SIGNAL_FUNC) cmd_bind); -	command_set_options(\"bind\", \"delete list\"); +	command_set_options(\"bind\", \"delete reset list\");  }    void keyboard_deinit(void) '),('irssi','1.1.1','b7906b87065829029f3b7ea21eb29699f7dc21fc','ailin-nemui','in fact hidden levels should not be re-set when you run /set','gui-windows.c','222','52','0','2','MODIFY','@@ -207,8 +207,6 @@ void gui_windows_reset_settings(void)  		WINDOW_REC *rec = tmp->data;  		GUI_WINDOW_REC *gui = WINDOW_GUI(rec);   -		textbuffer_view_set_hidden_level(gui->view, MSGLEVEL_HIDDEN); -  		textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));    		textbuffer_view_set_default_indent(gui->view, '),('irssi','1.1.1','8d07f52bae6fa7e85988125293f08a72e39de8c3','Alexander FÃ¦rÃ¸y','Add ABI check for otr_core module.','module.c','149','29','6','0','MODIFY','@@ -24,6 +24,7 @@    #include \"module.h\"   +#include \"common.h\"  #include \"signals.h\"  #include \"queries.h\"  #include \"commands.h\" @@ -259,3 +260,8 @@ void otr_core_deinit(void)    	otr_lib_uninit();  } + +void otr_core_abicheck(int *version) +{ +	*version = IRSSI_ABI_VERSION; +} '),('irssi','1.1.1','65a139aa9e8a7cb7a7a123ab57ee05836c9e89ea','ailin-nemui','move no window printing code','gui-printtext.c','271','58','19','14','MODIFY','@@ -249,9 +249,26 @@ static void view_add_eol(TEXT_BUFFER_VIEW_REC *view, LINE_REC **line)  	textbuffer_view_insert_line(view, *line);  }   +static void print_text_no_window(int flags, int fg, int bg, int attr, const char *str) +{ +	g_return_if_fail(next_xpos != -1); + +	term_set_color2(root_window, attr, fg, bg); + +	term_move(root_window, next_xpos, next_ypos); +	if (flags & GUI_PRINT_FLAG_CLRTOEOL) { +		if (clrtoeol_info->window != NULL) { +			term_window_clrtoeol_abs(clrtoeol_info->window, next_ypos); +		} else { +			term_clrtoeol(root_window); +		} +	} +	next_xpos += term_addstr(root_window, str); +} +  static void sig_gui_print_text(WINDOW_REC *window, void *fgcolor,  			       void *bgcolor, void *pflags, -			       char *str, TEXT_DEST_REC *dest) +			       const char *str, TEXT_DEST_REC *dest)  {          GUI_WINDOW_REC *gui;          TEXT_BUFFER_VIEW_REC *view; @@ -265,19 +282,7 @@ static void sig_gui_print_text(WINDOW_REC *window, void *fgcolor,  	get_colors(flags, &fg, &bg, &attr);    	if (window == NULL) { -		g_return_if_fail(next_xpos != -1); - -		term_set_color2(root_window, attr, fg, bg); - -		term_move(root_window, next_xpos, next_ypos); -		if (flags & GUI_PRINT_FLAG_CLRTOEOL) { -			if (clrtoeol_info->window != NULL) { -				term_window_clrtoeol_abs(clrtoeol_info->window, next_ypos); -			} else { -				term_clrtoeol(root_window); -			} -		} -		next_xpos += term_addstr(root_window, str); +		print_text_no_window(flags, fg, bg, attr, str);  		return;  	}   '),('irssi','1.1.1','c7ca8102c002287f492ca71f2193ee9b269f5bf5','ailin-nemui','fix a crash when trying to append to a NULL line  reported by @vague666','gui-printtext.c','275','60','7','0','MODIFY','@@ -120,12 +120,19 @@ void gui_printtext_internal(int xpos, int ypos, const char *str)  	next_xpos = next_ypos = -1;  }   +static void view_add_eol(TEXT_BUFFER_VIEW_REC *view, LINE_REC **line); +  void gui_printtext_after_time(TEXT_DEST_REC *dest, LINE_REC *prev, const char *str, time_t time)  {  	GUI_WINDOW_REC *gui;    	gui = WINDOW_GUI(dest->window);   +	if (prev == NULL && !gui->view->buffer->last_eol) { +		/* we have an unfinished line in the buffer still */ +		view_add_eol(gui->view, &gui->insert_after); +	} +  	gui->use_insert_after = TRUE;  	gui->insert_after = prev;  	gui->insert_after_time = time; '),('irssi','1.1.1','c7ca8102c002287f492ca71f2193ee9b269f5bf5','ailin-nemui','fix a crash when trying to append to a NULL line  reported by @vague666','textbuffer-view.c','1084','269','4','1','MODIFY','@@ -913,11 +913,14 @@ void textbuffer_view_resize(TEXT_BUFFER_VIEW_REC *view, int width, int height)  	} else if (view->startline == view->bottom_startline &&  		   view->subline > view->bottom_subline) {                  view->subline = view->bottom_subline; -	} else { +	} else if (view->startline != NULL) {  		/* make sure the subline is still in allowed range */  		linecount = view_get_linecount(view, view->startline);  		if (view->subline > linecount)                          view->subline = linecount; +	} else { +		/* we don\'t have a startline. still under construction? */ +		view->subline = 0;  	}    	textbuffer_view_init_ypos(view); '),('irssi','1.1.1','77a671c03726969525367f36429c448a3a0aaae8','ailin-nemui','update bind help','bind.in','23','0','2','1','MODIFY','@@ -6,7 +6,8 @@  %9Parameters:%9        -list:      Displays a list of all the bindable commands. -    -delete:    Removes the binding, +    -delete:    Removes the binding. +    -reset:     Reset a key to its default binding.        A name of the binding and the command to perform; if no parameter is given,      the list of bindings will be displayed. '),('irssi','1.1.1','d845ee7361886599f6ffa4f403b44a3f45fd88db','ailin-nemui','change the statusbar commands so that no accidenal status bars are created','statusbar.in','46','0','32','19','MODIFY','@@ -5,27 +5,35 @@    %9Parameters:%9   -    ENABLE:       Adds a statusbar to the list of statusbars. -    DISABLE:      Removes a statusbar from the list. Note that for -                  built-in statusbars they can be enabled again should the -                  user wish to add back the default statusbars. +    ADD:          Adds a statusbar to the list of statusbars. +    MODIFY:       Modifies the configuration of a statusbar.      RESET:        Restores the default statusbar configuration. -    TYPE:         Sets the type of statusbar, for each split window or only +    ADDITEM:      Adds an item to the specified statusbar. It can be set to +                  appear before/after another item and left/right aligned +                  to a specified position on the screen. +    MODIFYITEM:   Changes an item position inside a bar. +    REMOVEITEM:   Removes an item from the specified statusbar. +    INFO:         List the current details and items of the specified +                  statusbar. + +    -disable:     Removes a statusbar from the list. +    -type:        Sets the type of statusbar, for each split window or only                    for the current root screen. -    PLACEMENT:    Sets the placement of the statusbar, either at the top or +    -placement:   Sets the placement of the statusbar, either at the top or                    the bottom of the screen. -    POSITION:     Sets the position of the statusbar. Represented as a +    -position:    Sets the position of the statusbar. Represented as a                    number, with 0 implying the first position. -    VISIBLE:      Sets the visibility of the statusbar or item. If set to +    -visible:     Sets the visibility of the statusbar or item. If set to                    always it is visible on all screens, otherwise if set to                    inactive or active then it is only visible on inactive                    or active screens, respectively. -    ADD:          Adds an item to the specified statusbar. It can be set to -                  appear before/after another item and left/right aligned -                  to a specified position on the screen. -    REMOVE:       Removes an item from the specified statusbar. +    -before:      This item is added before the other item. +    -after:       This item is added after the other item. +    -priority:    When the statusbar items overflow, the item with the +                  lowest priority is removed first +    -alignment:   Display the item on the right side.   -    Where name refers to the name of the statusbar; if no argument is +    Where statusbar refers to the name of the statusbar; if no argument is      given, the entire list of statusbars will be displayed.    %9Description:%9 @@ -36,12 +44,17 @@  %9Examples:%9        /STATUSBAR -    /STATUSBAR window -    /STATUSBAR window REMOVE time -    /STATUSBAR window ADD time -    /STATUSBAR window RESET -    /STATUSBAR topic DISABLE -    /STATUSBAR topic ENABLE +    /STATUSBAR INFO window +    /STATUSBAR REMOVEITEM time window +    /STATUSBAR ADDITEM time window +    /STATUSBAR RESET window +    /STATUSBAR MODIFY -disable topic +    /STATUSBAR MODIFY -nodisable topic + +%9Remarks:%9 + +    Statusbar syntax was changed in Irssi 1.2. The old syntax is still +    accepted for backward compatibility, but no longer documented.    %9See also:%9 WINDOW   '),('irssi','1.1.1','d845ee7361886599f6ffa4f403b44a3f45fd88db','ailin-nemui','change the statusbar commands so that no accidenal status bars are created','statusbar-config.c','560','128','275','156','MODIFY','@@ -95,8 +95,10 @@ statusbar_config_find(STATUSBAR_GROUP_REC *group, const char *name)  	for (tmp = group->config_bars; tmp != NULL; tmp = tmp->next) {  		STATUSBAR_CONFIG_REC *config = tmp->data;   -		if (g_strcmp0(config->name, name) == 0) -                        return config; +		if ((config->name == NULL || name == NULL) ? +		        config->name == name : +		        g_ascii_strcasecmp(config->name, name) == 0) +			return config;  	}            return NULL; @@ -273,6 +275,24 @@ static const char *sbar_get_visibility(STATUSBAR_CONFIG_REC *rec)  		rec->visible == STATUSBAR_VISIBLE_INACTIVE ? \"inactive\" : \"??\";  }   +static CONFIG_NODE *sbar_node(const char *name, gboolean create) +{ +	CONFIG_NODE *node; +	STATUSBAR_CONFIG_REC *rec = statusbar_config_find(active_statusbar_group, name); +	if (rec != NULL) { +		name = rec->name; +	} else if (!create) { +		return NULL; +	} + +	/* lookup/create the statusbar node */ +	node = iconfig_node_traverse(\"statusbar\", TRUE); +	node = iconfig_node_section(node, active_statusbar_group->name, NODE_TYPE_BLOCK); +	node = iconfig_node_section(node, name, NODE_TYPE_BLOCK); + +	return node; +} +  static void statusbar_list_items(STATUSBAR_CONFIG_REC *bar)  {  	GSList *tmp; @@ -334,98 +354,133 @@ static void cmd_statusbar_list(void)    static void cmd_statusbar_print_info(const char *name)  { -	GSList *tmp; +	STATUSBAR_CONFIG_REC *rec = statusbar_config_find(active_statusbar_group, name);   -        tmp = active_statusbar_group->config_bars; -	for (; tmp != NULL; tmp = tmp->next) { -		STATUSBAR_CONFIG_REC *rec = tmp->data; - -		if (g_ascii_strcasecmp(rec->name, name) == 0) { -                        statusbar_print(rec); -			return; -		} +	if (rec != NULL) { +		statusbar_print(rec); +		return;  	}    	printformat(NULL, NULL, MSGLEVEL_CLIENTERROR,  		    TXT_STATUSBAR_NOT_FOUND, name);  }   -/* SYNTAX: STATUSBAR <name> ENABLE */ -static void cmd_statusbar_enable(const char *data, void *server, -				 void *item, CONFIG_NODE *node) +/* SYNTAX: STATUSBAR ADD|MODIFY [-disable | -nodisable] [-type window|root] +           [-placement top|bottom] [-position #] [-visible always|active|inactive] <statusbar> */ +static void cmd_statusbar_add_modify(const char *data, void *server, void *witem)  { -        iconfig_node_set_str(node, \"disabled\", NULL); -} +	GHashTable *optlist; +	CONFIG_NODE *node; +	char *name, *type, *placement, *visible; +	void *free_arg; +	int error;   -/* SYNTAX: STATUSBAR <name> DISABLE */ -static void cmd_statusbar_disable(const char *data, void *server, -				  void *item, CONFIG_NODE *node) -{ -        iconfig_node_set_bool(node, \"disabled\", TRUE); -} +	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_OPTIONS | PARAM_FLAG_STRIP_TRAILING_WS, +	                    \"statusbar add\", &optlist, &name)) +		return;   -/* SYNTAX: STATUSBAR <name> RESET */ -static void cmd_statusbar_reset(const char *data, void *server, -				void *item, CONFIG_NODE *node) -{ -	CONFIG_NODE *parent; +	if (*name == \'\\0\') { +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); +	}   -	parent = iconfig_node_traverse(\"statusbar\", TRUE); -	parent = iconfig_node_section(parent, active_statusbar_group->name, -				     NODE_TYPE_BLOCK); +	error = 0; + +	type = NULL; +	data = g_hash_table_lookup(optlist, \"type\"); +	if (data != NULL) { +		if (g_ascii_strcasecmp(data, \"window\") == 0) +			type = \"window\"; +		else if (g_ascii_strcasecmp(data, \"root\") == 0) +			type = \"root\"; +		else { +			printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_UNKNOWN_TYPE, +			            data); +			error++; +		} +	}   -        iconfig_node_set_str(parent, node->key, NULL); -} +	placement = NULL; +	data = g_hash_table_lookup(optlist, \"placement\"); +	if (data != NULL) { +		if (g_ascii_strcasecmp(data, \"top\") == 0) +			placement = \"top\"; +		else if (g_ascii_strcasecmp(data, \"bottom\") == 0) +			placement = \"bottom\"; +		else { +			printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +			            TXT_STATUSBAR_UNKNOWN_PLACEMENT, data); +			error++; +		} +	}   -/* SYNTAX: STATUSBAR <name> TYPE window|root */ -static void cmd_statusbar_type(const char *data, void *server, -			       void *item, CONFIG_NODE *node) -{ -	if (g_ascii_strcasecmp(data, \"window\") == 0) -		iconfig_node_set_str(node, \"type\", \"window\"); -        else if (g_ascii_strcasecmp(data, \"root\") == 0) -		iconfig_node_set_str(node, \"type\", \"root\"); -	else { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, -			    TXT_STATUSBAR_UNKNOWN_TYPE, data); +	visible = NULL; +	data = g_hash_table_lookup(optlist, \"visible\"); +	if (data != NULL) { +		if (g_ascii_strcasecmp(data, \"always\") == 0) +			visible = \"always\"; +		else if (g_ascii_strcasecmp(data, \"active\") == 0) +			visible = \"active\"; +		else if (g_ascii_strcasecmp(data, \"inactive\") == 0) +			visible = \"inactive\"; +		else { +			printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +			            TXT_STATUSBAR_UNKNOWN_VISIBILITY, data); +			error++; +		}  	} -}   -/* SYNTAX: STATUSBAR <name> PLACEMENT top|bottom */ -static void cmd_statusbar_placement(const char *data, void *server, -				    void *item, CONFIG_NODE *node) -{ -	if (g_ascii_strcasecmp(data, \"top\") == 0) -		iconfig_node_set_str(node, \"placement\", \"top\"); -        else if (g_ascii_strcasecmp(data, \"bottom\") == 0) -		iconfig_node_set_str(node, \"placement\", \"bottom\"); -	else { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, -			    TXT_STATUSBAR_UNKNOWN_PLACEMENT, data); +	if (error) { +		cmd_params_free(free_arg); +		return;  	} -}   -/* SYNTAX: STATUSBAR <name> POSITION <num> */ -static void cmd_statusbar_position(const char *data, void *server, -                                   void *item, CONFIG_NODE *node) -{ -	iconfig_node_set_int(node, \"position\", atoi(data)); +	node = sbar_node(name, TRUE); +	if (g_hash_table_lookup(optlist, \"nodisable\")) +		iconfig_node_set_str(node, \"disabled\", NULL); +	if (g_hash_table_lookup(optlist, \"disable\")) +		iconfig_node_set_bool(node, \"disabled\", TRUE); +	if (type != NULL) +		iconfig_node_set_str(node, \"type\", type); +	if (placement != NULL) +		iconfig_node_set_str(node, \"placement\", placement); +	data = g_hash_table_lookup(optlist, \"position\"); +	if (data != NULL) +		iconfig_node_set_int(node, \"position\", atoi(data)); +	if (visible != NULL) +		iconfig_node_set_str(node, \"visible\", visible); + +	read_statusbar_config(); +	cmd_params_free(free_arg);  }   -/* SYNTAX: STATUSBAR <name> VISIBLE always|active|inactive */ -static void cmd_statusbar_visible(const char *data, void *server, -				  void *item, CONFIG_NODE *node) +/* SYNTAX: STATUSBAR RESET <statusbar> */ +static void cmd_statusbar_reset(const char *data, void *server, void *witem)  { -	if (g_ascii_strcasecmp(data, \"always\") == 0) -		iconfig_node_set_str(node, \"visible\", \"always\"); -        else if (g_ascii_strcasecmp(data, \"active\") == 0) -		iconfig_node_set_str(node, \"visible\", \"active\"); -        else if (g_ascii_strcasecmp(data, \"inactive\") == 0) -		iconfig_node_set_str(node, \"visible\", \"inactive\"); -	else { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, -			    TXT_STATUSBAR_UNKNOWN_VISIBILITY, data); +	CONFIG_NODE *node, *parent; +	char *name; +	void *free_arg; + +	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_STRIP_TRAILING_WS, &name)) +		return; + +	if (*name == \'\\0\') { +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);  	} + +	node = sbar_node(name, FALSE); +	if (node == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, name); +		cmd_params_free(free_arg); +		return; +	} + +	parent = iconfig_node_traverse(\"statusbar\", TRUE); +	parent = iconfig_node_section(parent, active_statusbar_group->name, NODE_TYPE_BLOCK); + +	iconfig_node_set_str(parent, node->key, NULL); + +	read_statusbar_config(); +	cmd_params_free(free_arg);  }    static CONFIG_NODE *statusbar_items_section(CONFIG_NODE *parent) @@ -455,45 +510,58 @@ static CONFIG_NODE *statusbar_items_section(CONFIG_NODE *parent)  		node = iconfig_node_section(parent, rec->name,  					   NODE_TYPE_BLOCK);  		if (rec->priority != 0) -                        iconfig_node_set_int(node, \"priority\", rec->priority); +			iconfig_node_set_int(node, \"priority\", rec->priority);  		if (rec->right_alignment) -                        iconfig_node_set_str(node, \"alignment\", \"right\"); +			iconfig_node_set_str(node, \"alignment\", \"right\");  	}   -        return parent; +	return parent;  }   -/* SYNTAX: STATUSBAR <name> ADD [-before | -after <item>] -           [-priority #] [-alignment left|right] <item> */ -static void cmd_statusbar_add(const char *data, void *server, -			      void *item, CONFIG_NODE *node) +/* SYNTAX: STATUSBAR ADDITEM|MODIFYITEM [-before | -after <item>] +           [-priority #] [-alignment left|right] <item> <statusbar> */ +static void cmd_statusbar_additem_modifyitem(const char *data, void *server, void *witem)  { -        GHashTable *optlist; -        char *name, *value; +	CONFIG_NODE *node; +	GHashTable *optlist; +	char *item, *statusbar, *value;  	void *free_arg; -        int index; +	int index;   -	node = statusbar_items_section(node); -	if (node == NULL) -                return; +	if (!cmd_get_params(data, &free_arg, 2 | PARAM_FLAG_OPTIONS | PARAM_FLAG_STRIP_TRAILING_WS, +	                    \"statusbar additem\", &optlist, &item, &statusbar)) +		return; + +	if (*statusbar == \'\\0\') { +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); +	}   -	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_OPTIONS, -			    \"statusbar add\", &optlist, &name)) +	node = sbar_node(statusbar, FALSE); +	if (node == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, statusbar); +		cmd_params_free(free_arg);  		return; +	} + +	node = statusbar_items_section(node); +	if (node == NULL) { +		cmd_params_free(free_arg); +		return; +	}   -        /* get the index */ +	/* get the index */  	index = -1;  	value = g_hash_table_lookup(optlist, \"before\");  	if (value != NULL) index = config_node_index(node, value);  	value = g_hash_table_lookup(optlist, \"after\");  	if (value != NULL) index = config_node_index(node, value)+1;   -        /* create/move item */ -	node = iconfig_node_section_index(node, name, index, NODE_TYPE_BLOCK); +	/* create/move item */ +	node = iconfig_node_section_index(node, item, index, NODE_TYPE_BLOCK);   -        /* set the options */ -        value = g_hash_table_lookup(optlist, \"priority\"); -        if (value != NULL) iconfig_node_set_int(node, \"priority\", atoi(value)); +	/* set the options */ +	value = g_hash_table_lookup(optlist, \"priority\"); +	if (value != NULL) iconfig_node_set_int(node, \"priority\", atoi(value));    	value = g_hash_table_lookup(optlist, \"alignment\");  	if (value != NULL) { @@ -502,67 +570,115 @@ static void cmd_statusbar_add(const char *data, void *server,  				     \"right\" : NULL);  	}   +	read_statusbar_config();  	cmd_params_free(free_arg);  }   -/* SYNTAX: STATUSBAR <name> REMOVE <item> */ -static void cmd_statusbar_remove(const char *data, void *server, -				 void *item, CONFIG_NODE *node) +/* SYNTAX: STATUSBAR REMOVEITEM <item> <statusbar> */ +static void cmd_statusbar_removeitem(const char *data, void *server, void *witem)  { -        node = statusbar_items_section(node); -	if (node == NULL) -                return; +	CONFIG_NODE *node; +	char *item, *statusbar; +	void *free_arg; +	if (!cmd_get_params(data, &free_arg, 2 | PARAM_FLAG_STRIP_TRAILING_WS, &item, &statusbar)) +		return; + +	if (*statusbar == \'\\0\') { +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); +	} + +	node = sbar_node(statusbar, FALSE); +	if (node == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, statusbar); +		cmd_params_free(free_arg); +		return; +	}   -	if (iconfig_node_section(node, data, -1) != NULL) -		iconfig_node_set_str(node, data, NULL); +	node = statusbar_items_section(node); +	if (node == NULL) { +		cmd_params_free(free_arg); +		return; +	} + +	if (iconfig_node_section(node, item, -1) != NULL) +		iconfig_node_set_str(node, item, NULL);  	else { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, -			    TXT_STATUSBAR_ITEM_NOT_FOUND, data); +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item);  	} + +	read_statusbar_config(); +	cmd_params_free(free_arg);  }   -static void cmd_statusbar(const char *data) +/* SYNTAX: STATUSBAR INFO <statusbar> */ +static void cmd_statusbar_info(const char *data)  { -        CONFIG_NODE *node; -	char *name, *cmd, *params, *signal;  	void *free_arg; - -	if (!cmd_get_params(data, &free_arg, 3 | PARAM_FLAG_GETREST, -			    &name, &cmd, &params)) +	char *name; +	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_STRIP_TRAILING_WS, &name))  		return;    	if (*name == \'\\0\') { -		/* list all statusbars */ -                cmd_statusbar_list(); -		cmd_params_free(free_arg); -                return; +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);  	}   -	if (*cmd == \'\\0\') { -		/* print statusbar info */ -                cmd_statusbar_print_info(name); -		cmd_params_free(free_arg); -                return; -	} +	/* print statusbar info */ +	cmd_statusbar_print_info(name); +	cmd_params_free(free_arg); +	return; +}   -        /* lookup/create the statusbar node */ -	node = iconfig_node_traverse(\"statusbar\", TRUE); -	node = iconfig_node_section(node, active_statusbar_group->name, -				   NODE_TYPE_BLOCK); -	node = iconfig_node_section(node, name, NODE_TYPE_BLOCK); +static void cmd_statusbar(const char *data) +{ +	char *arg1, *arg2, *params, *oldcmd; +	void *free_arg;   -	/* call the subcommand */ -	signal = g_strconcat(\"command statusbar \", cmd, NULL); -	ascii_strdown(signal); -	if (!signal_emit(signal, 4, params, NULL, NULL, node)) { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, -			    TXT_STATUSBAR_UNKNOWN_COMMAND, cmd); -	} else { -                read_statusbar_config(); +	if (!cmd_get_params(data, &free_arg, 3 | PARAM_FLAG_GETREST | PARAM_FLAG_STRIP_TRAILING_WS, +	                    &arg1, &arg2, &params)) +		return; + +	/* backward compatibility layer */ +	oldcmd = NULL; +	if (*arg1 == \'\\0\') { +		oldcmd = g_strdup(\"list\"); +	} else if (g_ascii_strcasecmp(arg2, \"enable\") == 0) { +		oldcmd = g_strdup_printf(\"add -nodisable %s %s\", arg1, params); +	} else if (g_ascii_strcasecmp(arg2, \"disable\") == 0) { +		oldcmd = g_strdup_printf(\"add -disable %s %s\", arg1, params); +	} else if (g_ascii_strcasecmp(arg2, \"reset\") == 0) { +		oldcmd = g_strdup_printf(\"reset %s\", arg1); +	} else if (g_ascii_strcasecmp(arg2, \"type\") == 0) { +		oldcmd = g_strdup_printf(\"add -type %s %s\", params, arg1); +	} else if (g_ascii_strcasecmp(arg2, \"placement\") == 0) { +		oldcmd = g_strdup_printf(\"add -placement %s %s\", params, arg1); +	} else if (g_ascii_strcasecmp(arg2, \"position\") == 0) { +		oldcmd = g_strdup_printf(\"add -position %s %s\", params, arg1); +	} else if (g_ascii_strcasecmp(arg2, \"visible\") == 0) { +		oldcmd = g_strdup_printf(\"add -visible %s %s\", params, arg1); +	} else if (g_ascii_strcasecmp(arg2, \"add\") == 0) { +		oldcmd = g_strdup_printf(\"additem %s %s\", params, arg1); +	} else if (g_ascii_strcasecmp(arg2, \"remove\") == 0) { +		oldcmd = g_strdup_printf(\"removeitem %s %s\", params, arg1); +	} else if (*arg2 == \'\\0\') { +		oldcmd = g_strdup_printf(\"statusbar %s\", arg1); +		if (command_find(oldcmd) == NULL) { +			g_free(oldcmd); +			oldcmd = g_strdup_printf(\"info %s\", arg1); +		} else { +			g_free(oldcmd); +			oldcmd = NULL; +		}  	} -	g_free(signal);    	cmd_params_free(free_arg); +	if (oldcmd) { +		command_runsub(\"statusbar\", oldcmd, NULL, NULL); +		g_free(oldcmd); +	} else { +		command_runsub(\"statusbar\", data, NULL, NULL); +	} + +	return;  }    void statusbar_config_init(void) @@ -571,18 +687,22 @@ void statusbar_config_init(void)  	signal_add_last(\"setup reread\", (SIGNAL_FUNC) read_statusbar_config);  	signal_add(\"theme changed\", (SIGNAL_FUNC) read_statusbar_config);   -        command_bind(\"statusbar\", NULL, (SIGNAL_FUNC) cmd_statusbar); -        command_bind(\"statusbar enable\", NULL, (SIGNAL_FUNC) cmd_statusbar_enable); -        command_bind(\"statusbar disable\", NULL, (SIGNAL_FUNC) cmd_statusbar_disable); -        command_bind(\"statusbar reset\", NULL, (SIGNAL_FUNC) cmd_statusbar_reset); -        command_bind(\"statusbar add\", NULL, (SIGNAL_FUNC) cmd_statusbar_add); -        command_bind(\"statusbar remove\", NULL, (SIGNAL_FUNC) cmd_statusbar_remove); -        command_bind(\"statusbar type\", NULL, (SIGNAL_FUNC) cmd_statusbar_type); -        command_bind(\"statusbar placement\", NULL, (SIGNAL_FUNC) cmd_statusbar_placement); -        command_bind(\"statusbar position\", NULL, (SIGNAL_FUNC) cmd_statusbar_position); -        command_bind(\"statusbar visible\", NULL, (SIGNAL_FUNC) cmd_statusbar_visible); - -	command_set_options(\"statusbar add\", \"+before +after +priority +alignment\"); +	command_bind(\"statusbar\", NULL, (SIGNAL_FUNC) cmd_statusbar); +	command_bind(\"statusbar list\", NULL, (SIGNAL_FUNC) cmd_statusbar_list); +	command_bind(\"statusbar add\", NULL, (SIGNAL_FUNC) cmd_statusbar_add_modify); +	command_bind(\"statusbar modify\", NULL, (SIGNAL_FUNC) cmd_statusbar_add_modify); +	command_bind(\"statusbar reset\", NULL, (SIGNAL_FUNC) cmd_statusbar_reset); +	command_bind(\"statusbar info\", NULL, (SIGNAL_FUNC) cmd_statusbar_info); +	command_bind(\"statusbar additem\", NULL, (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); +	command_bind(\"statusbar modifyitem\", NULL, (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); +	command_bind(\"statusbar removeitem\", NULL, (SIGNAL_FUNC) cmd_statusbar_removeitem); + +	command_set_options(\"statusbar additem\", \"+before +after +priority +alignment\"); +	command_set_options(\"statusbar modifyitem\", \"+before +after +priority +alignment\"); +	command_set_options(\"statusbar add\", +	                    \"disable nodisable +type +placement +position +visible\"); +	command_set_options(\"statusbar modify\", +	                    \"disable nodisable +type +placement +position +visible\");  }    void statusbar_config_deinit(void) @@ -590,14 +710,13 @@ void statusbar_config_deinit(void)  	signal_remove(\"setup reread\", (SIGNAL_FUNC) read_statusbar_config);  	signal_remove(\"theme changed\", (SIGNAL_FUNC) read_statusbar_config);   -        command_unbind(\"statusbar\", (SIGNAL_FUNC) cmd_statusbar); -        command_unbind(\"statusbar enable\", (SIGNAL_FUNC) cmd_statusbar_enable); -        command_unbind(\"statusbar disable\", (SIGNAL_FUNC) cmd_statusbar_disable); -        command_unbind(\"statusbar reset\", (SIGNAL_FUNC) cmd_statusbar_reset); -        command_unbind(\"statusbar add\", (SIGNAL_FUNC) cmd_statusbar_add); -        command_unbind(\"statusbar remove\", (SIGNAL_FUNC) cmd_statusbar_remove); -        command_unbind(\"statusbar type\", (SIGNAL_FUNC) cmd_statusbar_type); -        command_unbind(\"statusbar placement\", (SIGNAL_FUNC) cmd_statusbar_placement); -        command_unbind(\"statusbar position\", (SIGNAL_FUNC) cmd_statusbar_position); -        command_unbind(\"statusbar visible\", (SIGNAL_FUNC) cmd_statusbar_visible); +	command_unbind(\"statusbar\", (SIGNAL_FUNC) cmd_statusbar); +	command_unbind(\"statusbar list\", (SIGNAL_FUNC) cmd_statusbar_list); +	command_unbind(\"statusbar add\", (SIGNAL_FUNC) cmd_statusbar_add_modify); +	command_unbind(\"statusbar modify\", (SIGNAL_FUNC) cmd_statusbar_add_modify); +	command_unbind(\"statusbar reset\", (SIGNAL_FUNC) cmd_statusbar_reset); +	command_unbind(\"statusbar info\", (SIGNAL_FUNC) cmd_statusbar_info); +	command_unbind(\"statusbar additem\", (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); +	command_unbind(\"statusbar modifyitem\", (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); +	command_unbind(\"statusbar removeitem\", (SIGNAL_FUNC) cmd_statusbar_removeitem);  } '),('irssi','1.1.1','61c58b7690e9eec159ba32e5ea40809ed17ef424','ailin-nemui','actually check which of add or modify was called','statusbar-config.c','573','132','25','9','MODIFY','@@ -374,6 +374,7 @@ static void cmd_statusbar_add_modify(const char *data, void *server, void *witem  	char *name, *type, *placement, *visible;  	void *free_arg;  	int error; +	int add = GPOINTER_TO_INT(signal_get_user_data());    	if (!cmd_get_params(data, &free_arg, 1 | PARAM_FLAG_OPTIONS | PARAM_FLAG_STRIP_TRAILING_WS,  	                    \"statusbar add\", &optlist, &name)) @@ -429,12 +430,20 @@ static void cmd_statusbar_add_modify(const char *data, void *server, void *witem  		}  	}   +	if (!error) { +		node = sbar_node(name, add); + +		if (node == NULL) { +			printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, name); +			error++; +		} +	} +  	if (error) {  		cmd_params_free(free_arg);  		return;  	}   -	node = sbar_node(name, TRUE);  	if (g_hash_table_lookup(optlist, \"nodisable\"))  		iconfig_node_set_str(node, \"disabled\", NULL);  	if (g_hash_table_lookup(optlist, \"disable\")) @@ -527,6 +536,7 @@ static void cmd_statusbar_additem_modifyitem(const char *data, void *server, voi  	char *item, *statusbar, *value;  	void *free_arg;  	int index; +	int additem = GINT_TO_POINTER(signal_get_user_data());    	if (!cmd_get_params(data, &free_arg, 2 | PARAM_FLAG_OPTIONS | PARAM_FLAG_STRIP_TRAILING_WS,  	                    \"statusbar additem\", &optlist, &item, &statusbar)) @@ -556,6 +566,12 @@ static void cmd_statusbar_additem_modifyitem(const char *data, void *server, voi  	value = g_hash_table_lookup(optlist, \"after\");  	if (value != NULL) index = config_node_index(node, value)+1;   +	if (!additem && iconfig_node_section(node, item, -1) == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); +		cmd_params_free(free_arg); +		return; +	} +  	/* create/move item */  	node = iconfig_node_section_index(node, item, index, NODE_TYPE_BLOCK);   @@ -689,12 +705,12 @@ void statusbar_config_init(void)    	command_bind(\"statusbar\", NULL, (SIGNAL_FUNC) cmd_statusbar);  	command_bind(\"statusbar list\", NULL, (SIGNAL_FUNC) cmd_statusbar_list); -	command_bind(\"statusbar add\", NULL, (SIGNAL_FUNC) cmd_statusbar_add_modify); -	command_bind(\"statusbar modify\", NULL, (SIGNAL_FUNC) cmd_statusbar_add_modify); +	command_bind_data(\"statusbar add\", NULL, (SIGNAL_FUNC) cmd_statusbar_add_modify, GINT_TO_POINTER(TRUE)); +	command_bind_data(\"statusbar modify\", NULL, (SIGNAL_FUNC) cmd_statusbar_add_modify, GINT_TO_POINTER(FALSE));  	command_bind(\"statusbar reset\", NULL, (SIGNAL_FUNC) cmd_statusbar_reset);  	command_bind(\"statusbar info\", NULL, (SIGNAL_FUNC) cmd_statusbar_info); -	command_bind(\"statusbar additem\", NULL, (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); -	command_bind(\"statusbar modifyitem\", NULL, (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); +	command_bind_data(\"statusbar additem\", NULL, (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem, GINT_TO_POINTER(TRUE)); +	command_bind_data(\"statusbar modifyitem\", NULL, (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem, GINT_TO_POINTER(FALSE));  	command_bind(\"statusbar removeitem\", NULL, (SIGNAL_FUNC) cmd_statusbar_removeitem);    	command_set_options(\"statusbar additem\", \"+before +after +priority +alignment\"); @@ -712,11 +728,11 @@ void statusbar_config_deinit(void)    	command_unbind(\"statusbar\", (SIGNAL_FUNC) cmd_statusbar);  	command_unbind(\"statusbar list\", (SIGNAL_FUNC) cmd_statusbar_list); -	command_unbind(\"statusbar add\", (SIGNAL_FUNC) cmd_statusbar_add_modify); -	command_unbind(\"statusbar modify\", (SIGNAL_FUNC) cmd_statusbar_add_modify); +	command_unbind_full(\"statusbar add\", (SIGNAL_FUNC) cmd_statusbar_add_modify, GINT_TO_POINTER(TRUE)); +	command_unbind_full(\"statusbar modify\", (SIGNAL_FUNC) cmd_statusbar_add_modify, GINT_TO_POINTER(FALSE));  	command_unbind(\"statusbar reset\", (SIGNAL_FUNC) cmd_statusbar_reset);  	command_unbind(\"statusbar info\", (SIGNAL_FUNC) cmd_statusbar_info); -	command_unbind(\"statusbar additem\", (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); -	command_unbind(\"statusbar modifyitem\", (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem); +	command_unbind_full(\"statusbar additem\", (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem, GINT_TO_POINTER(TRUE)); +	command_unbind_full(\"statusbar modifyitem\", (SIGNAL_FUNC) cmd_statusbar_additem_modifyitem, GINT_TO_POINTER(FALSE));  	command_unbind(\"statusbar removeitem\", (SIGNAL_FUNC) cmd_statusbar_removeitem);  } '),('irssi','1.1.1','c8191b33155ae7ee1ebb07d87b8e001f75188eeb','ailin-nemui','abi bump','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 15 +#define IRSSI_ABI_VERSION 16    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.1.1','501c150ec21b1dceeecc0c201d22fc1bad161cf4','ailin-nemui','make new status bar actually work','statusbar-config.c','652','158','153','41','MODIFY','@@ -275,22 +275,49 @@ static const char *sbar_get_visibility(STATUSBAR_CONFIG_REC *rec)  		rec->visible == STATUSBAR_VISIBLE_INACTIVE ? \"inactive\" : \"??\";  }   -static CONFIG_NODE *sbar_node(const char *name, gboolean create) +#define iconfig_sbar_node(a, b) config_sbar_node(mainconfig, a, b) +static CONFIG_NODE *config_sbar_node(CONFIG_REC *config, const char *name, gboolean create)  {  	CONFIG_NODE *node; + +	node = config_node_traverse(config, \"statusbar\", create); +	if (node != NULL) { +		node = config_node_section(config, node, active_statusbar_group->name, +		                           create ? NODE_TYPE_BLOCK : -1); +	} + +	if (node != NULL) { +		node = config_node_section(config, node, name, create ? NODE_TYPE_BLOCK : -1); +	} + +	return node; +} + +static CONFIG_NODE *sbar_node(const char *name, gboolean create) +{  	STATUSBAR_CONFIG_REC *rec = statusbar_config_find(active_statusbar_group, name);  	if (rec != NULL) {  		name = rec->name; -	} else if (!create) { -		return NULL;  	}    	/* lookup/create the statusbar node */ -	node = iconfig_node_traverse(\"statusbar\", TRUE); -	node = iconfig_node_section(node, active_statusbar_group->name, NODE_TYPE_BLOCK); -	node = iconfig_node_section(node, name, NODE_TYPE_BLOCK); +	return iconfig_sbar_node(name, create); +}   -	return node; +static gboolean sbar_node_isdefault(const char *name) +{ +	CONFIG_REC *config; +	CONFIG_NODE *node; + +	/* read the default statusbar settings from internal config */ +	config = config_open(NULL, -1); +	config_parse_data(config, default_config, \"internal\"); + +	node = config_sbar_node(config, name, FALSE); + +	config_close(config); + +	return node != NULL ? TRUE : FALSE;  }    static void statusbar_list_items(STATUSBAR_CONFIG_REC *bar) @@ -432,6 +459,11 @@ static void cmd_statusbar_add_modify(const char *data, void *server, void *witem    	if (!error) {  		node = sbar_node(name, add); +		if (node == NULL && !add && sbar_node_isdefault(name)) { +			/* If this node is a default status bar, we need to create it in the config +			 * to configure it */ +			node = sbar_node(name, TRUE); +		}    		if (node == NULL) {  			printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, name); @@ -477,50 +509,59 @@ static void cmd_statusbar_reset(const char *data, void *server, void *witem)  	}    	node = sbar_node(name, FALSE); -	if (node == NULL) { +	if (node == NULL && !sbar_node_isdefault(name)) {  		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, name);  		cmd_params_free(free_arg);  		return;  	}   -	parent = iconfig_node_traverse(\"statusbar\", TRUE); -	parent = iconfig_node_section(parent, active_statusbar_group->name, NODE_TYPE_BLOCK); +	parent = iconfig_node_traverse(\"statusbar\", FALSE); +	if (parent != NULL) { +		parent = iconfig_node_section(parent, active_statusbar_group->name, -1); +	}   -	iconfig_node_set_str(parent, node->key, NULL); +	if (parent != NULL && node != NULL) { +		iconfig_node_set_str(parent, node->key, NULL); +	}    	read_statusbar_config();  	cmd_params_free(free_arg);  }   -static CONFIG_NODE *statusbar_items_section(CONFIG_NODE *parent) +#define iconfig_sbar_items_section(a, b) config_sbar_items_section(mainconfig, a, b) +static CONFIG_NODE *config_sbar_items_section(CONFIG_REC *config, CONFIG_NODE *parent, +                                              gboolean create) +{ +	return config_node_section(config, parent, \"items\", create ? NODE_TYPE_BLOCK : -1); +} + +static CONFIG_NODE *statusbar_copy_config(CONFIG_REC *config, CONFIG_NODE *source, +                                          CONFIG_NODE *parent)  { -	STATUSBAR_CONFIG_REC *bar; -        CONFIG_NODE *node;          GSList *tmp;   -	node = iconfig_node_section(parent, \"items\", -1); -	if (node != NULL) -		return node; +	g_return_val_if_fail(parent != NULL, NULL);   -        /* find the statusbar configuration from memory */ -	bar = statusbar_config_find(active_statusbar_group, parent->key); -	if (bar == NULL) { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, -			    TXT_STATUSBAR_NOT_FOUND, parent->key); -                return NULL; -	} +	parent = iconfig_sbar_items_section(parent, TRUE);    	/* since items list in config file overrides defaults,  	   we\'ll need to copy the whole list. */ -	parent = iconfig_node_section(parent, \"items\", NODE_TYPE_BLOCK); -	for (tmp = bar->items; tmp != NULL; tmp = tmp->next) { -		SBAR_ITEM_CONFIG_REC *rec = tmp->data; +	for (tmp = config_node_first(source->value); tmp != NULL; tmp = config_node_next(tmp)) { +		int priority, right_alignment; +		CONFIG_NODE *node, *snode; + +		snode = tmp->data;   -		node = iconfig_node_section(parent, rec->name, -					   NODE_TYPE_BLOCK); -		if (rec->priority != 0) -			iconfig_node_set_int(node, \"priority\", rec->priority); -		if (rec->right_alignment) +		priority = config_node_get_int(snode, \"priority\", 0); +		right_alignment = +		    g_strcmp0(config_node_get_str(snode, \"alignment\", \"\"), \"right\") == 0; + +		/* create new item */ +		node = iconfig_node_section(parent, snode->key, NODE_TYPE_BLOCK); + +		if (priority != 0) +			iconfig_node_set_int(node, \"priority\", priority); +		if (right_alignment)  			iconfig_node_set_str(node, \"alignment\", \"right\");  	}   @@ -531,12 +572,13 @@ static CONFIG_NODE *statusbar_items_section(CONFIG_NODE *parent)             [-priority #] [-alignment left|right] <item> <statusbar> */  static void cmd_statusbar_additem_modifyitem(const char *data, void *server, void *witem)  { +	CONFIG_REC *config, *close_config;  	CONFIG_NODE *node;  	GHashTable *optlist;  	char *item, *statusbar, *value;  	void *free_arg;  	int index; -	int additem = GINT_TO_POINTER(signal_get_user_data()); +	int additem = GPOINTER_TO_INT(signal_get_user_data());    	if (!cmd_get_params(data, &free_arg, 2 | PARAM_FLAG_OPTIONS | PARAM_FLAG_STRIP_TRAILING_WS,  	                    \"statusbar additem\", &optlist, &item, &statusbar)) @@ -546,15 +588,33 @@ static void cmd_statusbar_additem_modifyitem(const char *data, void *server, voi  		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);  	}   +	close_config = NULL; +	config = mainconfig; +  	node = sbar_node(statusbar, FALSE); +	if (node == NULL) { +		/* we are looking up defaults from the internal config */ +		close_config = config = config_open(NULL, -1); +		config_parse_data(config, default_config, \"internal\"); +		node = config_sbar_node(config, statusbar, FALSE); +	} +  	if (node == NULL) {  		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, statusbar); +		if (close_config != NULL) { +			config_close(close_config); +		}  		cmd_params_free(free_arg);  		return;  	}   -	node = statusbar_items_section(node); +	node = config_sbar_items_section(config, node, additem); +  	if (node == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); +		if (close_config != NULL) { +			config_close(close_config); +		}  		cmd_params_free(free_arg);  		return;  	} @@ -566,8 +626,28 @@ static void cmd_statusbar_additem_modifyitem(const char *data, void *server, voi  	value = g_hash_table_lookup(optlist, \"after\");  	if (value != NULL) index = config_node_index(node, value)+1;   -	if (!additem && iconfig_node_section(node, item, -1) == NULL) { +	if (!additem && config_node_section(config, node, item, -1) == NULL) {  		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); +		if (close_config != NULL) { +			config_close(close_config); +		} +		cmd_params_free(free_arg); +		return; +	} + +	if (config != mainconfig) { +		/* we need to copy default to user config */ +		node = statusbar_copy_config(config, node, sbar_node(statusbar, TRUE)); +		config = mainconfig; +	} + +	if (close_config != NULL) { +		config_close(close_config); +		close_config = NULL; +	} + +	if (node == NULL) { +		g_warning(\"node not found\");  		cmd_params_free(free_arg);  		return;  	} @@ -593,6 +673,7 @@ static void cmd_statusbar_additem_modifyitem(const char *data, void *server, voi  /* SYNTAX: STATUSBAR REMOVEITEM <item> <statusbar> */  static void cmd_statusbar_removeitem(const char *data, void *server, void *witem)  { +	CONFIG_REC *config, *close_config;  	CONFIG_NODE *node;  	char *item, *statusbar;  	void *free_arg; @@ -603,25 +684,56 @@ static void cmd_statusbar_removeitem(const char *data, void *server, void *witem  		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);  	}   +	close_config = NULL; +	config = mainconfig; +  	node = sbar_node(statusbar, FALSE); +	if (node == NULL) { +		/* we are looking up defaults from the internal config */ +		close_config = config = config_open(NULL, -1); +		config_parse_data(config, default_config, \"internal\"); +		node = config_sbar_node(config, statusbar, FALSE); +	} +  	if (node == NULL) {  		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, statusbar); +		if (close_config != NULL) { +			config_close(close_config); +		}  		cmd_params_free(free_arg);  		return;  	}   -	node = statusbar_items_section(node); -	if (node == NULL) { +	node = config_sbar_items_section(config, node, FALSE); + +	if (node == NULL || config_node_section(config, node, item, -1) == NULL) { +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); +		if (close_config != NULL) { +			config_close(close_config); +		}  		cmd_params_free(free_arg);  		return;  	}   -	if (iconfig_node_section(node, item, -1) != NULL) -		iconfig_node_set_str(node, item, NULL); -	else { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); +	if (config != mainconfig) { +		/* we need to copy default to user config */ +		node = statusbar_copy_config(config, node, sbar_node(statusbar, TRUE)); +		config = mainconfig; +	} + +	if (close_config != NULL) { +		config_close(close_config); +		close_config = NULL;  	}   +	if (node == NULL) { +		g_warning(\"node not found\"); +		cmd_params_free(free_arg); +		return; +	} + +	iconfig_node_set_str(node, item, NULL); +  	read_statusbar_config();  	cmd_params_free(free_arg);  } '),('irssi','1.1.1','977c2c0a0d911e3b7b43387ed19c5bfee565c617','ailin-nemui','refactor common parts','statusbar-config.c','609','150','44','95','MODIFY','@@ -568,30 +568,16 @@ static CONFIG_NODE *statusbar_copy_config(CONFIG_REC *config, CONFIG_NODE *sourc  	return parent;  }   -/* SYNTAX: STATUSBAR ADDITEM|MODIFYITEM [-before | -after <item>] -           [-priority #] [-alignment left|right] <item> <statusbar> */ -static void cmd_statusbar_additem_modifyitem(const char *data, void *server, void *witem) +static CONFIG_NODE *sbar_find_item_with_defaults(const char *statusbar, const char *item, +                                                 gboolean create)  {  	CONFIG_REC *config, *close_config;  	CONFIG_NODE *node; -	GHashTable *optlist; -	char *item, *statusbar, *value; -	void *free_arg; -	int index; -	int additem = GPOINTER_TO_INT(signal_get_user_data()); - -	if (!cmd_get_params(data, &free_arg, 2 | PARAM_FLAG_OPTIONS | PARAM_FLAG_STRIP_TRAILING_WS, -	                    \"statusbar additem\", &optlist, &item, &statusbar)) -		return; - -	if (*statusbar == \'\\0\') { -		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS); -	}    	close_config = NULL;  	config = mainconfig; -  	node = sbar_node(statusbar, FALSE); +  	if (node == NULL) {  		/* we are looking up defaults from the internal config */  		close_config = config = config_open(NULL, -1); @@ -601,57 +587,65 @@ static void cmd_statusbar_additem_modifyitem(const char *data, void *server, voi    	if (node == NULL) {  		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, statusbar); -		if (close_config != NULL) { -			config_close(close_config); -		} -		cmd_params_free(free_arg); -		return; -	} - -	node = config_sbar_items_section(config, node, additem); - -	if (node == NULL) { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); -		if (close_config != NULL) { +		if (close_config != NULL)  			config_close(close_config); -		} -		cmd_params_free(free_arg); -		return; +		return NULL;  	}   -	/* get the index */ -	index = -1; -	value = g_hash_table_lookup(optlist, \"before\"); -	if (value != NULL) index = config_node_index(node, value); -	value = g_hash_table_lookup(optlist, \"after\"); -	if (value != NULL) index = config_node_index(node, value)+1; +	node = config_sbar_items_section(config, node, create);   -	if (!additem && config_node_section(config, node, item, -1) == NULL) { +	if (node == NULL || (!create && config_node_section(config, node, item, -1) == NULL)) {  		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); -		if (close_config != NULL) { +		if (close_config != NULL)  			config_close(close_config); -		} -		cmd_params_free(free_arg); -		return; +		return NULL;  	}    	if (config != mainconfig) {  		/* we need to copy default to user config */  		node = statusbar_copy_config(config, node, sbar_node(statusbar, TRUE)); -		config = mainconfig;  	}   -	if (close_config != NULL) { +	if (close_config != NULL)  		config_close(close_config); -		close_config = NULL; + +	return node; +} + +/* SYNTAX: STATUSBAR ADDITEM|MODIFYITEM [-before | -after <item>] +           [-priority #] [-alignment left|right] <item> <statusbar> */ +static void cmd_statusbar_additem_modifyitem(const char *data, void *server, void *witem) +{ +	CONFIG_NODE *node; +	GHashTable *optlist; +	char *item, *statusbar, *value; +	void *free_arg; +	int index; +	int additem = GPOINTER_TO_INT(signal_get_user_data()); + +	if (!cmd_get_params(data, &free_arg, 2 | PARAM_FLAG_OPTIONS | PARAM_FLAG_STRIP_TRAILING_WS, +	                    \"statusbar additem\", &optlist, &item, &statusbar)) +		return; + +	if (*statusbar == \'\\0\') { +		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);  	}   +	node = sbar_find_item_with_defaults(statusbar, item, additem);  	if (node == NULL) { -		g_warning(\"node not found\");  		cmd_params_free(free_arg);  		return;  	}   +	/* get the index */ +	index = -1; +	value = g_hash_table_lookup(optlist, \"before\"); +	if (value != NULL) +		index = config_node_index(node, value); +	value = g_hash_table_lookup(optlist, \"after\"); +	if (value != NULL) +		index = config_node_index(node, value) + 1; +  	/* create/move item */  	node = iconfig_node_section_index(node, item, index, NODE_TYPE_BLOCK);   @@ -684,55 +678,10 @@ static void cmd_statusbar_removeitem(const char *data, void *server, void *witem  		cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);  	}   -	close_config = NULL; -	config = mainconfig; - -	node = sbar_node(statusbar, FALSE); -	if (node == NULL) { -		/* we are looking up defaults from the internal config */ -		close_config = config = config_open(NULL, -1); -		config_parse_data(config, default_config, \"internal\"); -		node = config_sbar_node(config, statusbar, FALSE); -	} +	node = sbar_find_item_with_defaults(statusbar, item, FALSE);   -	if (node == NULL) { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_NOT_FOUND, statusbar); -		if (close_config != NULL) { -			config_close(close_config); -		} -		cmd_params_free(free_arg); -		return; -	} - -	node = config_sbar_items_section(config, node, FALSE); - -	if (node == NULL || config_node_section(config, node, item, -1) == NULL) { -		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, TXT_STATUSBAR_ITEM_NOT_FOUND, item); -		if (close_config != NULL) { -			config_close(close_config); -		} -		cmd_params_free(free_arg); -		return; -	} - -	if (config != mainconfig) { -		/* we need to copy default to user config */ -		node = statusbar_copy_config(config, node, sbar_node(statusbar, TRUE)); -		config = mainconfig; -	} - -	if (close_config != NULL) { -		config_close(close_config); -		close_config = NULL; -	} - -	if (node == NULL) { -		g_warning(\"node not found\"); -		cmd_params_free(free_arg); -		return; -	} - -	iconfig_node_set_str(node, item, NULL); +	if (node != NULL) +		iconfig_node_set_str(node, item, NULL);    	read_statusbar_config();  	cmd_params_free(free_arg); '),('irssi','1.1.1','ee04cd503ff70a1aed79cdb2c9f787c98b075182','ailin-nemui','add disabled txt','module-formats.c','68','0','1','0','MODIFY','@@ -67,6 +67,7 @@ FORMAT_REC gui_text_formats[] =  	{ \"statusbar_info_item_footer\", \"\", 0 },  	{ \"statusbar_info_item_name\",  \"%#         : $[35]0 $[9]1 $2\", 3, { 0, 1, 0 } },  	{ \"statusbar_not_found\", \"Statusbar doesn\'t exist: $0\", 1, { 0 } }, +	{ \"statusbar_not_found\", \"Statusbar is disabled: $0\", 1, { 0 } },  	{ \"statusbar_item_not_found\", \"Statusbar item doesn\'t exist: $0\", 1, { 0 } },  	{ \"statusbar_unknown_command\", \"Unknown statusbar command: $0\", 1, { 0 } },  	{ \"statusbar_unknown_type\", \"Statusbar type must be \'window\' or \'root\'\", 1, { 0 } }, '),('irssi','1.1.1','ee04cd503ff70a1aed79cdb2c9f787c98b075182','ailin-nemui','add disabled txt','module-formats.h','53','0','1','0','MODIFY','@@ -42,6 +42,7 @@ enum {  	TXT_STATUSBAR_INFO_ITEM_FOOTER,          TXT_STATUSBAR_INFO_ITEM_NAME,          TXT_STATUSBAR_NOT_FOUND, +        TXT_STATUSBAR_NOT_ENABLED,          TXT_STATUSBAR_ITEM_NOT_FOUND,  	TXT_STATUSBAR_UNKNOWN_COMMAND,          TXT_STATUSBAR_UNKNOWN_TYPE, '),('irssi','1.1.1','ee04cd503ff70a1aed79cdb2c9f787c98b075182','ailin-nemui','add disabled txt','statusbar-config.c','613','152','6','2','MODIFY','@@ -388,8 +388,12 @@ static void cmd_statusbar_print_info(const char *name)  		return;  	}   -	printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, -		    TXT_STATUSBAR_NOT_FOUND, name); +	if (sbar_node(name, FALSE) != NULL || sbar_node_isdefault(name)) +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +			    TXT_STATUSBAR_NOT_ENABLED, name); +	else +		printformat(NULL, NULL, MSGLEVEL_CLIENTERROR, +			    TXT_STATUSBAR_NOT_FOUND, name);  }    /* SYNTAX: STATUSBAR ADD|MODIFY [-disable | -nodisable] [-type window|root] '),('irssi','1.1.1','138eca0749dd05a4a16df9e43d87af2143b224f2','ailin-nemui','fix build','module-formats.h','53','0','9','9','MODIFY','@@ -30,24 +30,24 @@ enum {    	TXT_FILL_3,   -        TXT_STATUSBAR_LIST_HEADER, +	TXT_STATUSBAR_LIST_HEADER,  	TXT_STATUSBAR_LIST_FOOTER,  	TXT_STATUSBAR_LIST,  	TXT_STATUSBAR_INFO_NAME,  	TXT_STATUSBAR_INFO_TYPE, -        TXT_STATUSBAR_INFO_PLACEMENT, +	TXT_STATUSBAR_INFO_PLACEMENT,  	TXT_STATUSBAR_INFO_POSITION,  	TXT_STATUSBAR_INFO_VISIBLE, -        TXT_STATUSBAR_INFO_ITEM_HEADER, +	TXT_STATUSBAR_INFO_ITEM_HEADER,  	TXT_STATUSBAR_INFO_ITEM_FOOTER, -        TXT_STATUSBAR_INFO_ITEM_NAME, -        TXT_STATUSBAR_NOT_FOUND, -        TXT_STATUSBAR_NOT_ENABLED, -        TXT_STATUSBAR_ITEM_NOT_FOUND, +	TXT_STATUSBAR_INFO_ITEM_NAME, +	TXT_STATUSBAR_NOT_FOUND, +	TXT_STATUSBAR_NOT_ENABLED, +	TXT_STATUSBAR_ITEM_NOT_FOUND,  	TXT_STATUSBAR_UNKNOWN_COMMAND, -        TXT_STATUSBAR_UNKNOWN_TYPE, +	TXT_STATUSBAR_UNKNOWN_TYPE,  	TXT_STATUSBAR_UNKNOWN_PLACEMENT, -        TXT_STATUSBAR_UNKNOWN_VISIBILITY, +	TXT_STATUSBAR_UNKNOWN_VISIBILITY,    	TXT_FILL_4,   '),('irssi','1.1.1','138eca0749dd05a4a16df9e43d87af2143b224f2','ailin-nemui','fix build','statusbar-config.c','612','152','2','3','MODIFY','@@ -101,7 +101,7 @@ statusbar_config_find(STATUSBAR_GROUP_REC *group, const char *name)  			return config;  	}   -        return NULL; +	return NULL;  }    static void statusbar_reset_defaults(void) @@ -542,7 +542,7 @@ static CONFIG_NODE *config_sbar_items_section(CONFIG_REC *config, CONFIG_NODE *p  static CONFIG_NODE *statusbar_copy_config(CONFIG_REC *config, CONFIG_NODE *source,                                            CONFIG_NODE *parent)  { -        GSList *tmp; +	GSList *tmp;    	g_return_val_if_fail(parent != NULL, NULL);   @@ -671,7 +671,6 @@ static void cmd_statusbar_additem_modifyitem(const char *data, void *server, voi  /* SYNTAX: STATUSBAR REMOVEITEM <item> <statusbar> */  static void cmd_statusbar_removeitem(const char *data, void *server, void *witem)  { -	CONFIG_REC *config, *close_config;  	CONFIG_NODE *node;  	char *item, *statusbar;  	void *free_arg; '),('irssi','1.1.1','25a44dacf4114f33f3a887f358c02f4fd9938427','Dorian Harmans','fix build with LibreSSL 2.7.0','network-openssl.c','684','151','4','2','MODIFY','@@ -35,7 +35,8 @@  #include <openssl/err.h>    /* OpenSSL 1.1.0 introduced some backward-incompatible changes to the api */ -#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER) +#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && \\ +    (!defined(LIBRESSL_VERSION_NUMBER) || LIBRESSL_VERSION_NUMBER < 0x2070000fL)  /* The two functions below could be already defined if OPENSSL_API_COMPAT is   * below the 1.1.0 version so let\'s do a clean start */  #undef  X509_get_notBefore @@ -47,7 +48,8 @@    /* OpenSSL 1.1.0 also introduced some useful additions to the api */  #if (OPENSSL_VERSION_NUMBER >= 0x10002000L) -#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined (LIBRESSL_VERSION_NUMBER) +#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \\ +    (defined (LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x2070000fL)  static int X509_STORE_up_ref(X509_STORE *vfy)  {      int n; '),('irssi','1.1.1','b52cf1015eaa4d759c9377df35a56988655dce89','dequis','otr: add KEY_GEN_STARTED state to avoid starting it twice  Fun race condition there, got this when testing with the jabber xmlconsole open in bitlbee','key.c','255','27','5','3','MODIFY','@@ -43,9 +43,10 @@   */  enum key_gen_status {  	KEY_GEN_IDLE		= 0, -	KEY_GEN_RUNNING		= 1, -	KEY_GEN_FINISHED	= 2, -	KEY_GEN_ERROR		= 3, +	KEY_GEN_STARTED		= 1, +	KEY_GEN_RUNNING		= 2, +	KEY_GEN_FINISHED	= 3, +	KEY_GEN_ERROR		= 4,  };    /* @@ -208,6 +209,7 @@ void key_gen_run(struct otr_user_state *ustate, const char *account_name)  	/* Make sure the pointer does not go away during the proess. */  	key_gen_state.account_name = strdup(account_name);  	key_gen_state.ustate = ustate; +	key_gen_state.status = KEY_GEN_STARTED;    	/* Creating key file path. */  	key_gen_state.key_file_path = file_path_build(OTR_KEYFILE); '),('irssi','1.1.1','dd7dc7ca7d0b04ae2d522a209845c453bfd9aab5','dequis','otr: fix missing \'target\' param in \'message private\' signal  Fixes warnings like these on \'/msg yourself\'  -!- Irssi: critical privmsg_get_query: assertion \'nick != NULL\' failed -!- Irssi: critical query_find: assertion \'nick != NULL\' failed','module.c','149','29','3','3','MODIFY','@@ -79,7 +79,7 @@ static void sig_server_sendmsg(SERVER_REC *server, const char *target,  /*   * Pipes all incoming private messages through OTR   */ -void sig_message_private(SERVER_REC *server, const char *msg, const char *nick, const char *address) +void sig_message_private(SERVER_REC *server, const char *msg, const char *nick, const char *address, const char *target)  {  	char *new_msg = NULL;   @@ -91,7 +91,7 @@ void sig_message_private(SERVER_REC *server, const char *msg, const char *nick,    	if (new_msg == NULL) {  		/* This message was not OTR */ -		signal_continue(4, server, msg, nick, address); +		signal_continue(5, server, msg, nick, address, target);  	} else {  		/*  		 * Check for /me IRC marker and if so, handle it so the user does not @@ -103,7 +103,7 @@ void sig_message_private(SERVER_REC *server, const char *msg, const char *nick,  			signal_emit(\"message irc action\", 5, server, new_msg + OTR_IRC_MARKER_ME_LEN, nick, address, nick);  		} else {  			/* OTR received message */ -			signal_continue(4, server, new_msg, nick, address); +			signal_continue(5, server, new_msg, nick, address, target);  		}  	}   '),('irssi','1.1.1','dd7dc7ca7d0b04ae2d522a209845c453bfd9aab5','dequis','otr: fix missing \'target\' param in \'message private\' signal  Fixes warnings like these on \'/msg yourself\'  -!- Irssi: critical privmsg_get_query: assertion \'nick != NULL\' failed -!- Irssi: critical query_find: assertion \'nick != NULL\' failed','module.h','3','0','1','1','MODIFY','@@ -24,6 +24,6 @@  #include \"common.h\"  #include \"servers.h\"   -void sig_message_private(SERVER_REC *server, const char *msg, const char *nick, const char *address); +void sig_message_private(SERVER_REC *server, const char *msg, const char *nick, const char *address, const char *target);    #endif /* IRSSI_OTR_MODULE */ '),('irssi','1.1.1','7d7c6975edc13d6f285c00dfc8a4f1a98ffa6702','dequis','otr: add target param to the unencrypted \'message private\' signal  Same case as the previous commit.','otr-ops.c','248','49','1','1','MODIFY','@@ -183,7 +183,7 @@ static void ops_handle_msg_event(void *opdata, OtrlMessageEvent msg_event, ConnC  			 * submit a patch or email me a better way.  			 */  			signal_remove(\"message private\", (SIGNAL_FUNC) sig_message_private); -			signal_emit(\"message private\", 4, server, message, username, server->connrec->address); +			signal_emit(\"message private\", 5, server, message, username, server->connrec->address, server->nick);  			signal_add_first(\"message private\", (SIGNAL_FUNC) sig_message_private);  			break;  		case OTRL_MSGEVENT_RCVDMSG_UNRECOGNIZED: '),('irssi','1.1.1','a3b9e2370fd02eb6a400744e31d7db27c8fe92b8','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 15 +#define IRSSI_ABI_VERSION 16    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 ');
INSERT INTO `irssi` VALUES ('irssi','1.1.1','2830d91a89277052ee8e6978a41a7773c9fe5025','ailin-nemui','use precompiled libotr','.travis.yml','63','0','4','7','MODIFY','@@ -31,19 +31,16 @@ addons:    before_install:      - perl -V -    - wget https://otr.cypherpunks.ca/libotr-4.1.1.tar.gz -    - tar zxf libotr-*.tar.gz -    - cd libotr-* -    - ./configure --prefix $HOME/otr-prefix && make && make install -    - cd .. -    - ./autogen.sh --with-proxy --with-bot --with-perl=module --with-otr=yes --with-libotr-prefix=$HOME/otr-prefix/lib --with-libotr-inc-prefix=$HOME/otr-prefix/include +    - wget https://github.com/irssi-import/libotr/releases/download/4.1.1/travis-trusty-libotr-4.1.1.tar.gz +    - tar zxf travis-trusty-libotr*.tar.gz -C $HOME +    - ./autogen.sh --with-proxy --with-bot --with-perl=module --with-otr=yes --with-libotr-prefix=$HOME/otr-build/lib --with-libotr-inc-prefix=$HOME/otr-build/include      - make dist      - cd ..      - tar xaf */irssi-*.tar.*      - cd irssi-*    install: -    - ./configure --with-proxy --with-bot --with-perl=module --with-otr=yes --with-libotr-prefix=$HOME/otr-prefix/lib --with-libotr-inc-prefix=$HOME/otr-prefix/include --prefix=$HOME/irssi-build +    - ./configure --with-proxy --with-bot --with-perl=module --with-otr=yes --with-libotr-prefix=$HOME/otr-build/lib --with-libotr-inc-prefix=$HOME/otr-build/include --prefix=$HOME/irssi-build        $( $UNITTESTS && echo --enable-always-build-tests )      - make CFLAGS=\"-Wall -Werror -Werror=declaration-after-statement\"      - make install '),('irssi','1.1.1','c08685a1a3e4a719fcfe8f30a338a91db8c3b8d1','ailin-nemui','also reconnect lookup_servers','servers-reconnect.c','378','83','15','0','MODIFY','@@ -111,6 +111,21 @@ static int server_reconnect_timeout(void)  		}  	}   +	for (tmp = lookup_servers; tmp != NULL; tmp = next) { +		SERVER_REC *server = tmp->data; + +		next = tmp->next; +		if (server->connect_time + connect_timeout < now && +		    connect_timeout > 0) { +			if (server->connect_tag != -1) { +				g_source_remove(server->connect_tag); +				server->connect_tag = -1; +			} +			server->connection_lost = TRUE; +			server_connect_failed(server, \"Timeout\"); +		} +	} +  	/* If server_connect() removes the next reconnection in queue,  	   we\'re screwed. I don\'t think this should happen anymore, but just  	   to be sure we don\'t crash, do this safely. */ '),('irssi','1.1.1','c08685a1a3e4a719fcfe8f30a338a91db8c3b8d1','ailin-nemui','also reconnect lookup_servers','servers.c','547','133','1','0','MODIFY','@@ -426,6 +426,7 @@ int server_start_connect(SERVER_REC *server)  				    server_connect_callback_readpipe,  				    server);   +		server->connect_time = time(NULL);  		lookup_servers = g_slist_append(lookup_servers, server);    		signal_emit(\"server looking\", 1, server); '),('irssi','1.1.1','4501917cae4523d11fb049a5d20e5582bb0893ea','dequis','otr: rename module.c to otr-module.c','Makefile.am','34','0','1','1','MODIFY','@@ -21,7 +21,7 @@ libotr_core_la_LIBADD = $(OTR_LDFLAGS)    otr_sources = \\  	key.c \\ -	module.c \\ +	otr-module.c \\  	otr-formats.c \\  	otr-ops.c \\  	otr-fe.c \\ '),('irssi','1.1.1','4501917cae4523d11fb049a5d20e5582bb0893ea','dequis','otr: rename module.c to otr-module.c','otr-module.c','None','None','0','0','RENAME',''),('irssi','1.1.1','0b2f5b0a1e30932b07245c508a673eb0e9b6ab37','dequis','otr: fix blatant lies in help text','otr.in','73','0','1','1','MODIFY','@@ -1,7 +1,7 @@    OTR %|[OPTION]   -Command to control the OTR module. Without an option, this help is printed. +Command to control the OTR module. Without an option, /OTR INFO is printed.    This help contains three sections which are %9options, quickstart and files.%n   '),('irssi','1.1.1','407680efdc662787ecbd1297d1f4781acdb5168c','dequis','Add libgcrypt.m4 so autogen doesn\'t require libgcrypt-dev','libgcrypt.m4','130','0','143','0','ADD','@@ -0,0 +1,143 @@ +# libgcrypt.m4 - Autoconf macros to detect libgcrypt +# Copyright (C) 2002, 2003, 2004, 2011, 2014 g10 Code GmbH +# +# This file is free software; as a special exception the author gives +# unlimited permission to copy and/or distribute it, with or without +# modifications, as long as this notice is preserved. +# +# This file is distributed in the hope that it will be useful, but +# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the +# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. +# +# Last-changed: 2014-10-02 + + +dnl AM_PATH_LIBGCRYPT([MINIMUM-VERSION, +dnl                   [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]]) +dnl Test for libgcrypt and define LIBGCRYPT_CFLAGS and LIBGCRYPT_LIBS. +dnl MINIMUN-VERSION is a string with the version number optionalliy prefixed +dnl with the API version to also check the API compatibility. Example: +dnl a MINIMUN-VERSION of 1:1.2.5 won\'t pass the test unless the installed +dnl version of libgcrypt is at least 1.2.5 *and* the API number is 1.  Using +dnl this features allows to prevent build against newer versions of libgcrypt +dnl with a changed API. +dnl +dnl If a prefix option is not used, the config script is first +dnl searched in $SYSROOT/bin and then along $PATH.  If the used +dnl config script does not match the host specification the script +dnl is added to the gpg_config_script_warn variable. +dnl +AC_DEFUN([AM_PATH_LIBGCRYPT], +[ AC_REQUIRE([AC_CANONICAL_HOST]) +  AC_ARG_WITH(libgcrypt-prefix, +            AC_HELP_STRING([--with-libgcrypt-prefix=PFX], +                           [prefix where LIBGCRYPT is installed (optional)]), +     libgcrypt_config_prefix=\"$withval\", libgcrypt_config_prefix=\"\") +  if test x\"${LIBGCRYPT_CONFIG}\" = x ; then +     if test x\"${libgcrypt_config_prefix}\" != x ; then +        LIBGCRYPT_CONFIG=\"${libgcrypt_config_prefix}/bin/libgcrypt-config\" +     else +       case \"${SYSROOT}\" in +         /*) +           if test -x \"${SYSROOT}/bin/libgcrypt-config\" ; then +             LIBGCRYPT_CONFIG=\"${SYSROOT}/bin/libgcrypt-config\" +           fi +           ;; +         \'\') +           ;; +          *) +           AC_MSG_WARN([Ignoring \\$SYSROOT as it is not an absolute path.]) +           ;; +       esac +     fi +  fi + +  AC_PATH_PROG(LIBGCRYPT_CONFIG, libgcrypt-config, no) +  tmp=ifelse([$1], ,1:1.2.0,$1) +  if echo \"$tmp\" | grep \':\' >/dev/null 2>/dev/null ; then +     req_libgcrypt_api=`echo \"$tmp\"     | sed \'s/\\(.*\\):\\(.*\\)/\\1/\'` +     min_libgcrypt_version=`echo \"$tmp\" | sed \'s/\\(.*\\):\\(.*\\)/\\2/\'` +  else +     req_libgcrypt_api=0 +     min_libgcrypt_version=\"$tmp\" +  fi + +  AC_MSG_CHECKING(for LIBGCRYPT - version >= $min_libgcrypt_version) +  ok=no +  if test \"$LIBGCRYPT_CONFIG\" != \"no\" ; then +    req_major=`echo $min_libgcrypt_version | \\ +               sed \'s/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\1/\'` +    req_minor=`echo $min_libgcrypt_version | \\ +               sed \'s/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\2/\'` +    req_micro=`echo $min_libgcrypt_version | \\ +               sed \'s/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\)/\\3/\'` +    libgcrypt_config_version=`$LIBGCRYPT_CONFIG --version` +    major=`echo $libgcrypt_config_version | \\ +               sed \'s/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\).*/\\1/\'` +    minor=`echo $libgcrypt_config_version | \\ +               sed \'s/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\).*/\\2/\'` +    micro=`echo $libgcrypt_config_version | \\ +               sed \'s/\\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\.\\([[0-9]]*\\).*/\\3/\'` +    if test \"$major\" -gt \"$req_major\"; then +        ok=yes +    else +        if test \"$major\" -eq \"$req_major\"; then +            if test \"$minor\" -gt \"$req_minor\"; then +               ok=yes +            else +               if test \"$minor\" -eq \"$req_minor\"; then +                   if test \"$micro\" -ge \"$req_micro\"; then +                     ok=yes +                   fi +               fi +            fi +        fi +    fi +  fi +  if test $ok = yes; then +    AC_MSG_RESULT([yes ($libgcrypt_config_version)]) +  else +    AC_MSG_RESULT(no) +  fi +  if test $ok = yes; then +     # If we have a recent libgcrypt, we should also check that the +     # API is compatible +     if test \"$req_libgcrypt_api\" -gt 0 ; then +        tmp=`$LIBGCRYPT_CONFIG --api-version 2>/dev/null || echo 0` +        if test \"$tmp\" -gt 0 ; then +           AC_MSG_CHECKING([LIBGCRYPT API version]) +           if test \"$req_libgcrypt_api\" -eq \"$tmp\" ; then +             AC_MSG_RESULT([okay]) +           else +             ok=no +             AC_MSG_RESULT([does not match. want=$req_libgcrypt_api got=$tmp]) +           fi +        fi +     fi +  fi +  if test $ok = yes; then +    LIBGCRYPT_CFLAGS=`$LIBGCRYPT_CONFIG --cflags` +    LIBGCRYPT_LIBS=`$LIBGCRYPT_CONFIG --libs` +    ifelse([$2], , :, [$2]) +    libgcrypt_config_host=`$LIBGCRYPT_CONFIG --host 2>/dev/null || echo none` +    if test x\"$libgcrypt_config_host\" != xnone ; then +      if test x\"$libgcrypt_config_host\" != x\"$host\" ; then +  AC_MSG_WARN([[ +*** +*** The config script $LIBGCRYPT_CONFIG was +*** built for $libgcrypt_config_host and thus may not match the +*** used host $host. +*** You may want to use the configure option --with-libgcrypt-prefix +*** to specify a matching config script or use \\$SYSROOT. +***]]) +        gpg_config_script_warn=\"$gpg_config_script_warn libgcrypt\" +      fi +    fi +  else +    LIBGCRYPT_CFLAGS=\"\" +    LIBGCRYPT_LIBS=\"\" +    ifelse([$3], , :, [$3]) +  fi +  AC_SUBST(LIBGCRYPT_CFLAGS) +  AC_SUBST(LIBGCRYPT_LIBS) +]) '),('irssi','1.1.1','8607a5fa78ba44db51cc75a020e1a53c4e04a057','dequis','signals.txt: add missing \'server cap new|delete\' signals  Emitted by cap_emit_signal in irc/core/irc-cap.c, added as part of the CAP 3.2 PR merged recentlyish.','signals.txt','276','0','2','0','MODIFY','@@ -132,6 +132,8 @@ irc-servers.c:  irc-cap.c   \"server cap ack \"<cmd>, SERVER_REC   \"server cap nak \"<cmd>, SERVER_REC + \"server cap new \"<cmd>, SERVER_REC + \"server cap delete \"<cmd>, SERVER_REC   \"server cap end\", SERVER_REC    sasl.c '),('irssi','1.1.1','af5ee997e7544eb59ed509ef8fb79ec449756e90','dequis','Add \"server cap req\" signal, emitted before requesting caps','signals.txt','275','0','1','0','MODIFY','@@ -133,6 +133,7 @@ irc-cap.c   \"server cap ack \"<cmd>, SERVER_REC   \"server cap nak \"<cmd>, SERVER_REC   \"server cap end\", SERVER_REC + \"server cap req\", SERVER_REC, char *caps    sasl.c   \"server sasl failure\", SERVER_REC, char *reason '),('irssi','1.1.1','af5ee997e7544eb59ed509ef8fb79ec449756e90','dequis','Add \"server cap req\" signal, emitted before requesting caps','irc-cap.c','203','52','11','3','MODIFY','@@ -48,11 +48,17 @@ int cap_toggle (IRC_SERVER_REC *server, char *cap, int enable)  		if (!g_hash_table_lookup_extended(server->cap_supported, cap, NULL, NULL))  			return FALSE;   +		signal_emit(\"server cap req\", 2, server, cap);  		irc_send_cmdv(server, \"CAP REQ %s\", cap);  		return TRUE;  	}  	else if (!enable && gslist_find_string(server->cap_active, cap)) { -		irc_send_cmdv(server, \"CAP REQ -%s\", cap); +		char *negcap = g_strdup_printf(\"-%s\", cap); + +		signal_emit(\"server cap req\", 2, server, negcap); +		irc_send_cmdv(server, \"CAP REQ %s\", negcap); + +		g_free(negcap);  		return TRUE;  	}   @@ -194,10 +200,12 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add  				server->cap_queue = NULL;    				/* If the server doesn\'t support any cap we requested close the negotiation here */ -				if (avail_caps > 0) +				if (avail_caps > 0) { +					signal_emit(\"server cap req\", 2, server, cmd->str + sizeof(\"CAP REQ :\") - 1);  					irc_send_cmd_now(server, cmd->str); -				else +				} else {  					cap_finish_negotiation(server); +				}    				g_string_free(cmd, TRUE);  			} '),('irssi','1.1.1','d0151fd5a21cf026afa67239ad79f23bc26f0a10','dequis','Add fe-cap to show messages for CAP-related events in the UI  Replaces cap.pl','Makefile.am','41','0','1','0','MODIFY','@@ -27,6 +27,7 @@ real_sources = \\  	fe-common-irc.c \\  	fe-whois.c \\  	fe-sasl.c \\ +	fe-cap.c \\  	irc-completion.c \\  	module-formats.c    '),('irssi','1.1.1','d0151fd5a21cf026afa67239ad79f23bc26f0a10','dequis','Add fe-cap to show messages for CAP-related events in the UI  Replaces cap.pl','fe-cap.c','50','9','84','0','ADD','@@ -0,0 +1,84 @@ +/* +    fe-cap.c : irssi + +    Copyright (C) 2018 dequis + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"module-formats.h\" +#include \"signals.h\" +#include \"levels.h\" +#include \"misc.h\" + +#include \"irc-servers.h\" + +#include \"printtext.h\" + +static const struct { +	const char *command; +	const int template; +} fe_cap_messages[] = { +	{\"LS\", IRCTXT_CAP_LS}, +	{\"ACK\", IRCTXT_CAP_ACK}, +	{\"NAK\", IRCTXT_CAP_NAK}, +	{\"LIST\", IRCTXT_CAP_LIST}, +	{\"NEW\", IRCTXT_CAP_NEW}, +	{\"DEL\", IRCTXT_CAP_DEL}, +}; + +static void event_cap(IRC_SERVER_REC *server, char *args, char *nick, char *address) +{ +	int i; +	char *params, *evt, *list, *star; + +	params = event_get_params(args, 4, NULL, &evt, &star, &list); + +	if (params == NULL) { +		return; +	} + +	/* With multiline CAP LS, if the \'*\' parameter isn\'t present, +	 * adjust the parameter pointer to compensate for this */ +	if (strcmp(star, \"*\") != 0 && list[0] == \'\\0\') { +		list = star; +	} + +	for (i = 0; i < G_N_ELEMENTS(fe_cap_messages); i++) { +		if (!g_ascii_strcasecmp(evt, fe_cap_messages[i].command)) { +			printformat(server, NULL, MSGLEVEL_CRAP, fe_cap_messages[i].template, list); +		} +	} + +	g_free(params); +} + +static void sig_server_cap_req(IRC_SERVER_REC *server, char *caps) +{ +	printformat(server, NULL, MSGLEVEL_CRAP, IRCTXT_CAP_REQ, caps); +} + +void fe_cap_init(void) +{ +	signal_add(\"event cap\", (SIGNAL_FUNC) event_cap); +	signal_add(\"server cap req\", (SIGNAL_FUNC) sig_server_cap_req); +} + +void fe_cap_deinit(void) +{ +	signal_remove(\"event cap\", (SIGNAL_FUNC) event_cap); +	signal_remove(\"server cap req\", (SIGNAL_FUNC) sig_server_cap_req); +} '),('irssi','1.1.1','d0151fd5a21cf026afa67239ad79f23bc26f0a10','dequis','Add fe-cap to show messages for CAP-related events in the UI  Replaces cap.pl','fe-common-irc.c','87','2','5','0','MODIFY','@@ -72,6 +72,9 @@ void fe_whois_deinit(void);  void fe_sasl_init(void);  void fe_sasl_deinit(void);   +void fe_cap_init(void); +void fe_cap_deinit(void); +  void irc_completion_init(void);  void irc_completion_deinit(void);   @@ -95,6 +98,7 @@ void fe_common_irc_init(void)  	fe_netjoin_init();          fe_whois_init();  	fe_sasl_init(); +	fe_cap_init();          irc_completion_init();    	settings_check(); @@ -121,6 +125,7 @@ void fe_common_irc_deinit(void)  	fe_netjoin_deinit();          fe_whois_deinit();  	fe_sasl_deinit(); +	fe_cap_deinit();          irc_completion_deinit();    	theme_unregister(); '),('irssi','1.1.1','d0151fd5a21cf026afa67239ad79f23bc26f0a10','dequis','Add fe-cap to show messages for CAP-related events in the UI  Replaces cap.pl','module-formats.c','128','0','7','0','MODIFY','@@ -46,6 +46,13 @@ FORMAT_REC fecommon_irc_formats[] = {  	{ \"setupserver_footer\", \"\", 0 },  	{ \"sasl_success\", \"SASL authentication succeeded\", 0 },  	{ \"sasl_error\", \"Cannot authenticate via SASL ($0)\", 1, { 0 } }, +	{ \"cap_req\",  \"Capabilities requested: $0\", 1, { 0 } }, +	{ \"cap_ls\",   \"Capabilities supported: $0\", 1, { 0 } }, +	{ \"cap_ack\",  \"Capabilities acknowledged: $0\", 1, { 0 } }, +	{ \"cap_nak\",  \"Capabilities refused: $0\", 1, { 0 } }, +	{ \"cap_list\", \"Capabilities currently enabled: $0\", 1, { 0 } }, +	{ \"cap_new\",  \"Capabilities now available: $0\", 1, { 0 } }, +	{ \"cap_del\",  \"Capabilities removed: $0\", 1, { 0 } },    	/* ---- */  	{ NULL, \"Channels\", 0 }, '),('irssi','1.1.1','d0151fd5a21cf026afa67239ad79f23bc26f0a10','dequis','Add fe-cap to show messages for CAP-related events in the UI  Replaces cap.pl','module-formats.h','127','0','7','0','MODIFY','@@ -24,6 +24,13 @@ enum {  	IRCTXT_SETUPSERVER_FOOTER,  	IRCTXT_SASL_SUCCESS,  	IRCTXT_SASL_ERROR, +	IRCTXT_CAP_REQ, +	IRCTXT_CAP_LS, +	IRCTXT_CAP_ACK, +	IRCTXT_CAP_NAK, +	IRCTXT_CAP_LIST, +	IRCTXT_CAP_NEW, +	IRCTXT_CAP_DEL,    	IRCTXT_FILL_2,   '),('irssi','1.1.1','8deb6182c692904733544568479035b31fe1007e','dequis','Make config_write more atomic to prevent truncation when out of space  This is modeled after glib\'s g_file_set_contents. It doesn\'t use that function directly because the writing is done with GIOChannel streaming-like writes and g_file_set_contents expects the whole thing to be in-memory.  Main differences with g_file_set_contents:  - complete lack of win32 special casing (cygwin/WSL should work though) - no fallocate() (linux only, but we don\'t know the size upfront, anyway) - always calls fsync (glib skips it on btrfs or when not overwriting)  Other than that, it\'s the same old mkstemp + fsync + rename.','write.c','264','84','41','4','MODIFY','@@ -301,30 +301,67 @@ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)  {  	int ret;  	int fd; +	int save_errno; +	char *tmp_name; +	const char *dest_name;    	g_return_val_if_fail(rec != NULL, -1);          g_return_val_if_fail(fname != NULL || rec->fname != NULL, -1);          g_return_val_if_fail(create_mode != -1 || rec->create_mode != -1, -1);   -	fd = open(fname != NULL ? fname : rec->fname, +	dest_name = fname != NULL ? fname : rec->fname; +	tmp_name = g_strdup_printf(\"%s.XXXXXX\", dest_name); + +	fd = g_mkstemp_full(tmp_name,  			   O_WRONLY | O_TRUNC | O_CREAT,  			   create_mode != -1 ? create_mode : rec->create_mode); -	if (fd == -1) -		return config_error(rec, g_strerror(errno)); +	if (fd == -1) { +		config_error(rec, g_strerror(errno)); +		ret = -1; +		goto out; +	}    	rec->handle = g_io_channel_unix_new(fd);  	g_io_channel_set_encoding(rec->handle, NULL, NULL);  	g_io_channel_set_close_on_unref(rec->handle, TRUE); +  	rec->tmp_indent_level = 0;  	rec->tmp_last_lf = TRUE;          ret = config_write_block(rec, rec->mainnode, FALSE, TRUE); +	save_errno = errno; +  	if (ret == -1) {  		/* write error */ -		config_error(rec, errno == 0 ? \"bug\" : g_strerror(errno)); +		unlink(tmp_name); +		config_error(rec, save_errno == 0 ? \"bug\" : g_strerror(save_errno)); +		goto out; +	} + +	ret = fsync(fd); +	save_errno = errno; + +	if (ret == -1) { +		unlink(tmp_name); +		config_error(rec, g_strerror(errno)); +		goto out;  	}    	g_io_channel_unref(rec->handle);  	rec->handle = NULL;   +	if (rename(tmp_name, dest_name) == -1) { +		unlink(tmp_name); +		config_error(rec, g_strerror(errno)); +		goto out; +	} + +out: +	if (rec->handle) { +		g_io_channel_unref(rec->handle); +		rec->handle = NULL; +	} + +	g_free(tmp_name); +  	return ret;  } '),('irssi','1.1.1','34b31e8451829e7b515a60cf12183203a059d1c4','ailin-nemui','record line info on empty lines','formats.c','1138','354','9','0','MODIFY','@@ -1233,6 +1233,15 @@ void format_send_to_gui(TEXT_DEST_REC *dest, const char *text)  	dup = str = g_strdup(text);    	flags = 0; fgcolor = theme->default_color; bgcolor = -1; + +	if (*str == \'\\0\') { +		/* empty line, write line info only */ +		signal_emit_id(signal_gui_print_text, 6, dest->window, +			       GINT_TO_POINTER(fgcolor), +			       GINT_TO_POINTER(bgcolor), +			       GINT_TO_POINTER(flags), str, +			       dest); +	}  	while (*str != \'\\0\') {  		type = \'\\0\';  		for (ptr = str; *ptr != \'\\0\'; ptr++) { '),('irssi','1.1.1','34b31e8451829e7b515a60cf12183203a059d1c4','ailin-nemui','record line info on empty lines','textbuffer.c','470','139','0','3','MODIFY','@@ -355,9 +355,6 @@ LINE_REC *textbuffer_insert(TEXT_BUFFER_REC *buffer, LINE_REC *insert_after,  	g_return_val_if_fail(buffer != NULL, NULL);  	g_return_val_if_fail(data != NULL, NULL);   -	if (len == 0) -                return insert_after; -  	line = !buffer->last_eol ? insert_after :  		textbuffer_line_insert(buffer, insert_after);   '),('irssi','1.1.1','3075cbc6fb383024b87563611021f9fb712182fd','ailin-nemui','Fix test compilation on old glib  e.g. Debian 7','test-796.c','103','10','2','0','MODIFY','@@ -165,7 +165,9 @@ int main(int argc, char **argv)  		   server_destroy_flood_set_up, test_server_destroy_flood,  		   server_destroy_flood_tear_down);   +#if GLIB_CHECK_VERSION(2,38,0)  	g_test_set_nonfatal_assertions(); +#endif    	core_preinit(*argv);  	irssi_gui = IRSSI_GUI_NONE; '),('irssi','1.1.1','631650bd8ab467af8347b5d9b51b2b0193adfe63','ailin-nemui','Revert \"record line info on empty lines\"','formats.c','1131','353','0','9','MODIFY','@@ -1233,15 +1233,6 @@ void format_send_to_gui(TEXT_DEST_REC *dest, const char *text)  	dup = str = g_strdup(text);    	flags = 0; fgcolor = theme->default_color; bgcolor = -1; - -	if (*str == \'\\0\') { -		/* empty line, write line info only */ -		signal_emit_id(signal_gui_print_text, 6, dest->window, -			       GINT_TO_POINTER(fgcolor), -			       GINT_TO_POINTER(bgcolor), -			       GINT_TO_POINTER(flags), str, -			       dest); -	}  	while (*str != \'\\0\') {  		type = \'\\0\';  		for (ptr = str; *ptr != \'\\0\'; ptr++) { '),('irssi','1.1.1','631650bd8ab467af8347b5d9b51b2b0193adfe63','ailin-nemui','Revert \"record line info on empty lines\"','textbuffer.c','472','140','3','0','MODIFY','@@ -355,6 +355,9 @@ LINE_REC *textbuffer_insert(TEXT_BUFFER_REC *buffer, LINE_REC *insert_after,  	g_return_val_if_fail(buffer != NULL, NULL);  	g_return_val_if_fail(data != NULL, NULL);   +	if (len == 0) +                return insert_after; +  	line = !buffer->last_eol ? insert_after :  		textbuffer_line_insert(buffer, insert_after);   '),('irssi','1.1.1','db3b671328d0e6890b17c23baf9d4280d086e89b','vague666','Added HIDDEN level to ignores','ignore.c','359','137','14','3','MODIFY','@@ -82,9 +82,9 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)   * However we also want to allow NO_ACT combined with levels, so mask it out and   * match levels if set. */  #define ignore_match_level(rec, level) \\ -        (((level & MSGLEVEL_NO_ACT) != 0) ? \\ -         ((~MSGLEVEL_NO_ACT & level) & (rec)->level) != 0 : \\ -         ((rec)->level & MSGLEVEL_NO_ACT ? 0 : \\ +        (((level & (MSGLEVEL_NO_ACT|MSGLEVEL_HIDDEN)) != 0) ? \\ +         ((~(MSGLEVEL_NO_ACT|MSGLEVEL_HIDDEN) & level) & (rec)->level) != 0 : \\ +         ((rec)->level & (MSGLEVEL_NO_ACT|MSGLEVEL_HIDDEN) ? 0 : \\           (level & (rec)->level) != 0))    #define ignore_match_nickmask(rec, nick, nickmask) \\ @@ -212,6 +212,12 @@ IGNORE_REC *ignore_find_full(const char *servertag, const char *mask, const char  		if (!(flags & IGNORE_FIND_NOACT) && (rec->level & MSGLEVEL_NO_ACT) != 0)  			continue;   +		if ((flags & IGNORE_FIND_HIDDEN) && (rec->level & MSGLEVEL_HIDDEN) == 0) +			continue; + +		if (!(flags & IGNORE_FIND_HIDDEN) && (rec->level & MSGLEVEL_HIDDEN) != 0) +			continue; +  		if ((rec->mask == NULL && mask != NULL) ||  		    (rec->mask != NULL && mask == NULL))  			continue; @@ -264,6 +270,11 @@ IGNORE_REC *ignore_find_noact(const char *servertag, const char *mask, char **ch  	return ignore_find_full(servertag, mask, NULL, channels, IGNORE_FIND_NOACT);  }   +IGNORE_REC *ignore_find_hidden(const char *servertag, const char *mask, char **channels, int hidden) +{ +	return ignore_find_full(servertag, mask, NULL, channels, IGNORE_FIND_HIDDEN); +} +  static void ignore_set_config(IGNORE_REC *rec)  {  	CONFIG_NODE *node; '),('irssi','1.1.1','db3b671328d0e6890b17c23baf9d4280d086e89b','vague666','Added HIDDEN level to ignores','ignore.h','32','0','2','0','MODIFY','@@ -29,6 +29,7 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  enum {  	IGNORE_FIND_PATTERN = 0x01, /* Match the pattern */  	IGNORE_FIND_NOACT   = 0x02, /* Exclude the targets with NOACT level */ +	IGNORE_FIND_HIDDEN  = 0x03, /* Exclude the targets with HIDDEN level */  };    IGNORE_REC *ignore_find_full (const char *servertag, const char *mask, const char *pattern, @@ -38,6 +39,7 @@ IGNORE_REC *ignore_find_full (const char *servertag, const char *mask, const cha    IGNORE_REC *ignore_find(const char *servertag, const char *mask, char **channels);  IGNORE_REC *ignore_find_noact(const char *servertag, const char *mask, char **channels, int noact); +IGNORE_REC *ignore_find_hidden(const char *servertag, const char *mask, char **channels, int hidden);    void ignore_add_rec(IGNORE_REC *rec);  void ignore_update_rec(IGNORE_REC *rec); '),('irssi','1.1.1','db3b671328d0e6890b17c23baf9d4280d086e89b','vague666','Added HIDDEN level to ignores','fe-ignore.c','218','64','8','1','MODIFY','@@ -157,7 +157,8 @@ static void cmd_ignore(const char *data)  		g_strsplit(chanarg, \",\", -1);    	rec = ignore_find_full(servertag, mask, patternarg, channels, -			  IGNORE_FIND_PATTERN | ((level & MSGLEVEL_NO_ACT) ? IGNORE_FIND_NOACT : 0)); +			  IGNORE_FIND_PATTERN | ((level & MSGLEVEL_NO_ACT) ? IGNORE_FIND_NOACT : 0) | +			  ((level & MSGLEVEL_HIDDEN) ? IGNORE_FIND_HIDDEN : 0));  	new_ignore = rec == NULL;    	if (rec == NULL) { @@ -179,6 +180,12 @@ static void cmd_ignore(const char *data)  		rec->level |= MSGLEVEL_ALL;  	}   +	if (rec->level == MSGLEVEL_HIDDEN) { +		/* If only HIDDEN was specified add all levels; it makes no +		 * sense on its own. */ +		rec->level |= MSGLEVEL_ALL; +	} +  	if (new_ignore && rec->level == 0) {  		/* tried to unignore levels from nonexisting ignore */  		printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, '),('irssi','1.1.1','db3b671328d0e6890b17c23baf9d4280d086e89b','vague666','Added HIDDEN level to ignores','fe-messages.c','588','157','27','0','MODIFY','@@ -204,6 +204,9 @@ static void sig_message_public(SERVER_REC *server, const char *msg,  	if (ignore_check(server, nick, address, target, msg, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, nick, address, target, msg, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	if (settings_get_bool(\"emphasis\"))  		msg = freemsg = expand_emphasis((WI_ITEM_REC *) chanrec, msg);   @@ -263,6 +266,9 @@ static void sig_message_private(SERVER_REC *server, const char *msg,  	if (ignore_check(server, nick, address, NULL, msg, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, nick, address, NULL, msg, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	if (own) {  		printformat(server, target, level,  			    query == NULL ? TXT_OWN_MSG_PRIVATE : @@ -358,6 +364,9 @@ static void sig_message_join(SERVER_REC *server, const char *channel,  	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	printformat(server, channel, level,  		    TXT_JOIN, nick, address, channel);  } @@ -371,6 +380,9 @@ static void sig_message_part(SERVER_REC *server, const char *channel,  	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	printformat(server, channel, level,  		    TXT_PART, nick, address, channel, reason);  } @@ -390,6 +402,9 @@ static void sig_message_quit(SERVER_REC *server, const char *nick,  	if (ignore_check(server, nick, address, NULL, reason, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, nick, address, NULL, reason, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	print_channel = NULL;  	once = settings_get_bool(\"show_quit_once\");   @@ -412,6 +427,9 @@ static void sig_message_quit(SERVER_REC *server, const char *nick,  		if (ignore_check(server, nick, address, rec->visible_name, reason, MSGLEVEL_NO_ACT))  			level |= MSGLEVEL_NO_ACT;   +		if (ignore_check(server, nick, address, rec->visible_name, reason, MSGLEVEL_HIDDEN)) +			level |= MSGLEVEL_HIDDEN; +  		if (print_channel == NULL ||  		    active_win->active == (WI_ITEM_REC *) rec)  			print_channel = rec->visible_name; @@ -461,6 +479,9 @@ static void sig_message_kick(SERVER_REC *server, const char *channel,  	if (ignore_check(server, kicker, address, channel, reason, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, kicker, address, channel, reason, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	printformat(server, channel, level,  		    TXT_KICK, nick, channel, kicker, reason, address);  } @@ -482,6 +503,9 @@ static void print_nick_change_channel(SERVER_REC *server, const char *channel,  	if (!(level & MSGLEVEL_NO_ACT) && ignore_check(server, oldnick, address, channel, newnick, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (!(level & MSGLEVEL_HIDDEN) && ignore_check(server, oldnick, address, channel, newnick, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	printformat(server, channel, level,  		    ownnick ? TXT_YOUR_NICK_CHANGED : TXT_NICK_CHANGED,  		    oldnick, newnick, channel, address); @@ -561,6 +585,9 @@ static void sig_message_topic(SERVER_REC *server, const char *channel,  	if (ignore_check(server, nick, address, channel, topic, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, nick, address, channel, topic, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	printformat(server, channel, level,  		    *topic != \'\\0\' ? TXT_NEW_TOPIC : TXT_TOPIC_UNSET,  		    nick, channel, topic, address); '),('irssi','1.1.1','db3b671328d0e6890b17c23baf9d4280d086e89b','vague666','Added HIDDEN level to ignores','window-activity.c','113','26','1','1','MODIFY','@@ -125,7 +125,7 @@ static void read_settings(void)  	hide_targets = *targets == \'\\0\' ? NULL :  		g_strsplit(targets, \" \", -1);   -	hide_level = MSGLEVEL_NEVER | MSGLEVEL_NO_ACT | +	hide_level = MSGLEVEL_NEVER | MSGLEVEL_NO_ACT | MSGLEVEL_HIDDEN |  		settings_get_level(\"activity_hide_level\");  	msg_level = settings_get_level(\"activity_msg_level\");  	hilight_level = MSGLEVEL_HILIGHT | '),('irssi','1.1.1','db3b671328d0e6890b17c23baf9d4280d086e89b','vague666','Added HIDDEN level to ignores','fe-dcc-chat-messages.c','125','18','12','0','MODIFY','@@ -96,6 +96,10 @@ static void sig_message_dcc(CHAT_DCC_REC *dcc, const char *msg)  				level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +				level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag,  			       level, NULL);   @@ -118,6 +122,10 @@ static void sig_message_dcc_action(CHAT_DCC_REC *dcc, const char *msg)  				level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +				level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag,  			       level, NULL);   @@ -139,6 +147,10 @@ static void sig_message_dcc_ctcp(CHAT_DCC_REC *dcc, const char *cmd,  				level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, +				level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag,  			       level, NULL);   '),('irssi','1.1.1','db3b671328d0e6890b17c23baf9d4280d086e89b','vague666','Added HIDDEN level to ignores','fe-irc-messages.c','233','44','9','0','MODIFY','@@ -162,6 +162,10 @@ static void sig_message_irc_action(IRC_SERVER_REC *server, const char *msg,  			 level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(SERVER(server), nick, address, target, msg, +			 level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	if (server_ischannel(SERVER(server), target)) {  		item = irc_channel_find(server, target);  	} else { @@ -241,6 +245,11 @@ static void sig_message_irc_notice(SERVER_REC *server, const char *msg,  			 msg, level | MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   +	if (ignore_check(server, nick, address, +			 server_ischannel(SERVER(server), target) ? target : NULL, +			 msg, level | MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +          if (server_ischannel(SERVER(server), target)) {  		/* notice in some channel */  		printformat(server, target, level, '),('irssi','1.1.1','ac3af3fb56d98b884d03646e3c15435c8a435bf3','vague666','these were bitflags','ignore.h','32','0','1','1','MODIFY','@@ -29,7 +29,7 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  enum {  	IGNORE_FIND_PATTERN = 0x01, /* Match the pattern */  	IGNORE_FIND_NOACT   = 0x02, /* Exclude the targets with NOACT level */ -	IGNORE_FIND_HIDDEN  = 0x03, /* Exclude the targets with HIDDEN level */ +	IGNORE_FIND_HIDDEN  = 0x04, /* Exclude the targets with HIDDEN level */  };    IGNORE_REC *ignore_find_full (const char *servertag, const char *mask, const char *pattern, '),('irssi','1.1.1','1547248e9448c22476a56c630ee18d95a57dc05f','vague666','simplify code','fe-ignore.c','221','64','8','4','MODIFY','@@ -118,7 +118,7 @@ static void cmd_ignore(const char *data)  	char *patternarg, *chanarg, *mask, *levels, *timestr, *servertag;  	char **channels;  	void *free_arg; -	int new_ignore, msecs, level; +	int new_ignore, msecs, level, flags;    	if (*data == \'\\0\') {  		cmd_ignore_show(); @@ -156,9 +156,13 @@ static void cmd_ignore(const char *data)  	channels = (chanarg == NULL || *chanarg == \'\\0\') ? NULL :  		g_strsplit(chanarg, \",\", -1);   -	rec = ignore_find_full(servertag, mask, patternarg, channels, -			  IGNORE_FIND_PATTERN | ((level & MSGLEVEL_NO_ACT) ? IGNORE_FIND_NOACT : 0) | -			  ((level & MSGLEVEL_HIDDEN) ? IGNORE_FIND_HIDDEN : 0)); +	flags = IGNORE_FIND_PATTERN; +	if (level & MSGLEVEL_NO_ACT) +		flags |= IGNORE_FIND_NOACT; +	if (level & MSGLEVEL_HIDDEN) +		flags |= IGNORE_FIND_HIDDEN; + +	rec = ignore_find_full(servertag, mask, patternarg, channels, flags);  	new_ignore = rec == NULL;    	if (rec == NULL) { '),('irssi','1.1.1','d2e1caf7205220c9fd73861604de8248eb07f0d6','vague666','simplifying code','ignore.c','359','137','4','3','MODIFY','@@ -81,10 +81,11 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)   * used as a flag to indicate it should only look at ignore items with NO_ACT.   * However we also want to allow NO_ACT combined with levels, so mask it out and   * match levels if set. */ +#define FLAG_MSGLEVELS ( MSGLEVEL_NO_ACT | MSGLEVEL_HIDDEN )  #define ignore_match_level(rec, level) \\ -        (((level & (MSGLEVEL_NO_ACT|MSGLEVEL_HIDDEN)) != 0) ? \\ -         ((~(MSGLEVEL_NO_ACT|MSGLEVEL_HIDDEN) & level) & (rec)->level) != 0 : \\ -         ((rec)->level & (MSGLEVEL_NO_ACT|MSGLEVEL_HIDDEN) ? 0 : \\ +        (((level & FLAG_MSGLEVELS)!= 0) ? \\ +         ((~FLAG_MSGLEVELS & level) & (rec)->level) != 0 : \\ +         ((rec)->level & FLAG_MSGLEVELS ? 0 : \\           (level & (rec)->level) != 0))    #define ignore_match_nickmask(rec, nick, nickmask) \\ '),('irssi','1.1.1','ba2554dd1485259b95b4b37f281c989086b24739','vague666','missing space','ignore.c','359','137','1','1','MODIFY','@@ -83,7 +83,7 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)   * match levels if set. */  #define FLAG_MSGLEVELS ( MSGLEVEL_NO_ACT | MSGLEVEL_HIDDEN )  #define ignore_match_level(rec, level) \\ -        (((level & FLAG_MSGLEVELS)!= 0) ? \\ +        (((level & FLAG_MSGLEVELS) != 0) ? \\           ((~FLAG_MSGLEVELS & level) & (rec)->level) != 0 : \\           ((rec)->level & FLAG_MSGLEVELS ? 0 : \\           (level & (rec)->level) != 0)) '),('irssi','1.1.1','1ab679bf32028b175c14f977659af540550bba47','vague666','remove = from format because people get confused by it','module-formats.c','244','0','1','1','MODIFY','@@ -282,7 +282,7 @@ FORMAT_REC fecommon_core_formats[] = {  	{ \"glib_error\", \"{error $0} $1\", 2, { 0, 0 } },  	{ \"overwrite_config\", \"Overwrite config (y/N)?\", 0 },  	{ \"set_title\", \"[{hilight $0}]\", 1, { 0 } }, -	{ \"set_item\", \"$0 = $1\", 2, { 0, 0 } }, +	{ \"set_item\", \"$[-!32]0 %_$1\", 2, { 0, 0 } },  	{ \"set_unknown\", \"Unknown setting $0\", 1, { 0 } },  	{ \"set_not_boolean\", \"Setting {hilight $0} isn\'t boolean, use /SET\", 1, { 0 } },  	{ \"no_completions\", \"There are no completions\", 0 }, '),('irssi','1.1.1','d84a24444fbef8af6ae72888cfc3a539e0a1f005','Doug Freed','core/ignore: fix ignore_match_level handling of flag levels','ignore.c','370','141','11','5','MODIFY','@@ -82,11 +82,17 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)   * However we also want to allow NO_ACT combined with levels, so mask it out and   * match levels if set. */  #define FLAG_MSGLEVELS ( MSGLEVEL_NO_ACT | MSGLEVEL_HIDDEN ) -#define ignore_match_level(rec, level) \\ -        (((level & FLAG_MSGLEVELS) != 0) ? \\ -         ((~FLAG_MSGLEVELS & level) & (rec)->level) != 0 : \\ -         ((rec)->level & FLAG_MSGLEVELS ? 0 : \\ -         (level & (rec)->level) != 0)) +static int ignore_match_level(IGNORE_REC *rec, int level) +{ +	if (level & FLAG_MSGLEVELS) { +		int flaglevel = level & FLAG_MSGLEVELS; +		return (level & rec->level) && (flaglevel & rec->level); +	} else if (!(rec->level & FLAG_MSGLEVELS)) { +		return (level & rec->level); +	} else { +		return FALSE; +	} +}    #define ignore_match_nickmask(rec, nick, nickmask) \\  	((rec)->mask == NULL || \\ '),('irssi','1.1.1','4f45828ff3de2952fa2d6be8515e67986213e7a8','Janik Rabe','Keep errstr set to NULL if errno is not set  Don\'t use errno if it is not set and show the default error message instead. This prevents messages like \"SSL handshake failed: Success\" from being shown.','network-openssl.c','684','152','1','1','MODIFY','@@ -842,7 +842,7 @@ int irssi_ssl_handshake(GIOChannel *handle)  				return -1;  			case SSL_ERROR_SYSCALL:  				errstr = ERR_reason_error_string(ERR_get_error()); -				if (errstr == NULL && ret == -1) +				if (errstr == NULL && ret == -1 && errno)  					errstr = strerror(errno);  				g_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"server closed connection unexpectedly\");  				return -1; '),('irssi','1.1.1','0e187cf9cfb99c19f3dc9cf532fb5bac92dd1145','Will Storey','Fix typo in comment','channel-events.c','275','68','1','1','MODIFY','@@ -126,7 +126,7 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,    	chanrec = channel_find(SERVER(server), channel);  	if (chanrec == NULL) return; -	/* the topic may be send out encoded, so we need to +	/* the topic may be sent out encoded, so we need to  	   recode it back or /topic <tab> will not work properly */  	recoded = recode_in(SERVER(server), topic, channel);  	if (topic != NULL) { '),('irssi','1.1.1','b9e301362db545a4108b5d08c7eda45441a475f5','Will Storey','Ignore vim editor files','.gitignore','57','0','1','0','MODIFY','@@ -59,6 +59,7 @@ tests/irc/core/test-irc.trs  *.la  *.lo  *.o +*.swp  *~    *.tar.bz2 '),('irssi','1.1.1','15840ac27bd05e710ae13afe1a3c29853d2d6a0b','Will Storey','If we receive a 0 length topic, record it as unset  Fixes #888.  Previously we showed that there was a topic set when using /topic, just an empty one. This was different than how we show such topics when initially joining a channel. Now we say that the topic is unset in both cases.','channel-events.c','276','68','11','9','MODIFY','@@ -126,23 +126,25 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,    	chanrec = channel_find(SERVER(server), channel);  	if (chanrec == NULL) return; + +	g_free_and_null(chanrec->topic); +	g_free_and_null(chanrec->topic_by); +	chanrec->topic_time = 0; +  	/* the topic may be sent out encoded, so we need to  	   recode it back or /topic <tab> will not work properly */  	recoded = recode_in(SERVER(server), topic, channel); -	if (topic != NULL) { -		g_free_not_null(chanrec->topic); -		chanrec->topic = recoded == NULL ? NULL : g_strdup(recoded); +	if (recoded == NULL || strlen(recoded) == 0) { +		signal_emit(\"channel topic changed\", 1, chanrec); +		g_free(recoded); +		return;  	} -	g_free(recoded);   -	g_free_not_null(chanrec->topic_by); +	chanrec->topic = recoded;  	chanrec->topic_by = g_strdup(setby); - -	if (chanrec->topic_by == NULL) { +	if (chanrec->topic_by != NULL) {  		/* ensure invariant topic_time > 0 <=> topic_by != NULL.  		   this could be triggered by a topic command without sender */ -		chanrec->topic_time = 0; -	} else {  		chanrec->topic_time = settime;  	}   '),('irssi','1.1.1','b114b11e36598157b7b014cc8d4325fbf04c9b1e','dequis','channel_change_topic: change one strlen == 0 to *str == \'\\0\'','channel-events.c','276','68','1','1','MODIFY','@@ -134,7 +134,7 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,  	/* the topic may be sent out encoded, so we need to  	   recode it back or /topic <tab> will not work properly */  	recoded = recode_in(SERVER(server), topic, channel); -	if (recoded == NULL || strlen(recoded) == 0) { +	if (recoded == NULL || *recoded == \'\\0\') {  		signal_emit(\"channel topic changed\", 1, chanrec);  		g_free(recoded);  		return; '),('irssi','1.1.1','f3909b8bcb509bbb57d685ec5a2b9f93097b5755','Doug Freed','core/ignore: fix #900','ignore.c','371','141','2','1','MODIFY','@@ -86,7 +86,8 @@ static int ignore_match_level(IGNORE_REC *rec, int level)  {  	if (level & FLAG_MSGLEVELS) {  		int flaglevel = level & FLAG_MSGLEVELS; -		return (level & rec->level) && (flaglevel & rec->level); +		int msglevel = level & ~FLAG_MSGLEVELS; +		return (msglevel & rec->level) && (flaglevel & rec->level);  	} else if (!(rec->level & FLAG_MSGLEVELS)) {  		return (level & rec->level);  	} else { '),('irssi','1.1.1','10f632664989117afe6d4496a419f712fbb4c3b6','David Phillips','Redraw on SIGWINCH when screen size hasn\'t changed  Some programs and users send SIGWINCH as a request for the client to redraw in the event of session detachment/reattachment (e.g. abduco). A well-formed terminal will only send SIGWINCH when the window size has changed, so there is no need to optimise this case out.','term.c','133','33','3','5','MODIFY','@@ -81,11 +81,9 @@ void term_resize_dirty(void)  	if (!term_get_size(&width, &height))  		width = height = -1;   -	if (height != term_height || width != term_width) { -		term_resize(width, height); -		mainwindows_resize(term_width, term_height); -		term_resize_final(width, height); -	} +	term_resize(width, height); +	mainwindows_resize(term_width, term_height); +	term_resize_final(width, height);  }    #ifdef SIGWINCH '),('irssi','1.1.1','764f8215a9dad09b93832fdbb0c87eb1b0e6e773','Lukas Waymann','Fix `/save` replacing symlinks with regular files  A side-effect of 8deb618 is that `/save` may replace configuration files that are symlinks with regular files.  Fix this by resolving all symlinks before renaming the temporary file.','write.c','272','85','11','1','MODIFY','@@ -304,6 +304,7 @@ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)  	int save_errno;  	char *tmp_name;  	const char *dest_name; +	char *real_dest = NULL;    	g_return_val_if_fail(rec != NULL, -1);          g_return_val_if_fail(fname != NULL || rec->fname != NULL, -1); @@ -349,7 +350,15 @@ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)  	g_io_channel_unref(rec->handle);  	rec->handle = NULL;   -	if (rename(tmp_name, dest_name) == -1) { +	/* expand all symlinks; else we may replace a symlink with a regular file */ +	real_dest = realpath(dest_name, NULL); +	if (real_dest == NULL) { +		unlink(tmp_name); +		config_error(rec, g_strerror(errno)); +		goto out; +	} + +	if (rename(tmp_name, real_dest) == -1) {  		unlink(tmp_name);  		config_error(rec, g_strerror(errno));  		goto out; @@ -362,6 +371,7 @@ out:  	}    	g_free(tmp_name); +	g_free(real_dest);    	return ret;  } '),('irssi','1.1.1','7d3eb47ab51a93defb267912704e84b3241b4db6','Lukas Waymann','Fix potential `rename(3)` across file systems  Make sure the temporary file in the `config_write` function is created on the same file system as the file we `rename` it to later.','write.c','270','85','12','14','MODIFY','@@ -302,15 +302,21 @@ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)  	int ret;  	int fd;  	int save_errno; -	char *tmp_name; -	const char *dest_name; -	char *real_dest = NULL; +	char *tmp_name = NULL; +	char *dest_name = NULL;    	g_return_val_if_fail(rec != NULL, -1);          g_return_val_if_fail(fname != NULL || rec->fname != NULL, -1);          g_return_val_if_fail(create_mode != -1 || rec->create_mode != -1, -1);   -	dest_name = fname != NULL ? fname : rec->fname; +	/* expand all symlinks; else we may replace a symlink with a regular file */ +	dest_name = realpath(fname != NULL ? fname : rec->fname, NULL); +	if (dest_name == NULL) { +		config_error(rec, g_strerror(errno)); +		ret = -1; +		goto out; +	} +  	tmp_name = g_strdup_printf(\"%s.XXXXXX\", dest_name);    	fd = g_mkstemp_full(tmp_name, @@ -350,15 +356,7 @@ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)  	g_io_channel_unref(rec->handle);  	rec->handle = NULL;   -	/* expand all symlinks; else we may replace a symlink with a regular file */ -	real_dest = realpath(dest_name, NULL); -	if (real_dest == NULL) { -		unlink(tmp_name); -		config_error(rec, g_strerror(errno)); -		goto out; -	} - -	if (rename(tmp_name, real_dest) == -1) { +	if (rename(tmp_name, dest_name) == -1) {  		unlink(tmp_name);  		config_error(rec, g_strerror(errno));  		goto out; @@ -371,7 +369,7 @@ out:  	}    	g_free(tmp_name); -	g_free(real_dest); +	g_free(dest_name);    	return ret;  } '),('irssi','1.1.1','817179a7606b616795cf67e24505526dded34381','ailin-nemui','Revert \"Flag topic as unset if it is zero length\"','.gitignore','56','0','0','1','MODIFY','@@ -59,7 +59,6 @@ tests/irc/core/test-irc.trs  *.la  *.lo  *.o -*.swp  *~    *.tar.bz2 '),('irssi','1.1.1','817179a7606b616795cf67e24505526dded34381','ailin-nemui','Revert \"Flag topic as unset if it is zero length\"','channel-events.c','275','68','10','12','MODIFY','@@ -126,25 +126,23 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,    	chanrec = channel_find(SERVER(server), channel);  	if (chanrec == NULL) return; - -	g_free_and_null(chanrec->topic); -	g_free_and_null(chanrec->topic_by); -	chanrec->topic_time = 0; - -	/* the topic may be sent out encoded, so we need to +	/* the topic may be send out encoded, so we need to  	   recode it back or /topic <tab> will not work properly */  	recoded = recode_in(SERVER(server), topic, channel); -	if (recoded == NULL || *recoded == \'\\0\') { -		signal_emit(\"channel topic changed\", 1, chanrec); -		g_free(recoded); -		return; +	if (topic != NULL) { +		g_free_not_null(chanrec->topic); +		chanrec->topic = recoded == NULL ? NULL : g_strdup(recoded);  	} +	g_free(recoded);   -	chanrec->topic = recoded; +	g_free_not_null(chanrec->topic_by);  	chanrec->topic_by = g_strdup(setby); -	if (chanrec->topic_by != NULL) { + +	if (chanrec->topic_by == NULL) {  		/* ensure invariant topic_time > 0 <=> topic_by != NULL.  		   this could be triggered by a topic command without sender */ +		chanrec->topic_time = 0; +	} else {  		chanrec->topic_time = settime;  	}   '),('irssi','1.1.1','4f5f62ac63697d23e8a4d432f181a85c45a49d5e','Joseph Bisch','Add server-fuzz to fe-fuzz  Based on test-796.c in the tests directory.','Makefile.am','27','0','14','3','MODIFY','@@ -1,6 +1,6 @@  SUBDIRS = irc fe-common   -bin_PROGRAMS = irssi-fuzz +bin_PROGRAMS = irssi-fuzz server-fuzz    # Force link with CXX for libfuzzer support  CCLD=$(CXX) $(CXXFLAGS) @@ -21,7 +21,18 @@ irssi_fuzz_LDADD = \\    irssi_fuzz_SOURCES = \\          irssi.c \\ -	$(top_srcdir)/src/fe-text/module-formats.c +	../fe-text/module-formats.c + +server_fuzz_DEPENDENCIES = @COMMON_LIBS@ + +server_fuzz_LDADD = \\ +	@COMMON_LIBS@ \\ +	@PROG_LIBS@ \\ +	$(FUZZER_LIBS) + +server_fuzz_SOURCES = \\ +	server.c \\ +	../fe-text/module-formats.c    noinst_HEADERS = \\ -	$(top_srcdir)/src/fe-text/module-formats.h +	../fe-text/module-formats.h '),('irssi','1.1.1','4f5f62ac63697d23e8a4d432f181a85c45a49d5e','Joseph Bisch','Add server-fuzz to fe-fuzz  Based on test-796.c in the tests directory.','server.c','108','11','176','0','ADD','@@ -0,0 +1,176 @@ +/* + server.c : irssi + +    Copyright (C) 2018 Joseph Bisch + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include \"module.h\" +#include \"modules-load.h\" +#include \"module-formats.h\" +#include \"levels.h\" +#include \"themes.h\" +#include \"core.h\" +#include \"fe-common-core.h\" +#include \"args.h\" +#include \"printtext.h\" +#include \"misc.h\" +#include \"servers-setup.h\" + +#include <stddef.h> +#include <stdint.h> +#include <stdlib.h> +#include <string.h> +#include <unistd.h> + +#include \"irc.h\" +#include \"irc-servers.h\" +#include \"irc-channels.h\" + +/* irc.c */ +void irc_init(void); +void irc_deinit(void); + +/* irc-session.c */ +void irc_session_init(void); +void irc_session_deinit(void); + +/* fe-common-irc.c */ +void fe_common_irc_init(void); +void fe_common_irc_deinit(void); + +SERVER_REC *server; + +void event_connected(IRC_SERVER_REC *server, const char *data, const char *from) +{ +	char *params, *nick; + +	g_return_if_fail(server != NULL); + +	params = event_get_params(data, 1, &nick); + +	if (g_strcmp0(server->nick, nick) != 0) { +		/* nick changed unexpectedly .. connected via proxy, etc. */ +		g_free(server->nick); +		server->nick = g_strdup(nick); +	} + +	/* set the server address */ +	g_free(server->real_address); +	server->real_address = from == NULL ? +		g_strdup(server->connrec->address) : /* shouldn\'t happen.. */ +		g_strdup(from); + +	/* last welcome message found - commands can be sent to server now. */ +	server->connected = 1; +	server->real_connect_time = time(NULL); + +	/* let the queue send now that we are identified */ +	g_get_current_time(&server->wait_cmd); + +	if (server->connrec->usermode != NULL) { +		/* Send the user mode, before the autosendcmd. +		 * Do not pass this through cmd_mode because it +		 * is not known whether the resulting MODE message +		 * (if any) is the initial umode or a reply to this. +		 */ +		irc_send_cmdv(server, \"MODE %s %s\", server->nick, +				server->connrec->usermode); +		g_free_not_null(server->wanted_usermode); +		server->wanted_usermode = g_strdup(server->connrec->usermode); +	} + +	signal_emit(\"event connected\", 1, server); +	g_free(params); +} + +void irc_server_init_bare_minimum(IRC_SERVER_REC *server) { +	server->isupport = g_hash_table_new((GHashFunc) g_istr_hash, +					    (GCompareFunc) g_istr_equal); + +	/* set the standards */ +	g_hash_table_insert(server->isupport, g_strdup(\"CHANMODES\"), g_strdup(\"beI,k,l,imnpst\")); +	g_hash_table_insert(server->isupport, g_strdup(\"PREFIX\"), g_strdup(\"(ohv)@%+\")); +} + +void test_server() { +	//SERVER_REC *server; /* = g_new0(IRC_SERVER_REC, 1); */ +	CHAT_PROTOCOL_REC *proto; +	SERVER_CONNECT_REC *conn; + +	proto = chat_protocol_find(\"IRC\"); +	conn = server_create_conn(proto->id, \"localhost\", 0, \"\", \"\", \"user\"); +	server = proto->server_init_connect(conn); +	server->session_reconnect = TRUE; +	server->tag = g_strdup(\"testserver\"); + +	/* we skip some initialisations that would try to send data */ +	/* irc_servers_deinit(); */ +	irc_session_deinit(); +	irc_irc_deinit(); + +	server_connect_finished(server); + +	/* make up for the skipped session init */ +	irc_server_init_bare_minimum(IRC_SERVER(server)); + +	irc_irc_init(); +	irc_session_init(); +	/* irc_servers_init(); */ + +	server_connect_unref(conn); +} + +int LLVMFuzzerInitialize(int *argc, char ***argv) { +	core_register_options(); +	fe_common_core_register_options(); +	/* no args */ +	args_execute(0, NULL); +	core_preinit((*argv)[0]); +	core_init(); +	irc_init(); +	fe_common_core_init(); +	fe_common_irc_init(); +	signal_add(\"event 001\", (SIGNAL_FUNC) event_connected); +	module_register(\"core\", \"fe-fuzz\"); +	return 0; +} + +int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { +	if (size < 1) return 0; + +	test_server(); +	gboolean prefixedChoice = (gboolean)*data; +	gchar *copy = g_strndup((const gchar *)data+1, size-1); +	gchar **lines = g_strsplit(copy, \"\\r\\n\", -1); +	gchar **head = lines; + +	for (; *lines != NULL; lines++) { +		gchar *prefixedLine; +		if (prefixedChoice) { +			prefixedLine = g_strdup_printf(\":user %s\\n\", *lines); +		} else { +			prefixedLine = g_strdup_printf(\"%s\\n\", *lines); +		} +		signal_emit(\"server incoming\", 2, server, prefixedLine); +		g_free(prefixedLine); +	} + +	g_strfreev(head); +	g_free(copy); +	server_unref(server); +	return 0; +} '),('irssi','1.1.1','a19b503a31fa4fb31c2e6ee79ffdc18bf4a87db0','ailin-nemui','properly record line info on empty lines','formats.c','1135','354','7','0','MODIFY','@@ -1233,6 +1233,13 @@ void format_send_to_gui(TEXT_DEST_REC *dest, const char *text)  	dup = str = g_strdup(text);    	flags = 0; fgcolor = theme->default_color; bgcolor = -1; + +	if (*str == \'\\0\') { +		/* empty line, write line info only */ +		signal_emit_id(signal_gui_print_text, 6, dest->window, GINT_TO_POINTER(fgcolor), +		               GINT_TO_POINTER(bgcolor), GINT_TO_POINTER(flags), str, dest); +	} +  	while (*str != \'\\0\') {  		type = \'\\0\';  		for (ptr = str; *ptr != \'\\0\'; ptr++) { '),('irssi','1.1.1','a19b503a31fa4fb31c2e6ee79ffdc18bf4a87db0','ailin-nemui','properly record line info on empty lines','gui-printtext.c','276','62','9','3','MODIFY','@@ -307,9 +307,15 @@ static void sig_gui_print_text(WINDOW_REC *window, void *fgcolor,  	}  	textbuffer_line_add_colors(view->buffer, &insert_after, fg, bg, flags);   -	insert_after = textbuffer_insert(view->buffer, insert_after, -					 (unsigned char *) str, -					 strlen(str), &lineinfo); +	/* for historical reasons, the \\n will set +	   GUI_PRINT_FLAG_NEWLINE and print an empty string. in this +	   special case, ignore the empty string which would otherwise +	   start another new line */ +	if (~flags & GUI_PRINT_FLAG_NEWLINE || *str != \'\\0\') { +		insert_after = textbuffer_insert(view->buffer, insert_after, (unsigned char *) str, +		                                 strlen(str), &lineinfo); +	} +  	if (gui->use_insert_after)                  gui->insert_after = insert_after;  } '),('irssi','1.1.1','a19b503a31fa4fb31c2e6ee79ffdc18bf4a87db0','ailin-nemui','properly record line info on empty lines','textbuffer.c','471','139','2','4','MODIFY','@@ -333,8 +333,9 @@ void textbuffer_line_add_colors(TEXT_BUFFER_REC *buffer, LINE_REC **line,  		data[pos++] = LINE_CMD_INDENT;  	}   -        if (pos > 0) +	if (pos > 0) {  		*line = textbuffer_insert(buffer, *line, data, pos, NULL); +	}    	buffer->last_flags = flags;  } @@ -355,9 +356,6 @@ LINE_REC *textbuffer_insert(TEXT_BUFFER_REC *buffer, LINE_REC *insert_after,  	g_return_val_if_fail(buffer != NULL, NULL);  	g_return_val_if_fail(data != NULL, NULL);   -	if (len == 0) -                return insert_after; -  	line = !buffer->last_eol ? insert_after :  		textbuffer_line_insert(buffer, insert_after);   '),('irssi','1.1.1','af1e4d6e34317452ac32380bed795aecb00f5d88','ailin-nemui','initialise the line to zeros','textbuffer.c','471','139','1','1','MODIFY','@@ -192,7 +192,7 @@ static LINE_REC *textbuffer_line_create(TEXT_BUFFER_REC *buffer)  	if (buffer->cur_text == NULL)                  text_chunk_create(buffer);   -	rec = g_slice_new(LINE_REC); +	rec = g_slice_new0(LINE_REC);  	rec->text = buffer->cur_text->buffer + buffer->cur_text->pos;    	buffer->cur_text->refcount++; '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','Makefile.am','113','0','1','0','MODIFY','@@ -53,6 +53,7 @@ libcore_a_SOURCES = \\  	utf8.c \\  	$(regex_impl) \\  	wcwidth.c \\ +	wcwidth-wrapper.c \\  	tls.c \\  	write-buffer.c   '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','core.c','228','26','5','0','MODIFY','@@ -60,6 +60,9 @@ void chat_commands_deinit(void);  void log_away_init(void);  void log_away_deinit(void);   +void wcwidth_wrapper_init(void); +void wcwidth_wrapper_deinit(void); +  int irssi_gui;  int irssi_init_finished;  int reload_config; @@ -258,6 +261,7 @@ void core_init(void)  	nicklist_init();    	chat_commands_init(); +	wcwidth_wrapper_init();    	settings_add_str(\"misc\", \"ignore_signals\", \"\");  	settings_add_bool(\"misc\", \"override_coredump_limit\", FALSE); @@ -281,6 +285,7 @@ void core_deinit(void)  	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);  	signal_remove(\"irssi init finished\", (SIGNAL_FUNC) sig_irssi_init_finished);   +	wcwidth_wrapper_deinit();  	chat_commands_deinit();    	nicklist_deinit(); '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','utf8.c','82','20','1','1','MODIFY','@@ -36,7 +36,7 @@ int string_advance(char const **str, int policy)  		c = g_utf8_get_char(*str);  		*str = g_utf8_next_char(*str);   -		return unichar_isprint(c) ? mk_wcwidth(c) : 1; +		return unichar_isprint(c) ? i_wcwidth(c) : 1;  	} else {  		/* Assume TREAT_STRING_AS_BYTES: */  		*str += 1; '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','utf8.h','14','0','6','0','MODIFY','@@ -12,8 +12,14 @@  typedef guint32 unichar;    /* Returns width for character (0-2). */ +int i_wcwidth(unichar c); + +/* Older variant of the above */  int mk_wcwidth(unichar c);   +/* Signature for wcwidth implementations */ +typedef int (*WCWIDTH_FUNC) (unichar ucs); +  /* Advance the str pointer one character further; return the number of columns   * occupied by the skipped character.   */ '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','wcwidth-wrapper.c','59','12','117','0','ADD','@@ -0,0 +1,117 @@ +/* + wcwidth-wrapper.c : irssi + +    Copyright (C) 2018 dequis + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#define _XOPEN_SOURCE +#include <wchar.h> + +#include \"module.h\" +#include \"signals.h\" +#include \"settings.h\" +#include \"utf8.h\" + +/* wcwidth=2 since unicode 5.2.0 */ +#define UNICODE_SQUARE_HIRAGANA_HOKA 0x1F200 + +/* wcwidth=2 since unicode 9.0.0 */ +#define UNICODE_IRSSI_LOGO 0x1F525 + +enum { +	WCWIDTH_IMPL_AUTO = 0, +	WCWIDTH_IMPL_OLD, +	WCWIDTH_IMPL_SYSTEM, +}; + +WCWIDTH_FUNC wcwidth_impl_func = mk_wcwidth; + +int i_wcwidth(unichar ucs) +{ +	return (*wcwidth_impl_func)(ucs); +} + +static int system_wcwidth(unichar ucs) +{ +	int retval = wcwidth((wchar_t) ucs); + +	if (retval < 0) { +		/* Treat all unknown characters as taking one cell. This is +		 * the reason mk_wcwidth and other outdated implementations +		 * mostly worked with newer unicode, while glibc\'s wcwidth +		 * needs updating to recognize new characters. +		 * +		 * Instead of relying on that, we keep the behavior of assuming +		 * one cell even for glibc\'s implementation, which is still +		 * highly accurate and less of a headache overall. +		 */ +		return 1; +	} + +	return retval; +} + +static void read_settings(void) +{ +	static int choice = -1; +	int newchoice; + +	newchoice = settings_get_choice(\"wcwidth_implementation\"); + +	if (choice == newchoice) { +		return; +	} + +	choice = newchoice; + +	switch (choice) { +	case WCWIDTH_IMPL_AUTO: +		/* Test against characters that have wcwidth=2 +		 * since unicode 5.2 and 9.0 respectively */ + +		if (system_wcwidth(UNICODE_SQUARE_HIRAGANA_HOKA) == 2 || +		    system_wcwidth(UNICODE_IRSSI_LOGO) == 2) { +			wcwidth_impl_func = &system_wcwidth; +		} else { +			/* Fall back to our own (which implements 5.0) */ +			wcwidth_impl_func = &mk_wcwidth; +		} +		break; + +	case WCWIDTH_IMPL_OLD: +		wcwidth_impl_func = &mk_wcwidth; +		break; + +	case WCWIDTH_IMPL_SYSTEM: +		wcwidth_impl_func = &system_wcwidth; +		break; +	} + +} + +void wcwidth_wrapper_init(void) +{ +	settings_add_choice(\"misc\", \"wcwidth_implementation\", WCWIDTH_IMPL_AUTO, \"auto;old;system\"); + +	read_settings(); +	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings); +} + +void wcwidth_wrapper_deinit(void) +{ +	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings); +} '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','gui-entry.c','1179','370','8','8','MODIFY','@@ -51,7 +51,7 @@ static unichar i_tolower(unichar c)  static int i_isalnum(unichar c)  {  	if (term_type == TERM_TYPE_UTF8) -		return (g_unichar_isalnum(c) || mk_wcwidth(c) == 0); +		return (g_unichar_isalnum(c) || i_wcwidth(c) == 0);  	return c <= 255 ? isalnum(c) : 0;  }   @@ -219,7 +219,7 @@ static int pos2scrpos(GUI_ENTRY_REC *entry, int pos, int cursor)  		if (term_type == TERM_TYPE_BIG5)  			xpos += big5_width(c);  		else if (entry->utf8) -			xpos += unichar_isprint(c) ? mk_wcwidth(c) : 1; +			xpos += unichar_isprint(c) ? i_wcwidth(c) : 1;  		else  			xpos++;   @@ -246,7 +246,7 @@ static int scrpos2pos(GUI_ENTRY_REC *entry, int pos)  		if (term_type == TERM_TYPE_BIG5)  			width = big5_width(c);  		else if (entry->utf8) -			width = unichar_isprint(c) ? mk_wcwidth(c) : 1; +			width = unichar_isprint(c) ? i_wcwidth(c) : 1;  		else  			width = 1;   @@ -373,7 +373,7 @@ static void gui_entry_draw_from(GUI_ENTRY_REC *entry, int pos)  		else if (term_type == TERM_TYPE_BIG5)  			new_xpos += big5_width(c);  		else if (entry->utf8) -			new_xpos += unichar_isprint(c) ? mk_wcwidth(c) : 1; +			new_xpos += unichar_isprint(c) ? i_wcwidth(c) : 1;  		else  			new_xpos++;   @@ -647,7 +647,7 @@ void gui_entry_insert_char(GUI_ENTRY_REC *entry, unichar chr)  	if (chr == 0 || chr == 13 || chr == 10)  		return; /* never insert NUL, CR or LF characters */   -	if (entry->utf8 && entry->pos == 0 && mk_wcwidth(chr) == 0) +	if (entry->utf8 && entry->pos == 0 && i_wcwidth(chr) == 0)  		return;    	gui_entry_redraw_from(entry, entry->pos); @@ -829,7 +829,7 @@ void gui_entry_erase(GUI_ENTRY_REC *entry, int size, CUTBUFFER_UPDATE_OP update_    	if (entry->utf8)  		while (entry->pos-size-w > 0 && -		       mk_wcwidth(entry->text[entry->pos-size-w]) == 0) w++; +		       i_wcwidth(entry->text[entry->pos-size-w]) == 0) w++;    	g_memmove(entry->text + entry->pos - size, entry->text + entry->pos,  		  (entry->text_len-entry->pos+1) * sizeof(unichar)); @@ -867,7 +867,7 @@ void gui_entry_erase_cell(GUI_ENTRY_REC *entry)    	if (entry->utf8)  		while (entry->pos+size < entry->text_len && -		       mk_wcwidth(entry->text[entry->pos+size]) == 0) size++; +		       i_wcwidth(entry->text[entry->pos+size]) == 0) size++;    	g_memmove(entry->text + entry->pos, entry->text + entry->pos + size,  	          (entry->text_len-entry->pos-size+1) * sizeof(unichar)); @@ -1188,7 +1188,7 @@ void gui_entry_move_pos(GUI_ENTRY_REC *entry, int pos)    	if (entry->utf8) {  		int step = pos < 0 ? -1 : 1; -		while(mk_wcwidth(entry->text[entry->pos]) == 0 && +		while(i_wcwidth(entry->text[entry->pos]) == 0 &&  		      entry->pos + step >= 0 && entry->pos + step <= entry->text_len)  			entry->pos += step;  	} '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','term-terminfo.c','580','186','2','2','MODIFY','@@ -515,7 +515,7 @@ void term_add_unichar(TERM_WINDOW *window, unichar chr)    	switch (term_type) {  	case TERM_TYPE_UTF8: -	  	term_printed_text(unichar_isprint(chr) ? mk_wcwidth(chr) : 1); +		term_printed_text(unichar_isprint(chr) ? i_wcwidth(chr) : 1);                  term_addch_utf8(window, chr);  		break;  	case TERM_TYPE_BIG5: @@ -558,7 +558,7 @@ int term_addstr(TERM_WINDOW *window, const char *str)  				len++;  				ptr++;  			} else { -				len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1; +				len += unichar_isprint(tmp) ? i_wcwidth(tmp) : 1;  				ptr = g_utf8_next_char(ptr);  			}  		} '),('irssi','1.1.1','0d8632943d8fb526fbd4d853c86294d0037c43f6','dequis','Add a wrapper of wcwidth() that picks the best implementation  This adds a i_wcwidth() function that replaces mk_wcwidth(), and a \'wcwidth_implementation\' setting to pick which one it wraps.  Values:  - old: uses our local mk_wcwidth() which implements unicode 5.0 - system: uses the libc-provided wcwidth(), which may be better or worse   than ours depending on how up to date the system is. - auto: tests the system one against two characters that became   fullwidth in unicode 5.2 and 9.0 respectively. If either of them pass,   pick the system implementation, otherwise pick ours.  It defaults to auto.  mk_wcwidth() is still preferable in some cases, since the way it uses ranges for fullwidth characters means most CJK blocks are covered even if their characters didn\'t exist back then.  The \"system\" implementation is also wrapped to never return -1, but to assume those unknown characters use one cell. Quoting the code:      /* Treat all unknown characters as taking one cell. This is      * the reason mk_wcwidth and other outdated implementations      * mostly worked with newer unicode, while glibc\'s wcwidth      * needs updating to recognize new characters.      *      * Instead of relying on that, we keep the behavior of assuming      * one cell even for glibc\'s implementation, which is still      * highly accurate and less of a headache overall.      */','textbuffer-view.c','1084','269','1','1','MODIFY','@@ -197,7 +197,7 @@ static inline unichar read_unichar(const unsigned char *data, const unsigned cha  		*width = 1;  	} else {  		*next = (unsigned char *)g_utf8_next_char(data); -		*width = unichar_isprint(chr) ? mk_wcwidth(chr) : 1; +		*width = unichar_isprint(chr) ? i_wcwidth(chr) : 1;  	}  	return chr;  } '),('irssi','1.1.1','24f1ed7edb7d8498fdc6ec34e7727bca93fde74d','dequis','irc-cap: Don\'t show warning on CAP LIST response','irc-cap.c','205','53','3','0','MODIFY','@@ -276,6 +276,9 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add  			g_free(val);  		}  	} +	else if (!g_ascii_strcasecmp(evt, \"LIST\")) { +		/* do nothing, fe-cap will handle it */ +	}  	else {  		g_warning(\"Unhandled CAP subcommand %s\", evt);  	} '),('irssi','1.1.1','b95ce3e812b1d7218b6e5cea47084160cce84da7','ailin-nemui','add julia\'s utf8proc wcwidth implementation','configure.ac','783','4','6','1','MODIFY','@@ -326,6 +326,11 @@ PKG_CHECK_MODULES([OPENSSL], [openssl], [  	])  ])   +dnl ** +dnl ** utf8proc +dnl ** +AC_CHECK_LIB([utf8proc], [utf8proc_version]) +  dnl **  dnl ** curses checks  dnl ** @@ -815,7 +820,7 @@ echo \"Building with 64bit DCC support .. : $offt_64bit\"  echo \"Building with true color support.. : $want_truecolor\"  echo \"Building with GRegex ............. : $want_gregex\"  echo \"Building with Capsicum ........... : $want_capsicum\" - +echo \"Building with utf8proc ........... : $ac_cv_lib_utf8proc_utf8proc_version\"  if test \"x$want_otr\" = \"xstatic\"; then  	echo \"Building with OTR support ........ : static (in irssi binary)\"  elif test \"x$want_otr\" = \"xmodule\"; then '),('irssi','1.1.1','b95ce3e812b1d7218b6e5cea47084160cce84da7','ailin-nemui','add julia\'s utf8proc wcwidth implementation','wcwidth-wrapper.c','65','15','18','1','MODIFY','@@ -26,6 +26,10 @@  #include \"settings.h\"  #include \"utf8.h\"   +#ifdef HAVE_LIBUTF8PROC +#include <utf8proc.h> +#endif +  /* wcwidth=2 since unicode 5.2.0 */  #define UNICODE_SQUARE_HIRAGANA_HOKA 0x1F200   @@ -35,7 +39,10 @@  enum {  	WCWIDTH_IMPL_AUTO = 0,  	WCWIDTH_IMPL_OLD, -	WCWIDTH_IMPL_SYSTEM, +	WCWIDTH_IMPL_SYSTEM +#ifdef HAVE_LIBUTF8PROC +	,WCWIDTH_IMPL_JULIA +#endif  };    WCWIDTH_FUNC wcwidth_impl_func = mk_wcwidth; @@ -99,13 +106,23 @@ static void read_settings(void)  	case WCWIDTH_IMPL_SYSTEM:  		wcwidth_impl_func = &system_wcwidth;  		break; + +#ifdef HAVE_LIBUTF8PROC +	case WCWIDTH_IMPL_JULIA: +		wcwidth_impl_func = (WCWIDTH_FUNC) &utf8proc_charwidth; +		break; +#endif  	}    }    void wcwidth_wrapper_init(void)  { +#ifdef HAVE_LIBUTF8PROC +	settings_add_choice(\"misc\", \"wcwidth_implementation\", WCWIDTH_IMPL_AUTO, \"auto;old;system;julia\"); +#else  	settings_add_choice(\"misc\", \"wcwidth_implementation\", WCWIDTH_IMPL_AUTO, \"auto;old;system\"); +#endif    	read_settings();  	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings); '),('irssi','1.1.1','3ef0b9b3d06ae1c004fa1e140042eefe00acb9c0','ailin-nemui','move \"auto\" to default instead','wcwidth-wrapper.c','63','14','14','16','MODIFY','@@ -37,7 +37,6 @@  #define UNICODE_IRSSI_LOGO 0x1F525    enum { -	WCWIDTH_IMPL_AUTO = 0,  	WCWIDTH_IMPL_OLD,  	WCWIDTH_IMPL_SYSTEM  #ifdef HAVE_LIBUTF8PROC @@ -86,19 +85,6 @@ static void read_settings(void)  	choice = newchoice;    	switch (choice) { -	case WCWIDTH_IMPL_AUTO: -		/* Test against characters that have wcwidth=2 -		 * since unicode 5.2 and 9.0 respectively */ - -		if (system_wcwidth(UNICODE_SQUARE_HIRAGANA_HOKA) == 2 || -		    system_wcwidth(UNICODE_IRSSI_LOGO) == 2) { -			wcwidth_impl_func = &system_wcwidth; -		} else { -			/* Fall back to our own (which implements 5.0) */ -			wcwidth_impl_func = &mk_wcwidth; -		} -		break; -  	case WCWIDTH_IMPL_OLD:  		wcwidth_impl_func = &mk_wcwidth;  		break; @@ -118,10 +104,22 @@ static void read_settings(void)    void wcwidth_wrapper_init(void)  { +	int wcwidth_impl_default = 0; +	/* Test against characters that have wcwidth=2 +	 * since unicode 5.2 and 9.0 respectively */ + +	if (system_wcwidth(UNICODE_SQUARE_HIRAGANA_HOKA) == 2 || +	    system_wcwidth(UNICODE_IRSSI_LOGO) == 2) { +		wcwidth_impl_default = WCWIDTH_IMPL_SYSTEM; +	} else { +		/* Fall back to our own (which implements 5.0) */ +		wcwidth_impl_default = WCWIDTH_IMPL_OLD; +	} +  #ifdef HAVE_LIBUTF8PROC -	settings_add_choice(\"misc\", \"wcwidth_implementation\", WCWIDTH_IMPL_AUTO, \"auto;old;system;julia\"); +	settings_add_choice(\"misc\", \"wcwidth_implementation\", wcwidth_impl_default, \"old;system;julia\");  #else -	settings_add_choice(\"misc\", \"wcwidth_implementation\", WCWIDTH_IMPL_AUTO, \"auto;old;system\"); +	settings_add_choice(\"misc\", \"wcwidth_implementation\", wcwidth_impl_default, \"old;system\");  #endif    	read_settings(); '),('irssi','1.1.1','b2a429bfb45c63d6518ff8af5d8861618434bdae','ailin-nemui','update line cache on switching wcwidth implementation','wcwidth-wrapper.c','63','14','1','1','MODIFY','@@ -123,7 +123,7 @@ void wcwidth_wrapper_init(void)  #endif    	read_settings(); -	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings); +	signal_add_first(\"setup changed\", (SIGNAL_FUNC) read_settings);  }    void wcwidth_wrapper_deinit(void) '),('irssi','1.1.1','b2a429bfb45c63d6518ff8af5d8861618434bdae','ailin-nemui','update line cache on switching wcwidth implementation','gui-windows.c','232','54','12','0','MODIFY','@@ -31,6 +31,7 @@  #include \"gui-printtext.h\"    static int window_create_override; +int wcwidth_impl;    static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,  				       MAIN_WINDOW_REC *parent) @@ -51,6 +52,7 @@ static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,  					   !settings_get_bool(\"indent_always\"),  					   get_default_indent_func());  	textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\")); +	wcwidth_impl = settings_get_choice(\"wcwidth_implementation\");  	textbuffer_view_set_hidden_level(gui->view, MSGLEVEL_HIDDEN);  	if (parent->active == window)  		textbuffer_view_set_window(gui->view, parent->screen_win); @@ -202,11 +204,17 @@ void gui_window_reparent(WINDOW_REC *window, MAIN_WINDOW_REC *parent)  void gui_windows_reset_settings(void)  {  	GSList *tmp; +	int old_wcwidth_impl = wcwidth_impl; +	wcwidth_impl  = settings_get_choice(\"wcwidth_implementation\");    	for (tmp = windows; tmp != NULL; tmp = tmp->next) {  		WINDOW_REC *rec = tmp->data;  		GUI_WINDOW_REC *gui = WINDOW_GUI(rec);   +		if (old_wcwidth_impl != wcwidth_impl) { +			textbuffer_view_reset_cache(gui->view); +		} +  		textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));    		textbuffer_view_set_default_indent(gui->view, @@ -217,6 +225,10 @@ void gui_windows_reset_settings(void)  		textbuffer_view_set_scroll(gui->view,  					   gui->use_scroll ? gui->scroll :  					   settings_get_bool(\"scroll\")); + +		if (old_wcwidth_impl != wcwidth_impl) { +			textbuffer_view_redraw(gui->view); +		}  	}  }   '),('irssi','1.1.1','b2a429bfb45c63d6518ff8af5d8861618434bdae','ailin-nemui','update line cache on switching wcwidth implementation','textbuffer-view.c','1084','269','4','4','MODIFY','@@ -374,7 +374,7 @@ static void view_update_cache(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,  		view->cache->last_linecount = view_get_linecount(view, line);  }   -static void view_reset_cache(TEXT_BUFFER_VIEW_REC *view) +void textbuffer_view_reset_cache(TEXT_BUFFER_VIEW_REC *view)  {  	GSList *tmp;   @@ -691,7 +691,7 @@ void textbuffer_view_set_break_wide(TEXT_BUFFER_VIEW_REC *view,  {  	if (view->break_wide != break_wide) {  		view->break_wide = break_wide; -		view_reset_cache(view); +		textbuffer_view_reset_cache(view);  	}  }   @@ -703,7 +703,7 @@ static void view_unregister_indent_func(TEXT_BUFFER_VIEW_REC *view,    	/* recreate cache so it won\'t contain references  	   to the indent function */ -	view_reset_cache(view); +	textbuffer_view_reset_cache(view);  	view->cache = textbuffer_cache_get(view->siblings, view->width);  }   @@ -1314,7 +1314,7 @@ void textbuffer_view_remove_all_lines(TEXT_BUFFER_VIEW_REC *view)  	g_hash_table_foreach_remove(view->bookmarks,  				    (GHRFunc) g_free_true, NULL);   -	view_reset_cache(view); +	textbuffer_view_reset_cache(view);  	textbuffer_view_clear(view);  	g_slist_foreach(view->siblings, (GFunc) textbuffer_view_clear, NULL);  } '),('irssi','1.1.1','b2a429bfb45c63d6518ff8af5d8861618434bdae','ailin-nemui','update line cache on switching wcwidth implementation','textbuffer-view.h','85','0','2','0','MODIFY','@@ -129,6 +129,8 @@ void textbuffer_view_scroll_line(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line);  /* Return line cache */  LINE_CACHE_REC *textbuffer_view_get_line_cache(TEXT_BUFFER_VIEW_REC *view,  					       LINE_REC *line); +/* Reset the whole line cache */ +void textbuffer_view_reset_cache(TEXT_BUFFER_VIEW_REC *view);    /*     Functions for manipulating the text buffer, using these commands update '),('irssi','1.1.1','610ab2dafac4668732733009b079ebcf585dee9f','coypu@sdf.org','Use-after-frees  Hi folks!  I tried clang-static-analyzer on irssi 1.1.1, it seems like it finds some things. Here\'s a diff, but there might be more that you would want to check, or choose to work differently.  (in special-vars.c, ret is commands->data sometime)  I hope it\'s not too much trouble if reported as a confidential bug. Thanks.','modules.c','206','41','2','1','MODIFY','@@ -289,8 +289,9 @@ void modules_deinit(void)    	while (list != NULL) {  		module_uniq_destroy(list->data); -		g_free(list->data); +		gconstpointer tmp = list->data;  		list = g_slist_remove(list, list->data); +		g_free(tmp);  	}    	g_hash_table_destroy(idlookup); '),('irssi','1.1.1','610ab2dafac4668732733009b079ebcf585dee9f','coypu@sdf.org','Use-after-frees  Hi folks!  I tried clang-static-analyzer on irssi 1.1.1, it seems like it finds some things. Here\'s a diff, but there might be more that you would want to check, or choose to work differently.  (in special-vars.c, ret is commands->data sometime)  I hope it\'s not too much trouble if reported as a confidential bug. Thanks.','rawlog.c','181','41','2','1','MODIFY','@@ -64,9 +64,10 @@ static void rawlog_add(RAWLOG_REC *rawlog, char *str)  	if (rawlog->nlines < rawlog_lines || rawlog_lines <= 2)  		rawlog->nlines++;  	else { -		g_free(rawlog->lines->data); +		gconstpointer tmp = rawlog->lines->data;  		rawlog->lines = g_slist_remove(rawlog->lines,  					       rawlog->lines->data); +		g_free(tmp);  	}    	if (rawlog->logging) { '),('irssi','1.1.1','610ab2dafac4668732733009b079ebcf585dee9f','coypu@sdf.org','Use-after-frees  Hi folks!  I tried clang-static-analyzer on irssi 1.1.1, it seems like it finds some things. Here\'s a diff, but there might be more that you would want to check, or choose to work differently.  (in special-vars.c, ret is commands->data sometime)  I hope it\'s not too much trouble if reported as a confidential bug. Thanks.','special-vars.c','547','163','1','1','MODIFY','@@ -620,8 +620,8 @@ void eval_special_string(const char *cmd, const char *data,  		/* FIXME: window item would need reference counting as well,  		   eg. \"/EVAL win close;say hello\" wouldn\'t work now.. */   -		g_free(ret);  		commands = g_slist_remove(commands, commands->data); +		g_free(ret);  	}  	g_free(orig);  } '),('irssi','1.1.1','610ab2dafac4668732733009b079ebcf585dee9f','coypu@sdf.org','Use-after-frees  Hi folks!  I tried clang-static-analyzer on irssi 1.1.1, it seems like it finds some things. Here\'s a diff, but there might be more that you would want to check, or choose to work differently.  (in special-vars.c, ret is commands->data sometime)  I hope it\'s not too much trouble if reported as a confidential bug. Thanks.','themes.c','1147','282','2','1','MODIFY','@@ -1424,8 +1424,9 @@ void themes_reload(void)  	change_theme(settings_get_str(\"theme\"), FALSE);    	while (refs != NULL) { -		theme_unref(refs->data); +		gconstpointer tmp = refs->data;  		refs = g_slist_remove(refs, refs->data); +		theme_unref(tmp);  	}  }   '),('irssi','1.1.1','610ab2dafac4668732733009b079ebcf585dee9f','coypu@sdf.org','Use-after-frees  Hi folks!  I tried clang-static-analyzer on irssi 1.1.1, it seems like it finds some things. Here\'s a diff, but there might be more that you would want to check, or choose to work differently.  (in special-vars.c, ret is commands->data sometime)  I hope it\'s not too much trouble if reported as a confidential bug. Thanks.','dcc.c','430','109','1','1','MODIFY','@@ -57,8 +57,8 @@ void dcc_unregister_type(const char *type)    	pos = gslist_find_string(dcc_types, type);  	if (pos != NULL) { -		g_free(pos->data);                  dcc_types = g_slist_remove(dcc_types, pos->data); +		g_free(pos->data);  	}  }   '),('irssi','1.1.1','071ada830bd77055107220a420c96b41702f8cc2','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 16 +#define IRSSI_ABI_VERSION 17    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.1.1','9dd836b87663929ae540b6b3c724c53b24e512ba','dequis','Fix \"discards â€˜constâ€™ qualifier\" warnings','modules.c','206','41','1','1','MODIFY','@@ -289,7 +289,7 @@ void modules_deinit(void)    	while (list != NULL) {  		module_uniq_destroy(list->data); -		gconstpointer tmp = list->data; +		void *tmp = list->data;  		list = g_slist_remove(list, list->data);  		g_free(tmp);  	} '),('irssi','1.1.1','9dd836b87663929ae540b6b3c724c53b24e512ba','dequis','Fix \"discards â€˜constâ€™ qualifier\" warnings','rawlog.c','181','41','1','1','MODIFY','@@ -64,7 +64,7 @@ static void rawlog_add(RAWLOG_REC *rawlog, char *str)  	if (rawlog->nlines < rawlog_lines || rawlog_lines <= 2)  		rawlog->nlines++;  	else { -		gconstpointer tmp = rawlog->lines->data; +		void *tmp = rawlog->lines->data;  		rawlog->lines = g_slist_remove(rawlog->lines,  					       rawlog->lines->data);  		g_free(tmp); '),('irssi','1.1.1','9dd836b87663929ae540b6b3c724c53b24e512ba','dequis','Fix \"discards â€˜constâ€™ qualifier\" warnings','themes.c','1147','282','1','1','MODIFY','@@ -1424,7 +1424,7 @@ void themes_reload(void)  	change_theme(settings_get_str(\"theme\"), FALSE);    	while (refs != NULL) { -		gconstpointer tmp = refs->data; +		void *tmp = refs->data;  		refs = g_slist_remove(refs, refs->data);  		theme_unref(tmp);  	} '),('irssi','1.1.1','ade2f87fe599773886a044b7c29a482622dfaea4','dequis','Fix use after free introduced by the use after free patch','dcc.c','431','109','3','2','MODIFY','@@ -57,8 +57,9 @@ void dcc_unregister_type(const char *type)    	pos = gslist_find_string(dcc_types, type);  	if (pos != NULL) { -                dcc_types = g_slist_remove(dcc_types, pos->data); -		g_free(pos->data); +		void *tmp = pos->data; +		dcc_types = g_slist_remove(dcc_types, pos->data); +		g_free(tmp);  	}  }   '),('irssi','1.1.1','e450a7f8c1c74132625d0a884f0ca851abd69197','dequis','modules_deinit: Fix -Werror=declaration-after-statement','modules.c','206','41','1','1','MODIFY','@@ -288,8 +288,8 @@ void modules_deinit(void)  	g_hash_table_foreach(stridlookup, (GHFunc) uniq_get_modules, &list);    	while (list != NULL) { -		module_uniq_destroy(list->data);  		void *tmp = list->data; +		module_uniq_destroy(list->data);  		list = g_slist_remove(list, list->data);  		g_free(tmp);  	} '),('irssi','1.1.1','92804cb1aa753fa1f5e9b588a4bd7125bc98ce49','dequis','gui-windows: make the wcwidth_impl global var into static','gui-windows.c','232','54','3','2','MODIFY','@@ -31,7 +31,7 @@  #include \"gui-printtext.h\"    static int window_create_override; -int wcwidth_impl; +static int wcwidth_impl;    static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,  				       MAIN_WINDOW_REC *parent) @@ -205,7 +205,8 @@ void gui_windows_reset_settings(void)  {  	GSList *tmp;  	int old_wcwidth_impl = wcwidth_impl; -	wcwidth_impl  = settings_get_choice(\"wcwidth_implementation\"); + +	wcwidth_impl = settings_get_choice(\"wcwidth_implementation\");    	for (tmp = windows; tmp != NULL; tmp = tmp->next) {  		WINDOW_REC *rec = tmp->data; '),('irssi','1.1.1','7b70d051da10e6ea54cc118e8f7f254ddd07f6c1','dequis','wcwidth-wrapper: avoid cast with a tiny wrapper, julia_wcwidth()','wcwidth-wrapper.c','67','15','10','1','MODIFY','@@ -71,6 +71,15 @@ static int system_wcwidth(unichar ucs)  	return retval;  }   +#ifdef HAVE_LIBUTF8PROC +/* wrapper because the function signatures are different + * (the parameter is unsigned for us, signed for them) */ +static int julia_wcwidth(unichar ucs) +{ +	return utf8proc_charwidth(ucs); +} +#endif +  static void read_settings(void)  {  	static int choice = -1; @@ -95,7 +104,7 @@ static void read_settings(void)    #ifdef HAVE_LIBUTF8PROC  	case WCWIDTH_IMPL_JULIA: -		wcwidth_impl_func = (WCWIDTH_FUNC) &utf8proc_charwidth; +		wcwidth_impl_func = &julia_wcwidth;  		break;  #endif  	} '),('irssi','1.1.1','bbca1a5a0fa59567fc3082263dc5e9b087e02da6','Will Storey','Revert \"Revert \"Flag topic as unset if it is zero length\"\"  This reverts commit 817179a7606b616795cf67e24505526dded34381.','.gitignore','57','0','1','0','MODIFY','@@ -59,6 +59,7 @@ tests/irc/core/test-irc.trs  *.la  *.lo  *.o +*.swp  *~    *.tar.bz2 '),('irssi','1.1.1','bbca1a5a0fa59567fc3082263dc5e9b087e02da6','Will Storey','Revert \"Revert \"Flag topic as unset if it is zero length\"\"  This reverts commit 817179a7606b616795cf67e24505526dded34381.','channel-events.c','276','68','12','10','MODIFY','@@ -126,23 +126,25 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,    	chanrec = channel_find(SERVER(server), channel);  	if (chanrec == NULL) return; -	/* the topic may be send out encoded, so we need to + +	g_free_and_null(chanrec->topic); +	g_free_and_null(chanrec->topic_by); +	chanrec->topic_time = 0; + +	/* the topic may be sent out encoded, so we need to  	   recode it back or /topic <tab> will not work properly */  	recoded = recode_in(SERVER(server), topic, channel); -	if (topic != NULL) { -		g_free_not_null(chanrec->topic); -		chanrec->topic = recoded == NULL ? NULL : g_strdup(recoded); +	if (recoded == NULL || *recoded == \'\\0\') { +		signal_emit(\"channel topic changed\", 1, chanrec); +		g_free(recoded); +		return;  	} -	g_free(recoded);   -	g_free_not_null(chanrec->topic_by); +	chanrec->topic = recoded;  	chanrec->topic_by = g_strdup(setby); - -	if (chanrec->topic_by == NULL) { +	if (chanrec->topic_by != NULL) {  		/* ensure invariant topic_time > 0 <=> topic_by != NULL.  		   this could be triggered by a topic command without sender */ -		chanrec->topic_time = 0; -	} else {  		chanrec->topic_time = settime;  	}   '),('irssi','1.1.1','04db359a6d0f6d8630c2439fb26b7420ecc48582','Will Storey','Handle topic info numeric separately from topic & topic numeric  As we called the same function for the topic info numeric, we ended up losing the topic as that numeric does not include it. We now call a different function to handle this case more carefully. Fixes #903.','channel-events.c','294','71','28','3','MODIFY','@@ -28,6 +28,9 @@  #include \"irc-servers.h\"  #include \"irc-channels.h\"   +static void set_topic_info(CHANNEL_REC *const, char const *const, +		time_t const); +  static void check_join_failure(IRC_SERVER_REC *server, const char *channel)  {  	CHANNEL_REC *chanrec; @@ -141,14 +144,36 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,  	}    	chanrec->topic = recoded; +	set_topic_info(chanrec, setby, settime); + +	signal_emit(\"channel topic changed\", 1, chanrec); +} + +static void channel_change_topic_info(IRC_SERVER_REC *server, +				 const char *channel, const char *setby, time_t settime) +{ +	CHANNEL_REC *chanrec; + +	chanrec = channel_find(SERVER(server), channel); +	if (chanrec == NULL) return; + +	g_free_and_null(chanrec->topic_by); +	chanrec->topic_time = 0; + +	set_topic_info(chanrec, setby, settime); + +	signal_emit(\"channel topic changed\", 1, chanrec); +} + +static void set_topic_info(CHANNEL_REC *const chanrec, char const *const setby, +		time_t const settime) +{  	chanrec->topic_by = g_strdup(setby);  	if (chanrec->topic_by != NULL) {  		/* ensure invariant topic_time > 0 <=> topic_by != NULL.  		   this could be triggered by a topic command without sender */  		chanrec->topic_time = settime;  	} - -	signal_emit(\"channel topic changed\", 1, chanrec);  }    static void event_topic_get(IRC_SERVER_REC *server, const char *data) @@ -188,7 +213,7 @@ static void event_topic_info(IRC_SERVER_REC *server, const char *data)  				  &topicby, &topictime);    	t = (time_t) atol(topictime); -	channel_change_topic(server, channel, NULL, topicby, t); +	channel_change_topic_info(server, channel, topicby, t);  	g_free(params);  }   '),('irssi','1.1.1','2d6033542e0e47072d61ef442430c3014e3b430f','Will Storey','Add functions to override irssi dir and config  Setting up to test is easier this way.','core.c','232','28','10','0','MODIFY','@@ -73,12 +73,22 @@ const char *get_irssi_dir(void)          return irssi_dir;  }   +void set_irssi_dir(char *const s) +{ +	irssi_dir = s; +} +  /* return full path for ~/.irssi/config */  const char *get_irssi_config(void)  {          return irssi_config_file;  }   +void set_irssi_config(char *const s) +{ +	irssi_config_file = s; +} +  static void sig_reload_config(int signo)  {          reload_config = TRUE; '),('irssi','1.1.1','2d6033542e0e47072d61ef442430c3014e3b430f','Will Storey','Add functions to override irssi dir and config  Setting up to test is easier this way.','core.h','11','0','3','0','MODIFY','@@ -16,6 +16,9 @@ extern int irssi_init_finished; /* TRUE after \"irssi init finished\" signal is se  extern int reload_config; /* TRUE after received SIGHUP. */  extern time_t client_start_time;   +void set_irssi_dir(char *const); +void set_irssi_config(char *const); +  void core_preinit(const char *path);    void core_register_options(void); '),('irssi','1.1.1','2ccb312b8b56db9585a4801184c064bfd3e3ff90','Will Storey','Expose functions for testing','Makefile.am','58','0','1','0','MODIFY','@@ -40,6 +40,7 @@ pkginc_irc_coredir=$(pkgincludedir)/src/irc/core  pkginc_irc_core_HEADERS = \\  	bans.h \\          ctcp.h \\ +	channel-events.h \\          channel-rejoin.h \\          irc.h \\          irc-channels.h \\ '),('irssi','1.1.1','2ccb312b8b56db9585a4801184c064bfd3e3ff90','Will Storey','Expose functions for testing','channel-events.c','295','71','4','3','MODIFY','@@ -21,6 +21,7 @@  #include \"module.h\"  #include \"signals.h\"  #include \"misc.h\" +#include \"channel-events.h\"  #include \"channels-setup.h\"  #include \"settings.h\"  #include \"recode.h\" @@ -176,7 +177,7 @@ static void set_topic_info(CHANNEL_REC *const chanrec, char const *const setby,  	}  }   -static void event_topic_get(IRC_SERVER_REC *server, const char *data) +void event_topic_get(IRC_SERVER_REC *server, const char *data)  {  	char *params, *channel, *topic;   @@ -187,7 +188,7 @@ static void event_topic_get(IRC_SERVER_REC *server, const char *data)  	g_free(params);  }   -static void event_topic(IRC_SERVER_REC *server, const char *data, +void event_topic(IRC_SERVER_REC *server, const char *data,  			const char *nick, const char *addr)  {  	char *params, *channel, *topic, *mask; @@ -202,7 +203,7 @@ static void event_topic(IRC_SERVER_REC *server, const char *data,  	g_free(params);  }   -static void event_topic_info(IRC_SERVER_REC *server, const char *data) +void event_topic_info(IRC_SERVER_REC *server, const char *data)  {  	char *params, *channel, *topicby, *topictime;  	time_t t; '),('irssi','1.1.1','2ccb312b8b56db9585a4801184c064bfd3e3ff90','Will Storey','Expose functions for testing','channel-events.h','5','0','12','0','ADD','@@ -0,0 +1,12 @@ +#ifndef __CHANNEL_EVENTS_H +#define __CHANNEL_EVENTS_H + +#include \"irc.h\" + +/* Not private for tests. */ +void event_topic_get(IRC_SERVER_REC *, const char *); +void event_topic(IRC_SERVER_REC *, const char *, +			const char *, const char *); +void event_topic_info(IRC_SERVER_REC *, const char *); + +#endif '),('irssi','1.1.1','6f38d67d87f2ef443172cca4d9ee82300d9f5ca4','Will Storey','Add tests for channel change events','Makefile.am','23','0','7','4','MODIFY','@@ -8,21 +8,24 @@ AM_CPPFLAGS = \\  	-DSYSCONFDIR=\\\"\"$(sysconfdir)\"\\\" \\  	$(GLIB_CFLAGS)   -test_programs = test-irc +test_programs = test-channel-events test-irc   -test_irc_CPPFLAGS = \\ +CPPFLAGS = \\  	-I$(top_srcdir)/src/irc/core \\  	$(AM_CPPFLAGS)   -test_irc_DEPENDENCIES = \\ +DEPENDENCIES = \\  	../../../src/core/libcore.a \\  	../../../src/lib-config/libirssi_config.a   -test_irc_LDADD = \\ +LDADD = \\  	../../../src/irc/core/libirc_core.a \\  	../../../src/core/libcore.a \\  	../../../src/lib-config/libirssi_config.a \\  	@PROG_LIBS@   +test_channel_events_SOURCES = \\ +	test-channel-events.c +  test_irc_SOURCES = \\  	test-irc.c '),('irssi','1.1.1','6f38d67d87f2ef443172cca4d9ee82300d9f5ca4','Will Storey','Add tests for channel change events','test-channel-events.c','142','10','202','0','ADD','@@ -0,0 +1,202 @@ +/* + test-irc.c : irssi + +    Copyright (C) 2018 Will Storey + +    This program is free software; you can redistribute it and/or modify +    it under the terms of the GNU General Public License as published by +    the Free Software Foundation; either version 2 of the License, or +    (at your option) any later version. + +    This program is distributed in the hope that it will be useful, +    but WITHOUT ANY WARRANTY; without even the implied warranty of +    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the +    GNU General Public License for more details. + +    You should have received a copy of the GNU General Public License along +    with this program; if not, write to the Free Software Foundation, Inc., +    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. +*/ + +#include <glib.h> + +#include <channel-events.h> +#include <common.h> +#include <core.h> +#include <irc.h> +#include <irc-channels.h> +#include <irc-servers.h> +#include <modules.h> +#include <recode.h> +#include <settings.h> +#include <signals.h> +#include <time.h> + +#define MODULE_NAME \"test-channel-events\" + +typedef struct { +	char const *const description; +	char const *const input; +	char const *const topic; +	char const *const topic_by; +	time_t const topic_time; +} topic_test_case; + +static void test_event_topic_get(topic_test_case const *const); +static void test_event_topic(topic_test_case const *const); +static void test_event_topic_info(topic_test_case const *const); +static void setup(void); +static void teardown(void); + +static IRC_SERVER_REC *server; +static CHANNEL_REC *channel; + +topic_test_case const event_topic_get_test_cases[] = { +	{ +		.description = \"Normal 332 message with a topic with multiple words\", +		.input       = \"testnick #test :new topic\", +		.topic       = \"new topic\", +		.topic_by    = NULL, +		.topic_time  = 0, +	}, +}; + +topic_test_case const event_topic_info_test_cases[] = { +	{ +		.description = \"Normal 333 message\", +		.input       = \"testnick #test newnick!user@example.com 1533866229\", +		.topic       = \"initial topic\", +		.topic_by    = \"newnick!user@example.com\", +		.topic_time  = 1533866229, +	}, +}; + +topic_test_case const event_topic_test_cases[] = { +	{ +		.description = \"Normal TOPIC message\", +		.input       = \"#test :new topic\", +		.topic       = \"new topic\", +		.topic_by    = \"newnick!user@example.com\", +		.topic_time  = 0, /* Dynamic */ +	}, +}; + +int main(int argc, char **argv) +{ +	int i, res; + +	g_test_init(&argc, &argv, NULL); + +	modules_init(); +	signals_init(); +	set_irssi_dir(\"/tmp/irssi\"); +	set_irssi_config(\"/tmp/irssi/config\"); +	settings_init(); +	recode_init(); + +	settings_add_str(\"lookandfeel\", \"term_charset\", \"UTF-8\"); +	recode_update_charset(); + +	for (i = 0; i < G_N_ELEMENTS(event_topic_get_test_cases); i++) { +		char *const name = g_strdup_printf(\"/test/event_topic_get/%d\", i); +		g_test_add_data_func(name, &event_topic_get_test_cases[i], +				(GTestDataFunc)test_event_topic_get); +		g_free(name); +	} + +	for (i = 0; i < G_N_ELEMENTS(event_topic_test_cases); i++) { +		char *const name = g_strdup_printf(\"/test/event_topic/%d\", i); +		g_test_add_data_func(name, &event_topic_test_cases[i], +				(GTestDataFunc)test_event_topic); +		g_free(name); +	} + +	for (i = 0; i < G_N_ELEMENTS(event_topic_info_test_cases); i++) { +		char *const name = g_strdup_printf(\"/test/event_topic_info/%d\", i); +		g_test_add_data_func(name, &event_topic_info_test_cases[i], +				(GTestDataFunc)test_event_topic_info); +		g_free(name); +	} + +#if GLIB_CHECK_VERSION(2,38,0) +	g_test_set_nonfatal_assertions(); +#endif +	res = g_test_run(); + +	recode_deinit(); +	settings_deinit(); +	signals_deinit(); +	modules_deinit(); + +	return res; +} + +static void test_event_topic_get(topic_test_case const *const test) +{ +	setup(); + +	event_topic_get(server, test->input); + +	g_assert_cmpstr(channel->topic,      ==, test->topic); +	g_assert_cmpstr(channel->topic_by,   ==, test->topic_by); +	g_assert_cmpint(channel->topic_time, ==, test->topic_time); + +	teardown(); +} + +static void test_event_topic(topic_test_case const *const test) +{ +	time_t now; + +	setup(); + +	now = time(NULL); +	event_topic(server, test->input, \"newnick\", \"user@example.com\"); + +	g_assert_cmpstr(channel->topic,      ==, test->topic); +	g_assert_cmpstr(channel->topic_by,   ==, test->topic_by); +	g_assert_cmpint(channel->topic_time, >=, now); + +	teardown(); +} + +static void test_event_topic_info(topic_test_case const *const test) +{ +	setup(); + +	event_topic_info(server, test->input); + +	g_assert_cmpstr(channel->topic,      ==, test->topic); +	g_assert_cmpstr(channel->topic_by,   ==, test->topic_by); +	g_assert_cmpint(channel->topic_time, ==, test->topic_time); + +	teardown(); +} + +static void setup(void) +{ +	server = g_new0(IRC_SERVER_REC, 1); +	MODULE_DATA_INIT(server); +	server->type = module_get_uniq_id(\"SERVER\", 0); + +	channel = g_new0(CHANNEL_REC, 1); +	channel->name = \"#test\"; +	server->channels = g_slist_append(server->channels, channel); + +	g_assert_nonnull(channel_find(SERVER(server), \"#test\")); + +	channel->topic = g_strdup(\"initial topic\"); +	channel->topic_by = g_strdup(\"initialnick!user@example.com\"); +	channel->topic_time = 123; +} + +static void teardown(void) +{ +	g_slist_free(server->channels); +	MODULE_DATA_DEINIT(server); +	g_free(server); + +	g_free(channel->topic); +	g_free(channel->topic_by); +	g_free(channel); +} '),('irssi','1.1.1','0edb64c4dc731065705f3303307f20b3ccb5674a','Will Storey','Add test files to .gitignore','.gitignore','72','0','17','2','MODIFY','@@ -51,8 +51,23 @@ src/perl/*/Makefile.old  src/fe-fuzz/crash-*  src/fe-fuzz/oom-*   -tests/irc/core/test-irc -tests/irc/core/test-irc.trs +/core +/tests/fe-common/core/test-formats +/tests/fe-common/core/test-formats.log +/tests/fe-common/core/test-formats.trs +/tests/fe-common/core/test-suite.log +/tests/irc/core/core +/tests/irc/core/test-channel-events +/tests/irc/core/test-channel-events.log +/tests/irc/core/test-channel-events.trs +/tests/irc/core/test-irc +/tests/irc/core/test-irc.log +/tests/irc/core/test-irc.trs +/tests/irc/core/test-suite.log +/tests/irc/flood/test-796 +/tests/irc/flood/test-796.log +/tests/irc/flood/test-796.trs +/tests/irc/flood/test-suite.log    *.a  *.bs '),('irssi','1.1.1','b11932d24f01703d07eb0f7a0de6c226ebcde195','Will Storey','Make channel event functions static again','channel-events.c','295','71','3','3','MODIFY','@@ -177,7 +177,7 @@ static void set_topic_info(CHANNEL_REC *const chanrec, char const *const setby,  	}  }   -void event_topic_get(IRC_SERVER_REC *server, const char *data) +static void event_topic_get(IRC_SERVER_REC *server, const char *data)  {  	char *params, *channel, *topic;   @@ -188,7 +188,7 @@ void event_topic_get(IRC_SERVER_REC *server, const char *data)  	g_free(params);  }   -void event_topic(IRC_SERVER_REC *server, const char *data, +static void event_topic(IRC_SERVER_REC *server, const char *data,  			const char *nick, const char *addr)  {  	char *params, *channel, *topic, *mask; @@ -203,7 +203,7 @@ void event_topic(IRC_SERVER_REC *server, const char *data,  	g_free(params);  }   -void event_topic_info(IRC_SERVER_REC *server, const char *data) +static void event_topic_info(IRC_SERVER_REC *server, const char *data)  {  	char *params, *channel, *topicby, *topictime;  	time_t t; '),('irssi','1.1.1','b11932d24f01703d07eb0f7a0de6c226ebcde195','Will Storey','Make channel event functions static again','channel-events.h','3','0','2','5','MODIFY','@@ -3,10 +3,7 @@    #include \"irc.h\"   -/* Not private for tests. */ -void event_topic_get(IRC_SERVER_REC *, const char *); -void event_topic(IRC_SERVER_REC *, const char *, -			const char *, const char *); -void event_topic_info(IRC_SERVER_REC *, const char *); +void channel_events_init(void); +void channel_events_deinit(void);    #endif '),('irssi','1.1.1','7b09cac9ec0ce7e549ae8fecf4db8b8d811c18b1','Will Storey','Call functions via signals rather than directly  This allows us to leave functions static.','test-channel-events.c','145','10','6','3','MODIFY','@@ -93,6 +93,7 @@ int main(int argc, char **argv)  	set_irssi_config(\"/tmp/irssi/config\");  	settings_init();  	recode_init(); +	channel_events_init();    	settings_add_str(\"lookandfeel\", \"term_charset\", \"UTF-8\");  	recode_update_charset(); @@ -123,6 +124,7 @@ int main(int argc, char **argv)  #endif  	res = g_test_run();   +	channel_events_deinit();  	recode_deinit();  	settings_deinit();  	signals_deinit(); @@ -135,7 +137,7 @@ static void test_event_topic_get(topic_test_case const *const test)  {  	setup();   -	event_topic_get(server, test->input); +	signal_emit(\"event 332\", 2, server, test->input);    	g_assert_cmpstr(channel->topic,      ==, test->topic);  	g_assert_cmpstr(channel->topic_by,   ==, test->topic_by); @@ -151,7 +153,8 @@ static void test_event_topic(topic_test_case const *const test)  	setup();    	now = time(NULL); -	event_topic(server, test->input, \"newnick\", \"user@example.com\"); +	signal_emit(\"event topic\", 4, server, test->input, \"newnick\", +			\"user@example.com\");    	g_assert_cmpstr(channel->topic,      ==, test->topic);  	g_assert_cmpstr(channel->topic_by,   ==, test->topic_by); @@ -164,7 +167,7 @@ static void test_event_topic_info(topic_test_case const *const test)  {  	setup();   -	event_topic_info(server, test->input); +	signal_emit(\"event 333\", 2, server, test->input);    	g_assert_cmpstr(channel->topic,      ==, test->topic);  	g_assert_cmpstr(channel->topic_by,   ==, test->topic_by); '),('irssi','1.1.1','82702de047237550d1299cb9b7461a952e6cc74d','ailin-nemui','Add information about crash on unload to perl.txt  reported by urchlay: http://urchlay.naptime.net/repos/misc-scripts/tree/selfunload.pl','perl.txt','1062','0','1','0','MODIFY','@@ -1192,6 +1192,7 @@ Client->{}   Bugs and Limitations   --------------------  * Calling die in \'script error\' handler causes segfault (#101) +* Calling \"script unload\" from your own script causes segfault  * Storing and later using any Irssi object may result in use-after-free related crash    - Workaround: always acquire fresh objects  * Calling $dcc->close from the \"dcc created\" signal will cause unstable behaviour and crashes (#386) '),('irssi','1.1.1','3351c54a2f8ac2add41ba7ce829c215a65d3c923','dequis','Fix /save not working if the config didn\'t previously exist  realpath() was supposed to resolve symlinks but it also fails with ENOENT (no such file or directory) if the file just isn\'t there.','write.c','277','86','13','4','MODIFY','@@ -302,6 +302,7 @@ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)  	int ret;  	int fd;  	int save_errno; +	const char *base_name;  	char *tmp_name = NULL;  	char *dest_name = NULL;   @@ -309,12 +310,20 @@ int config_write(CONFIG_REC *rec, const char *fname, int create_mode)          g_return_val_if_fail(fname != NULL || rec->fname != NULL, -1);          g_return_val_if_fail(create_mode != -1 || rec->create_mode != -1, -1);   +	base_name = fname != NULL ? fname : rec->fname; +  	/* expand all symlinks; else we may replace a symlink with a regular file */ -	dest_name = realpath(fname != NULL ? fname : rec->fname, NULL); +	dest_name = realpath(base_name, NULL); +  	if (dest_name == NULL) { -		config_error(rec, g_strerror(errno)); -		ret = -1; -		goto out; +		if (errno == ENOENT) { +			dest_name = g_strdup(base_name); +			errno = 0; +		} else { +			config_error(rec, g_strerror(errno)); +			ret = -1; +			goto out; +		}  	}    	tmp_name = g_strdup_printf(\"%s.XXXXXX\", dest_name); '),('irssi','1.1.1','e2e27d1809684a6745d7b449561aeb5f30a42a74','dequis','Improve error message when failing to create the config dir','settings.c','694','161','2','1','MODIFY','@@ -762,7 +762,8 @@ static void init_configfile(void)  	if (stat(get_irssi_dir(), &statbuf) != 0) {  		/* ~/.irssi not found, create it. */  		if (g_mkdir_with_parents(get_irssi_dir(), 0700) != 0) { -			g_error(\"Couldn\'t create %s directory\", get_irssi_dir()); +			g_error(\"Couldn\'t create %s directory: %s\", +			        get_irssi_dir(), g_strerror(errno));  		}  	} else if (!S_ISDIR(statbuf.st_mode)) {  		g_error(\"%s is not a directory.\\n\" '),('irssi','1.1.1','04497ed69d35cf44b0700437bf427f48dbc42871','Dominyk Tiller','configure: fix Perl detection on macOS Mojave  Apple has significantly changed the way `perl` is structured in macOS Mojave/10.14, which is due to ship stable this month. The `perl` restructuring has been an issue for a while but I recently obtained confirmation from Apple the changes were intentional & consequently not something that was going to be walked back before Mojave reaches its stable release.  As of 10.14 the Perl headers are moving inside the SDK, instead of residing in `/System` directly. There\'s a flag to tell Clang to look inside the SDK without projects having to explicitly locate the SDK & fiddle with the location themselves, which is `-iwithsysroot`, and that\'s what `perl` outputs now when `configure` checks `perl -MExtUtils::Embed -e ccopts`:  ```   -g -pipe -fno-common -DPERL_DARWIN -fno-strict-aliasing -fstack-protector  -iwithsysroot /System/Library/Perl/5.18/darwin-thread-multi-2level/CORE ```  The latter bit of that was previously `-I/System/Library/Perl/5.18/darwin-thread-multi-2level/CORE`. The problem here is that `configure` filters out flags that start with a lowercase `i` and consequently the Perl elements fail to build. This tiny patch fixes that issue, restoring Perl support to `irssi` when built on macOS 10.14.','configure.ac','779','4','2','2','MODIFY','@@ -388,8 +388,8 @@ if test \"$want_perl\" != \"no\"; then  		dnl * fix those command line options a bit so GCC won\'t  		dnl * complain about them. Normally there\'s only few options  		dnl * that we want to keep: -		dnl * -Ddefine -Uundef -I/path -fopt -mopt -		PERL_CFLAGS=`echo $PERL_CFLAGS | $perlpath -pe \'s/^(.* )?-@<:@^DUIfm@:>@@<:@^ @:>@+/\\1/g; s/^(.* )?\\+@<:@^ @:>@+/\\1/g\'` +		dnl * -Ddefine -Uundef -I/path -fopt -mopt -iwithsysroot +		PERL_CFLAGS=`echo $PERL_CFLAGS | $perlpath -pe \'s/^(.* )?-@<:@^DUIifm@:>@@<:@^ @:>@+/\\1/g; s/^(.* )?\\+@<:@^ @:>@+/\\1/g\'`    		PERL_EXTRA_OPTS=\"CCCDLFLAGS=\\\"-fPIC\\\"\"  		AC_SUBST(PERL_EXTRA_OPTS) '),('irssi','1.1.1','329448939ba8f9cc9803d4b3045d517b0ab0f9aa','ailin-nemui','Fix gnu wcwidth','wcwidth-wrapper.c','67','15','1','1','MODIFY','@@ -18,7 +18,7 @@      51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.  */   -#define _XOPEN_SOURCE +#define _GNU_SOURCE  #include <wchar.h>    #include \"module.h\" '),('irssi','1.1.1','3f0a4ef1970a164d7bce64e2fa887036fd162236','ailin-nemui','Remove incorrectly copied automake commands from fuzzer','Makefile.am','27','0','0','13','MODIFY','@@ -10,19 +10,6 @@ AM_CPPFLAGS = \\  	-I$(top_srcdir)/src/fe-common/core/ \\  	$(GLIB_CFLAGS)   -AM_DEPENDENCIES = \\ -	../../../core/libcore.a \\ -	../../../lib-config/libirssi_config.a \\ -	../../../irc/libirc.a \\ -	../../../irc/core/libirc_core.a \\ -	../../../irc/dcc/libirc_dcc.a \\ -	../../../irc/flood/libirc_flood.a \\ -	../../../irc/notifylist/libirc_notifylist.a \\ -	../../../fe-common/core/libfe_common_core.a \\ -	../../../fe-common/irc/libfe_common_irc.a \\ -	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\ -	../../../fe-common/irc/notifylist/libfe_irc_notifylist.a -  LDADD = \\  	../../../irc/libirc.a \\  	../../../irc/core/libirc_core.a \\ '),('irssi','1.1.1','3f0a4ef1970a164d7bce64e2fa887036fd162236','ailin-nemui','Remove incorrectly copied automake commands from fuzzer','Makefile.am','27','0','0','13','MODIFY','@@ -10,19 +10,6 @@ AM_CPPFLAGS = \\  	-I$(top_srcdir)/src/fe-common/core/ \\  	$(GLIB_CFLAGS)   -AM_DEPENDENCIES = \\ -	../../../core/libcore.a \\ -	../../../lib-config/libirssi_config.a \\ -	../../../irc/libirc.a \\ -	../../../irc/core/libirc_core.a \\ -	../../../irc/dcc/libirc_dcc.a \\ -	../../../irc/flood/libirc_flood.a \\ -	../../../irc/notifylist/libirc_notifylist.a \\ -	../../../fe-common/core/libfe_common_core.a \\ -	../../../fe-common/irc/libfe_common_irc.a \\ -	../../../fe-common/irc/dcc/libfe_irc_dcc.a \\ -	../../../fe-common/irc/notifylist/libfe_irc_notifylist a -  LDADD = \\  	../../../irc/libirc.a \\  	../../../irc/core/libirc_core.a \\ '),('irssi','1.1.1','74e8371bde8143535da46a833835313d75ae8f4e','ailin-nemui','fix accessing unallocated text when checking entry position  fixes #928','gui-entry.c','1179','371','2','3','MODIFY','@@ -212,7 +212,7 @@ static int pos2scrpos(GUI_ENTRY_REC *entry, int pos, int cursor)  		xpos += scrlen_str(entry->extents[0], entry->utf8);  	}   -	for (i = 0; i < pos; i++) { +	for (i = 0; i < entry->text_len && i < pos; i++) {  		unichar c = entry->text[i];  		const char *extent = entry->uses_extents ? entry->extents[i+1] : NULL;   @@ -226,9 +226,8 @@ static int pos2scrpos(GUI_ENTRY_REC *entry, int pos, int cursor)  		if (extent != NULL) {  			xpos += scrlen_str(extent, entry->utf8);  		} -  	} -	return xpos; +	return xpos + pos - i;  }    static int scrpos2pos(GUI_ENTRY_REC *entry, int pos) '),('irssi','1.1.1','c80946bcf5f1a9c48213fd718a8c8bffc6dd1307','ailin-nemui','Disconnect SASL properly in case the sasl module got unloaded from server  stops from getting on the network when sasl is unavailable  fixes #629','fe-sasl.c','27','4','0','22','MODIFY','@@ -40,36 +40,14 @@ static void sig_sasl_failure(IRC_SERVER_REC *server, const char *reason)  	printformat(server, NULL, MSGLEVEL_CRAP, IRCTXT_SASL_ERROR, reason);  }   -static void sig_cap_end(IRC_SERVER_REC *server) -{ -	/* The negotiation has now been terminated, if we didn\'t manage to -	 * authenticate successfully with the server just disconnect. */ -	if (!server->sasl_success && -	    server->connrec->sasl_mechanism != SASL_MECHANISM_NONE && -	    settings_get_bool(\"sasl_disconnect_on_failure\")) { -		/* We can\'t use server_disconnect() here because we\'d end up -		 * freeing the \'server\' object and be guilty of a slew of UaF. */ -		server->connection_lost = TRUE; -		/* By setting connection_lost we make sure the communication is -		 * halted and when the control goes back to irc_parse_incoming -		 * the server object is safely destroyed. */ -		signal_stop(); -	} - -} -  void fe_sasl_init(void)  { -	settings_add_bool(\"server\", \"sasl_disconnect_on_failure\", TRUE); -  	signal_add(\"server sasl success\", (SIGNAL_FUNC) sig_sasl_success);  	signal_add(\"server sasl failure\", (SIGNAL_FUNC) sig_sasl_failure); -	signal_add_first(\"server cap end\", (SIGNAL_FUNC) sig_cap_end);  }    void fe_sasl_deinit(void)  {  	signal_remove(\"server sasl success\", (SIGNAL_FUNC) sig_sasl_success);  	signal_remove(\"server sasl failure\", (SIGNAL_FUNC) sig_sasl_failure); -	signal_remove(\"server cap end\", (SIGNAL_FUNC) sig_cap_end);  } '),('irssi','1.1.1','c80946bcf5f1a9c48213fd718a8c8bffc6dd1307','ailin-nemui','Disconnect SASL properly in case the sasl module got unloaded from server  stops from getting on the network when sasl is unavailable  fixes #629','irc-servers-setup.c','157','52','1','1','MODIFY','@@ -98,9 +98,9 @@ static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,  	if (ircnet->sasl_mechanism != NULL) {  		if (!g_ascii_strcasecmp(ircnet->sasl_mechanism, \"plain\")) {  			/* The PLAIN method needs both the username and the password */ +			conn->sasl_mechanism = SASL_MECHANISM_PLAIN;  			if (ircnet->sasl_username != NULL && *ircnet->sasl_username &&  			    ircnet->sasl_password != NULL && *ircnet->sasl_password) { -				conn->sasl_mechanism = SASL_MECHANISM_PLAIN;  				conn->sasl_username = ircnet->sasl_username;  				conn->sasl_password = ircnet->sasl_password;  			} else '),('irssi','1.1.1','c80946bcf5f1a9c48213fd718a8c8bffc6dd1307','ailin-nemui','Disconnect SASL properly in case the sasl module got unloaded from server  stops from getting on the network when sasl is unavailable  fixes #629','sasl.c','214','39','36','0','MODIFY','@@ -301,9 +301,42 @@ static void sasl_disconnected(IRC_SERVER_REC *server)  	sasl_timeout_stop(server);  }   +static void sig_sasl_over(IRC_SERVER_REC *server) +{ +	if (!IS_IRC_SERVER(server)) +		return; + +	/* The negotiation has now been terminated, if we didn\'t manage to +	 * authenticate successfully with the server just disconnect. */ +	if (!server->sasl_success && +	    server->connrec->sasl_mechanism != SASL_MECHANISM_NONE) { +		if (server->cap_supported == NULL || +		    !g_hash_table_lookup_extended(server->cap_supported, \"sasl\", NULL, NULL)) { +			signal_emit(\"server sasl failure\", 2, server, \"The server did not offer SASL\"); +		} + +		if (settings_get_bool(\"sasl_disconnect_on_failure\")) { +			/* We can\'t use server_disconnect() here because we\'d end up +			 * freeing the \'server\' object and be guilty of a slew of UaF. */ +			server->connection_lost = TRUE; +			/* By setting connection_lost we make sure the communication is +			 * halted and when the control goes back to irc_parse_incoming +			 * the server object is safely destroyed. */ +			signal_stop(); +		} +	} + +} +  void sasl_init(void)  { +	settings_add_bool(\"server\", \"sasl_disconnect_on_failure\", TRUE); + +	signal_add_first(\"event 001\", (SIGNAL_FUNC) sig_sasl_over); +	/* this event can get us connected on broken ircds, see irc-servers.c */ +	signal_add_first(\"event 375\", (SIGNAL_FUNC) sig_sasl_over);  	signal_add_first(\"server cap ack sasl\", (SIGNAL_FUNC) sasl_start); +	signal_add_first(\"server cap end\", (SIGNAL_FUNC) sig_sasl_over);  	signal_add_first(\"event authenticate\", (SIGNAL_FUNC) sasl_step);  	signal_add_first(\"event 903\", (SIGNAL_FUNC) sasl_success);  	signal_add_first(\"event 902\", (SIGNAL_FUNC) sasl_fail); @@ -316,7 +349,10 @@ void sasl_init(void)    void sasl_deinit(void)  { +	signal_remove(\"event 001\", (SIGNAL_FUNC) sig_sasl_over); +	signal_remove(\"event 375\", (SIGNAL_FUNC) sig_sasl_over);  	signal_remove(\"server cap ack sasl\", (SIGNAL_FUNC) sasl_start); +	signal_remove(\"server cap end\", (SIGNAL_FUNC) sig_sasl_over);  	signal_remove(\"event authenticate\", (SIGNAL_FUNC) sasl_step);  	signal_remove(\"event 903\", (SIGNAL_FUNC) sasl_success);  	signal_remove(\"event 902\", (SIGNAL_FUNC) sasl_fail); '),('irssi','1.1.1','c174247502ebffe615f1e55ba7a5010856db41d3','ailin-nemui','fix compilation of theme-indent module','Makefile.am','64','0','11','11','MODIFY','@@ -53,20 +53,20 @@ irssi_SOURCES = \\    pkginc_fe_textdir=$(pkgincludedir)/src/fe-text  pkginc_fe_text_HEADERS = \\ -	statusbar-item.h +	gui-printtext.h \\ +	gui-windows.h \\ +	mainwindows.h \\ +	statusbar-item.h \\ +	term.h \\ +	textbuffer.h \\ +	textbuffer-view.h    noinst_HEADERS = \\ -        gui-entry.h \\ -        gui-printtext.h \\ -        gui-readline.h \\ -        gui-windows.h \\ -        mainwindows.h \\ -        statusbar.h \\ -        statusbar-config.h \\ -	term.h \\ +	gui-entry.h \\ +	gui-readline.h \\ +	statusbar.h \\ +	statusbar-config.h \\  	terminfo-core.h \\ -        textbuffer.h \\ -        textbuffer-view.h \\  	module.h \\  	module-formats.h   '),('irssi','1.1.1','20dcf4e53e05f61ed6e901f203e6f1ab90bc2bea','ailin-nemui','fix compilation of python module','Makefile.am','64','0','1','1','MODIFY','@@ -56,6 +56,7 @@ pkginc_fe_text_HEADERS = \\  	gui-printtext.h \\  	gui-windows.h \\  	mainwindows.h \\ +	statusbar.h \\  	statusbar-item.h \\  	term.h \\  	textbuffer.h \\ @@ -64,7 +65,6 @@ pkginc_fe_text_HEADERS = \\  noinst_HEADERS = \\  	gui-entry.h \\  	gui-readline.h \\ -	statusbar.h \\  	statusbar-config.h \\  	terminfo-core.h \\  	module.h \\ '),('irssi','1.1.1','b9a274a81d4020b4a1c5809b150ec869c897f17b','ailin-nemui','correctly separate ignore flags (no_act, hidden) from level','ignore.c','369','140','16','16','MODIFY','@@ -82,17 +82,12 @@ static int ignore_match_pattern(IGNORE_REC *rec, const char *text)   * However we also want to allow NO_ACT combined with levels, so mask it out and   * match levels if set. */  #define FLAG_MSGLEVELS ( MSGLEVEL_NO_ACT | MSGLEVEL_HIDDEN ) -static int ignore_match_level(IGNORE_REC *rec, int level) +static int ignore_match_level(IGNORE_REC *rec, int level, int flags)  { -	if (level & FLAG_MSGLEVELS) { -		int flaglevel = level & FLAG_MSGLEVELS; -		int msglevel = level & ~FLAG_MSGLEVELS; -		return (msglevel & rec->level) && (flaglevel & rec->level); -	} else if (!(rec->level & FLAG_MSGLEVELS)) { -		return (level & rec->level); -	} else { -		return FALSE; -	} +	level &= ~FLAG_MSGLEVELS; +	flags &= FLAG_MSGLEVELS; + +	return ((flags & rec->level) == flags) && ((level & rec->level) != 0);  }    #define ignore_match_nickmask(rec, nick, nickmask) \\ @@ -109,7 +104,7 @@ static int ignore_match_level(IGNORE_REC *rec, int level)  	((rec)->channels == NULL || ((channel) != NULL && \\  		strarray_find((rec)->channels, (channel)) != -1))   -static int ignore_check_replies(CHANNEL_REC *chanrec, const char *text, int level) +static int ignore_check_replies(CHANNEL_REC *chanrec, const char *text, int level, int flags)  {  	GSList *tmp;   @@ -121,7 +116,7 @@ static int ignore_check_replies(CHANNEL_REC *chanrec, const char *text, int leve  		IGNORE_REC *rec = tmp->data;    		if (rec->mask != NULL && rec->replies && -		    ignore_match_level(rec, level) && +		    ignore_match_level(rec, level, flags) &&  		    ignore_match_channel(rec, chanrec->name) &&  		    ignore_check_replies_rec(rec, chanrec, text))  			return TRUE; @@ -130,8 +125,8 @@ static int ignore_check_replies(CHANNEL_REC *chanrec, const char *text, int leve  	return FALSE;  }   -int ignore_check(SERVER_REC *server, const char *nick, const char *host, -		 const char *channel, const char *text, int level) +int ignore_check_flags(SERVER_REC *server, const char *nick, const char *host, +		       const char *channel, const char *text, int level, int flags)  {  	CHANNEL_REC *chanrec;  	NICK_REC *nickrec; @@ -167,7 +162,7 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  				ignore_match_channel(rec, channel) &&  				ignore_match_nickmask(rec, nick, nickmask);  		if (match && -		    ignore_match_level(rec, level) && +		    ignore_match_level(rec, level, flags) &&  		    ignore_match_pattern(rec, text)) {  			len = rec->mask == NULL ? 0 : strlen(rec->mask);  			if (len > best_mask) { @@ -188,7 +183,12 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  	if (best_match || (level & MSGLEVEL_PUBLIC) == 0)  		return best_match;   -        return ignore_check_replies(chanrec, text, level); +        return ignore_check_replies(chanrec, text, level, flags); +} + +int ignore_check(SERVER_REC *server, const char *nick, const char *host, +		 const char *channel, const char *text, int level) { +	return ignore_check_flags(server, nick, host, channel, text, level, 0);  }    IGNORE_REC *ignore_find_full(const char *servertag, const char *mask, const char *pattern, '),('irssi','1.1.1','b9a274a81d4020b4a1c5809b150ec869c897f17b','ailin-nemui','correctly separate ignore flags (no_act, hidden) from level','ignore.h','34','0','2','0','MODIFY','@@ -25,6 +25,8 @@ extern GSList *ignores;    int ignore_check(SERVER_REC *server, const char *nick, const char *host,  		 const char *channel, const char *text, int level); +int ignore_check_flags(SERVER_REC *server, const char *nick, const char *host, +		       const char *channel, const char *text, int level, int flags);    enum {  	IGNORE_FIND_PATTERN = 0x01, /* Match the pattern */ '),('irssi','1.1.1','b9a274a81d4020b4a1c5809b150ec869c897f17b','ailin-nemui','correctly separate ignore flags (no_act, hidden) from level','fe-messages.c','588','155','18','18','MODIFY','@@ -201,10 +201,10 @@ static void sig_message_public(SERVER_REC *server, const char *msg,  	if (for_me)  		level |= MSGLEVEL_HILIGHT;   -	if (ignore_check(server, nick, address, target, msg, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, nick, address, target, msg, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, nick, address, target, msg, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, nick, address, target, msg, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	if (settings_get_bool(\"emphasis\")) @@ -263,10 +263,10 @@ static void sig_message_private(SERVER_REC *server, const char *msg,  	if (settings_get_bool(\"emphasis\"))  		msg = freemsg = expand_emphasis((WI_ITEM_REC *) query, msg);   -	if (ignore_check(server, nick, address, NULL, msg, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, nick, address, NULL, msg, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, nick, address, NULL, msg, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, nick, address, NULL, msg, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	if (own) { @@ -361,10 +361,10 @@ static void sig_message_join(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_JOINS;   -	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	printformat(server, channel, level, @@ -377,10 +377,10 @@ static void sig_message_part(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_PARTS;   -	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, nick, address, channel, NULL, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	printformat(server, channel, level, @@ -399,10 +399,10 @@ static void sig_message_quit(SERVER_REC *server, const char *nick,  	if (ignore_check(server, nick, address, NULL, reason, MSGLEVEL_QUITS))  		return;   -	if (ignore_check(server, nick, address, NULL, reason, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, nick, address, NULL, reason, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, nick, address, NULL, reason, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, nick, address, NULL, reason, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	print_channel = NULL; @@ -424,10 +424,10 @@ static void sig_message_quit(SERVER_REC *server, const char *nick,  			continue;  		}   -		if (ignore_check(server, nick, address, rec->visible_name, reason, MSGLEVEL_NO_ACT)) +		if (ignore_check_flags(server, nick, address, rec->visible_name, reason, MSGLEVEL_QUITS, MSGLEVEL_NO_ACT))  			level |= MSGLEVEL_NO_ACT;   -		if (ignore_check(server, nick, address, rec->visible_name, reason, MSGLEVEL_HIDDEN)) +		if (ignore_check_flags(server, nick, address, rec->visible_name, reason, MSGLEVEL_QUITS, MSGLEVEL_HIDDEN))  			level |= MSGLEVEL_HIDDEN;    		if (print_channel == NULL || @@ -476,10 +476,10 @@ static void sig_message_kick(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_KICKS;   -	if (ignore_check(server, kicker, address, channel, reason, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, kicker, address, channel, reason, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, kicker, address, channel, reason, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, kicker, address, channel, reason, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	printformat(server, channel, level, @@ -500,10 +500,10 @@ static void print_nick_change_channel(SERVER_REC *server, const char *channel,  	level = MSGLEVEL_NICKS;          if (ownnick) level |= MSGLEVEL_NO_ACT;   -	if (!(level & MSGLEVEL_NO_ACT) && ignore_check(server, oldnick, address, channel, newnick, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, oldnick, address, channel, newnick, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (!(level & MSGLEVEL_HIDDEN) && ignore_check(server, oldnick, address, channel, newnick, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, oldnick, address, channel, newnick, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	printformat(server, channel, level, @@ -582,10 +582,10 @@ static void sig_message_topic(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_TOPICS;   -	if (ignore_check(server, nick, address, channel, topic, level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(server, nick, address, channel, topic, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, nick, address, channel, topic, level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(server, nick, address, channel, topic, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	printformat(server, channel, level, '),('irssi','1.1.1','b9a274a81d4020b4a1c5809b150ec869c897f17b','ailin-nemui','correctly separate ignore flags (no_act, hidden) from level','fe-dcc-chat-messages.c','125','18','12','12','MODIFY','@@ -92,12 +92,12 @@ static void sig_message_dcc(CHAT_DCC_REC *dcc, const char *msg)  	tag = g_strconcat(\"=\", dcc->id, NULL);  	query = query_find(NULL, tag);   -	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -				level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +			       level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -				level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +			       level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag, @@ -118,12 +118,12 @@ static void sig_message_dcc_action(CHAT_DCC_REC *dcc, const char *msg)  	tag = g_strconcat(\"=\", dcc->id, NULL);  	query = query_find(NULL, tag);   -	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -				level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +			       level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -				level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +			       level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag, @@ -143,12 +143,12 @@ static void sig_message_dcc_ctcp(CHAT_DCC_REC *dcc, const char *cmd,    	tag = g_strconcat(\"=\", dcc->id, NULL);   -	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, -				level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, +			       level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, -				level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, +			       level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag, '),('irssi','1.1.1','b9a274a81d4020b4a1c5809b150ec869c897f17b','ailin-nemui','correctly separate ignore flags (no_act, hidden) from level','fe-irc-messages.c','233','44','8','8','MODIFY','@@ -158,12 +158,12 @@ static void sig_message_irc_action(IRC_SERVER_REC *server, const char *msg,  	if (ignore_check(SERVER(server), nick, address, target, msg, level))  		return;   -	if (ignore_check(SERVER(server), nick, address, target, msg, -			 level | MSGLEVEL_NO_ACT)) +	if (ignore_check_flags(SERVER(server), nick, address, target, msg, +			       level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(SERVER(server), nick, address, target, msg, -			 level | MSGLEVEL_HIDDEN)) +	if (ignore_check_flags(SERVER(server), nick, address, target, msg, +			       level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;    	if (server_ischannel(SERVER(server), target)) { @@ -240,14 +240,14 @@ static void sig_message_irc_notice(SERVER_REC *server, const char *msg,  			 msg, level))  		return;   -	if (ignore_check(server, nick, address, +	if (ignore_check_flags(server, nick, address,  			 server_ischannel(SERVER(server), target) ? target : NULL, -			 msg, level | MSGLEVEL_NO_ACT)) +			       msg, level, MSGLEVEL_NO_ACT))  		level |= MSGLEVEL_NO_ACT;   -	if (ignore_check(server, nick, address, +	if (ignore_check_flags(server, nick, address,  			 server_ischannel(SERVER(server), target) ? target : NULL, -			 msg, level | MSGLEVEL_HIDDEN)) +			       msg, level, MSGLEVEL_HIDDEN))  		level |= MSGLEVEL_HIDDEN;            if (server_ischannel(SERVER(server), target)) { '),('irssi','1.1.1','b9a274a81d4020b4a1c5809b150ec869c897f17b','ailin-nemui','correctly separate ignore flags (no_act, hidden) from level','fe-modes.c','164','36','13','3','MODIFY','@@ -162,19 +162,29 @@ static void sig_message_mode(IRC_SERVER_REC *server, const char *channel,  			     const char *nick, const char *addr,  			     const char *mode)  { +	int level = MSGLEVEL_MODES; +  	if (nick == NULL) nick = server->real_address;    	if (ignore_check(SERVER(server), nick, addr, channel,  			 mode, MSGLEVEL_MODES))  		return;   +	if (ignore_check_flags(SERVER(server), nick, addr, channel, +			       mode, MSGLEVEL_MODES, MSGLEVEL_NO_ACT)) +		level |= MSGLEVEL_NO_ACT; + +	if (ignore_check_flags(SERVER(server), nick, addr, channel, +			       mode, MSGLEVEL_MODES, MSGLEVEL_HIDDEN)) +		level |= MSGLEVEL_HIDDEN; +  	if (!server_ischannel(SERVER(server), channel)) {  		/* user mode change */ -		printformat(server, NULL, MSGLEVEL_MODES, +		printformat(server, NULL, level,  			    IRCTXT_USERMODE_CHANGE, mode, channel);  	} else if (addr == NULL) {  		/* channel mode changed by server */ -		printformat(server, channel, MSGLEVEL_MODES, +		printformat(server, channel, level,  			    IRCTXT_SERVER_CHANMODE_CHANGE,  			    channel, mode, nick);  	} else { @@ -187,7 +197,7 @@ static void sig_message_mode(IRC_SERVER_REC *server, const char *channel,  		if (chanrec != NULL && g_ascii_strcasecmp(nick, server->nick) != 0)  			msg_multi_mode(chanrec, nick, addr, mode);  		else { -			printformat(server, channel, MSGLEVEL_MODES, +			printformat(server, channel, level,  				    IRCTXT_CHANMODE_CHANGE,  				    channel, mode, nick, addr);  		} '),('irssi','1.1.1','b9a274a81d4020b4a1c5809b150ec869c897f17b','ailin-nemui','correctly separate ignore flags (no_act, hidden) from level','Ignore.xs','63','1','23','0','MODIFY','@@ -25,6 +25,19 @@ CODE:  OUTPUT:  	RETVAL   +int +ignore_check_flags(nick, host, channel, text, level, flags) +	char *nick +	char *host +	char *channel +	char *text +	int level +	int flags +CODE: +	RETVAL = ignore_check_flags(NULL, nick, host, channel, text, level, flags); +OUTPUT: +	RETVAL +  #*******************************  MODULE = Irssi::Ignore  PACKAGE = Irssi::Server  #******************************* @@ -38,6 +51,16 @@ ignore_check(server, nick, host, channel, text, level)  	char *text  	int level   +int +ignore_check_flags(server, nick, host, channel, text, level, flags) +	Irssi::Server server +	char *nick +	char *host +	char *channel +	char *text +	int level +	int flags +  #*******************************  MODULE = Irssi::Ignore  PACKAGE = Irssi::Ignore  PREFIX = ignore_  #******************************* '),('irssi','1.1.1','7e9f8c694b38ae785771fb837fb0a4a434b614d3','ailin-nemui','simplify ignore hidden/no_act code','ignore.c','380','145','16','0','MODIFY','@@ -191,6 +191,22 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  	return ignore_check_flags(server, nick, host, channel, text, level, 0);  }   +int ignore_check_plus(SERVER_REC *server, const char *nick, const char *address, +		      const char *target, const char *msg, int *level, int test_ignore) { +	int olevel = *level; + +	if (test_ignore && ignore_check(server, nick, address, target, msg, olevel)) +		return TRUE; + +	if (ignore_check_flags(server, nick, address, target, msg, olevel, MSGLEVEL_NO_ACT)) +		*level |= MSGLEVEL_NO_ACT; + +	if (ignore_check_flags(server, nick, address, target, msg, olevel, MSGLEVEL_HIDDEN)) +		*level |= MSGLEVEL_HIDDEN; + +	return FALSE; +} +  IGNORE_REC *ignore_find_full(const char *servertag, const char *mask, const char *pattern,  		char **channels, const int flags)  { '),('irssi','1.1.1','7e9f8c694b38ae785771fb837fb0a4a434b614d3','ailin-nemui','simplify ignore hidden/no_act code','ignore.h','36','0','2','0','MODIFY','@@ -27,6 +27,8 @@ int ignore_check(SERVER_REC *server, const char *nick, const char *host,  		 const char *channel, const char *text, int level);  int ignore_check_flags(SERVER_REC *server, const char *nick, const char *host,  		       const char *channel, const char *text, int level, int flags); +int ignore_check_plus(SERVER_REC *server, const char *nick, const char *host, +		      const char *channel, const char *text, int *level, int test_ignore);    enum {  	IGNORE_FIND_PATTERN = 0x01, /* Match the pattern */ '),('irssi','1.1.1','7e9f8c694b38ae785771fb837fb0a4a434b614d3','ailin-nemui','simplify ignore hidden/no_act code','fe-messages.c','558','137','12','55','MODIFY','@@ -201,11 +201,7 @@ static void sig_message_public(SERVER_REC *server, const char *msg,  	if (for_me)  		level |= MSGLEVEL_HILIGHT;   -	if (ignore_check_flags(server, nick, address, target, msg, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, nick, address, target, msg, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(server, nick, address, target, msg, &level, FALSE);    	if (settings_get_bool(\"emphasis\"))  		msg = freemsg = expand_emphasis((WI_ITEM_REC *) chanrec, msg); @@ -263,11 +259,7 @@ static void sig_message_private(SERVER_REC *server, const char *msg,  	if (settings_get_bool(\"emphasis\"))  		msg = freemsg = expand_emphasis((WI_ITEM_REC *) query, msg);   -	if (ignore_check_flags(server, nick, address, NULL, msg, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, nick, address, NULL, msg, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(server, nick, address, NULL, msg, &level, FALSE);    	if (own) {  		printformat(server, target, level, @@ -361,11 +353,7 @@ static void sig_message_join(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_JOINS;   -	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(server, nick, address, channel, NULL, &level, FALSE);    	printformat(server, channel, level,  		    TXT_JOIN, nick, address, channel); @@ -377,11 +365,7 @@ static void sig_message_part(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_PARTS;   -	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, nick, address, channel, NULL, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(server, nick, address, channel, NULL, &level, FALSE);    	printformat(server, channel, level,  		    TXT_PART, nick, address, channel, reason); @@ -396,15 +380,9 @@ static void sig_message_quit(SERVER_REC *server, const char *nick,  	char *print_channel;  	int once, count, level = MSGLEVEL_QUITS;   -	if (ignore_check(server, nick, address, NULL, reason, MSGLEVEL_QUITS)) +	if (ignore_check_plus(server, nick, address, NULL, reason, &level, TRUE))  		return;   -	if (ignore_check_flags(server, nick, address, NULL, reason, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, nick, address, NULL, reason, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; -  	print_channel = NULL;  	once = settings_get_bool(\"show_quit_once\");   @@ -418,18 +396,12 @@ static void sig_message_quit(SERVER_REC *server, const char *nick,  		if (!nicklist_find(rec, nick))  			continue;   -		if (ignore_check(server, nick, address, rec->visible_name, -				 reason, MSGLEVEL_QUITS)) { +		if (ignore_check_plus(server, nick, address, rec->visible_name, +				      reason, &level, TRUE)) {  			count++;  			continue;  		}   -		if (ignore_check_flags(server, nick, address, rec->visible_name, reason, MSGLEVEL_QUITS, MSGLEVEL_NO_ACT)) -			level |= MSGLEVEL_NO_ACT; - -		if (ignore_check_flags(server, nick, address, rec->visible_name, reason, MSGLEVEL_QUITS, MSGLEVEL_HIDDEN)) -			level |= MSGLEVEL_HIDDEN; -  		if (print_channel == NULL ||  		    active_win->active == (WI_ITEM_REC *) rec)  			print_channel = rec->visible_name; @@ -476,11 +448,7 @@ static void sig_message_kick(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_KICKS;   -	if (ignore_check_flags(server, kicker, address, channel, reason, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, kicker, address, channel, reason, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(server, kicker, address, channel, reason, &level, FALSE);    	printformat(server, channel, level,  		    TXT_KICK, nick, channel, kicker, reason, address); @@ -493,18 +461,11 @@ static void print_nick_change_channel(SERVER_REC *server, const char *channel,  {  	int level;   -	if (ignore_check(server, oldnick, address, -			 channel, newnick, MSGLEVEL_NICKS)) -		return; -  	level = MSGLEVEL_NICKS;          if (ownnick) level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, oldnick, address, channel, newnick, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, oldnick, address, channel, newnick, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	if (ignore_check_plus(server, oldnick, address, +			      channel, newnick, &level, TRUE)) +		return;    	printformat(server, channel, level,  		    ownnick ? TXT_YOUR_NICK_CHANGED : TXT_NICK_CHANGED, @@ -582,11 +543,7 @@ static void sig_message_topic(SERVER_REC *server, const char *channel,  {  	int level = MSGLEVEL_TOPICS;   -	if (ignore_check_flags(server, nick, address, channel, topic, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, nick, address, channel, topic, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(server, nick, address, channel, topic, &level, FALSE);    	printformat(server, channel, level,  		    *topic != \'\\0\' ? TXT_NEW_TOPIC : TXT_TOPIC_UNSET, '),('irssi','1.1.1','7e9f8c694b38ae785771fb837fb0a4a434b614d3','ailin-nemui','simplify ignore hidden/no_act code','fe-dcc-chat-messages.c','113','12','6','21','MODIFY','@@ -92,13 +92,8 @@ static void sig_message_dcc(CHAT_DCC_REC *dcc, const char *msg)  	tag = g_strconcat(\"=\", dcc->id, NULL);  	query = query_find(NULL, tag);   -	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -			       level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -			       level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +			  &level, FALSE);    	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag,  			       level, NULL); @@ -118,13 +113,8 @@ static void sig_message_dcc_action(CHAT_DCC_REC *dcc, const char *msg)  	tag = g_strconcat(\"=\", dcc->id, NULL);  	query = query_find(NULL, tag);   -	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -			       level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, -			       level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(SERVER(dcc->server), tag, dcc->addrstr, NULL, msg, +			  &level, FALSE);    	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag,  			       level, NULL); @@ -143,13 +133,8 @@ static void sig_message_dcc_ctcp(CHAT_DCC_REC *dcc, const char *cmd,    	tag = g_strconcat(\"=\", dcc->id, NULL);   -	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, -			       level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, -			       level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; +	ignore_check_plus(SERVER(dcc->server), tag, dcc->addrstr, NULL, cmd, +			  &level, FALSE);    	format_create_dest_tag(&dest, dcc->server, dcc->servertag, tag,  			       level, NULL); '),('irssi','1.1.1','7e9f8c694b38ae785771fb837fb0a4a434b614d3','ailin-nemui','simplify ignore hidden/no_act code','fe-irc-messages.c','220','38','7','24','MODIFY','@@ -155,17 +155,9 @@ static void sig_message_irc_action(IRC_SERVER_REC *server, const char *msg,  	level = MSGLEVEL_ACTIONS |  		(server_ischannel(SERVER(server), target) ? MSGLEVEL_PUBLIC : MSGLEVEL_MSGS);   -	if (ignore_check(SERVER(server), nick, address, target, msg, level)) +	if (ignore_check_plus(SERVER(server), nick, address, target, msg, &level, TRUE))  		return;   -	if (ignore_check_flags(SERVER(server), nick, address, target, msg, -			       level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(SERVER(server), nick, address, target, msg, -			       level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; -  	if (server_ischannel(SERVER(server), target)) {  		item = irc_channel_find(server, target);  	} else { @@ -226,30 +218,21 @@ static void sig_message_irc_notice(SERVER_REC *server, const char *msg,  	target = fe_channel_skip_prefix(IRC_SERVER(server), target);    	if (address == NULL || *address == \'\\0\') { +		level = MSGLEVEL_SNOTES;  		/* notice from server */ -		if (!ignore_check(server, nick, \"\", -				  target, msg, MSGLEVEL_SNOTES)) { -			printformat(server, target, MSGLEVEL_SNOTES, +		if (!ignore_check_plus(server, nick, \"\", +				       target, msg, &level, TRUE)) { +			printformat(server, target, level,  				    IRCTXT_NOTICE_SERVER, nick, msg);  		}                  return;  	}   -	if (ignore_check(server, nick, address, +	if (ignore_check_plus(server, nick, address,  			 server_ischannel(SERVER(server), target) ? target : NULL, -			 msg, level)) +			      msg, &level, TRUE))  		return;   -	if (ignore_check_flags(server, nick, address, -			 server_ischannel(SERVER(server), target) ? target : NULL, -			       msg, level, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(server, nick, address, -			 server_ischannel(SERVER(server), target) ? target : NULL, -			       msg, level, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; -          if (server_ischannel(SERVER(server), target)) {  		/* notice in some channel */  		printformat(server, target, level, '),('irssi','1.1.1','7e9f8c694b38ae785771fb837fb0a4a434b614d3','ailin-nemui','simplify ignore hidden/no_act code','fe-modes.c','158','34','2','10','MODIFY','@@ -166,18 +166,10 @@ static void sig_message_mode(IRC_SERVER_REC *server, const char *channel,    	if (nick == NULL) nick = server->real_address;   -	if (ignore_check(SERVER(server), nick, addr, channel, -			 mode, MSGLEVEL_MODES)) +	if (ignore_check_plus(SERVER(server), nick, addr, channel, +			      mode, &level, TRUE))  		return;   -	if (ignore_check_flags(SERVER(server), nick, addr, channel, -			       mode, MSGLEVEL_MODES, MSGLEVEL_NO_ACT)) -		level |= MSGLEVEL_NO_ACT; - -	if (ignore_check_flags(SERVER(server), nick, addr, channel, -			       mode, MSGLEVEL_MODES, MSGLEVEL_HIDDEN)) -		level |= MSGLEVEL_HIDDEN; -  	if (!server_ischannel(SERVER(server), channel)) {  		/* user mode change */  		printformat(server, NULL, level, '),('irssi','1.1.1','011d9437d158ae815cfab55a5e2c0b0a57430353','ailin-nemui','oops','ignore.c','380','145','1','1','MODIFY','@@ -87,7 +87,7 @@ static int ignore_match_level(IGNORE_REC *rec, int level, int flags)  	level &= ~FLAG_MSGLEVELS;  	flags &= FLAG_MSGLEVELS;   -	return ((flags & rec->level) == flags) && ((level & rec->level) != 0); +	return ((FLAG_MSGLEVELS & rec->level) == flags) && ((level & rec->level) != 0);  }    #define ignore_match_nickmask(rec, nick, nickmask) \\ '),('irssi','1.1.1','cb6279c63bbb98a419f9f72495b8a8232a3e7529','Doug Freed','fe-text: add window_default_hidelevel setting  Allows specifying the hidelevel that new windows get by default.','gui-windows.c','233','54','2','1','MODIFY','@@ -53,7 +53,7 @@ static GUI_WINDOW_REC *gui_window_init(WINDOW_REC *window,  					   get_default_indent_func());  	textbuffer_view_set_break_wide(gui->view, settings_get_bool(\"break_wide\"));  	wcwidth_impl = settings_get_choice(\"wcwidth_implementation\"); -	textbuffer_view_set_hidden_level(gui->view, MSGLEVEL_HIDDEN); +	textbuffer_view_set_hidden_level(gui->view, settings_get_level(\"window_default_hidelevel\"));  	if (parent->active == window)  		textbuffer_view_set_window(gui->view, parent->screen_win);  	return gui; @@ -303,6 +303,7 @@ void gui_windows_init(void)  	settings_add_bool(\"lookandfeel\", \"indent_always\", FALSE);  	settings_add_bool(\"lookandfeel\", \"break_wide\", FALSE);  	settings_add_bool(\"lookandfeel\", \"scroll\", TRUE); +	settings_add_level(\"lookandfeel\", \"window_default_hidelevel\", \"HIDDEN\");    	window_create_override = MAIN_WINDOW_TYPE_NONE;   '),('irssi','1.1.1','074e6cf768b9c153b64a916b4b2d332d8ba6bef4','Doug Freed','fe-text: only save non-default window hidelevel  This will only save the window hidelevel in the layout if it differs from window_default_hidelevel.','mainwindows-layout.c','241','58','3','2','MODIFY','@@ -42,7 +42,7 @@ static void sig_layout_window_save(WINDOW_REC *window, CONFIG_NODE *node)  			iconfig_node_set_int(node, \"parent\", active->refnum);  	}   -	if (gui->view->hidden_level != MSGLEVEL_HIDDEN) { +	if (gui->view->hidden_level != settings_get_level(\"window_default_hidelevel\")) {  		char *level = bits2level(gui->view->hidden_level);  		iconfig_node_set_str(node, \"hidelevel\", level);  		g_free(level); @@ -56,6 +56,7 @@ static void sig_layout_window_restore(WINDOW_REC *window, CONFIG_NODE *node)  {  	WINDOW_REC *parent;  	GUI_WINDOW_REC *gui; +	char *default_hidelevel = settings_get_str(\"window_default_hidelevel\");    	gui = WINDOW_GUI(window);   @@ -66,7 +67,7 @@ static void sig_layout_window_restore(WINDOW_REC *window, CONFIG_NODE *node)  	if (config_node_get_bool(node, \"sticky\", FALSE))  		gui_window_set_sticky(window);   -	textbuffer_view_set_hidden_level(gui->view, level2bits(config_node_get_str(node, \"hidelevel\", \"HIDDEN\"), NULL)); +	textbuffer_view_set_hidden_level(gui->view, level2bits(config_node_get_str(node, \"hidelevel\", default_hidelevel), NULL));    	if (config_node_get_str(node, \"scroll\", NULL) != NULL) {  		gui->use_scroll = TRUE; '),('irssi','1.1.1','cad79f1db74787c68951e166cdc68af21ec67301','Doug Freed','Fix compilation warning','mainwindows-layout.c','241','58','1','1','MODIFY','@@ -56,7 +56,7 @@ static void sig_layout_window_restore(WINDOW_REC *window, CONFIG_NODE *node)  {  	WINDOW_REC *parent;  	GUI_WINDOW_REC *gui; -	char *default_hidelevel = settings_get_str(\"window_default_hidelevel\"); +	const char *default_hidelevel = settings_get_str(\"window_default_hidelevel\");    	gui = WINDOW_GUI(window);   '),('irssi','1.1.1','f231a59e81a7487dc46ad58fbdbde90d3b750435','ailin-nemui','properly document the ignore_match_level so I understand it next time','ignore.c','384','147','11','1','MODIFY','@@ -87,7 +87,17 @@ static int ignore_match_level(IGNORE_REC *rec, int level, int flags)  	level &= ~FLAG_MSGLEVELS;  	flags &= FLAG_MSGLEVELS;   -	return ((FLAG_MSGLEVELS & rec->level) == flags) && ((level & rec->level) != 0); +	if (!flags) { +		/* case: we are not checking special flags. then, the +		   record must not have any flags either, but it must +		   have some of the levels */ +		return !(FLAG_MSGLEVELS & rec->level) && (level & rec->level); +	} else { +		 /* case: we want to test if some special flags +		    apply. then, the record must have some of the +		    flags and some of the levels */ +		return (flags & rec->level) && (level & rec->level); +	}  }    #define ignore_match_nickmask(rec, nick, nickmask) \\ '),('irssi','1.1.1','01f961cdf1d009ea4a8adc55fd6688f81dbb76c6','ailin-nemui','Don\'t trigger activity on hidden lines by default  This is controlled by a new activity_hide_window_hidelevel setting.','signals.txt','278','0','1','0','MODIFY','@@ -286,6 +286,7 @@ themes.c:    window-activity.c:   \"window hilight\", WINDOW_REC + \"window hilight check\", TEXT_DEST_REC, char *msg, int *data_level, int *should_ignore   \"window dehilight\", WINDOW_REC   \"window activity\", WINDOW_REC, int old_level   \"window item hilight\", WI_ITEM_REC '),('irssi','1.1.1','01f961cdf1d009ea4a8adc55fd6688f81dbb76c6','ailin-nemui','Don\'t trigger activity on hidden lines by default  This is controlled by a new activity_hide_window_hidelevel setting.','window-activity.c','119','27','10','2','MODIFY','@@ -34,7 +34,7 @@  #include \"fe-common-core.h\"    static char **hide_targets; -static int hide_level, msg_level, hilight_level; +static int hide_level, msg_level, hilight_level, signal_window_hilight_check;    void window_activity(WINDOW_REC *window, int data_level,  		     const char *hilight_color) @@ -74,6 +74,7 @@ static void sig_hilight_text(TEXT_DEST_REC *dest, const char *msg)  {  	WI_ITEM_REC *item;  	int data_level; +	int cb_ignore = 0;    	if (dest->window == active_win || (dest->level & hide_level))  		return; @@ -91,6 +92,12 @@ static void sig_hilight_text(TEXT_DEST_REC *dest, const char *msg)  			return;  	}   +	/* we should ask the text view if this line is hidden */ +	signal_emit_id(signal_window_hilight_check, 5, dest, msg, &data_level, &cb_ignore); +	if (cb_ignore) { +		return; +	} +  	if (dest->target != NULL) {  		item = window_item_find(dest->server, dest->target);  		if (item != NULL) { @@ -125,7 +132,7 @@ static void read_settings(void)  	hide_targets = *targets == \'\\0\' ? NULL :  		g_strsplit(targets, \" \", -1);   -	hide_level = MSGLEVEL_NEVER | MSGLEVEL_NO_ACT | MSGLEVEL_HIDDEN | +	hide_level = MSGLEVEL_NEVER | MSGLEVEL_NO_ACT |  		settings_get_level(\"activity_hide_level\");  	msg_level = settings_get_level(\"activity_msg_level\");  	hilight_level = MSGLEVEL_HILIGHT | @@ -138,6 +145,7 @@ void window_activity_init(void)  	settings_add_level(\"lookandfeel\", \"activity_hide_level\", \"\");  	settings_add_level(\"lookandfeel\", \"activity_msg_level\", \"PUBLIC\");  	settings_add_level(\"lookandfeel\", \"activity_hilight_level\", \"MSGS DCCMSGS\"); +	signal_window_hilight_check = signal_get_uniq_id(\"window hilight check\");    	read_settings();  	signal_add(\"print text\", (SIGNAL_FUNC) sig_hilight_text); '),('irssi','1.1.1','01f961cdf1d009ea4a8adc55fd6688f81dbb76c6','ailin-nemui','Don\'t trigger activity on hidden lines by default  This is controlled by a new activity_hide_window_hidelevel setting.','textbuffer-commands.c','323','74','31','0','MODIFY','@@ -30,6 +30,8 @@  #include \"printtext.h\"  #include \"gui-windows.h\"   +static int activity_hide_window_hidelevel; +  /* SYNTAX: CLEAR [-all] [<refnum>] */  static void cmd_clear(const char *data)  { @@ -373,8 +375,32 @@ static void sig_away_changed(SERVER_REC *server)  	}  }   +static void sig_window_hilight_check(TEXT_DEST_REC *dest, char *msg, int *data_level, int *ignore) +{ +	GUI_WINDOW_REC *gui; + +	g_return_if_fail(dest != NULL); +	g_return_if_fail(ignore != NULL); + +	if (*ignore != 0 || !activity_hide_window_hidelevel || dest->window == NULL) +		return; + +	gui = WINDOW_GUI(dest->window); + +	if (dest->level & gui->view->hidden_level) { +		*ignore = TRUE; +	} +} + +static void read_settings(void) +{ +	activity_hide_window_hidelevel = settings_get_bool(\"activity_hide_window_hidelevel\"); +} +  void textbuffer_commands_init(void)  { +	settings_add_bool(\"lookandfeel\", \"activity_hide_window_hidelevel\", TRUE); +  	command_bind(\"clear\", NULL, (SIGNAL_FUNC) cmd_clear);  	command_bind(\"window scroll\", NULL, (SIGNAL_FUNC) cmd_window_scroll);  	command_bind(\"window hidelevel\", NULL, (SIGNAL_FUNC) cmd_window_hidelevel); @@ -390,7 +416,10 @@ void textbuffer_commands_init(void)  	command_set_options(\"scrollback clear\", \"all\");  	command_set_options(\"scrollback levelclear\", \"all -level\");   +	read_settings(); +	signal_add(\"setup changed\", (SIGNAL_FUNC) read_settings);  	signal_add(\"away mode changed\", (SIGNAL_FUNC) sig_away_changed); +	signal_add(\"window hilight check\", (SIGNAL_FUNC) sig_window_hilight_check);  }    void textbuffer_commands_deinit(void) @@ -406,5 +435,7 @@ void textbuffer_commands_deinit(void)  	command_unbind(\"scrollback end\", (SIGNAL_FUNC) cmd_scrollback_end);  	command_unbind(\"scrollback status\", (SIGNAL_FUNC) cmd_scrollback_status);   +	signal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);  	signal_remove(\"away mode changed\", (SIGNAL_FUNC) sig_away_changed); +	signal_remove(\"window hilight check\", (SIGNAL_FUNC) sig_window_hilight_check);  } '),('irssi','1.1.1','db005007cf3c951ace57b1810b30248fe371e4be','ailin-nemui','fix irssi being stuck when resized very small','mainwindows.c','1479','359','6','1','MODIFY','@@ -285,8 +285,13 @@ static MAIN_WINDOW_REC *mainwindows_find_lower(MAIN_WINDOW_REC *window)  	MAIN_WINDOW_REC *best;  	GSList *tmp;   +	/* unfortunate special case: if the window has been resized +	   and there is not enough room, the last_line could become +	   smaller than the first_line, sending us in an infinite +	   loop */  	if (window != NULL) -		last_line = window->last_line; +		last_line = +		    window->last_line > window->first_line ? window->last_line : window->first_line;  	else  		last_line = -1;   '),('irssi','1.1.1','76b934d18e81ffbfa1e7480396d47fcced9394e8','ailin-nemui','Fix broken display after resizing many windows very small','mainwindows.c','1483','361','14','6','MODIFY','@@ -520,7 +520,7 @@ static void gui_windows_remove_parent(MAIN_WINDOW_REC *window)  	}  }   -void mainwindow_destroy(MAIN_WINDOW_REC *window) +static void mainwindow_destroy_full(MAIN_WINDOW_REC *window, int respace)  {  	g_return_if_fail(window != NULL);   @@ -531,7 +531,7 @@ void mainwindow_destroy(MAIN_WINDOW_REC *window)    	if (mainwindows != NULL) {  		gui_windows_remove_parent(window); -		if (!quitting) { +		if (respace) {  			mainwindows_add_space(window);  			mainwindows_redraw();  		} @@ -542,12 +542,14 @@ void mainwindow_destroy(MAIN_WINDOW_REC *window)  	if (active_mainwin == window) active_mainwin = NULL;  }   +void mainwindow_destroy(MAIN_WINDOW_REC *window) +{ +	mainwindow_destroy_full(window, !quitting); +} +  void mainwindow_destroy_half(MAIN_WINDOW_REC *window)  { -	int really_quitting = quitting; -	quitting = TRUE; -	mainwindow_destroy(window); -	quitting = really_quitting; +	mainwindow_destroy_full(window, FALSE);  }    void mainwindows_redraw(void) @@ -821,6 +823,12 @@ void mainwindows_resize(int width, int height)  		mainwindows_resize_smaller(ydiff);  	}   +	/* if we lost our active mainwin, get a new one */ +	if (active_mainwin == NULL && !quitting) { +		active_mainwin = WINDOW_MAIN(active_win); +		window_set_active(active_mainwin->active); +	} +  	signal_emit(\"terminal resized\", 0);    	irssi_redraw(); '),('irssi','1.1.1','8684ccb45c267fdeaaa779fce9323047aa5a9e38','ailin-nemui','invalidate startline and bottom_startline when hidden  this was overlooked when adding hidden line support. if the lines are removed, Irssi has to update the startline. It does that by \"scrolling\" the lines to the proper place. The scroll function was adjusted to calculate 0 for hidden lines, thus it would miss them.','textbuffer-view.c','1092','271','10','0','MODIFY','@@ -1230,6 +1230,11 @@ static void view_remove_line(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,  			if (is_last == 1)  				view->startline = NULL;  		} + +		if (view->startline == line) { +			view->startline = line->next; +			view->subline = 0; +		}  	} else {  		if (textbuffer_line_exists_after(view->bottom_startline,  						 line)) { @@ -1239,6 +1244,11 @@ static void view_remove_line(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line,  			view->empty_linecount += linecount-realcount;  		}   +		if (view->bottom_startline == line) { +			view->bottom_startline = view->bottom_startline->next; +			view->bottom_subline = 0; +		} +  		if (textbuffer_line_exists_after(view->startline,  						 line)) {  			view_remove_line_update_startline(view, line, '),('irssi','1.1.1','04daf62dbf9a1668b5eb12b64f90701b11f374ca','ailin-nemui','Fix insufficient size of help column when the window width is small','fe-help.c','196','50','6','1','MODIFY','@@ -77,7 +77,12 @@ static void help_category(GSList *cmdlist, int items)  				    max_width, 6, 1, 3, &columns, &rows);  	cmdlist = columns_sort_list(cmdlist, rows);   -        /* rows in last column */ +	/* if the screen is too narrow the window width may be not +	   enough for even 1 column */ +	if (cols == 1 && columns[0] > max_width) +		max_width = columns[0]; + +	/* rows in last column */  	last_col_rows = rows-(cols*rows-g_slist_length(cmdlist));  	if (last_col_rows == 0)                  last_col_rows = rows; '),('irssi','1.1.1','b264540f4ed5e273835a2d5feb10decb18a4fed6','Doug Freed','fe-text: clear hidelevel in layout if default  This is required, otherwise setting the hidelevel to the default will\r not be written in the layout and so won\'t persist.','mainwindows-layout.c','243','58','2','0','MODIFY','@@ -46,6 +46,8 @@ static void sig_layout_window_save(WINDOW_REC *window, CONFIG_NODE *node)  		char *level = bits2level(gui->view->hidden_level);  		iconfig_node_set_str(node, \"hidelevel\", level);  		g_free(level); +	} else { +		iconfig_node_set_str(node, \"hidelevel\", NULL);  	}    	if (gui->use_scroll) '),('irssi','1.1.1','f5e587a83b0f3569a8024b54713667d55e157370','Doug Freed','Fix 01f961c','window-activity.c','119','27','1','1','MODIFY','@@ -93,7 +93,7 @@ static void sig_hilight_text(TEXT_DEST_REC *dest, const char *msg)  	}    	/* we should ask the text view if this line is hidden */ -	signal_emit_id(signal_window_hilight_check, 5, dest, msg, &data_level, &cb_ignore); +	signal_emit_id(signal_window_hilight_check, 4, dest, msg, &data_level, &cb_ignore);  	if (cb_ignore) {  		return;  	} '),('irssi','1.1.1','c4bf228e6c2a045f4906b38e9eaf2591cc4f984e','Doug Freed','Fix check for C99 in printtext.h','printtext.h','57','4','5','5','MODIFY','@@ -46,16 +46,16 @@ void printtext_deinit(void);  	printformat_module_dest(MODULE_NAME, dest, ##formatnum)  #  define printformat_gui(formatnum...) \\  	printformat_module_gui(MODULE_NAME, ##formatnum) -#elif defined (_ISOC99_SOURCE) +#elif __STDC_VERSION__ >= 199901L  /* C99 */  #  define printformat(server, target, level, formatnum, ...) \\ -	printformat_module(MODULE_NAME, server, target, level, formatnum, __VA_ARGS__) +	printformat_module(MODULE_NAME, server, target, level, formatnum, ##__VA_ARGS__)  #  define printformat_window(window, level, formatnum, ...) \\ -	printformat_module_window(MODULE_NAME, window, level, formatnum, __VA_ARGS__) +	printformat_module_window(MODULE_NAME, window, level, formatnum, ##__VA_ARGS__)  #  define printformat_dest(dest, formatnum, ...) \\ -	printformat_module_dest(MODULE_NAME, dest, formatnum, __VA_ARGS__) +	printformat_module_dest(MODULE_NAME, dest, formatnum, ##__VA_ARGS__)  #  define printformat_gui(formatnum, ...) \\ -	printformat_module_gui(MODULE_NAME, formatnum, __VA_ARGS__) +	printformat_module_gui(MODULE_NAME, formatnum, ##__VA_ARGS__)  #else  /* inline/static */  #ifdef G_CAN_INLINE '),('irssi','1.1.1','ca1ec21dc21563e63a91d4e307dc5ad0490e6cc4','ailin-nemui','fix and document window width on screen width dependency','mainwindows.c','1484','362','2','2','MODIFY','@@ -252,9 +252,9 @@ MAIN_WINDOW_REC *mainwindow_create(int right)  			}  			g_slist_free(line);  		} else { -			if (MAIN_WINDOW_TEXT_WIDTH(parent) < -			    2* NEW_WINDOW_WIDTH) +			if (MAIN_WINDOW_TEXT_WIDTH(parent) < 2 * NEW_WINDOW_WIDTH) {  				parent = find_window_with_room_right(); +			}  			if (parent == NULL)  				return NULL; /* not enough space */   '),('irssi','1.1.1','ca1ec21dc21563e63a91d4e307dc5ad0490e6cc4','ailin-nemui','fix and document window width on screen width dependency','mainwindows.h','43','0','1','1','MODIFY','@@ -5,7 +5,7 @@  #include \"term.h\"    #define WINDOW_MIN_SIZE 2 -#define NEW_WINDOW_WIDTH 10 +#define NEW_WINDOW_WIDTH 20 /* must be >= MIN_SCREEN_WIDTH defined in term.c */    #define MAIN_WINDOW_TEXT_HEIGHT(window) \\          ((window)->height-(window)->statusbar_lines) '),('irssi','1.1.1','ff7f4a2207c19c2d5e67edc61c24b1f9781fe1c5','ailin-nemui','Remove cubes from irssi.conf  This is long and ugly and better done externally (script)','irssi.conf','333','0','0','1','MODIFY','@@ -115,7 +115,6 @@ aliases = {    C           = \"CLEAR\";    CALC        = \"EXEC - if command -v bc >/dev/null 2>&1\\\\; then printf \'%s=\' \'$*\'\\\\; echo \'$*\' | bc -l\\\\; else echo bc was not found\\\\; fi\";    CHAT        = \"DCC CHAT\"; -  CUBES       = \"SCRIPT EXEC Irssi::active_win->print(\\\"%_bases\\\", MSGLEVEL_CLIENTCRAP) \\\\; Irssi::active_win->print( do { join \'\', map { \\\"%x0\\\\${_}0\\\\$_\\\" } \'0\'..\'9\',\'A\'..\'F\' }, MSGLEVEL_NEVER | MSGLEVEL_CLIENTCRAP) \\\\; Irssi::active_win->print(\\\"%_cubes\\\", MSGLEVEL_CLIENTCRAP) \\\\; Irssi::active_win->print( do { my \\\\$y = \\\\$_*6 \\\\; join \'\', map { my \\\\$x = \\\\$_ \\\\; map { \\\"%x\\\\$x\\\\$_\\\\$x\\\\$_\\\" } @{[\'0\'..\'9\',\'A\'..\'Z\']}[\\\\$y .. \\\\$y+5] } 1..6 }, MSGLEVEL_NEVER | MSGLEVEL_CLIENTCRAP) for 0..5 \\\\; Irssi::active_win->print(\\\"%_grays\\\", MSGLEVEL_CLIENTCRAP) \\\\; Irssi::active_win->print( do { join \'\', map { \\\"%x7\\\\${_}7\\\\$_\\\" } \'A\'..\'X\' }, MSGLEVEL_NEVER | MSGLEVEL_CLIENTCRAP) \\\\; Irssi::active_win->print(\\\"%_mIRC extended colours\\\", MSGLEVEL_CLIENTCRAP) \\\\; my \\\\$x \\\\; \\\\$x .= sprintf \\\"\\00399,%02d%02d\\\",\\\\$_,\\\\$_ for 0..15 \\\\; Irssi::active_win->print(\\\\$x, MSGLEVEL_NEVER | MSGLEVEL_CLIENTCRAP) \\\\; for my \\\\$z (0..6) { my \\\\$x \\\\; \\\\$x .= sprintf \\\"\\00399,%02d%02d\\\",\\\\$_,\\\\$_ for 16+(\\\\$z*12)..16+(\\\\$z*12)+11 \\\\; Irssi::active_win->print(\\\\$x, MSGLEVEL_NEVER | MSGLEVEL_CLIENTCRAP) }\";    DATE        = \"TIME\";    DEHIGHLIGHT = \"DEHILIGHT\";    DESCRIBE    = \"ACTION\"; '),('irssi','1.1.1','05fd64dd1611610e2efe596718c657343db839e1','ailin-nemui','improve rawlog perf','rawlog.c','177','41','7','11','MODIFY','@@ -48,8 +48,8 @@ void rawlog_destroy(RAWLOG_REC *rawlog)  {  	g_return_if_fail(rawlog != NULL);   -	g_slist_foreach(rawlog->lines, (GFunc) g_free, NULL); -	g_slist_free(rawlog->lines); +	g_queue_foreach(rawlog->lines, (GFunc) g_free, NULL); +	g_queue_free(rawlog->lines);    	if (rawlog->logging) {  		write_buffer_flush(); @@ -61,12 +61,8 @@ void rawlog_destroy(RAWLOG_REC *rawlog)  /* NOTE! str must be dynamically allocated and must not be freed after! */  static void rawlog_add(RAWLOG_REC *rawlog, char *str)  { -	if (rawlog->nlines < rawlog_lines || rawlog_lines <= 2) -		rawlog->nlines++; -	else { -		void *tmp = rawlog->lines->data; -		rawlog->lines = g_slist_remove(rawlog->lines, -					       rawlog->lines->data); +	if (rawlog->lines->length >= rawlog_lines && rawlog_lines > 0) { +		void *tmp = g_queue_pop_tail(rawlog->lines);  		g_free(tmp);  	}   @@ -75,7 +71,7 @@ static void rawlog_add(RAWLOG_REC *rawlog, char *str)  		write_buffer(rawlog->handle, \"\\n\", 1);  	}   -	rawlog->lines = g_slist_append(rawlog->lines, str); +	g_queue_push_head(rawlog->lines, str);  	signal_emit_id(signal_rawlog, 2, rawlog, str);  }   @@ -105,10 +101,10 @@ void rawlog_redirect(RAWLOG_REC *rawlog, const char *str)    static void rawlog_dump(RAWLOG_REC *rawlog, int f)  { -	GSList *tmp; +	GList *tmp;  	ssize_t ret = 0;   -	for (tmp = rawlog->lines; ret != -1 && tmp != NULL; tmp = tmp->next) { +	for (tmp = rawlog->lines->tail; ret != -1 && tmp != NULL; tmp = tmp->prev) {  		ret = write(f, tmp->data, strlen((char *) tmp->data));                  if (ret != -1)                          ret = write(f, \"\\n\", 1); '),('irssi','1.1.1','05fd64dd1611610e2efe596718c657343db839e1','ailin-nemui','improve rawlog perf','rawlog.h','16','0','1','2','MODIFY','@@ -5,8 +5,7 @@ struct _RAWLOG_REC {  	int logging;  	int handle;   -        int nlines; -	GSList *lines; +	GQueue *lines;  };    RAWLOG_REC *rawlog_create(void); '),('irssi','1.1.1','05fd64dd1611610e2efe596718c657343db839e1','ailin-nemui','improve rawlog perf','perl-common.c','542','70','1','1','MODIFY','@@ -501,7 +501,7 @@ static void perl_log_item_fill_hash(HV *hv, LOG_ITEM_REC *item)  static void perl_rawlog_fill_hash(HV *hv, RAWLOG_REC *rawlog)  {  	(void) hv_store(hv, \"logging\", 7, newSViv(rawlog->logging), 0); -	(void) hv_store(hv, \"nlines\", 6, newSViv(rawlog->nlines), 0); +	(void) hv_store(hv, \"nlines\", 6, newSViv(rawlog->lines->length), 0);  }    static void perl_reconnect_fill_hash(HV *hv, RECONNECT_REC *reconnect) '),('irssi','1.1.1','95692d4d86c4a39697d16e937a452a662e6ba448','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 17 +#define IRSSI_ABI_VERSION 18    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.1.1','ff0daf5870909b250e377ffa438c4fe0ebc2f8ce','ailin-nemui','actually create the queue, too','rawlog.c','178','41','2','1','MODIFY','@@ -41,7 +41,8 @@ RAWLOG_REC *rawlog_create(void)  	RAWLOG_REC *rec;    	rec = g_new0(RAWLOG_REC, 1); -        return rec; +	rec->lines = g_queue_new(); +	return rec;  }    void rawlog_destroy(RAWLOG_REC *rawlog) '),('irssi','1.1.1','1e2547eb92e8a681540925a0da3867a879afd696','ailin-nemui','fixup perl side','Rawlog.xs','46','1','2','2','MODIFY','@@ -19,9 +19,9 @@ void  rawlog_get_lines(rawlog)  	Irssi::Rawlog rawlog  PREINIT: -	GSList *tmp; +	GList *tmp;  PPCODE: -	for (tmp = rawlog->lines; tmp != NULL; tmp = tmp->next) { +	for (tmp = rawlog->lines->tail; tmp != NULL; tmp = tmp->prev) {  		XPUSHs(sv_2mortal(new_pv(tmp->data)));  	}   '),('irssi','1.1.1','2200bd3656f0790554bf3c949cce5224ec588a44','ailin-nemui','Make /1/2/3/... a setting','irssi.conf','235','0','0','99','MODIFY','@@ -160,105 +160,6 @@ aliases = {    WN          = \"WINDOW NEW HIDDEN\";    WQUERY      = \"QUERY -window\";    WW          = \"WHOWAS\"; -  1           = \"WINDOW GOTO 1\"; -  2           = \"WINDOW GOTO 2\"; -  3           = \"WINDOW GOTO 3\"; -  4           = \"WINDOW GOTO 4\"; -  5           = \"WINDOW GOTO 5\"; -  6           = \"WINDOW GOTO 6\"; -  7           = \"WINDOW GOTO 7\"; -  8           = \"WINDOW GOTO 8\"; -  9           = \"WINDOW GOTO 9\"; -  10          = \"WINDOW GOTO 10\"; -  11          = \"WINDOW GOTO 11\"; -  12          = \"WINDOW GOTO 12\"; -  13          = \"WINDOW GOTO 13\"; -  14          = \"WINDOW GOTO 14\"; -  15          = \"WINDOW GOTO 15\"; -  16          = \"WINDOW GOTO 16\"; -  17          = \"WINDOW GOTO 17\"; -  18          = \"WINDOW GOTO 18\"; -  19          = \"WINDOW GOTO 19\"; -  20          = \"WINDOW GOTO 20\"; -  21          = \"WINDOW GOTO 21\"; -  22          = \"WINDOW GOTO 22\"; -  23          = \"WINDOW GOTO 23\"; -  24          = \"WINDOW GOTO 24\"; -  25          = \"WINDOW GOTO 25\"; -  26          = \"WINDOW GOTO 26\"; -  27          = \"WINDOW GOTO 27\"; -  28          = \"WINDOW GOTO 28\"; -  29          = \"WINDOW GOTO 29\"; -  30          = \"WINDOW GOTO 30\"; -  31          = \"WINDOW GOTO 31\"; -  32          = \"WINDOW GOTO 32\"; -  33          = \"WINDOW GOTO 33\"; -  34          = \"WINDOW GOTO 34\"; -  35          = \"WINDOW GOTO 35\"; -  36          = \"WINDOW GOTO 36\"; -  37          = \"WINDOW GOTO 37\"; -  38          = \"WINDOW GOTO 38\"; -  39          = \"WINDOW GOTO 39\"; -  40          = \"WINDOW GOTO 40\"; -  41          = \"WINDOW GOTO 41\"; -  42          = \"WINDOW GOTO 42\"; -  43          = \"WINDOW GOTO 43\"; -  44          = \"WINDOW GOTO 44\"; -  45          = \"WINDOW GOTO 45\"; -  46          = \"WINDOW GOTO 46\"; -  47          = \"WINDOW GOTO 47\"; -  48          = \"WINDOW GOTO 48\"; -  49          = \"WINDOW GOTO 49\"; -  50          = \"WINDOW GOTO 50\"; -  51          = \"WINDOW GOTO 51\"; -  52          = \"WINDOW GOTO 52\"; -  53          = \"WINDOW GOTO 53\"; -  54          = \"WINDOW GOTO 54\"; -  55          = \"WINDOW GOTO 55\"; -  56          = \"WINDOW GOTO 56\"; -  57          = \"WINDOW GOTO 57\"; -  58          = \"WINDOW GOTO 58\"; -  59          = \"WINDOW GOTO 59\"; -  60          = \"WINDOW GOTO 60\"; -  61          = \"WINDOW GOTO 61\"; -  62          = \"WINDOW GOTO 62\"; -  63          = \"WINDOW GOTO 63\"; -  64          = \"WINDOW GOTO 64\"; -  65          = \"WINDOW GOTO 65\"; -  66          = \"WINDOW GOTO 66\"; -  67          = \"WINDOW GOTO 67\"; -  68          = \"WINDOW GOTO 68\"; -  69          = \"WINDOW GOTO 69\"; -  70          = \"WINDOW GOTO 70\"; -  71          = \"WINDOW GOTO 71\"; -  72          = \"WINDOW GOTO 72\"; -  73          = \"WINDOW GOTO 73\"; -  74          = \"WINDOW GOTO 74\"; -  75          = \"WINDOW GOTO 75\"; -  76          = \"WINDOW GOTO 76\"; -  77          = \"WINDOW GOTO 77\"; -  78          = \"WINDOW GOTO 78\"; -  79          = \"WINDOW GOTO 79\"; -  80          = \"WINDOW GOTO 80\"; -  81          = \"WINDOW GOTO 81\"; -  82          = \"WINDOW GOTO 82\"; -  83          = \"WINDOW GOTO 83\"; -  84          = \"WINDOW GOTO 84\"; -  85          = \"WINDOW GOTO 85\"; -  86          = \"WINDOW GOTO 86\"; -  87          = \"WINDOW GOTO 87\"; -  88          = \"WINDOW GOTO 88\"; -  89          = \"WINDOW GOTO 89\"; -  90          = \"WINDOW GOTO 90\"; -  91          = \"WINDOW GOTO 91\"; -  92          = \"WINDOW GOTO 92\"; -  93          = \"WINDOW GOTO 93\"; -  94          = \"WINDOW GOTO 94\"; -  95          = \"WINDOW GOTO 95\"; -  96          = \"WINDOW GOTO 96\"; -  97          = \"WINDOW GOTO 97\"; -  98          = \"WINDOW GOTO 98\"; -  99          = \"WINDOW GOTO 99\";  };    statusbar = { '),('irssi','1.1.1','2200bd3656f0790554bf3c949cce5224ec588a44','ailin-nemui','Make /1/2/3/... a setting','fe-core-commands.c','256','53','2','1','MODIFY','@@ -249,6 +249,7 @@ static void event_default_command(const char *data, void *server,  	long diff;    	cmdchars = settings_get_str(\"cmdchars\"); +	signal_stop();    	ptr = data;  	while (*ptr != \'\\0\' && *ptr != \' \') { @@ -338,7 +339,7 @@ void fe_core_commands_init(void)    	signal_add(\"send command\", (SIGNAL_FUNC) event_command);  	signal_add_last(\"send command\", (SIGNAL_FUNC) event_command_last); -	signal_add(\"default command\", (SIGNAL_FUNC) event_default_command); +	signal_add_last(\"default command\", (SIGNAL_FUNC) event_default_command);  	signal_add(\"error command\", (SIGNAL_FUNC) event_cmderror);  	signal_add(\"list subcommands\", (SIGNAL_FUNC) event_list_subcommands);   '),('irssi','1.1.1','2200bd3656f0790554bf3c949cce5224ec588a44','ailin-nemui','Make /1/2/3/... a setting','window-commands.c','724','182','15','0','MODIFY','@@ -867,9 +867,22 @@ static void cmd_foreach_window(const char *data)  	g_free(str);  }   +static void cmd_window_default_command(const char *data, SERVER_REC *server, WI_ITEM_REC *item) +{ +	if (!is_numeric(data, 0) || +	    !settings_get_bool(\"window_number_commands\")) { +		return; +	} +	signal_emit(\"command window refnum\", 3, data, server, item); +	signal_stop(); +} +  void window_commands_init(void)  {  	settings_add_bool(\"lookandfeel\", \"active_window_ignore_refnum\", TRUE); +	settings_add_bool(\"misc\", \"window_number_commands\", TRUE); + +	signal_add(\"default command\", (SIGNAL_FUNC) cmd_window_default_command);    	command_bind(\"window\", NULL, (SIGNAL_FUNC) cmd_window);  	command_bind(\"window new\", NULL, (SIGNAL_FUNC) cmd_window_new); @@ -944,4 +957,6 @@ void window_commands_deinit(void)  	command_unbind(\"layout save\", (SIGNAL_FUNC) windows_layout_save);  	command_unbind(\"layout reset\", (SIGNAL_FUNC) windows_layout_reset);  	command_unbind(\"foreach window\", (SIGNAL_FUNC) cmd_foreach_window); + +	signal_remove(\"default command\", (SIGNAL_FUNC) cmd_window_default_command);  } '),('irssi','1.1.1','d2dbcc19993a8cf33258d0989b05305be34336a4','ailin-nemui','Route notices intended for channels into the channel','fe-irc-messages.c','249','46','35','1','MODIFY','@@ -202,6 +202,23 @@ static void sig_message_irc_action(IRC_SERVER_REC *server, const char *msg,  static void sig_message_own_notice(IRC_SERVER_REC *server, const char *msg,  				   const char *target)  { +	if (*msg == \'[\') { +		/* check if this is a cnotice */ +		char *end, *channel; +		end = strpbrk(msg, \" ,]\"); +		if (end != NULL && *end == \']\') { +			channel = g_strndup(msg + 1, end - msg - 1); +			if (server_ischannel(SERVER(server), channel)) { +				printformat(server, channel, +				            MSGLEVEL_NOTICES | MSGLEVEL_NOHILIGHT | MSGLEVEL_NO_ACT, +				            IRCTXT_OWN_NOTICE, target, msg); +				g_free(channel); +				return; +			} +			g_free(channel); +			/* fall through. */ +		} +	}  	printformat(server, fe_channel_skip_prefix(server, target), MSGLEVEL_NOTICES |  		    MSGLEVEL_NOHILIGHT | MSGLEVEL_NO_ACT,  		    IRCTXT_OWN_NOTICE, target, msg); @@ -233,11 +250,28 @@ static void sig_message_irc_notice(SERVER_REC *server, const char *msg,  			      msg, &level, TRUE))  		return;   -        if (server_ischannel(SERVER(server), target)) { +	if (server_ischannel(SERVER(server), target)) {  		/* notice in some channel */  		printformat(server, target, level,  			    IRCTXT_NOTICE_PUBLIC, nick, oldtarget, msg);  	} else { +		if (*msg == \'[\') { +			/* check if this is a cnotice */ +			char *end, *channel; +			end = strpbrk(msg, \" ,]\"); +			if (end != NULL && *end == \']\') { +				channel = g_strndup(msg + 1, end - msg - 1); +				if (server_ischannel(SERVER(server), channel)) { +					printformat(server, channel, level, IRCTXT_NOTICE_PRIVATE, +					            nick, address, msg); +					g_free(channel); +					return; +				} +				g_free(channel); +				/* fall through. */ +			} +		} +  		/* private notice */  		privmsg_get_query(SERVER(server), nick, FALSE,  				  MSGLEVEL_NOTICES); '),('irssi','1.1.1','08ac2ee5beebdfd374caccf76a7e63da67b40798','ailin-nemui','refactor cnotice test into function','fe-irc-messages.c','241','46','24','32','MODIFY','@@ -199,29 +199,31 @@ static void sig_message_irc_action(IRC_SERVER_REC *server, const char *msg,  	g_free_not_null(freemsg);  }   -static void sig_message_own_notice(IRC_SERVER_REC *server, const char *msg, -				   const char *target) +static char *notice_channel_context(SERVER_REC *server, const char *msg)  {  	if (*msg == \'[\') { -		/* check if this is a cnotice */  		char *end, *channel;  		end = strpbrk(msg, \" ,]\");  		if (end != NULL && *end == \']\') {  			channel = g_strndup(msg + 1, end - msg - 1);  			if (server_ischannel(SERVER(server), channel)) { -				printformat(server, channel, -				            MSGLEVEL_NOTICES | MSGLEVEL_NOHILIGHT | MSGLEVEL_NO_ACT, -				            IRCTXT_OWN_NOTICE, target, msg); -				g_free(channel); -				return; +				return channel;  			}  			g_free(channel); -			/* fall through. */  		}  	} -	printformat(server, fe_channel_skip_prefix(server, target), MSGLEVEL_NOTICES | -		    MSGLEVEL_NOHILIGHT | MSGLEVEL_NO_ACT, -		    IRCTXT_OWN_NOTICE, target, msg); +	return NULL; +} + +static void sig_message_own_notice(IRC_SERVER_REC *server, const char *msg, const char *target) +{ +	char *channel; +	/* check if this is a cnotice */ +	channel = notice_channel_context((SERVER_REC *) server, msg); +	printformat(server, channel != NULL ? channel : fe_channel_skip_prefix(server, target), +	            MSGLEVEL_NOTICES | MSGLEVEL_NOHILIGHT | MSGLEVEL_NO_ACT, IRCTXT_OWN_NOTICE, +	            target, msg); +	g_free(channel);  }    static void sig_message_irc_notice(SERVER_REC *server, const char *msg, @@ -255,28 +257,18 @@ static void sig_message_irc_notice(SERVER_REC *server, const char *msg,  		printformat(server, target, level,  			    IRCTXT_NOTICE_PUBLIC, nick, oldtarget, msg);  	} else { -		if (*msg == \'[\') { -			/* check if this is a cnotice */ -			char *end, *channel; -			end = strpbrk(msg, \" ,]\"); -			if (end != NULL && *end == \']\') { -				channel = g_strndup(msg + 1, end - msg - 1); -				if (server_ischannel(SERVER(server), channel)) { -					printformat(server, channel, level, IRCTXT_NOTICE_PRIVATE, -					            nick, address, msg); -					g_free(channel); -					return; -				} -				g_free(channel); -				/* fall through. */ -			} +		char *channel; +		/* check if this is a cnotice */ +		channel = notice_channel_context(server, msg); + +		if (channel == NULL) { +			/* private notice */ +			privmsg_get_query(SERVER(server), nick, FALSE, MSGLEVEL_NOTICES);  		} +		printformat(server, channel == NULL ? nick : channel, level, IRCTXT_NOTICE_PRIVATE, +		            nick, address, msg);   -		/* private notice */ -		privmsg_get_query(SERVER(server), nick, FALSE, -				  MSGLEVEL_NOTICES); -		printformat(server, nick, level, -			    IRCTXT_NOTICE_PRIVATE, nick, address, msg); +		g_free(channel);  	}  }   '),('irssi','1.1.1','8b1afbd3557e605f35cf4dab16d49cb4c89ca496','ailin-nemui','revert core changes','core.c','224','26','0','10','MODIFY','@@ -73,22 +73,12 @@ const char *get_irssi_dir(void)          return irssi_dir;  }   -void set_irssi_dir(char *const s) -{ -	irssi_dir = s; -} -  /* return full path for ~/.irssi/config */  const char *get_irssi_config(void)  {          return irssi_config_file;  }   -void set_irssi_config(char *const s) -{ -	irssi_config_file = s; -} -  static void sig_reload_config(int signo)  {          reload_config = TRUE; '),('irssi','1.1.1','8b1afbd3557e605f35cf4dab16d49cb4c89ca496','ailin-nemui','revert core changes','core.h','9','0','0','3','MODIFY','@@ -16,9 +16,6 @@ extern int irssi_init_finished; /* TRUE after \"irssi init finished\" signal is se  extern int reload_config; /* TRUE after received SIGHUP. */  extern time_t client_start_time;   -void set_irssi_dir(char *const); -void set_irssi_config(char *const); -  void core_preinit(const char *path);    void core_register_options(void); '),('irssi','1.1.1','8b1afbd3557e605f35cf4dab16d49cb4c89ca496','ailin-nemui','revert core changes','channel-events.c','276','68','13','40','MODIFY','@@ -29,9 +29,6 @@  #include \"irc-servers.h\"  #include \"irc-channels.h\"   -static void set_topic_info(CHANNEL_REC *const, char const *const, -		time_t const); -  static void check_join_failure(IRC_SERVER_REC *server, const char *channel)  {  	CHANNEL_REC *chanrec; @@ -130,51 +127,27 @@ static void channel_change_topic(IRC_SERVER_REC *server, const char *channel,    	chanrec = channel_find(SERVER(server), channel);  	if (chanrec == NULL) return; - -	g_free_and_null(chanrec->topic); -	g_free_and_null(chanrec->topic_by); -	chanrec->topic_time = 0; - -	/* the topic may be sent out encoded, so we need to +	/* the topic may be send out encoded, so we need to  	   recode it back or /topic <tab> will not work properly */  	recoded = recode_in(SERVER(server), topic, channel); -	if (recoded == NULL || *recoded == \'\\0\') { -		signal_emit(\"channel topic changed\", 1, chanrec); -		g_free(recoded); -		return; +	if (topic != NULL) { +		g_free_not_null(chanrec->topic); +		chanrec->topic = recoded == NULL ? NULL : g_strdup(recoded);  	} +	g_free(recoded);   -	chanrec->topic = recoded; -	set_topic_info(chanrec, setby, settime); - -	signal_emit(\"channel topic changed\", 1, chanrec); -} - -static void channel_change_topic_info(IRC_SERVER_REC *server, -				 const char *channel, const char *setby, time_t settime) -{ -	CHANNEL_REC *chanrec; - -	chanrec = channel_find(SERVER(server), channel); -	if (chanrec == NULL) return; - -	g_free_and_null(chanrec->topic_by); -	chanrec->topic_time = 0; - -	set_topic_info(chanrec, setby, settime); - -	signal_emit(\"channel topic changed\", 1, chanrec); -} - -static void set_topic_info(CHANNEL_REC *const chanrec, char const *const setby, -		time_t const settime) -{ +	g_free_not_null(chanrec->topic_by);  	chanrec->topic_by = g_strdup(setby); -	if (chanrec->topic_by != NULL) { + +	if (chanrec->topic_by == NULL) {  		/* ensure invariant topic_time > 0 <=> topic_by != NULL.  		   this could be triggered by a topic command without sender */ +		chanrec->topic_time = 0; +	} else {  		chanrec->topic_time = settime;  	} + +	signal_emit(\"channel topic changed\", 1, chanrec);  }    static void event_topic_get(IRC_SERVER_REC *server, const char *data) @@ -214,7 +187,7 @@ static void event_topic_info(IRC_SERVER_REC *server, const char *data)  				  &topicby, &topictime);    	t = (time_t) atol(topictime); -	channel_change_topic_info(server, channel, topicby, t); +	channel_change_topic(server, channel, NULL, topicby, t);  	g_free(params);  }   '),('irssi','1.1.1','8b1afbd3557e605f35cf4dab16d49cb4c89ca496','ailin-nemui','revert core changes','test-channel-events.c','146','10','4','2','MODIFY','@@ -31,6 +31,7 @@  #include <settings.h>  #include <signals.h>  #include <time.h> +#include <args.h>    #define MODULE_NAME \"test-channel-events\"   @@ -87,10 +88,11 @@ int main(int argc, char **argv)    	g_test_init(&argc, &argv, NULL);   +	core_preinit(*argv); +	irssi_gui = IRSSI_GUI_NONE; +  	modules_init();  	signals_init(); -	set_irssi_dir(\"/tmp/irssi\"); -	set_irssi_config(\"/tmp/irssi/config\");  	settings_init();  	recode_init();  	channel_events_init(); '),('irssi','1.1.1','80f9f16939b65536c5fc3ae1fedb885b84c82855','ailin-nemui','Show the proper TXT when topic was unset','fe-irc-commands.c','332','80','1','1','MODIFY','@@ -305,7 +305,7 @@ static void cmd_topic(const char *data, SERVER_REC *server, WI_ITEM_REC *item)  	if (channel == NULL) return;    	printformat(server, channel->visible_name, MSGLEVEL_CRAP, -		    channel->topic == NULL ? IRCTXT_NO_TOPIC : IRCTXT_TOPIC, +		    (channel->topic == NULL || *channel->topic == \'\\0\') ? IRCTXT_NO_TOPIC : IRCTXT_TOPIC,  		    channel->visible_name, channel->topic);    	if (channel->topic_time > 0) { '),('irssi','1.1.1','cdcb50f413537177ff50478b766b570fb7bae057','ailin-nemui','add a setting','fe-irc-messages.c','244','47','6','1','MODIFY','@@ -201,12 +201,15 @@ static void sig_message_irc_action(IRC_SERVER_REC *server, const char *msg,    static char *notice_channel_context(SERVER_REC *server, const char *msg)  { +	if (!settings_get_bool(\"notice_channel_context\")) +		return NULL; +  	if (*msg == \'[\') {  		char *end, *channel;  		end = strpbrk(msg, \" ,]\");  		if (end != NULL && *end == \']\') {  			channel = g_strndup(msg + 1, end - msg - 1); -			if (server_ischannel(SERVER(server), channel)) { +			if (server_ischannel(server, channel)) {  				return channel;  			}  			g_free(channel); @@ -294,6 +297,8 @@ static void sig_message_irc_ctcp(IRC_SERVER_REC *server, const char *cmd,    void fe_irc_messages_init(void)  { +	settings_add_bool(\"misc\", \"notice_channel_context\", TRUE); +          signal_add_last(\"message own_public\", (SIGNAL_FUNC) sig_message_own_public);          signal_add_last(\"message irc op_public\", (SIGNAL_FUNC) sig_message_irc_op_public);          signal_add_last(\"message irc own_wall\", (SIGNAL_FUNC) sig_message_own_wall); '),('irssi','1.1.1','08b4d6c031fbc816f35e2cd1d57adfbb6ba4e3db','Will Storey','Fix some space indentation','hilight-text.c','543','156','13','13','MODIFY','@@ -45,7 +45,7 @@ static void reset_level_cache(void)  {  	GSList *tmp;   -        never_hilight_level = MSGLEVEL_ALL & ~default_hilight_level; +	never_hilight_level = MSGLEVEL_ALL & ~default_hilight_level;  	for (tmp = hilights; tmp != NULL; tmp = tmp->next) {  		HILIGHT_REC *rec = tmp->data;   @@ -180,7 +180,7 @@ static HILIGHT_REC *hilight_find(const char *text, char **channels)  		/* check that channels match */  		for (chan = channels; *chan != NULL; chan++) {  			if (strarray_find(rec->channels, *chan) == -1) -                                break; +				break;  		}    		if (*chan == NULL) @@ -239,10 +239,10 @@ static gboolean hilight_match_text(HILIGHT_REC *rec, const char *text,  HILIGHT_REC *hilight_match(SERVER_REC *server, const char *channel,  			   const char *nick, const char *address,  			   int level, const char *str, -                           int *match_beg, int *match_end) +			   int *match_beg, int *match_end)  {  	GSList *tmp; -        CHANNEL_REC *chanrec; +	CHANNEL_REC *chanrec;  	NICK_REC *nickrec;    	g_return_val_if_fail(str != NULL, NULL); @@ -251,12 +251,12 @@ HILIGHT_REC *hilight_match(SERVER_REC *server, const char *channel,  		return NULL;    	if (nick != NULL) { -                /* check nick mask hilights */ +		/* check nick mask hilights */  		chanrec = channel_find(server, channel);  		nickrec = chanrec == NULL ? NULL :  			nicklist_find(chanrec, nick);  		if (nickrec != NULL) { -                        HILIGHT_REC *rec; +			HILIGHT_REC *rec;    			if (nickrec->host == NULL)  				nicklist_set_host(chanrec, nickrec, address); @@ -388,10 +388,10 @@ static void sig_print_text(TEXT_DEST_REC *dest, const char *text,  		/* end of the line */  		pos = strip_real_length(text, hilight_end,  					&color_pos, &color_len); -		if (color_pos > 0) +		if (color_pos > 0) {  			g_string_append_len(tmp, text + color_pos, color_len); -                else { -                        /* no colors in line, change back to default */ +		} else { +			/* no colors in line, change back to default */  			g_string_append_c(tmp, 4);  			g_string_append_c(tmp, FORMAT_STYLE_DEFAULTS);  		} @@ -413,7 +413,7 @@ HILIGHT_REC *hilight_match_nick(SERVER_REC *server, const char *channel,  			 const char *nick, const char *address,  			 int level, const char *msg)  { -        HILIGHT_REC *rec; +	HILIGHT_REC *rec;    	rec = hilight_match(server, channel, nick, address,  				level, msg, NULL, NULL); @@ -431,7 +431,7 @@ static void read_hilight_config(void)    	node = iconfig_node_traverse(\"hilights\", FALSE);  	if (node == NULL) { -                reset_cache(); +		reset_cache();  		return;  	}   @@ -545,8 +545,8 @@ static void cmd_hilight_show(void)  }    /* SYNTAX: HILIGHT [-nick | -word | -line] [-mask | -full | -matchcase | -regexp] -                   [-color <color>] [-actcolor <color>] [-level <level>] -		   [-network <network>] [-channels <channels>] <text> */ +   [-color <color>] [-actcolor <color>] [-level <level>] +   [-network <network>] [-channels <channels>] <text> */  static void cmd_hilight(const char *data)  {  	GHashTable *optlist; '),('irssi','1.1.1','81f3d6dbc1133bc72ec1f3211e7eef7027bae157','Will Storey','Comment colour code meaning','formats.c','1135','354','4','1','MODIFY','@@ -1121,7 +1121,7 @@ int strip_real_length(const char *str, int len,  		*last_color_len = -1;    	while (*str != \'\\0\') { -		if (*str == 3) { +		if (*str == 3) { /* mIRC color */  			const char *mircstart = str;    			if (last_color_pos != NULL) @@ -1132,6 +1132,9 @@ int strip_real_length(const char *str, int len,  				*last_color_len = (int) (str-mircstart);    		} else if (*str == 4 && str[1] != \'\\0\') { +			/* We expect 4 to indicate an internal Irssi color code. However 4 +			 * also means hex color, an alternative to mIRC color codes. We +			 * don\'t support those. */  #ifdef TERM_TRUECOLOR  			if (str[1] == FORMAT_COLOR_24 && str[2] != \'\\0\') {  				if (str[3] == \'\\0\') str++; '),('irssi','1.1.1','da15279fa3ce8a965f6d77e4483811ce94a8f9ea','ailin-nemui','fix flood test libs','Makefile.am','32','0','1','2','MODIFY','@@ -33,8 +33,7 @@ test_796_LDADD = \\  	../../../src/fe-common/core/libfe_common_core.a \\  	../../../src/core/libcore.a \\  	../../../src/lib-config/libirssi_config.a \\ -	@GLIB_LIBS@ \\ -	@OPENSSL_LIBS@ +	@PROG_LIBS@    test_796_SOURCES = \\  	test-796.c '),('irssi','1.1.1','cbc27062e7f7d501623ee52614bc8012f1d5a97a','ailin-nemui','fix duplicate include guard','fe-settings.h','1','0','2','2','MODIFY','@@ -1,5 +1,5 @@ -#ifndef __FE_CHANNELS_H -#define __FE_CHANNELS_H +#ifndef __FE_SETTINGS_H +#define __FE_SETTINGS_H    void fe_settings_set_print(const char *key);   '),('irssi','1.1.1','f11b629b2fa65ce355ce122c7c1482e8cba229db','Doug Freed','Fix issues pointed out by e38774cc','commands.c','711','187','2','2','MODIFY','@@ -305,7 +305,7 @@ void command_runsub(const char *cmd, const char *data,    	if (*data == \'\\0\') {                  /* no subcommand given - list the subcommands */ -		signal_emit(\"list subcommands\", 2, cmd); +		signal_emit(\"list subcommands\", 1, cmd);  		return;  	}   @@ -891,7 +891,7 @@ static void parse_command(const char *command, int expand_aliases,  	if (rec != NULL && !cmd_protocol_match(rec, server)) {  		g_free(orig);   -		signal_emit(\"error command\", 2, +		signal_emit(\"error command\", 1,  			    GINT_TO_POINTER(server == NULL ?  					    CMDERR_NOT_CONNECTED :  					    CMDERR_ILLEGAL_PROTO)); '),('irssi','1.1.1','2093530e7590f91608d43f4617d8faf76ebf56ee','vague666','Make it possible to only autolog saved channels','fe-log.c','589','151','7','0','MODIFY','@@ -41,6 +41,8 @@  #include \"printtext.h\"  #include \"fe-common-core.h\"   +#include \"channels-setup.h\" +  /* close autologs after 5 minutes of inactivity */  #define AUTOLOG_INACTIVITY_CLOSE (60*5)   @@ -486,6 +488,10 @@ static void autolog_open_check(TEXT_DEST_REC *dest)    	deftarget = server ? server->nick : \"unknown\";   +	/* log only channels that have been saved to the config */ +	if (settings_get_bool(\"autolog_only_saved_channels\") && channel_setup_find(target, server_tag) == NULL) +		return; +  	if (autolog_ignore_targets != NULL &&  	    strarray_find_dest(autolog_ignore_targets, dest))  		return; @@ -722,6 +728,7 @@ void fe_log_init(void)  	settings_add_bool(\"log\", \"awaylog_colors\", TRUE);          settings_add_bool(\"log\", \"autolog\", FALSE);  	settings_add_bool(\"log\", \"autolog_colors\", FALSE); +	settings_add_bool(\"log\", \"autolog_only_saved_channels\", FALSE);          settings_add_str(\"log\", \"autolog_path\", \"~/irclogs/$tag/$0.log\");  	settings_add_level(\"log\", \"autolog_level\", \"all -crap -clientcrap -ctcps\");          settings_add_str(\"log\", \"log_theme\", \"\"); '),('irssi','1.1.1','3061f5d848f6f487e8c73a5d5846b7a860ca5466','vague666','make sure only channels are checked','fe-log.c','591','152','3','1','MODIFY','@@ -24,6 +24,7 @@  #include \"commands.h\"  #include \"chat-protocols.h\"  #include \"servers.h\" +#include \"channels.h\"  #include \"levels.h\"  #include \"misc.h\"  #include \"log.h\" @@ -489,7 +490,8 @@ static void autolog_open_check(TEXT_DEST_REC *dest)  	deftarget = server ? server->nick : \"unknown\";    	/* log only channels that have been saved to the config */ -	if (settings_get_bool(\"autolog_only_saved_channels\") && channel_setup_find(target, server_tag) == NULL) +	if (settings_get_bool(\"autolog_only_saved_channels\") && IS_CHANNEL(window_item_find(server, target)) +		&& channel_setup_find(target, server_tag) == NULL)  		return;    	if (autolog_ignore_targets != NULL && '),('irssi','1.1.1','f7966d9c081641ff5b1adca2bd8c217a331bcaa6','vague666','allow activity_hide_targets to hide activity in itemless windows','fe-common-core.c','398','48','3','1','MODIFY','@@ -480,7 +480,9 @@ gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)  	g_return_val_if_fail(array != NULL, FALSE);  	g_return_val_if_fail(dest != NULL, FALSE);  	g_return_val_if_fail(dest->window != NULL, FALSE); -	g_return_val_if_fail(dest->target != NULL, FALSE); + +	if (dest->target == NULL) { +		return strarray_find(array, dest->window->name) != -1 ? TRUE : FALSE;    	item = window_item_find_window(dest->window, dest->server, dest->target);  	if (item == NULL) { '),('irssi','1.1.1','f7966d9c081641ff5b1adca2bd8c217a331bcaa6','vague666','allow activity_hide_targets to hide activity in itemless windows','window-activity.c','119','26','1','1','MODIFY','@@ -86,7 +86,7 @@ static void sig_hilight_text(TEXT_DEST_REC *dest, const char *msg)  			DATA_LEVEL_MSG : DATA_LEVEL_TEXT;  	}   -	if (hide_targets != NULL && (dest->level & MSGLEVEL_HILIGHT) == 0 && dest->target != NULL) { +	if (hide_targets != NULL && (dest->level & MSGLEVEL_HILIGHT) == 0) {  		/* check for both target and tag/target */  		if (strarray_find_dest(hide_targets, dest))  			return; '),('irssi','1.1.1','ec577f9265fff6b36b0e25c3e1a04ef8f0aee9d6','vague666','typo','fe-common-core.c','398','66','1','1','MODIFY','@@ -481,7 +481,7 @@ gboolean strarray_find_dest(char **array, const TEXT_DEST_REC *dest)  	g_return_val_if_fail(dest != NULL, FALSE);  	g_return_val_if_fail(dest->window != NULL, FALSE);   -	if (dest->target == NULL) { +	if (dest->target == NULL)  		return strarray_find(array, dest->window->name) != -1 ? TRUE : FALSE;    	item = window_item_find_window(dest->window, dest->server, dest->target); '),('irssi','1.1.1','2847b751e359bde8eb5dc3d89f57575c3b5f0948','ailin-nemui','design.txt is now sourced from website  also run syncdocs, fixes missing placeholder in startup-HOWTO','Makefile.am','17','0','1','0','MODIFY','@@ -3,6 +3,7 @@ man_MANS = \\    doc_DATA = \\  	capsicum.txt \\ +	design.html \\  	design.txt \\  	formats.txt \\  	manual.txt \\ '),('irssi','1.1.1','2847b751e359bde8eb5dc3d89f57575c3b5f0948','ailin-nemui','design.txt is now sourced from website  also run syncdocs, fixes missing placeholder in startup-HOWTO','design.html','137','1','166','0','ADD','@@ -0,0 +1,166 @@ +<base href=\'https://irssi.org/documentation/design/\'> +<h1>Design</h1> + +<p>Irssiâ€™s hierarchy is something like this:</p> + +<pre class=\"repl\" id=\"fig1\"><code class=\"language-ascidia\"> +        sub1 sub2 +           \\ / +      xxx  IRC       COMMON ICQ  yyy +       |    |           |    |    | +       \'----+-----:-----+----+----\' +                  | +                 GUI (gtk/gnome, qt/kde, text, none) +                  | +        sub1 sub2 | +           \\ /    | +      xxx  IRC    |  COMMON ICQ  yyy +       \'----+-----+-----+----+----\' +                  | +              COMMON UI +                  | +        sub1 sub2 | +           \\ /    | +      xxx  IRC    |    ICQ  yyy +       |    |     |     |    | +       \'----+-----+-----+----\' +                  | +                CORE +                / +       lib-config + +</code></pre> + +<p>(IRC, ICQ, xxx and yyy are chat protocols ..)</p> + +<p>(sub1 and sub2 are submodules of IRC module, like DCC and flood protect)</p> + +<p>Chat protocols and frontends are kept in separate modules. Common UI +and GUI modules also have the common parts which donâ€™t know anything +about the chat protocols. This should allow implementing modules to +whatever chat protocols and with whatever frontends easily.</p> + +<h2 id=\"signals\">Signals</h2> + +<p>Communication between different modules are done with â€œsignalsâ€. They are +not related to UNIX signals in any way, you could more like think of them +as â€œeventsâ€ - which might be a better name for them, but I donâ€™t really +want to change it anymore :)</p> + +<p>So, you send signal with <code>signal_emit()</code> and itâ€™s sent to all modules that +have grabbed it by calling <code>signal_add()</code> in their init function. For +example:</p> + +<div><div><pre><code>signal_emit(\"mysignal\", 1, \"hello\"); +</code></pre></div></div> + +<p>Sends a â€œmysignalâ€ function with one argument â€œhelloâ€ - before that, you +should have grabbed the signal somewhere else with:</p> + +<div><div><pre><code>static void sig_mysignal(const char *arg1) +{ +  /* arg1 contains \"hello\" */ +} + +signal_add(\"mysignal\", (SIGNAL_FUNC) sig_mysignal); +</code></pre></div></div> + +<p>There are three different <code>signal_add()</code> functions which you can use to +specify if you want to grab the signal first, â€œnormallyâ€ or last. You can +also stop the signal from going any further.</p> + +<p>Emitting signal with itâ€™s name creates a small overhead since it has to +look up the signalâ€™s numeric ID first, after which it looks up the signal +structure. This is done because if you call a signal <em>really</em> often, +itâ€™s faster to find it with itâ€™s numeric ID instead of the string. You +can use <code>signal_get_uniq_id()</code> macro to convert the signal name into ID - +youâ€™ll have to do this only once! - and use <code>signal_emit_id()</code> to emit the +signal. Donâ€™t bother to do this unless your signal is sent (or could be +sent) several times in a second.</p> + +<p>See <code>src/core/signals.h</code> for definition of the signal function, and +signals.txt for a list of signals.</p> + +<h2 id=\"lib-config\">lib-config</h2> + +<p>Irssi depends on this for reading and saving configuration. +(created by me for irssi)</p> + +<h2 id=\"core-module\">CORE module</h2> + +<p>Provides some functionality that all other modules can use:</p> +<ul> +  <li>signal handling</li> +  <li>keeping list of settings</li> +  <li>keeping list of /commands</li> +  <li>keeping track of loaded modules</li> +  <li>networking functions (with nonblocking connects, IPv6 support)</li> +  <li>handles connecting to servers</li> +  <li>raw logging of serverâ€™s input/output data</li> +  <li>/EVAL support</li> +  <li>fgets() like function line_split() without any maximum line limits</li> +  <li>command line parameter handling</li> +  <li>miscellaneous useful little functions</li> +  <li>handles logging</li> +</ul> + +<h2 id=\"common-ui-module\">COMMON UI module</h2> + +<ul> +  <li>knows basics about windows and window items (=channels, queries, ..)</li> +  <li>printtext() - parsing texts and feeding it for GUI to print.</li> +  <li>themes</li> +  <li>translation tables</li> +  <li>text hilighting</li> +  <li>command history</li> +  <li>user interface (/commands) for COREâ€™s functionality</li> +</ul> + +<h2 id=\"gui-modules\">GUI modules</h2> + +<ul> +  <li>all the rest of the functionality needed for a working client.</li> +</ul> + +<h2 id=\"irc-module\">IRC module</h2> + +<ul> +  <li>CORE +    <ul> +      <li>IRC specific /commands</li> +      <li>flood protecting commands sent to server</li> +      <li>creating IRC masks based on nick/address for bans, ignores, etc.</li> +      <li>keeps list of channels, nicks, channel modes, bans, etc.</li> +      <li>keeps list of servers, server settings, irc networks, +server reconnections and irc network splits</li> +      <li>redirection of commandsâ€™ replies</li> +      <li>lag detection</li> +      <li>ctcp support and flood protection</li> +      <li>Handles ignoring people</li> +    </ul> +  </li> +  <li>DCC +    <ul> +      <li>DCC chat, send and get</li> +    </ul> +  </li> +  <li>FLOOD +    <ul> +      <li>detects private or channel flooding and sends â€œfloodâ€ signal</li> +      <li>automatic ignoring when flooding</li> +    </ul> +  </li> +  <li>NOTIFYLIST +    <ul> +      <li>handles notifylist</li> +    </ul> +  </li> +</ul> + +<h2 id=\"irc-ui-module\">IRC UI module</h2> + +<ul> +  <li>placing channels and queries in windows</li> +  <li>nick completion</li> +  <li>printing infomation of some events</li> +</ul> \\ No newline at end of file '),('irssi','1.1.1','2847b751e359bde8eb5dc3d89f57575c3b5f0948','ailin-nemui','design.txt is now sourced from website  also run syncdocs, fixes missing placeholder in startup-HOWTO','startup-HOWTO.html','475','0','1','1','MODIFY','@@ -378,7 +378,7 @@ Ctrl-X                - set the next server in list active  <div><div><pre><code>/SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default)  </code></pre></div></div>   -<p>By default irssi logs to ~/irclogs/<servertag>/<target>.log. You can change this with</target></servertag></p> +<p>By default irssi logs to ~/irclogs/&lt;servertag&gt;/&lt;target&gt;.log. You can change this with</p>    <div><div><pre><code>/SET autolog_path ~/irclogs/$tag/$0.log (this is the default)  </code></pre></div></div> '),('irssi','1.1.1','2847b751e359bde8eb5dc3d89f57575c3b5f0948','ailin-nemui','design.txt is now sourced from website  also run syncdocs, fixes missing placeholder in startup-HOWTO','startup-HOWTO.txt','584','0','2','1','MODIFY','@@ -416,7 +416,8 @@ requests, etc). You can specify the logging level yourself with    /SET autolog_level ALL -CRAP -CLIENTCRAP -CTCPS (this is the default)   -By default irssi logs to ~/irclogs//.log. You can change this with +By default irssi logs to ~/irclogs/<servertag>/<target>.log. You can change +this with    /SET autolog_path ~/irclogs/$tag/$0.log (this is the default)   '),('irssi','1.1.1','2847b751e359bde8eb5dc3d89f57575c3b5f0948','ailin-nemui','design.txt is now sourced from website  also run syncdocs, fixes missing placeholder in startup-HOWTO','syncdocs.sh','84','7','5','0','MODIFY','@@ -7,6 +7,7 @@ site=https://irssi.org    faq=$site/documentation/faq/  howto=$site/documentation/startup/ +design=$site/documentation/design/    # remove everything until H1 and optionally 2 DIVs before the  # FOOTER. May need to be adjusted as the source pages change @@ -84,6 +85,7 @@ download_it() {    download_it \"FAQ\" \"$faq\" \"$srcdir\"/docs/faq.html  download_it \"Startup How-To\" \"$howto\" \"$srcdir\"/docs/startup-HOWTO.html +download_it \"Design\" \"$design\" \"$srcdir\"/docs/design.html    # .html -> .txt with lynx or elinks  echo \"Documentation: html -> txt...\" @@ -100,3 +102,6 @@ cat \"$srcdir\"/docs/faq.html \\  cat \"$srcdir\"/docs/startup-HOWTO.html \\      | perl -pe \"s/\\\\bhref=([\\\"\\\'])#.*?\\\\1//\" \\      | LC_ALL=en_IE.utf8 $converter > \"$srcdir\"/docs/startup-HOWTO.txt + +cat \"$srcdir\"/docs/design.html \\ +    | LC_ALL=en_IE.utf8 $converter > \"$srcdir\"/docs/design.txt '),('irssi','1.1.1','9d2429c027770a711aa6ea6be86545e7966ec1ba','ailin-nemui','test line joining','configure.ac','784','4','1','0','MODIFY','@@ -732,6 +732,7 @@ scripts/examples/Makefile  tests/Makefile  tests/fe-common/Makefile  tests/fe-common/core/Makefile +tests/fe-text/Makefile  tests/irc/Makefile  tests/irc/core/Makefile  tests/irc/flood/Makefile '),('irssi','1.1.1','9d2429c027770a711aa6ea6be86545e7966ec1ba','ailin-nemui','test line joining','Makefile.am','4','0','5','1','MODIFY','@@ -1 +1,5 @@ -SUBDIRS = fe-common irc +if BUILD_TEXTUI +TEXTUI=fe-text +endif + +SUBDIRS = fe-common irc $(TEXTUI) '),('irssi','1.1.1','9d2429c027770a711aa6ea6be86545e7966ec1ba','ailin-nemui','test line joining','Makefile.am','29','0','38','0','ADD','@@ -0,0 +1,38 @@ +include $(top_srcdir)/utils/glib-tap.mk + +PACKAGE_STRING=fe-text + +AM_CPPFLAGS = \\ +	-I$(top_srcdir)/src \\ +	-I$(top_srcdir)/src/core \\ +	-I$(top_srcdir)/src/fe-common/core \\ +	-I$(top_srcdir)/src/fe-text \\ +	$(GLIB_CFLAGS) + +test_programs = test-paste-join-multiline + +test_paste_join_multiline_CPPFLAGS = \\ +	$(AM_CPPFLAGS) + +# test_paste_join_multiline_DEPENDENCIES = + +test_paste_join_multiline_LDADD = \\ +        ../../src/fe-common/core/libfe_common_core.a \\ +        ../../src/core/libcore.a \\ +        ../../src/lib-config/libirssi_config.a \\ +	@PROG_LIBS@ \\ +	@TEXTUI_LIBS@ + + +test_paste_join_multiline_SOURCES = \\ +	../../src/fe-text/gui-entry.c \\ +	../../src/fe-text/mainwindows.c \\ +	../../src/fe-text/term-terminfo.c \\ +	../../src/fe-text/terminfo-core.c \\ +	../../src/fe-text/term.c \\ +	../../src/fe-text/textbuffer-view.c \\ +	../../src/fe-text/textbuffer.c \\ +	../../src/fe-text/gui-windows.c \\ +	../../src/fe-text/gui-printtext.c \\ +	mock-irssi.c \\ +	test-paste-join-multiline.c '),('irssi','1.1.1','9d2429c027770a711aa6ea6be86545e7966ec1ba','ailin-nemui','test line joining','mock-irssi.c','7','2','9','0','ADD','@@ -0,0 +1,9 @@ +void irssi_set_dirty(void) +{ +} + +void irssi_redraw(void) +{ +} + +int quitting = 0; '),('irssi','1.1.1','9d2429c027770a711aa6ea6be86545e7966ec1ba','ailin-nemui','test line joining','test-paste-join-multiline.c','40','4','55','0','ADD','@@ -0,0 +1,55 @@ +#include \"common.h\" +#include \"gui-readline.c\" + +typedef struct { +	char const *const description; +	char const *const input; +	char const *const result; +} paste_join_multiline_test_case; + +static void test_paste_join_multiline(const paste_join_multiline_test_case *test); + +paste_join_multiline_test_case const paste_join_multiline_fixture[] = { +	{ +		.description = \"Lines should be joined, separator NL\", +		.input = \"<User> hello world\\n       how are you\\n       screen is narrow\", +		.result = \"<User> hello world how are you screen is narrow\", +	}, +}; + +int main(int argc, char **argv) +{ +	int i; + +	g_test_init(&argc, &argv, NULL); + +	for (i = 0; i < G_N_ELEMENTS(paste_join_multiline_fixture); i++) { +		char *name = g_strdup_printf(\"/test/paste_join_multiline/%d\", i); +		g_test_add_data_func(name, &paste_join_multiline_fixture[i], (GTestDataFunc)test_paste_join_multiline); +		g_free(name); +	} + +#if GLIB_CHECK_VERSION(2,38,0) +	g_test_set_nonfatal_assertions(); +#endif +	return g_test_run(); +} + +static void test_paste_join_multiline(const paste_join_multiline_test_case *test) +{ +	char *resultstr; +	GArray *buffer = g_array_new(FALSE, FALSE, sizeof(unichar)); + +	g_test_message(\"Testing: %s\", test->description); + +	buffer->data = (char *) g_utf8_to_ucs4_fast(test->input, -1, (glong *) &buffer->len); +	paste_buffer_join_lines(buffer); +	resultstr = g_ucs4_to_utf8((unichar *) buffer->data, buffer->len, NULL, NULL, NULL); + +	g_assert_cmpstr(resultstr, ==, test->result); + +	g_free(resultstr); +	g_array_free(buffer, TRUE); + +	return; +} '),('irssi','1.1.1','83e98da2ffa295723b10f63ec41211f70ea87153','ailin-nemui','add test for paste_join_multiline','test-paste-join-multiline.c','52','4','15','3','MODIFY','@@ -12,8 +12,18 @@ static void test_paste_join_multiline(const paste_join_multiline_test_case *test  paste_join_multiline_test_case const paste_join_multiline_fixture[] = {  	{  		.description = \"Lines should be joined, separator NL\", -		.input = \"<User> hello world\\n       how are you\\n       screen is narrow\", -		.result = \"<User> hello world how are you screen is narrow\", +		.input = \"<User> A1\\n       B22\\n       C33\", +		.result = \"<User> A1 B22 C33\", +	}, +	{ +		.description = \"Lines should be joined, separator LF\", +		.input = \"<User> A1\\r       B22\\r       C33\", +		.result = \"<User> A1 B22 C33\", +	}, +	{ +		.description = \"Lines should be joined, white space should be skipped\", +		.input = \"<User> A1 \\n       B22 \\n       C33 \", +		.result = \"<User> A1 B22 C33 \",  	},  };   @@ -37,10 +47,12 @@ int main(int argc, char **argv)    static void test_paste_join_multiline(const paste_join_multiline_test_case *test)  { -	char *resultstr; +	char *resultstr, *t1;  	GArray *buffer = g_array_new(FALSE, FALSE, sizeof(unichar));    	g_test_message(\"Testing: %s\", test->description); +	g_test_message(\"INPUT: \\\"%s\\\"\", (t1 = g_strescape(test->input, NULL))); +	g_free(t1);    	buffer->data = (char *) g_utf8_to_ucs4_fast(test->input, -1, (glong *) &buffer->len);  	paste_buffer_join_lines(buffer); '),('irssi','1.1.1','c1fb9a840201131982f2c2e1ff8737436f495841','ailin-nemui','fix paste_join_multiline','gui-readline.c','1066','210','9','7','MODIFY','@@ -160,6 +160,7 @@ static void window_next_page(void)  	gui_window_scroll(active_win, get_scroll_count());  }   +#define isnewline(x) ((x) == \'\\n\' || (x) == \'\\r\')  static void paste_buffer_join_lines(GArray *buf)  {  	unsigned int i, count, indent, line_len; @@ -199,7 +200,7 @@ static void paste_buffer_join_lines(GArray *buf)    	/* find the first beginning of indented line */  	for (i = 1; i < buf->len; i++) { -		if (arr[i-1] == \'\\n\' && isblank(arr[i])) +		if (isnewline(arr[i-1]) && isblank(arr[i]))  			break;  	}  	if (i == buf->len) @@ -226,7 +227,7 @@ static void paste_buffer_join_lines(GArray *buf)  				count = 0;  			}  		} -		if (arr[i] == \'\\n\') +		if (isnewline(arr[i]))  			last_lf = TRUE;  	}   @@ -236,11 +237,12 @@ static void paste_buffer_join_lines(GArray *buf)  	for (i = 0; i < buf->len; i++) {  		if (last_lf && isblank(arr[i])) {  			/* whitespace, ignore */ -		} else if (arr[i] == \'\\n\') { +		} else if (isnewline(arr[i])) {  			if (!last_lf && i+1 != buf->len &&  			    isblank(arr[i+1])) {  				last_lf_pos = dest; -				*dest++ = \' \'; +				if (i != 0 && !isblank(arr[i-1])) +					*dest++ = \' \';  			} else {  				*dest++ = \'\\n\'; /* double-LF */  				line_len = 0; @@ -287,7 +289,7 @@ static void paste_send(void)  		/* first line has to be kludged kind of to get pasting in the  		   middle of line right.. */  		for (i = 0; i < paste_buffer->len; i++) { -			if (arr[i] == \'\\r\' || arr[i] == \'\\n\') { +			if (isnewline(arr[i])) {  				i++;  				break;  			} @@ -303,7 +305,7 @@ static void paste_send(void)  	/* rest of the lines */  	str = g_string_new(NULL);  	for (; i < paste_buffer->len; i++) { -		if (arr[i] == \'\\r\' || arr[i] == \'\\n\') { +		if (isnewline(arr[i])) {  			paste_send_line(str->str);  			g_string_truncate(str, 0);  		} else if (active_entry->utf8) { @@ -769,7 +771,7 @@ static void paste_bracketed_end(int i, gboolean rest)    	last_char = g_array_index(paste_buffer, unichar, i - 1);   -	if (paste_line_count > 0 && last_char != \'\\n\' && last_char != \'\\r\') { +	if (paste_line_count > 0 && !isnewline(last_char)) {  		/* there are newlines, but there\'s also stuff after the newline  		 * adjust line count to reflect this */  		paste_line_count++; '),('irssi','1.1.1','60d2364989b50ed8b76076022dde39690dc95416','ailin-nemui','run syncscripts.sh  sync buf.pl to version 3.00 sync usercount.pl to version 1.20','buf.pl','109','10','58','61','MODIFY','@@ -1,22 +1,24 @@  use strict;  use vars qw($VERSION %IRSSI); +use Storable; +use 5.014000;    use Irssi qw(command signal_add signal_add_first active_win               settings_get_str settings_get_bool channels windows -	     settings_add_str settings_add_bool get_irssi_dir -	     window_find_refnum signal_stop); -$VERSION = \'2.20\'; +             settings_add_str settings_add_bool get_irssi_dir +             window_find_refnum signal_stop); +$VERSION = \'3.00\';  %IRSSI = ( -    authors	=> \'Juerd\', -    contact	=> \'juerd@juerd.nl\', -    name	=> \'Scroll buffer restorer\', -    description	=> \'Saves the buffer for /upgrade, so that no information is lost\', -    license	=> \'Public Domain\', -    url		=> \'http://juerd.nl/irssi/\', -    changed	=> \'Thu Sep 22 01:37 CEST 2016\', -    changes	=> \'Fixed file permissions (leaked everything via filesystem)\', -    note1	=> \'This script HAS TO BE in your scripts/autorun!\', -    note2	=> \'Perl support must be static or in startup\', +    authors     => \'Juerd\', +    contact     => \'juerd@juerd.nl\', +    name        => \'Scroll buffer restorer\', +    description => \'Saves the buffer for /upgrade, so that no information is lost\', +    license     => \'Public Domain\', +    url         => \'http://juerd.nl/irssi/\', +    changed     => \'Thu Mar 29 10:00 CEST 2018\', +    changes     => \'Fixed file permissions (leaked everything via filesystem), rewritten to use Storable and print to correct levels\', +    note1       => \'This script HAS TO BE in your scripts/autorun!\', +    note2       => \'Perl support must be static or in startup\',  );    # Q: How can I get a very smooth and clean upgrade? @@ -40,30 +42,28 @@ my %suppress;  sub _filename { sprintf \'%s/scrollbuffer\', get_irssi_dir }    sub upgrade { -    my $fn = _filename; -    my $old_umask = umask 0077; -    open my $fh, q{>}, $fn or die \"open $fn: $!\"; -    umask $old_umask; - -    print $fh join(\"\\0\", map $_->{server}->{address} . $_->{name}, channels), \"\\n\"; +    my $out = { suppress => [ map $_->{server}->{address} . $_->{name}, channels ] };      for my $window (windows) { -	next unless defined $window; -	next if $window->{name} eq \'status\'; -	my $view = $window->view; -	my $line = $view->get_lines; -	my $lines  = 0; -	my $buf = \'\'; -	if (defined $line){ -	    { -		$buf .= $line->get_text(1) . \"\\n\"; -		$line = $line->next; -		$lines++; -		redo if defined $line; -	    } -	} -	printf $fh \"%s:%s\\n%s\", $window->{refnum}, $lines, $buf; +        next unless defined $window; +        next if $window->{name} eq \'status\'; +        my $view = $window->view; +        my $line = $view->get_lines; +        my $lines  = 0; +        my $buf = \'\'; +        my $output; +        if (defined $line) { +            { +              push @$output, { level => $line->{info}{level}, data => $line->get_text(1) }; +              $line = $line->next; +              redo if defined $line; +            } +        } +        push @{$out->{windows}}, { refnum => $window->{refnum}, lines => $output };      } -    close $fh; +    my $old_umask = umask 0077; +    my $fn = _filename; +    store($out, $fn) or die \"Could not store data to $fn\"; +    umask $old_umask;      unlink sprintf(\"%s/sessionconfig\", get_irssi_dir);      command \'layout save\';      command \'save\'; @@ -71,33 +71,30 @@ sub upgrade {    sub restore {      my $fn = _filename; -    open my $fh, q{<}, $fn or die \"open $fn: $!\"; +    my $in = retrieve($fn) or die \"Could not retrieve data from $fn\";      unlink $fn or warn \"unlink $fn: $!\"; - -    my @suppress = split /\\0/, readline $fh; -    if (settings_get_bool \'upgrade_suppress_join\') { -	chomp $suppress[-1]; -	@suppress{@suppress} = (2) x @suppress; -    } +   +    my @suppress = @{$in->{suppress}}; +    @suppress{@suppress} = (2) x @suppress if (settings_get_bool \'upgrade_suppress_join\'); +        active_win->command(\'^window scroll off\'); -    while (my $bla = readline $fh){ -	chomp $bla; -	my ($refnum, $lines) = split /:/, $bla; -	next unless $lines; -	my $window = window_find_refnum $refnum; -	unless (defined $window){ -	    readline $fh for 1..$lines; -	    next; -	} -	my $view = $window->view; -	$view->remove_all_lines(); -	$view->redraw(); -	my $buf = \'\'; -	$buf .= readline $fh for 1..$lines; -	my $sep = settings_get_str \'upgrade_separator\'; -	$sep .= \"\\n\" if $sep ne \'\'; -	$window->gui_printtext_after(undef, MSGLEVEL_CLIENTNOTICE, \"$buf\\cO$sep\"); -	$view->redraw(); +    for my $win (@{$in->{windows}}) { +        my $window = window_find_refnum $win->{refnum}; +        next unless $window; +        my @lines  = @{ $win->{lines} || [] }; +        next unless @lines; +     +        my $view = $window->view; +        $view->remove_all_lines(); +        $view->redraw(); +        for my $line (@lines) { +            my $level = $line->{level}; +            my $data  = $line->{data}; +            $window->gui_printtext_after($window->last_line_insert, $level, \"$data\\n\"); +        } +        my $sep = settings_get_str \'upgrade_separator\'; +        $window->gui_printtext_after($window->last_line_insert, MSGLEVEL_CLIENTNOTICE, \"\\cO$sep\\n\") if $sep ne \'\'; +        $view->redraw();      }      active_win->command(\'^window scroll on\');      active_win->command(\'^scrollback end\'); @@ -110,7 +107,7 @@ sub suppress {      $key_part =~ s/^://;      my $key = $first->{address} . $key_part;      if (exists $suppress{$key} and $suppress{$key}--) { -    	signal_stop(); +        signal_stop();          delete $suppress{$key} unless $suppress{$key};      }  } '),('irssi','1.1.1','60d2364989b50ed8b76076022dde39690dc95416','ailin-nemui','run syncscripts.sh  sync buf.pl to version 3.00 sync usercount.pl to version 1.20','usercount.pl','150','9','2','2','MODIFY','@@ -1,7 +1,7 @@  use strict;  use Irssi 20040119.2359 ();  use vars qw($VERSION %IRSSI); -$VERSION = \"1.19\"; +$VERSION = \"1.20\";  %IRSSI = (      authors     => \'David Leadbeater, Timo Sirainen, Georg Lukas\',      contact     => \'dgl@dgl.cx, tss@iki.fi, georg@boerde.de\', @@ -128,7 +128,7 @@ sub calc_users() {    }      # Server doesn\'t support halfops?  -  if($server->isupport(\"PREFIX\") !~ /\\%/) { +  if($server->can(\'isupport\') && $server->isupport(\"PREFIX\") !~ /\\%/) {       $halfops = undef;    } else {       $halfops = undef unless Irssi::settings_get_bool(\'usercount_show_halfops\'); '),('irssi','1.1.1','4537d85b0b1e3bbd5240e379d015752423381e9a','ailin-nemui','reverse queue','rawlog.c','178','41','3','3','MODIFY','@@ -63,7 +63,7 @@ void rawlog_destroy(RAWLOG_REC *rawlog)  static void rawlog_add(RAWLOG_REC *rawlog, char *str)  {  	if (rawlog->lines->length >= rawlog_lines && rawlog_lines > 0) { -		void *tmp = g_queue_pop_tail(rawlog->lines); +		void *tmp = g_queue_pop_head(rawlog->lines);  		g_free(tmp);  	}   @@ -72,7 +72,7 @@ static void rawlog_add(RAWLOG_REC *rawlog, char *str)  		write_buffer(rawlog->handle, \"\\n\", 1);  	}   -	g_queue_push_head(rawlog->lines, str); +	g_queue_push_tail(rawlog->lines, str);  	signal_emit_id(signal_rawlog, 2, rawlog, str);  }   @@ -105,7 +105,7 @@ static void rawlog_dump(RAWLOG_REC *rawlog, int f)  	GList *tmp;  	ssize_t ret = 0;   -	for (tmp = rawlog->lines->tail; ret != -1 && tmp != NULL; tmp = tmp->prev) { +	for (tmp = rawlog->lines->head; ret != -1 && tmp != NULL; tmp = tmp->next) {  		ret = write(f, tmp->data, strlen((char *) tmp->data));                  if (ret != -1)                          ret = write(f, \"\\n\", 1); '),('irssi','1.1.1','4537d85b0b1e3bbd5240e379d015752423381e9a','ailin-nemui','reverse queue','Rawlog.xs','46','1','1','1','MODIFY','@@ -21,7 +21,7 @@ rawlog_get_lines(rawlog)  PREINIT:  	GList *tmp;  PPCODE: -	for (tmp = rawlog->lines->tail; tmp != NULL; tmp = tmp->prev) { +	for (tmp = rawlog->lines->head; tmp != NULL; tmp = tmp->next) {  		XPUSHs(sv_2mortal(new_pv(tmp->data)));  	}   '),('irssi','1.1.1','9e5e5d8625714c58546fad00b9d95bce7f3a1afb','ailin-nemui','expose wcwidth and related to perl','Core.xs','649','29','21','0','MODIFY','@@ -2,6 +2,8 @@  #include \"module.h\"  #include \"irssi-version.h\"  #include \"core.h\" +#include \"utf8.h\" +#include \"recode.h\"    #include \"pidwait.h\"  #include \"session.h\" @@ -687,6 +689,25 @@ CODE:  OUTPUT:  	RETVAL   +int +string_width(str) +	char *str +C_ARGS: +	str, is_utf8() ? TREAT_STRING_AS_UTF8 : TREAT_STRING_AS_BYTES + +void +string_chars_for_width(str, width) +	char *str +	unsigned int width +PREINIT: +	int retval; +	unsigned int bytes; +PPCODE: +	retval = string_chars_for_width(str, is_utf8() ? TREAT_STRING_AS_UTF8 : TREAT_STRING_AS_BYTES, width, &bytes); +	mXPUSHi(retval); +	mXPUSHu(bytes); + +  #*******************************  MODULE = Irssi::Core	PACKAGE = Irssi::Server  #******************************* '),('irssi','1.1.1','9e5e5d8625714c58546fad00b9d95bce7f3a1afb','ailin-nemui','expose wcwidth and related to perl','TextUI.xs','250','12','21','0','MODIFY','@@ -205,6 +205,27 @@ gui_input_set_pos(pos)  CODE:  	gui_entry_set_pos(active_entry, pos);   +int +wcwidth(c) +	char *c +CODE: +	if (term_type == TERM_TYPE_UTF8) { +		unichar chr = g_utf8_get_char_validated((const char *) c, -1); + +		if (chr & 0x80000000) { +			RETVAL = 1; +		} else { +			RETVAL = i_wcwidth(chr); +		} +	} else if (term_type != TERM_TYPE_BIG5 || +	    c[1] == \'\\0\' || !is_big5(c[0], c[1])) { +		RETVAL = 1; +	} else { +		RETVAL = 2; +	} +OUTPUT: +	RETVAL +  MODULE = Irssi::TextUI PACKAGE = Irssi::UI::Window    void '),('irssi','1.1.1','deaa1da55e3250badbdb3a769989cf5525b301e2','ailin-nemui','cast to unsigned char','TextUI.xs','251','12','2','1','MODIFY','@@ -218,7 +218,8 @@ CODE:  			RETVAL = i_wcwidth(chr);  		}  	} else if (term_type != TERM_TYPE_BIG5 || -	    c[1] == \'\\0\' || !is_big5(c[0], c[1])) { +		   c[1] == \'\\0\' || +		   !is_big5((unsigned char) c[0], (unsigned char) c[1])) {  		RETVAL = 1;  	} else {  		RETVAL = 2; '),('irssi','1.1.1','288f220f875d4e4f00e86dd809c04aa805b49991','ailin-nemui','fix width of byte codepoints','TextUI.xs','251','12','1','1','MODIFY','@@ -220,7 +220,7 @@ CODE:  	} else if (term_type != TERM_TYPE_BIG5 ||  		   c[1] == \'\\0\' ||  		   !is_big5((unsigned char) c[0], (unsigned char) c[1])) { -		RETVAL = 1; +		RETVAL = i_wcwidth((unsigned char) *c);  	} else {  		RETVAL = 2;  	} '),('irssi','1.1.1','4380f3820e5504b039d4a1ed0853c4442fa251b1','Calvin Buckley','Fix compilation of irc/core on AIX and IBM i  There\'s a function in the standard library of these OSes that conflict with this function. Prefix it with `irc_`.','irc-cap.c','205','53','1','1','MODIFY','@@ -296,7 +296,7 @@ static void event_invalid_cap (IRC_SERVER_REC *server, const char *data, const c  	irc_send_cmd_now(server, \"CAP END\");  }   -void cap_init (void) +void irc_cap_init (void)  {  	signal_add_first(\"event cap\", (SIGNAL_FUNC) event_cap);  	signal_add_first(\"event 410\", (SIGNAL_FUNC) event_invalid_cap); '),('irssi','1.1.1','4380f3820e5504b039d4a1ed0853c4442fa251b1','Calvin Buckley','Fix compilation of irc/core on AIX and IBM i  There\'s a function in the standard library of these OSes that conflict with this function. Prefix it with `irc_`.','irc-cap.h','4','0','2','1','MODIFY','@@ -1,7 +1,8 @@  #ifndef __IRC_CAP_H  #define __IRC_CAP_H   -void cap_init(void); +/* this is prefixed as to not conflict with an AIX/i function in their stdlib */ +void irc_cap_init(void);  void cap_deinit(void);  int cap_toggle (IRC_SERVER_REC *server, char *cap, int enable);  void cap_finish_negotiation (IRC_SERVER_REC *server); '),('irssi','1.1.1','4380f3820e5504b039d4a1ed0853c4442fa251b1','Calvin Buckley','Fix compilation of irc/core on AIX and IBM i  There\'s a function in the standard library of these OSes that conflict with this function. Prefix it with `irc_`.','irc-core.c','103','8','1','1','MODIFY','@@ -119,7 +119,7 @@ void irc_core_init(void)  	lag_init();  	netsplit_init();  	irc_expandos_init(); -	cap_init(); +	irc_cap_init();  	sasl_init();    	settings_check(); '),('irssi','1.1.1','795e7ec16240613dd13e8378128bb5fa66b6dc93','Calvin Buckley','Fix build on IBM i  	* Lots of warnings about subdirectories. Set an automake 	  option to deal with this.  	* Set an ar flag for explicit 64-bit when on IBM i, due to 	  it defaulting to 64-bit output with official gcc by default.','configure.ac','791','4','7','1','MODIFY','@@ -5,7 +5,7 @@ AC_PREREQ(2.50)    AC_CONFIG_HEADERS([irssi-config.h])  AC_CONFIG_MACRO_DIR([m4]) -AM_INIT_AUTOMAKE([1.9 no-define foreign]) +AM_INIT_AUTOMAKE([1.9 no-define foreign subdir-objects])    AM_SILENT_RULES([yes])   @@ -199,6 +199,12 @@ case \"$host_os\" in    hpux*)      CFLAGS=\"$CFLAGS -D_XOPEN_SOURCE_EXTENDED\"      ;; +  os400*) +    dnl IBM i uses ppc64 gcc by default, but binutils defaults to 32-bit. Force +    dnl IBM binutils, and force it into ppc64 mode. This isn\'t set for AIX +    dnl because gcc there defaults to ppc32. +    AR=\"/usr/bin/ar -X64\" +    ;;    *)      ;;  esac '),('irssi','1.1.1','88b16491956f0a882cc61fffa6a76d469006a87d','ailin-nemui','add keep_word setting to completion','completion.c','662','187','5','0','MODIFY','@@ -240,6 +240,10 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  			/* Remove all nulls (from the signal) before doing further processing */  			complist = g_list_remove_all(g_list_first(complist), NULL);  		} + +		if (settings_get_bool(\"completion_keep_word\") && complist != NULL) { +			complist = g_list_append(complist, g_strdup(word)); +		}  	}    	g_free(linestart); @@ -897,6 +901,7 @@ void completion_init(void)    	chat_completion_init();   +	settings_add_bool(\"completion\", \"completion_keep_word\", TRUE);  	command_bind(\"completion\", NULL, (SIGNAL_FUNC) cmd_completion);    	signal_add_first(\"complete word\", (SIGNAL_FUNC) sig_complete_word); '),('irssi','1.1.1','10f41e067eef33e30a211279d69160b5c7721f96','ailin-nemui','fix backward completion','completion.c','669','188','11','3','MODIFY','@@ -229,6 +229,7 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  				g_list_first(complist);  		want_space = last_want_space;  	} else { +		int keep_word = settings_get_bool(\"completion_keep_word\");  		/* get new completion list */  		free_completions();   @@ -239,10 +240,17 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i  		if (complist != NULL) {  			/* Remove all nulls (from the signal) before doing further processing */  			complist = g_list_remove_all(g_list_first(complist), NULL); -		}   -		if (settings_get_bool(\"completion_keep_word\") && complist != NULL) { -			complist = g_list_append(complist, g_strdup(word)); +			if (keep_word) { +				complist = g_list_append(complist, g_strdup(word)); +			} + +			if (backward) { +				complist = g_list_last(complist); +				if (keep_word) { +					complist = complist->prev; +				} +			}  		}  	}   '),('irssi','1.1.1','a634b34ba48d7e050bb125d86205e58a5dc00c3d','Calvin Buckley','Rename cap_* funcs to irc_cap_*  Some systems often \"namespace\" cap_ for themselves, and so irssi\'s usage can conflict with their own. Bump ABI for this.','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 18 +#define IRSSI_ABI_VERSION 19    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.1.1','a634b34ba48d7e050bb125d86205e58a5dc00c3d','Calvin Buckley','Rename cap_* funcs to irc_cap_*  Some systems often \"namespace\" cap_ for themselves, and so irssi\'s usage can conflict with their own. Bump ABI for this.','irc-cap.c','205','53','7','7','MODIFY','@@ -24,7 +24,7 @@  #include \"irc-cap.h\"  #include \"irc-servers.h\"   -int cap_toggle (IRC_SERVER_REC *server, char *cap, int enable) +int irc_cap_toggle (IRC_SERVER_REC *server, char *cap, int enable)  {  	if (cap == NULL || *cap == \'\\0\')  		return FALSE; @@ -65,7 +65,7 @@ int cap_toggle (IRC_SERVER_REC *server, char *cap, int enable)  	return FALSE;  }   -void cap_finish_negotiation (IRC_SERVER_REC *server) +void irc_cap_finish_negotiation (IRC_SERVER_REC *server)  {  	if (server->cap_complete)  		return; @@ -130,7 +130,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add  	}  	/* Malformed request, terminate the negotiation */  	else { -		cap_finish_negotiation(server); +		irc_cap_finish_negotiation(server);  		g_warn_if_reached();  		return;  	} @@ -177,7 +177,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add  		if (multiline == FALSE) {  			/* No CAP has been requested */  			if (server->cap_queue == NULL) { -				cap_finish_negotiation(server); +				irc_cap_finish_negotiation(server);  			}  			else {  				cmd = g_string_new(\"CAP REQ :\"); @@ -204,7 +204,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add  					signal_emit(\"server cap req\", 2, server, cmd->str + sizeof(\"CAP REQ :\") - 1);  					irc_send_cmd_now(server, cmd->str);  				} else { -					cap_finish_negotiation(server); +					irc_cap_finish_negotiation(server);  				}    				g_string_free(cmd, TRUE); @@ -233,7 +233,7 @@ static void event_cap (IRC_SERVER_REC *server, char *args, char *nick, char *add  		 * negotiation, unless sasl was requested. In this case we must not terminate the negotiation  		 * until the sasl handshake is over. */  		if (got_sasl == FALSE) -			cap_finish_negotiation(server); +			irc_cap_finish_negotiation(server);  	}  	else if (!g_ascii_strcasecmp(evt, \"NAK\")) {  		g_warning(\"The server answered with a NAK to our CAP request, this should not happen\"); @@ -302,7 +302,7 @@ void irc_cap_init (void)  	signal_add_first(\"event 410\", (SIGNAL_FUNC) event_invalid_cap);  }   -void cap_deinit (void) +void irc_cap_deinit (void)  {  	signal_remove(\"event cap\", (SIGNAL_FUNC) event_cap);  	signal_remove(\"event 410\", (SIGNAL_FUNC) event_invalid_cap); '),('irssi','1.1.1','a634b34ba48d7e050bb125d86205e58a5dc00c3d','Calvin Buckley','Rename cap_* funcs to irc_cap_*  Some systems often \"namespace\" cap_ for themselves, and so irssi\'s usage can conflict with their own. Bump ABI for this.','irc-cap.h','4','0','3','3','MODIFY','@@ -3,8 +3,8 @@    /* this is prefixed as to not conflict with an AIX/i function in their stdlib */  void irc_cap_init(void); -void cap_deinit(void); -int cap_toggle (IRC_SERVER_REC *server, char *cap, int enable); -void cap_finish_negotiation (IRC_SERVER_REC *server); +void irc_cap_deinit(void); +int irc_cap_toggle (IRC_SERVER_REC *server, char *cap, int enable); +void irc_cap_finish_negotiation (IRC_SERVER_REC *server);    #endif '),('irssi','1.1.1','a634b34ba48d7e050bb125d86205e58a5dc00c3d','Calvin Buckley','Rename cap_* funcs to irc_cap_*  Some systems often \"namespace\" cap_ for themselves, and so irssi\'s usage can conflict with their own. Bump ABI for this.','irc-core.c','103','8','1','1','MODIFY','@@ -131,7 +131,7 @@ void irc_core_deinit(void)  	signal_emit(\"chat protocol deinit\", 1, chat_protocol_find(\"IRC\"));    	sasl_deinit(); -	cap_deinit(); +	irc_cap_deinit();  	irc_expandos_deinit();  	netsplit_deinit();  	lag_deinit(); '),('irssi','1.1.1','a634b34ba48d7e050bb125d86205e58a5dc00c3d','Calvin Buckley','Rename cap_* funcs to irc_cap_*  Some systems often \"namespace\" cap_ for themselves, and so irssi\'s usage can conflict with their own. Bump ABI for this.','irc-servers.c','782','196','2','2','MODIFY','@@ -236,9 +236,9 @@ static void server_init(IRC_SERVER_REC *server)  	}    	if (conn->sasl_mechanism != SASL_MECHANISM_NONE) -		cap_toggle(server, \"sasl\", TRUE); +		irc_cap_toggle(server, \"sasl\", TRUE);   -	cap_toggle(server, \"multi-prefix\", TRUE); +	irc_cap_toggle(server, \"multi-prefix\", TRUE);    	irc_send_cmd_now(server, \"CAP LS\");   '),('irssi','1.1.1','a634b34ba48d7e050bb125d86205e58a5dc00c3d','Calvin Buckley','Rename cap_* funcs to irc_cap_*  Some systems often \"namespace\" cap_ for themselves, and so irssi\'s usage can conflict with their own. Bump ABI for this.','sasl.c','214','39','5','5','MODIFY','@@ -45,7 +45,7 @@ static gboolean sasl_timeout(IRC_SERVER_REC *server)  {  	/* The authentication timed out, we can\'t do much beside terminating it */  	irc_send_cmd_now(server, \"AUTHENTICATE *\"); -	cap_finish_negotiation(server); +	irc_cap_finish_negotiation(server);    	server->sasl_timeout = 0;  	server->sasl_success = FALSE; @@ -96,7 +96,7 @@ static void sasl_fail(IRC_SERVER_REC *server, const char *data, const char *from  	signal_emit(\"server sasl failure\", 2, server, error);    	/* Terminate the negotiation */ -	cap_finish_negotiation(server); +	irc_cap_finish_negotiation(server);    	g_free(params);  } @@ -110,7 +110,7 @@ static void sasl_already(IRC_SERVER_REC *server, const char *data, const char *f  	signal_emit(\"server sasl success\", 1, server);    	/* We\'re already authenticated, do nothing */ -	cap_finish_negotiation(server); +	irc_cap_finish_negotiation(server);  }    static void sasl_success(IRC_SERVER_REC *server, const char *data, const char *from) @@ -122,7 +122,7 @@ static void sasl_success(IRC_SERVER_REC *server, const char *data, const char *f  	signal_emit(\"server sasl success\", 1, server);    	/* The authentication succeeded, time to finish the CAP negotiation */ -	cap_finish_negotiation(server); +	irc_cap_finish_negotiation(server);  }    /* @@ -263,7 +263,7 @@ static void sasl_step_complete(IRC_SERVER_REC *server, GString *data)  static void sasl_step_fail(IRC_SERVER_REC *server)  {  	irc_send_cmd_now(server, \"AUTHENTICATE *\"); -	cap_finish_negotiation(server); +	irc_cap_finish_negotiation(server);    	sasl_timeout_stop(server);   '),('irssi','1.1.1','a634b34ba48d7e050bb125d86205e58a5dc00c3d','Calvin Buckley','Rename cap_* funcs to irc_cap_*  Some systems often \"namespace\" cap_ for themselves, and so irssi\'s usage can conflict with their own. Bump ABI for this.','Server.xs','138','6','1','1','MODIFY','@@ -155,6 +155,6 @@ irc_server_cap_toggle(server, cap, enable)  	char *cap  	int enable  CODE: -	RETVAL = cap_toggle(server, cap, enable); +	RETVAL = irc_cap_toggle(server, cap, enable);  OUTPUT:  	RETVAL '),('irssi','1.1.1','bed0a3309f4f452f5ebf6d5d5becf869da190d7a','Calvin Buckley','Revert back to using original version of the configure script  	* IBM i rpmbuild environments set the magic variables for 	  building w/ 64-bit binutils automatically, and one can 	  set this for themselves with `OBJECT_MODE=64` when 	  buildings. Remove this.  	* The subdir-objects change will need to be made due to 	  upstream autotools making it mandatory in the future, but 	  that isn\'t my decision to make.','configure.ac','783','4','1','7','MODIFY','@@ -5,7 +5,7 @@ AC_PREREQ(2.50)    AC_CONFIG_HEADERS([irssi-config.h])  AC_CONFIG_MACRO_DIR([m4]) -AM_INIT_AUTOMAKE([1.9 no-define foreign subdir-objects]) +AM_INIT_AUTOMAKE([1.9 no-define foreign])    AM_SILENT_RULES([yes])   @@ -199,12 +199,6 @@ case \"$host_os\" in    hpux*)      CFLAGS=\"$CFLAGS -D_XOPEN_SOURCE_EXTENDED\"      ;; -  os400*) -    dnl IBM i uses ppc64 gcc by default, but binutils defaults to 32-bit. Force -    dnl IBM binutils, and force it into ppc64 mode. This isn\'t set for AIX -    dnl because gcc there defaults to ppc32. -    AR=\"/usr/bin/ar -X64\" -    ;;    *)      ;;  esac '),('irssi','1.1.1','482a3a5bdd7bf3755c67d678b7e74f72cfbaaecb','Calvin Buckley','Remove unneeded comment','irc-cap.h','4','0','0','1','MODIFY','@@ -1,7 +1,6 @@  #ifndef __IRC_CAP_H  #define __IRC_CAP_H   -/* this is prefixed as to not conflict with an AIX/i function in their stdlib */  void irc_cap_init(void);  void irc_cap_deinit(void);  int irc_cap_toggle (IRC_SERVER_REC *server, char *cap, int enable); '),('irssi','1.1.1','4f26ad74f50b6d68bee0b75d69507cb8a9c413aa','Jaroslav Å karvada','Fixed problem found by Coverity Scan  Fixes #981  Signed-off-by: Jaroslav Å karvada <jskarvad@redhat.com>','dcc-send.c','353','75','1','0','MODIFY','@@ -425,6 +425,7 @@ static int dcc_send_one_file(int queue, const char *target, const char *fname,  	g_free(str);  	if (dcc == NULL) {  		g_warn_if_reached(); +		close(hfile);  		return FALSE;  	}   '),('irssi','1.1.1','821e8af9fecdda2f25f18d5cc0be965b06e05362','ailin-nemui','automake warns that subdir-objects will be enabled in 2.0','configure.ac','784','4','1','1','MODIFY','@@ -5,7 +5,7 @@ AC_PREREQ(2.50)    AC_CONFIG_HEADERS([irssi-config.h])  AC_CONFIG_MACRO_DIR([m4]) -AM_INIT_AUTOMAKE([1.9 no-define foreign]) +AM_INIT_AUTOMAKE([1.9 no-define foreign subdir-objects])    AM_SILENT_RULES([yes])   '),('irssi','1.1.1','7e6e3cd503b3619a22709db66234cd4aeefa866f','ailin-nemui','Add escape_string_escape function for expand_escapes  To avoid expanding, tab completion escapes the completion list. But the escape_string function escapes too much for the expand_escapes code. Add a function that only escapes the backslashes.','misc.c','803','263','16','0','MODIFY','@@ -757,6 +757,22 @@ char *escape_string(const char *str)  	return ret;  }   +/* Escape all \'\\\' chars with \'\\\' */ +char *escape_string_escape(const char *str) +{ +	char *ret, *p; + +	p = ret = g_malloc(strlen(str)*2+1); +	while (*str != \'\\0\') { +		if (*str == \'\\\\\') +			*p++ = \'\\\\\'; +		*p++ = *str++; +	} +	*p = \'\\0\'; + +	return ret; +} +  int nearest_power(int num)  {  	int n = 1; '),('irssi','1.1.1','7e6e3cd503b3619a22709db66234cd4aeefa866f','ailin-nemui','Add escape_string_escape function for expand_escapes  To avoid expanding, tab completion escapes the completion list. But the escape_string function escapes too much for the expand_escapes code. Add a function that only escapes the backslashes.','misc.h','50','0','3','0','MODIFY','@@ -93,6 +93,9 @@ char *ascii_strdown(char *str);  /* Escape all \'\"\', \"\'\" and \'\\\' chars with \'\\\' */  char *escape_string(const char *str);   +/* Escape all \'\\\' chars with \'\\\' */ +char *escape_string_escape(const char *str); +  /* convert all low-ascii (<32) to ^<A..> combinations */  char *show_lowascii(const char *str);   '),('irssi','1.1.1','7e6e3cd503b3619a22709db66234cd4aeefa866f','ailin-nemui','Add escape_string_escape function for expand_escapes  To avoid expanding, tab completion escapes the completion list. But the escape_string function escapes too much for the expand_escapes code. Add a function that only escapes the backslashes.','completion.c','658','185','1','1','MODIFY','@@ -256,7 +256,7 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i    	/* escape if the word doesn\'t begin with \'/\' and expand_escapes are turned on */  	data = strchr(cmdchars, *line) == NULL && expand_escapes ? -		escape_string(complist->data) : g_strdup(complist->data); +		escape_string_escape(complist->data) : g_strdup(complist->data);    	/* word completed */  	*pos = startpos + strlen(data); '),('irssi','1.1.1','35f5e5f278444ecbbd3610292d9569d3a2f51ce1','ailin-nemui','up abi','common.h','42','0','1','1','MODIFY','@@ -6,7 +6,7 @@  #define IRSSI_GLOBAL_CONFIG \"irssi.conf\" /* config file name in /etc/ */  #define IRSSI_HOME_CONFIG \"config\" /* config file name in ~/.irssi/ */   -#define IRSSI_ABI_VERSION 18 +#define IRSSI_ABI_VERSION 19    #define DEFAULT_SERVER_ADD_PORT 6667  #define DEFAULT_SERVER_ADD_TLS_PORT 6697 '),('irssi','1.1.1','8c30367452dd592027917ce92bcebe9301d2c87a','ailin-nemui','rename function','misc.c','803','263','1','1','MODIFY','@@ -758,7 +758,7 @@ char *escape_string(const char *str)  }    /* Escape all \'\\\' chars with \'\\\' */ -char *escape_string_escape(const char *str) +char *escape_string_backslashes(const char *str)  {  	char *ret, *p;   '),('irssi','1.1.1','8c30367452dd592027917ce92bcebe9301d2c87a','ailin-nemui','rename function','misc.h','50','0','1','1','MODIFY','@@ -94,7 +94,7 @@ char *ascii_strdown(char *str);  char *escape_string(const char *str);    /* Escape all \'\\\' chars with \'\\\' */ -char *escape_string_escape(const char *str); +char *escape_string_backslashes(const char *str);    /* convert all low-ascii (<32) to ^<A..> combinations */  char *show_lowascii(const char *str); '),('irssi','1.1.1','8c30367452dd592027917ce92bcebe9301d2c87a','ailin-nemui','rename function','completion.c','658','185','1','1','MODIFY','@@ -256,7 +256,7 @@ char *word_complete(WINDOW_REC *window, const char *line, int *pos, int erase, i    	/* escape if the word doesn\'t begin with \'/\' and expand_escapes are turned on */  	data = strchr(cmdchars, *line) == NULL && expand_escapes ? -		escape_string_escape(complist->data) : g_strdup(complist->data); +		escape_string_backslashes(complist->data) : g_strdup(complist->data);    	/* word completed */  	*pos = startpos + strlen(data); ');
/*!40000 ALTER TABLE `irssi` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-12-04 17:41:14
